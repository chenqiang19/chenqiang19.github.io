<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.0.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css">


<script id="hexo-configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    hostname: new URL('http://yoursite.com').hostname,
    root: '/',
    scheme: 'Mist',
    version: '7.5.0',
    exturl: false,
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false},
    copycode: {"enable":false,"show_result":false,"style":null},
    back2top: {"enable":true,"sidebar":false,"scrollpercent":false},
    bookmark: {"enable":false,"color":"#222","save":"auto"},
    fancybox: false,
    mediumzoom: false,
    lazyload: false,
    pangu: false,
    algolia: {
      appID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    },
    localsearch: {"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},
    path: 'search.xml',
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    sidebarPadding: 40
  };
</script>

  <meta name="description" content="记录是忘记的第一助手.">
<meta property="og:type" content="website">
<meta property="og:title" content="编辑尼撑">
<meta property="og:url" content="http:&#x2F;&#x2F;yoursite.com&#x2F;page&#x2F;3&#x2F;index.html">
<meta property="og:site_name" content="编辑尼撑">
<meta property="og:description" content="记录是忘记的第一助手.">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://yoursite.com/page/3/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome: true,
    isPost: false,
    isPage: false,
    isArchive: false
  };
</script>

  <title>编辑尼撑</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="编辑尼撑" type="application/atom+xml"><!-- hexo-inject:begin --><!-- hexo-inject:end -->
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-meta">

    <div>
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">编辑尼撑</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
        <p class="site-subtitle">学无止境</p>
  </div>

  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>
</div>


<nav class="site-nav">
  
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-schedule">

    <a href="/schedule/" rel="section"><i class="fa fa-fw fa-calendar"></i>日程表</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>

</nav>
  <div class="site-search">
    <div class="popup search-popup">
    <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocorrect="off" autocapitalize="none"
           placeholder="搜索..." spellcheck="false"
           type="text" id="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result"></div>

</div>
<div class="search-pop-overlay"></div>

  </div>
</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content">
            

  <div class="posts-expand">
        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/25/Cloud-Paas-Learn/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qiang Chen">
      <meta itemprop="description" content="记录是忘记的第一助手.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="编辑尼撑">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/25/Cloud-Paas-Learn/" class="post-title-link" itemprop="url">Cloud-Paas-Learn</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-25 21:29:11" itemprop="dateCreated datePublished" datetime="2021-07-25T21:29:11+08:00">2021-07-25</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/25/Image-Process-Pattern-Recognition/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qiang Chen">
      <meta itemprop="description" content="记录是忘记的第一助手.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="编辑尼撑">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/25/Image-Process-Pattern-Recognition/" class="post-title-link" itemprop="url">Image-Process-Pattern-Recognition</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-25 20:45:40 / 修改时间：20:46:48" itemprop="dateCreated datePublished" datetime="2021-07-25T20:45:40+08:00">2021-07-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Image-Processing/" itemprop="url" rel="index">
                    <span itemprop="name">Image Processing</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="图像处理学习"><a href="#图像处理学习" class="headerlink" title="图像处理学习"></a>图像处理学习</h2><p><strong>模式识别</strong>主要介绍两大领域：<strong>决策理论方法</strong>和<strong>结构方法</strong>。第一类使用<strong>定量描述子</strong>来描述各种模式，就是由量化的值。第二类方法处理的是由<strong>定性描述子</strong>来描述的各种模式。</p>
<p><strong>模式</strong>是<strong>描述子</strong>的组合，也可以说是<strong>特征的组合</strong>。比如一个模式由两个用于描述的特征组成，长度和宽度。模式类是指具有某些共同属性的一族模式。模式类用&omega;<sub>1</sub>,&omega;<sub>2</sub>,…&omega;<sub>W</sub>表示，其中W是模式类数。模式组合的形式可以是向量(用于定量描述)，串和树(用于结构描述)，模式向量的分量便成为每个物理样本的完整描述。</p>
<p>经典的<strong>特征选择</strong>问题，即类的可分程度在很大程度上取决于所用的描述子的选择，也即特征的选择。</p>
<h4 id="一、基于决策理论方法的识别"><a href="#一、基于决策理论方法的识别" class="headerlink" title="一、基于决策理论方法的识别"></a>一、基于决策理论方法的识别</h4><p>以决策(或判别)函数为基础。令x=(x<sub>1</sub>,x<sub>2</sub>,…,x<sub>n</sub>)<sup>T</sup>表示一个n维模式向量。对于W个模式类&omega;<sub>1</sub>,&omega;<sub>2</sub>,…&omega;<sub>W</sub>，决策理论模式识别的基本问题是依据模式向量找出W个决策函数d<sub>1</sub>(x),d<sub>2</sub>(x),…,d<sub>W</sub>(x): 如果模式x属于类&omega;<sub>i</sub>，则</p>
<script type="math/tex; mode=display">
d_i(x)\gt d_j(x) \quad j=1,2,...,W;j\neq i</script><p>就是说将模式x代入W个决策函数中，找出其中使决策函数最大的模式类，作为模式x的模式类，称未知模式x属于第i个模式类。</p>
<p><strong>那么如何确定决策边界？</strong></p>
<script type="math/tex; mode=display">
通常使用单一函数d_{ij}(x)=d_i(x)-d_j=0来识别两类之间的决策边界。\\
对于模式类\omega_i有d_{ij}(x)\gt0,对于模式类\omega_j有d_{ij}(x)\lt0</script><h5 id="1-1-匹配"><a href="#1-1-匹配" class="headerlink" title="1.1 匹配"></a>1.1 匹配</h5><p>基于匹配的识别技术通过一个原型模式向量来表示每个类。根据一种预定义的度量，将一个未知模板赋予最接近的类。</p>
<p><strong>最小距离分类器</strong></p>
<p>假设每个模式类的原型定义为该类模式的平均向量：</p>
<script type="math/tex; mode=display">
m_j=\frac{1}{N_j}\sum^{}_{X\in \omega_j}(x_j)\quad j=1,2,3,...,W,m_j为每个模板类的平均值，N_j为来自\omega_j类模式向量的数量</script><p>使用欧式距离求接近程度，可以表示为如下的距离度量：</p>
<script type="math/tex; mode=display">
D_j(x)=\lVert x-m_j\rVert\quad j=1,2,...,W</script><h5 id="1-2-相关匹配"><a href="#1-2-相关匹配" class="headerlink" title="1.2 相关匹配"></a>1.2 相关匹配</h5><p>可以使用归一化相关系数用于模板匹配，当归一化的w和f中对应的归一化区域相同时，&gamma;(x,y)出现最大值。即最大相关为最好的匹配。当模板与图像区域有最小相似性时，归一化相关系数出现最小值。归一化相关系数的公式如下：</p>
<script type="math/tex; mode=display">
\gamma(x,y)=\frac{\sum_{s}^{}\sum^{}_{t}[w(s,t)-\overline w][f(x+s,y+t-\overline f_{xy})]}{\{\sum^{}_{s}\sum^{}_{t}[w(s,t)-\overline w]^2\sum^{}_{s}\sum^{}_{t}[f(x+s,y+t-\overline f_{xy})]^2\}^\frac{1}{2}}\\\overline w模板均值，\overline f_{xy}是f中与w重合区域均值,\gamma(x,y)\in[-1,1]</script><h5 id="1-3-最佳统计分类器"><a href="#1-3-最佳统计分类器" class="headerlink" title="1.3 最佳统计分类器"></a>1.3 最佳统计分类器</h5><p>主要将概率应用于模式识别中，主要分类器为贝叶斯分类器</p>
<h5 id="1-4-神经网络"><a href="#1-4-神经网络" class="headerlink" title="1.4 神经网络"></a>1.4 神经网络</h5><p>多层感知机</p>
<h4 id="二、结构方法"><a href="#二、结构方法" class="headerlink" title="二、结构方法"></a>二、结构方法</h4><h5 id="2-1-匹配形状数"><a href="#2-1-匹配形状数" class="headerlink" title="2.1 匹配形状数"></a>2.1 匹配形状数</h5><p>两个区域边界(形状)之间的相似度k定义为它们的形状数保持一致的最大阶。两个形状a和b之间的距离定义为它们的相似度的倒数：</p>
<script type="math/tex; mode=display">
D(a,b)=\frac{1}{k}\\
该距离满足：D(a,b)\ge0,D(a,b)=0;if \quad a=b;D(a,c)\le max[D(a,b),D(b,c)]</script><p>如果使用相似度，则k越大，形状越相似。当使用距离度量时，情形正好相反。</p>
<h5 id="2-2-串匹配"><a href="#2-2-串匹配" class="headerlink" title="2.2 串匹配"></a>2.2 串匹配</h5><p>将两个区域编码成串，分别记录两个串之间的匹配数&alpha;,和不匹配的符号数&beta;。则a和b之间的一种简单的相似性度量比率是：</p>
<script type="math/tex; mode=display">
R=\frac{\alpha}{\beta}=\frac{\alpha}{max(|a|,|b|)-\alpha},当且仅当a和b相同时，\beta=0</script><p>对于完美匹配，R为无限大，而当a和b中没有任何符号匹配时，R为0。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/25/Image-Process-Edge-Detection/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qiang Chen">
      <meta itemprop="description" content="记录是忘记的第一助手.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="编辑尼撑">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/25/Image-Process-Edge-Detection/" class="post-title-link" itemprop="url">Image-Process-Edge-Detection</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-25 20:43:53 / 修改时间：20:45:01" itemprop="dateCreated datePublished" datetime="2021-07-25T20:43:53+08:00">2021-07-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Image-Processing/" itemprop="url" rel="index">
                    <span itemprop="name">Image Processing</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="图像处理学习"><a href="#图像处理学习" class="headerlink" title="图像处理学习"></a>图像处理学习</h2><h4 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h4><p> 对于灰度突变、局部变化可以用微分类来检测，因此，可以使用一阶微分和二阶微分。其中，一阶或二阶微分有如下的一些性质：</p>
<ul>
<li>一阶导数通常在图像中产生较粗的边缘</li>
<li>二阶导数对精细细节，如细线、孤立点和噪声有较强的响应</li>
<li>二阶导数在灰度斜坡和灰度台阶过渡处会产生双边缘响应</li>
<li>二阶导数的符号可用于确定边缘的过渡是从亮到暗还是从暗到亮。(边缘从暗到亮是正二阶导数，反之为负二阶导数)</li>
</ul>
<p>图像中每个像素位置处的一阶导数和二阶导数的可选择方法是使用空间滤波器。</p>
<p><strong>注意：微弱的可见噪声对检测边缘所用的一阶导数核二阶导数有严重的影响。所以使用导数之前图像平滑处理，应重点关注。</strong></p>
<h4 id="一、孤立点检测"><a href="#一、孤立点检测" class="headerlink" title="一、孤立点检测"></a>一、孤立点检测</h4><p>点的检测应用二阶导数，所以可以使用拉普拉斯算子：</p>
<script type="math/tex; mode=display">
\nabla^2f(x,y)=\frac{\partial^2f}{\partial x^2}+\frac{\partial^2f}{\partial y^2} \\
\frac{\partial^2f(x,y)}{\partial x^2}=f(x+1,y)+f(x-1,y)-2f(x,y) \\
\frac{\partial^2f(x,y)}{\partial y^2}=f(x,y+1)+f(x,y-1)-2f(x,y) \\
\nabla^2f(x,y)=f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)</script><p>使用如下的卷积核对原始图像进行卷积操作：</p>
<script type="math/tex; mode=display">
\begin{matrix} 1 & 1 & 1 \\ 1 & -8 & 1 \\ 1 & 1 & 1 \end{matrix}</script><p>如果在某点处该模板的响应的绝对值超过了一个指定的阈值，那么表明在模板中心位置(x,y)处的点已经被检测到了。</p>
<script type="math/tex; mode=display">
g(x,y)=\begin{cases} 1, & |R(x,y)|\ge T\\ 0, & 其他\end{cases}</script><p>g(x,y)是输出图像，T是一个非负的阈值。</p>
<h4 id="二、边缘检测"><a href="#二、边缘检测" class="headerlink" title="二、边缘检测"></a>二、边缘检测</h4><p>一般的基本步骤：</p>
<ol>
<li>为降噪对图像进行平滑处理。</li>
<li>边缘点的检测，这是一个局部操作，从一副图像中提取所有的点，这些点是边缘点的潜在候选者。</li>
<li>边缘定位，从候选边缘点中选择组成边缘点集合中的真实成员。</li>
</ol>
<h5 id="1、一阶导数用于边缘检测-数字图像处理第三版p455"><a href="#1、一阶导数用于边缘检测-数字图像处理第三版p455" class="headerlink" title="1、一阶导数用于边缘检测(数字图像处理第三版p455)"></a>1、<strong>一阶导数用于边缘检测</strong>(数字图像处理第三版p455)</h5><script type="math/tex; mode=display">
g_x=\frac{\partial f(x,y)}{\partial x}=f(x+1,y)-f(x,y),g_y=\frac{\partial f(x,y)}{\partial y}=f(x,y+1)-f(x,y) \\
上式可以用右边的两个模板做卷积，\begin{matrix} -1 & 0 \\ 0 & -1 \end{matrix} \quad 和 \quad\begin{matrix} 0 & -1 \\ 1 & 0 \end{matrix}</script><p>但是一般使用中心对称的模板计算边缘方向，最小的模板尺寸是3x3，所以对如下的3x3模板可以定义卷积核为：</p>
<script type="math/tex; mode=display">
g_x=\frac{\partial f(x,y)}{\partial x}=(z_7+z_8+z_9)-(z_1+z_2+z_3)\\g_y=\frac{\partial f(x,y)}{\partial y}=(z_3+z_6+z_9)-(z_1+z_4+z_7) \\
\begin{matrix} z_1 & z_2 & z_3 \\ z_4 & z_5 & z_6 \\ z_7 & z_8 & z_9 \end{matrix}\quad\Rightarrow \quad \begin{matrix} -1 & -1 & -1 \\ 0 & 0 & 0 \\ 1 & 1 & 1 \end{matrix} \quad 和 \quad \begin{matrix} -1 & 0 & 1 \\ -1 & 0 & 1 \\ -1 & 0 & 1 \end{matrix}\quad (Prewitt算子)</script><p>另一个变化是中心系数上使用一个权值2（权值为2变为Sobel算子能较好地抑制噪声的特性）：</p>
<script type="math/tex; mode=display">
g_x=\frac{\partial f(x,y)}{\partial x}=(z_7+2z_8+z_9)-(z_1+2z_2+z_3)\\
g_y=\frac{\partial f(x,y)}{\partial y}=(z_3+2z_6+z_9)-(z_1+2z_4+z_7) \\
\begin{matrix} z_1 & z_2 & z_3 \\ z_4 & z_5 & z_6 \\ z_7 & z_8 & z_9 \end{matrix}\quad\Rightarrow \quad \begin{matrix} -1 & -2 & -1 \\ 0 & 0 & 0 \\ 1 & 2 & 1 \end{matrix} \quad 和 \quad \begin{matrix} -1 & 0 & 1 \\ -2 & 0 & 2 \\ -1 & 0 & 1 \end{matrix}\quad (Sobel算子)</script><h5 id="2、二阶导数用于边缘检测"><a href="#2、二阶导数用于边缘检测" class="headerlink" title="2、二阶导数用于边缘检测"></a>2、<strong>二阶导数用于边缘检测</strong></h5><p><strong>Marr-Hildreth边缘检测器</strong></p>
<p>Marr和Hildreth证明：</p>
<ol>
<li>灰度变化与图像尺寸无关，要求检测使用不同尺寸的算子</li>
<li>灰度的突然变化会在一阶导数中引起波峰或波谷，二阶导数中等效地引起零交叉</li>
</ol>
<p>所以边缘检测算子应有两个显著特点：</p>
<ol>
<li>检测微分算子是一个能计算图像中每一点处的一阶导数或二阶导数</li>
<li>能被调整以便在任何期望的尺寸上起作用</li>
</ol>
<p>Marr和Hildreth论证，满足上述条件的算子是滤波器&nabla;<sup>2</sup>G，&nabla;<sup>2</sup>是拉普拉斯算子，G是二维高斯函数</p>
<script type="math/tex; mode=display">
\begin{align}G(x,y)=e^{-\frac{x^2+y^2}{2\sigma^2}},\nabla^2G(x,y)=&\frac{\partial^2G(x,y)}{\partial x^2}+\frac{\partial^2(x,y)}{\partial y^2}=\frac{\partial}{\partial x}[\frac{-x}{\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}]+\frac{\partial}{\partial y}[\frac{-y}{\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}]\\
=&[\frac{x^2}{\sigma^4}-\frac{1}{\sigma^2}]e^{-\frac{x^2+y^2}{2\sigma^2}}+[\frac{y^2}{\sigma^4}-\frac{1}{\sigma^2}]e^{-\frac{x^2+y^2}{2\sigma^2}} \\
=&[\frac{x^2+y^2-2\sigma^2}{\sigma^4}]e^{-\frac{x^2+y^2}{2\sigma^2}}
\end{align}</script><p>上式称为高斯拉普拉斯(LoG)</p>
<p><strong>为什么选择高斯拉普拉斯算子？</strong></p>
<ol>
<li>算子的高斯部分会模糊图像，从而在寸尺上将结构的灰度(包括噪声)降低到远小于&sigma;的程度，并且高斯滤波可以用于空域和频域。</li>
<li>拉普拉斯使用了二阶导数，并具有各向同性的优点，避免了使用多个模板去计算图像中任何点处的最强响应。</li>
</ol>
<p>Marr-Hildreth边缘检测算法由LOG滤波器与一幅输入图像f(x,y)卷积组成，即：</p>
<script type="math/tex; mode=display">
g(x,y)=[\nabla^2G(x,y)]*f(x,y)，由于操作都是线性的，所以\Leftrightarrow g(x,y)=\nabla^2[G(x,y)*f(x,y)]</script><p><strong>Marr-Hildreth步骤：</strong></p>
<ol>
<li><p>用一个对高斯取样得到的nxn的高斯低通滤波器(大小为nxn的LoG离散滤波器，其n值应该是大于等于6&sigma;的最小奇整数，解释在p461)对输入图像滤波</p>
</li>
<li><p>计算由第一步得到的图像的拉普拉斯</p>
<p>拉普拉斯算子可用如下所示的模板：</p>
<script type="math/tex; mode=display">
\begin{matrix} 1 & 1 & 1 \\ 1 & -8 & 1 \\ 1 & 1 & 1 \end{matrix}</script></li>
<li><p>找步骤2所得图像的零交叉(一种方法是用以p为中心的一个3x3领域，判断至少两个相对的领域像素的符号不同左/右、上/下和两个对角)，并将g(x,y)与一个给定的阈值比较。</p>
</li>
</ol>
<p>Marr-Hildreth指出使用DoG(高斯差分近似高斯拉普拉斯是可能的)</p>
<script type="math/tex; mode=display">
DoG(x,y)=\frac{1}{2\pi\sigma_1^2}e^{-\frac{x^2+y^2}{2\sigma_1^2}}-\frac{1}{2\pi\sigma_2^2}e^{-\frac{x^2+y^2}{2\sigma_2^2}},其中，\sigma_1\gt\sigma_2</script><h5 id="3、坎尼检测器-Canny-检测器"><a href="#3、坎尼检测器-Canny-检测器" class="headerlink" title="3、坎尼检测器(Canny)检测器"></a>3、坎尼检测器(Canny)检测器</h5><p>三个基本目标：</p>
<ol>
<li>低错误率。所有边缘都应被找到，并且应该没有伪响应。</li>
<li>边缘点应被很好地定位。已定位边缘必须尽可能接近真实边缘。</li>
<li>单一的边缘点响应。对于真实的边缘点，检测器仅应返回一个点。 </li>
</ol>
<p>对由加性高斯白噪声污染的一维台阶边缘。其最佳台阶边缘检测器的一个较好近似是高斯一阶导数：</p>
<script type="math/tex; mode=display">
\frac{d}{dx}e^{-\frac{x^2}{2\sigma^2}}=\frac{-x}{\sigma^2}e^{-\frac{x^2}{2\sigma^2}}</script><p>为了将一维推广到二维，因为预先法线方向未知，就需要在所有可能的方向上应用一维边缘检测器。</p>
<p>因此，canny边缘检测算法是由下列基本步骤组成的：</p>
<ol>
<li><p>用一个高斯滤波器平滑输入灰度图像g<sub>s</sub>，主要为了降噪，同时也可能增大边缘的宽度</p>
</li>
<li><p>利用prewitt或sobel算子获取平滑后图像的梯度图，计算梯度幅值图和角度图</p>
<script type="math/tex; mode=display">
M(x,y)=\sqrt{g_x^2+g_y^2},\alpha(x,y)=\arctan[\frac{g_y}{g_x}],g_x=\partial f_s/\partial x,g_y=\partial f_s/\partial y</script></li>
<li><p>对梯度幅值图像应用非极大值抑制</p>
<p>本质是指定边缘法线的许多离散方向，通常定义四个边缘方向：水平、垂直、+45&deg;和-45&deg;。由边缘法线的方向(角度图中获得)确定边缘方向。假设令d<sub>1</sub>，d<sub>2</sub>，d<sub>3</sub>，d<sub>4</sub>表示3x3区域的四个基本边缘方向：水平、垂直、+45&deg;和-45&deg;。(为什么？一个中心像素其左右，上下和两个对角线上才有幅度值，为了找出极大值，需要先确定x,y点最接近的梯度方向，当然用线性插值计算参与比较的像素梯度值也可)</p>
<p>对于&alpha;(x,y)中以点(x,y)为中心的3x3区域，非最大抑制方向为：1、寻找最接近&alpha;(x,y)的方向d<sub>k</sub>，2、如果M(x,y)的值至少小于沿d<sub>k</sub>的两个邻居之一，则令g<sub>N</sub>(x,y)=0(抑制)；否则，令g<sub>N</sub>(x,y)=M(x,y)，g<sub>N</sub>是非最大抑制后的图像。g<sub>N</sub>为新创建的一个array</p>
</li>
<li><p>用双阈值(滞后阈值)和连接分析来检测并连接边缘</p>
<p>对g<sub>N</sub>进行阈值处理(二值化)，定义一个高阈值和一个低阈值。梯度强度低于低阈值的像素点被抑制，不作为边缘点；高于高阈值的像素点被定义为强边缘，保留为边缘点；处于高低阈值之间的定义为弱边缘，如果与确定为边缘的像素点邻接(4或8)，则判定为边缘；否则为非边缘。具体步骤看数字图像处理第三版p465。</p>
<ul>
<li>如果x，y梯度幅值⼤于⾼阈值的话，令g<sub>N</sub>=255</li>
<li>如果x，y梯度幅值小于⾼阈值的话，令g<sub>N</sub>=0</li>
<li>如果x，y梯度幅值介于⾼阈值和低阈值之间并且周围8邻域内有⽐⾼阈值⾼的像素点存在，令g<sub>N</sub>=255</li>
</ul>
<p><strong>梯度方向量化</strong></p>
<script type="math/tex; mode=display">
angle =
\begin{cases}
0 & \text{-0.4142<tan<0.4142}  \\
45 & \text{0.4142<tan<2.4142} \\
90 & |tan|\ge2.4142\\
135 & \text{-2.4142<tan<0.4142}
\end{cases}</script></li>
</ol>
   <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Canny</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># Gray scale</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">BGR2GRAY</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">		b = img[:, :, <span class="number">0</span>].copy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">		g = img[:, :, <span class="number">1</span>].copy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">		r = img[:, :, <span class="number">2</span>].copy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># Gray scale</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">		out = <span class="number">0.2126</span> * r + <span class="number">0.7152</span> * g + <span class="number">0.0722</span> * b</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">		out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># Gaussian filter for grayscale</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">gaussian_filter</span><span class="params">(img, K_size=<span class="number">3</span>, sigma=<span class="number">1.3</span>)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">if</span> len(img.shape) == <span class="number">3</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">			H, W, C = img.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">			gray = <span class="literal">False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">			img = np.expand_dims(img, axis=<span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">			H, W, C = img.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">			gray = <span class="literal">True</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">		<span class="comment">## Zero padding</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">		pad = K_size // <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">		out = np.zeros([H + pad * <span class="number">2</span>, W + pad * <span class="number">2</span>, C], dtype=np.float)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">		out[pad : pad + H, pad : pad + W] = img.copy().astype(np.float)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">		<span class="comment">## prepare Kernel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">		K = np.zeros((K_size, K_size), dtype=np.float)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">for</span> x <span class="keyword">in</span> range(-pad, -pad + K_size):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">for</span> y <span class="keyword">in</span> range(-pad, -pad + K_size):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">				K[y + pad, x + pad] = np.exp( - (x ** <span class="number">2</span> + y ** <span class="number">2</span>) / (<span class="number">2</span> * sigma * sigma))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">		<span class="comment">#K /= (sigma * np.sqrt(2 * np.pi))</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">		K /= (<span class="number">2</span> * np.pi * sigma * sigma)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">		K /= K.sum()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">		tmp = out.copy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># filtering</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">				<span class="keyword">for</span> c <span class="keyword">in</span> range(C):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">					out[pad + y, pad + x, c] = np.sum(K * tmp[y : y + K_size, x : x + K_size, c])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">		out = np.clip(out, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">		out = out[pad : pad + H, pad : pad + W]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">		out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">if</span> gray:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">			out = out[..., <span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># sobel filter</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sobel_filter</span><span class="params">(img, K_size=<span class="number">3</span>)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">if</span> len(img.shape) == <span class="number">3</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">			H, W, C = img.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">			H, W = img.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># Zero padding</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">		pad = K_size // <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">		out = np.zeros((H + pad * <span class="number">2</span>, W + pad * <span class="number">2</span>), dtype=np.float)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">		out[pad : pad + H, pad : pad + W] = img.copy().astype(np.float)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">		tmp = out.copy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">		out_v = out.copy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">		out_h = out.copy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">		<span class="comment">## Sobel vertical</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">		Kv = [[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">1.</span>],[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>], [<span class="number">-1.</span>, <span class="number">-2.</span>, <span class="number">-1.</span>]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">		<span class="comment">## Sobel horizontal</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">		Kh = [[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">-1.</span>],[<span class="number">2.</span>, <span class="number">0.</span>, <span class="number">-2.</span>],[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">-1.</span>]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># filtering</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">				out_v[pad + y, pad + x] = np.sum(Kv * (tmp[y : y + K_size, x : x + K_size]))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">				out_h[pad + y, pad + x] = np.sum(Kh * (tmp[y : y + K_size, x : x + K_size]))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">		out_v = np.clip(out_v, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">		out_h = np.clip(out_h, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">		out_v = out_v[pad : pad + H, pad : pad + W]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line">		out_v = out_v.astype(np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line">		out_h = out_h[pad : pad + H, pad : pad + W]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line">		out_h = out_h.astype(np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">97</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">98</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">return</span> out_v, out_h</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">99</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">100</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">101</span></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_edge_angle</span><span class="params">(fx, fy)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">102</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># get edge strength</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">103</span></pre></td><td class="code"><pre><span class="line">		edge = np.sqrt(np.power(fx.astype(np.float32), <span class="number">2</span>) + np.power(fy.astype(np.float32), <span class="number">2</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">104</span></pre></td><td class="code"><pre><span class="line">		edge = np.clip(edge, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">105</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">106</span></pre></td><td class="code"><pre><span class="line">		fx = np.maximum(fx, <span class="number">1e-10</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">107</span></pre></td><td class="code"><pre><span class="line">		<span class="comment">#fx[np.abs(fx) &lt;= 1e-5] = 1e-5</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">108</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">109</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># get edge angle</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">110</span></pre></td><td class="code"><pre><span class="line">		angle = np.arctan(fy / fx)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">111</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">112</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">return</span> edge, angle</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">113</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">114</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">115</span></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">angle_quantization</span><span class="params">(angle)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">116</span></pre></td><td class="code"><pre><span class="line">		angle = angle / np.pi * <span class="number">180</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">117</span></pre></td><td class="code"><pre><span class="line">		angle[angle &lt; <span class="number">-22.5</span>] = <span class="number">180</span> + angle[angle &lt; <span class="number">-22.5</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">118</span></pre></td><td class="code"><pre><span class="line">		_angle = np.zeros_like(angle, dtype=np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">119</span></pre></td><td class="code"><pre><span class="line">		_angle[np.where(angle &lt;= <span class="number">22.5</span>)] = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">120</span></pre></td><td class="code"><pre><span class="line">		_angle[np.where((angle &gt; <span class="number">22.5</span>) &amp; (angle &lt;= <span class="number">67.5</span>))] = <span class="number">45</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">121</span></pre></td><td class="code"><pre><span class="line">		_angle[np.where((angle &gt; <span class="number">67.5</span>) &amp; (angle &lt;= <span class="number">112.5</span>))] = <span class="number">90</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">122</span></pre></td><td class="code"><pre><span class="line">		_angle[np.where((angle &gt; <span class="number">112.5</span>) &amp; (angle &lt;= <span class="number">157.5</span>))] = <span class="number">135</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">123</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">124</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">return</span> _angle</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">125</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">126</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">127</span></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">non_maximum_suppression</span><span class="params">(angle, edge)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">128</span></pre></td><td class="code"><pre><span class="line">		H, W = angle.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">129</span></pre></td><td class="code"><pre><span class="line">		_edge = edge.copy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">130</span></pre></td><td class="code"><pre><span class="line">		</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">131</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">132</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">133</span></pre></td><td class="code"><pre><span class="line">					<span class="keyword">if</span> angle[y, x] == <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">134</span></pre></td><td class="code"><pre><span class="line">							dx1, dy1, dx2, dy2 = <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">135</span></pre></td><td class="code"><pre><span class="line">					<span class="keyword">elif</span> angle[y, x] == <span class="number">45</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">136</span></pre></td><td class="code"><pre><span class="line">							dx1, dy1, dx2, dy2 = <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">137</span></pre></td><td class="code"><pre><span class="line">					<span class="keyword">elif</span> angle[y, x] == <span class="number">90</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">138</span></pre></td><td class="code"><pre><span class="line">							dx1, dy1, dx2, dy2 = <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">139</span></pre></td><td class="code"><pre><span class="line">					<span class="keyword">elif</span> angle[y, x] == <span class="number">135</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">140</span></pre></td><td class="code"><pre><span class="line">							dx1, dy1, dx2, dy2 = <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">141</span></pre></td><td class="code"><pre><span class="line">					<span class="keyword">if</span> x == <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">142</span></pre></td><td class="code"><pre><span class="line">							dx1 = max(dx1, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">143</span></pre></td><td class="code"><pre><span class="line">							dx2 = max(dx2, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">144</span></pre></td><td class="code"><pre><span class="line">					<span class="keyword">if</span> x == W<span class="number">-1</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">145</span></pre></td><td class="code"><pre><span class="line">							dx1 = min(dx1, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">146</span></pre></td><td class="code"><pre><span class="line">							dx2 = min(dx2, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">147</span></pre></td><td class="code"><pre><span class="line">					<span class="keyword">if</span> y == <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">148</span></pre></td><td class="code"><pre><span class="line">							dy1 = max(dy1, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">149</span></pre></td><td class="code"><pre><span class="line">							dy2 = max(dy2, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">150</span></pre></td><td class="code"><pre><span class="line">					<span class="keyword">if</span> y == H<span class="number">-1</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">151</span></pre></td><td class="code"><pre><span class="line">							dy1 = min(dy1, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">152</span></pre></td><td class="code"><pre><span class="line">							dy2 = min(dy2, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">153</span></pre></td><td class="code"><pre><span class="line">					<span class="keyword">if</span> max(max(edge[y, x], edge[y + dy1, x + dx1]), edge[y + dy2, x + dx2]) != edge[y, x]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">154</span></pre></td><td class="code"><pre><span class="line">							_edge[y, x] = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">155</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">156</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">return</span> _edge</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">157</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">158</span></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">hysterisis</span><span class="params">(edge, HT=<span class="number">100</span>, LT=<span class="number">30</span>)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">159</span></pre></td><td class="code"><pre><span class="line">		H, W = edge.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">160</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">161</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># Histeresis threshold</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">162</span></pre></td><td class="code"><pre><span class="line">		edge[edge &gt;= HT] = <span class="number">255</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">163</span></pre></td><td class="code"><pre><span class="line">		edge[edge &lt;= LT] = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">164</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">165</span></pre></td><td class="code"><pre><span class="line">		_edge = np.zeros((H + <span class="number">2</span>, W + <span class="number">2</span>), dtype=np.float32)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">166</span></pre></td><td class="code"><pre><span class="line">		_edge[<span class="number">1</span> : H + <span class="number">1</span>, <span class="number">1</span> : W + <span class="number">1</span>] = edge</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">167</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">168</span></pre></td><td class="code"><pre><span class="line">		<span class="comment">## 8 - Nearest neighbor</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">169</span></pre></td><td class="code"><pre><span class="line">		nn = np.array(((<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>), (<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>), (<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>)), dtype=np.float32)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">170</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">171</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>, H+<span class="number">2</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">172</span></pre></td><td class="code"><pre><span class="line">				<span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, W+<span class="number">2</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">173</span></pre></td><td class="code"><pre><span class="line">						<span class="keyword">if</span> _edge[y, x] &lt; LT <span class="keyword">or</span> _edge[y, x] &gt; HT:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">174</span></pre></td><td class="code"><pre><span class="line">								<span class="keyword">continue</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">175</span></pre></td><td class="code"><pre><span class="line">						<span class="keyword">if</span> np.max(_edge[y<span class="number">-1</span>:y+<span class="number">2</span>, x<span class="number">-1</span>:x+<span class="number">2</span>] * nn) &gt;= HT:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">176</span></pre></td><td class="code"><pre><span class="line">								_edge[y, x] = <span class="number">255</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">177</span></pre></td><td class="code"><pre><span class="line">						<span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">178</span></pre></td><td class="code"><pre><span class="line">								_edge[y, x] = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">179</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">180</span></pre></td><td class="code"><pre><span class="line">		edge = _edge[<span class="number">1</span>:H+<span class="number">1</span>, <span class="number">1</span>:W+<span class="number">1</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">181</span></pre></td><td class="code"><pre><span class="line">								</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">182</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">return</span> edge</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">183</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">184</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># grayscale</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">185</span></pre></td><td class="code"><pre><span class="line">	gray = BGR2GRAY(img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">186</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">187</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># gaussian filtering</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">188</span></pre></td><td class="code"><pre><span class="line">	gaussian = gaussian_filter(gray, K_size=<span class="number">5</span>, sigma=<span class="number">1.4</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">189</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">190</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># sobel filtering</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">191</span></pre></td><td class="code"><pre><span class="line">	fy, fx = sobel_filter(gaussian, K_size=<span class="number">3</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">192</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">193</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># get edge strength, angle</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">194</span></pre></td><td class="code"><pre><span class="line">	edge, angle = get_edge_angle(fx, fy)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">195</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">196</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># angle quantization</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">197</span></pre></td><td class="code"><pre><span class="line">	angle = angle_quantization(angle)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">198</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">199</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># non maximum suppression</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">200</span></pre></td><td class="code"><pre><span class="line">	edge = non_maximum_suppression(angle, edge)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">201</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">202</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># hysterisis threshold</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">203</span></pre></td><td class="code"><pre><span class="line">	out = hysterisis(edge, <span class="number">50</span>, <span class="number">20</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">204</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">205</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">206</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">207</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Read image</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">208</span></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imori.jpg"</span>).astype(np.float32)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">209</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">210</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Canny</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">211</span></pre></td><td class="code"><pre><span class="line">edge = Canny(img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">212</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">213</span></pre></td><td class="code"><pre><span class="line">out = edge.astype(np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">214</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">215</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Save result</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">216</span></pre></td><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">"out.jpg"</span>, out)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">217</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"result"</span>, out)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">218</span></pre></td><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">219</span></pre></td><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
   <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// RGB to Gray scale</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">BGR2GRAY</span><span class="params">(cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// BGR -&gt; Gray</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (<span class="keyword">int</span>)((<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">0</span>] * <span class="number">0.0722</span> + \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">1</span>] * <span class="number">0.7152</span> + \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">2</span>] * <span class="number">0.2126</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">clip</span><span class="params">(<span class="keyword">float</span> value, <span class="keyword">float</span> <span class="built_in">min</span>, <span class="keyword">float</span> <span class="built_in">max</span>)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> fmin(fmax(value, <span class="number">0</span>), <span class="number">255</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// gaussian filter</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">gaussian_filter</span><span class="params">(cv::Mat img, <span class="keyword">double</span> sigma, <span class="keyword">int</span> kernel_size)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC3);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (channel == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// prepare kernel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> pad = <span class="built_in">floor</span>(kernel_size / <span class="number">2</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> _x = <span class="number">0</span>, _y = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> kernel_sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// get gaussian kernel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">float</span> kernel[kernel_size][kernel_size];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; kernel_size; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; kernel_size; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">      _y = y - pad;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">      _x = x - pad; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">      kernel[y][x] = <span class="number">1</span> / (<span class="number">2</span> * M_PI * sigma * sigma) * <span class="built_in">exp</span>( - (_x * _x + _y * _y) / (<span class="number">2</span> * sigma * sigma));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">      kernel_sum += kernel[y][x];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; kernel_size; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; kernel_size; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">      kernel[y][x] /= kernel_sum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// filtering</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// for BGR</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (channel == <span class="number">3</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">          v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> dy = -pad; dy &lt; pad + <span class="number">1</span>; dy++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> dx = -pad; dx &lt; pad + <span class="number">1</span>; dx++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">              <span class="keyword">if</span> (((x + dx) &gt;= <span class="number">0</span>) &amp;&amp; ((y + dy) &gt;= <span class="number">0</span>) &amp;&amp; ((x + dx) &lt; <span class="built_in">width</span>) &amp;&amp; ((y + dy) &lt; <span class="built_in">height</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">                v += (<span class="keyword">double</span>)img.at&lt;cv::Vec3b&gt;(y + dy, x + dx)[c] * kernel[dy + pad][dx + pad];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">              &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">          out.at&lt;cv::Vec3b&gt;(y, x)[c] = (uchar)clip(v, <span class="number">0</span>, <span class="number">255</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// for Gray</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">        v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dy = -pad; dy &lt; pad + <span class="number">1</span>; dy++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> dx = -pad; dx &lt; pad + <span class="number">1</span>; dx++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (((x + dx) &gt;= <span class="number">0</span>) &amp;&amp; ((y + dy) &gt;= <span class="number">0</span>) &amp;&amp; ((x + dx) &lt; <span class="built_in">width</span>) &amp;&amp; ((y + dy) &lt; <span class="built_in">height</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">              v += (<span class="keyword">double</span>)img.at&lt;uchar&gt;(y + dy, x + dx) * kernel[dy + pad][dx + pad];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">        out.at&lt;uchar&gt;(y, x) = (uchar)clip(v, <span class="number">0</span>, <span class="number">255</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sobel filter</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">97</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">sobel_filter</span><span class="params">(cv::Mat img, <span class="keyword">int</span> kernel_size, <span class="keyword">bool</span> horizontal)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">98</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">99</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">100</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">101</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">102</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">103</span></pre></td><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">104</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">105</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// prepare kernel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">106</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> kernel[kernel_size][kernel_size] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">107</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">108</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (horizontal)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">109</span></pre></td><td class="code"><pre><span class="line">    kernel[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">110</span></pre></td><td class="code"><pre><span class="line">    kernel[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">111</span></pre></td><td class="code"><pre><span class="line">    kernel[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">112</span></pre></td><td class="code"><pre><span class="line">    kernel[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">-2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">113</span></pre></td><td class="code"><pre><span class="line">    kernel[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">114</span></pre></td><td class="code"><pre><span class="line">    kernel[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">115</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">116</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">117</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> pad = <span class="built_in">floor</span>(kernel_size / <span class="number">2</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">118</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">119</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">120</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">121</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// filtering  </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">122</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">123</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">124</span></pre></td><td class="code"><pre><span class="line">      v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">125</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> dy = -pad; dy &lt; pad + <span class="number">1</span>; dy++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">126</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dx = -pad; dx &lt; pad + <span class="number">1</span>; dx++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">127</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">if</span> (((y + dy) &gt;= <span class="number">0</span>) &amp;&amp; (( x + dx) &gt;= <span class="number">0</span>) &amp;&amp; ((y + dy) &lt; <span class="built_in">height</span>) &amp;&amp; ((x + dx) &lt; <span class="built_in">width</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">128</span></pre></td><td class="code"><pre><span class="line">            v += (<span class="keyword">double</span>)img.at&lt;uchar&gt;(y + dy, x + dx) * kernel[dy + pad][dx + pad];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">129</span></pre></td><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">130</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">131</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">132</span></pre></td><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (uchar)clip(v, <span class="number">0</span>, <span class="number">255</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">133</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">134</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">135</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">136</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">137</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">138</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// get edge</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">139</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">get_edge</span><span class="params">(cv::Mat fx, cv::Mat fy)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">140</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">141</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = fx.rows;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">142</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = fx.cols;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">143</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">144</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">145</span></pre></td><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">146</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">147</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> _fx, _fy;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">148</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">149</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">150</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">151</span></pre></td><td class="code"><pre><span class="line">      _fx = (<span class="keyword">double</span>)fx.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">152</span></pre></td><td class="code"><pre><span class="line">      _fy = (<span class="keyword">double</span>)fy.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">153</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">154</span></pre></td><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (uchar)clip(<span class="built_in">sqrt</span>(_fx * _fx + _fy * _fy), <span class="number">0</span>, <span class="number">255</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">155</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">156</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">157</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">158</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">159</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">160</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">161</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// get angle</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">162</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">get_angle</span><span class="params">(cv::Mat fx, cv::Mat fy)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">163</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">164</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = fx.rows;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">165</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = fx.cols;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">166</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">167</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">168</span></pre></td><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">169</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">170</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> _fx, _fy;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">171</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> angle;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">172</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">173</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">174</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">175</span></pre></td><td class="code"><pre><span class="line">      _fx = fmax((<span class="keyword">double</span>)fx.at&lt;uchar&gt;(y, x), <span class="number">0.000001</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">176</span></pre></td><td class="code"><pre><span class="line">      _fy = (<span class="keyword">double</span>)fy.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">177</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">178</span></pre></td><td class="code"><pre><span class="line">      angle = <span class="built_in">atan2</span>(_fy, _fx);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">179</span></pre></td><td class="code"><pre><span class="line">      angle = angle / M_PI * <span class="number">180</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">180</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">181</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span>(angle &lt; <span class="number">-22.5</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">182</span></pre></td><td class="code"><pre><span class="line">        angle = <span class="number">180</span> + angle;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">183</span></pre></td><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (angle &gt;= <span class="number">157.5</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">184</span></pre></td><td class="code"><pre><span class="line">        angle = angle - <span class="number">180</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">185</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">186</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">187</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">//std::cout &lt;&lt; angle &lt;&lt; " " ;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">188</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">189</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// quantization</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">190</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (angle &lt;= <span class="number">22.5</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">191</span></pre></td><td class="code"><pre><span class="line">        out.at&lt;uchar&gt;(y, x) = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">192</span></pre></td><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (angle &lt;= <span class="number">67.5</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">193</span></pre></td><td class="code"><pre><span class="line">        out.at&lt;uchar&gt;(y, x) = <span class="number">45</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">194</span></pre></td><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (angle &lt;= <span class="number">112.5</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">195</span></pre></td><td class="code"><pre><span class="line">        out.at&lt;uchar&gt;(y, x) = <span class="number">90</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">196</span></pre></td><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">197</span></pre></td><td class="code"><pre><span class="line">        out.at&lt;uchar&gt;(y, x) = <span class="number">135</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">198</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">199</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">200</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">201</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">202</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">203</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">204</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">205</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">206</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// non maximum suppression</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">207</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">non_maximum_suppression</span><span class="params">(cv::Mat angle, cv::Mat edge)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">208</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = angle.rows;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">209</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = angle.cols;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">210</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = angle.channels();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">211</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">212</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> dx1, dx2, dy1, dy2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">213</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> now_angle;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">214</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">215</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">216</span></pre></td><td class="code"><pre><span class="line">  cv::Mat _edge = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">217</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">218</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">219</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">220</span></pre></td><td class="code"><pre><span class="line">      now_angle = angle.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">221</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// angle condition</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">222</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (now_angle == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">223</span></pre></td><td class="code"><pre><span class="line">        dx1 = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">224</span></pre></td><td class="code"><pre><span class="line">        dy1 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">225</span></pre></td><td class="code"><pre><span class="line">        dx2 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">226</span></pre></td><td class="code"><pre><span class="line">        dy2 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">227</span></pre></td><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(now_angle == <span class="number">45</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">228</span></pre></td><td class="code"><pre><span class="line">        dx1 = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">229</span></pre></td><td class="code"><pre><span class="line">        dy1 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">230</span></pre></td><td class="code"><pre><span class="line">        dx2 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">231</span></pre></td><td class="code"><pre><span class="line">        dy2 = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">232</span></pre></td><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(now_angle == <span class="number">90</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">233</span></pre></td><td class="code"><pre><span class="line">        dx1 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">234</span></pre></td><td class="code"><pre><span class="line">        dy1 = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">235</span></pre></td><td class="code"><pre><span class="line">        dx2 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">236</span></pre></td><td class="code"><pre><span class="line">        dy2 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">237</span></pre></td><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">238</span></pre></td><td class="code"><pre><span class="line">        dx1 = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">239</span></pre></td><td class="code"><pre><span class="line">        dy1 = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">240</span></pre></td><td class="code"><pre><span class="line">        dx2 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">241</span></pre></td><td class="code"><pre><span class="line">        dy2 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">242</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">243</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">244</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (x == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">245</span></pre></td><td class="code"><pre><span class="line">        dx1 = fmax(dx1, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">246</span></pre></td><td class="code"><pre><span class="line">        dx2 = fmax(dx2, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">247</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">248</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (x == (<span class="built_in">width</span> - <span class="number">1</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">249</span></pre></td><td class="code"><pre><span class="line">        dx1 = fmin(dx1, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">250</span></pre></td><td class="code"><pre><span class="line">        dx2 = fmin(dx2, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">251</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">252</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (y == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">253</span></pre></td><td class="code"><pre><span class="line">        dy1 = fmax(dy1, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">254</span></pre></td><td class="code"><pre><span class="line">        dy2 = fmax(dy2, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">255</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">256</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (y == (<span class="built_in">height</span> - <span class="number">1</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">257</span></pre></td><td class="code"><pre><span class="line">        dy1 = fmin(dy1, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">258</span></pre></td><td class="code"><pre><span class="line">        dy2 = fmin(dy2, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">259</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">260</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">261</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// if pixel is max among adjuscent pixels, pixel is kept</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">262</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (fmax(fmax(edge.at&lt;uchar&gt;(y, x), edge.at&lt;uchar&gt;(y + dy1, x + dx1)), edge.at&lt;uchar&gt;(y + dy2, x + dx2)) == edge.at&lt;uchar&gt;(y, x)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">263</span></pre></td><td class="code"><pre><span class="line">        _edge.at&lt;uchar&gt;(y, x) = edge.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">264</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">265</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">266</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">267</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">268</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> _edge;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">269</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">270</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">271</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// histerisis</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">272</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">histerisis</span><span class="params">(cv::Mat edge, <span class="keyword">int</span> HT, <span class="keyword">int</span> LT)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">273</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = edge.rows;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">274</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = edge.cols;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">275</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> channle = edge.channels();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">276</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">277</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">278</span></pre></td><td class="code"><pre><span class="line">  cv::Mat _edge = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">279</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">280</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> now_pixel;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">281</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">282</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">283</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">284</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// get pixel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">285</span></pre></td><td class="code"><pre><span class="line">      now_pixel = edge.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">286</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">287</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// if pixel &gt;= HT</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">288</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (now_pixel &gt;= HT)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">289</span></pre></td><td class="code"><pre><span class="line">        _edge.at&lt;uchar&gt;(y, x) = <span class="number">255</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">290</span></pre></td><td class="code"><pre><span class="line">      &#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">291</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// if LT &lt; pixel &lt; HT</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">292</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (now_pixel &gt; LT) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">293</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dy = <span class="number">-1</span>; dy &lt; <span class="number">2</span>; dy++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">294</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> dx = <span class="number">-1</span>; dx &lt; <span class="number">2</span>; dx++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">295</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// if 8 nearest neighbor pixel &gt;= HT</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">296</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (edge.at&lt;uchar&gt;(fmin(fmax(y + dy, <span class="number">0</span>), <span class="number">255</span>), fmin(fmax(x + dx, <span class="number">0</span>), <span class="number">255</span>)) &gt;= HT)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">297</span></pre></td><td class="code"><pre><span class="line">              _edge.at&lt;uchar&gt;(y, x) = <span class="number">255</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">298</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">299</span></pre></td><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">300</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">301</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">302</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">303</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">304</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> _edge;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">305</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">306</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">307</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">308</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Canny</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">309</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">Canny</span><span class="params">(cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">310</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// BGR -&gt; Gray</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">311</span></pre></td><td class="code"><pre><span class="line">  cv::Mat gray = BGR2GRAY(img);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">312</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">313</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// gaussian filter</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">314</span></pre></td><td class="code"><pre><span class="line">  cv::Mat gaussian = gaussian_filter(gray, <span class="number">1.4</span>, <span class="number">5</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">315</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">316</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// sobel filter (vertical)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">317</span></pre></td><td class="code"><pre><span class="line">  cv::Mat fy = sobel_filter(gaussian, <span class="number">3</span>, <span class="literal">false</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">318</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">319</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// sobel filter (horizontal)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">320</span></pre></td><td class="code"><pre><span class="line">  cv::Mat fx = sobel_filter(gaussian, <span class="number">3</span>, <span class="literal">true</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">321</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">322</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// get edge</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">323</span></pre></td><td class="code"><pre><span class="line">  cv::Mat edge = get_edge(fx, fy);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">324</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">325</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// get angle</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">326</span></pre></td><td class="code"><pre><span class="line">  cv::Mat angle = get_angle(fx, fy);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">327</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">328</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// edge non-maximum suppression</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">329</span></pre></td><td class="code"><pre><span class="line">  edge = non_maximum_suppression(angle, edge);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">330</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">331</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// histerisis</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">332</span></pre></td><td class="code"><pre><span class="line">  edge = histerisis(edge, <span class="number">50</span>, <span class="number">20</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">333</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">334</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> edge;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">335</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">336</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">337</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">338</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// read image</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">339</span></pre></td><td class="code"><pre><span class="line">  cv::Mat img = cv::imread(<span class="string">"imori.jpg"</span>, cv::IMREAD_COLOR);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">340</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">341</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Canny</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">342</span></pre></td><td class="code"><pre><span class="line">  cv::Mat edge = Canny(img);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">343</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">344</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//cv::imwrite("out.jpg", out);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">345</span></pre></td><td class="code"><pre><span class="line">  cv::imshow(<span class="string">"answer(edge)"</span>, edge);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">346</span></pre></td><td class="code"><pre><span class="line">  cv::waitKey(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">347</span></pre></td><td class="code"><pre><span class="line">  cv::destroyAllWindows();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">348</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">349</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h5 id="4、直线检测-霍夫变换-Hough-Transform"><a href="#4、直线检测-霍夫变换-Hough-Transform" class="headerlink" title="4、直线检测-霍夫变换(Hough Transform)"></a>4、直线检测-霍夫变换(Hough Transform)</h5><p> 考虑<strong>xy平面</strong>上的一个点(x<sub>i</sub>,y<sub>i</sub>)和斜截式形式为y<sub>i</sub>=ax<sub>i</sub>+b的一条直线。通过点(x<sub>i</sub>,y<sub>i</sub>)的直线有无数条，且对a和b的不同值，他们都满足方程y<sub>i</sub>=ax<sub>i</sub>+b。该式可以写成b=-x<sub>i</sub>a+y<sub>i</sub>，考虑<strong>ab平面(参数空间)</strong>，将得到固定点(x<sub>i</sub>,y<sub>i</sub>)的单一直线方程。<strong>什么意思？</strong>就是说在xy平面中直线L上的点，因为有固定的斜率和截距，所以转到ab参数空间中的时候，xy平面直线L上的任意点，因为有不同的x值和y值，所以在ab参数空间会对应以-x为斜率y为截距的一组直线，这组ab参数空间中的直线相交于一个点(a<sup>‘</sup>，b<sup>’</sup>)。</p>
<p>那么接下来就是要统计在ab平面中交与一点的点在xy平面中的坐标，直接从xy平面向ab平面转换时有个问题，就是当垂直时斜率a没法求tan(90&deg;)趋于无穷。所以需要做一个极坐标的转换：</p>
<script type="math/tex; mode=display">
\frac{x}{\rho}=\cos\theta,\frac{y}{\rho}=\sin\theta;\frac{x\cos\theta}{\rho}=\cos^2\theta,\frac{y\sin\theta}{\rho}=\sin^2\theta,所以，x\cos\theta+y\sin\theta=\rho</script><p>水平直线有&theta;=0&deg;，&rho;等于正的x的截距。类似地，垂直直线有&theta;=90&deg;，&rho;等于正的y截距；或者有&theta;=-90&deg;，&rho;等于负的y的截距。</p>
<p><img src="/2021/07/25/Image-Process-Edge-Detection/1.png" alt="Image-Process-Edge-Detection"></p>
<p><img src="/2021/07/25/Image-Process-Edge-Detection/1.png" alt="Image-Process-Edge-Detection"></p>
<p>霍夫变换可将&rho;&theta;参数空间划分为所谓的累计单元，其中(&rho;<sub>min</sub>,&rho;<sub>max</sub>)和(&theta;<sub>min</sub>,&theta;<sub>max</sub>)是所有期望的参数值范围：-90&deg;&le;&theta;&le;90&deg;和-D&le;&rho;&le;D，其中D是图像中对角之间的最大距离。D的值从&rho;关于x，y坐标的关系可以看出。如果获取坐标(i，j)处的累加值A(i，j)，对应于参数空间坐标(&rho;<sub>i</sub>,&theta;<sub>j</sub>)相关联的累加单元。</p>
<ul>
<li>将所有的累加单元置零</li>
<li>对于xy平面中的每个非背景点(x<sub>k</sub>，y<sub>k</sub>)，令&theta;等于&theta;轴上每个允许的细分值，同时使用方程&rho;=x<sub>k</sub>cos&theta;+y<sub>k</sub>sin&theta;解出对应的&rho;</li>
<li>对&rho;四舍五入，得到沿&theta;轴最接近的一个允许单元值</li>
<li>如果选择一个&theta;<sub>p</sub>得到解&rho;<sub>q</sub>，则令A(p,q)=A(p,q)+1</li>
<li>所有非背景点结束后，A(i,j)中的值P将意味着xy平面中有P个点位于直线xcos&theta;<sub>j</sub>+ysin&theta;<sub>j</sub>=&rho;<sub>i</sub>上。</li>
</ul>
<p>&rho;&theta;平面中的细分数量决定了这些点的共线性的精确度。对于对于霍夫变换用于别的形状的分析看数字图像处理第三版p474。</p>
<p><strong>霍夫变换的方法</strong></p>
<ol>
<li><p>用边缘图像来对边缘像素进行霍夫变换</p>
<p>1.1    求出图像的对角线长r<sub>max</sub>;</p>
<p>1.2    在用检测算法检测到的边缘点(x,y)处，&theta;取遍[0,179]，求取&rho;值</p>
<p>1.3    做一个180 &times; &rho;<sub>max</sub>大小的表，根据1.2式计算的&rho;值对表进行投票</p>
</li>
<li><p>霍夫变换后获取值的直方图并选择最大点</p>
<p>2.1    在上述表中，如果遍历到的像素的投票数⼤于其8近邻的像素值，则它不变</p>
<p>2.2    如果遍历到的像素的投票数⼩于其8近邻的像素值，则设置为0(NMS)</p>
</li>
<li><p>对极大值点的&rho;和&theta;的值进行霍夫逆变换以获得检测到的直线方程</p>
<script type="math/tex; mode=display">
y=-\frac{\cos\theta}{\sin\theta}x+\frac{r}{\sin\theta},x=-\frac{\sin\theta}{\cos\theta}y+\frac{r}{\cos\theta}</script></li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Canny</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># Gray scale</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">BGR2GRAY</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">		b = img[:, :, <span class="number">0</span>].copy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">		g = img[:, :, <span class="number">1</span>].copy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">		r = img[:, :, <span class="number">2</span>].copy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># Gray scale</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">		out = <span class="number">0.2126</span> * r + <span class="number">0.7152</span> * g + <span class="number">0.0722</span> * b</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">		out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># Gaussian filter for grayscale</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">gaussian_filter</span><span class="params">(img, K_size=<span class="number">3</span>, sigma=<span class="number">1.3</span>)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">if</span> len(img.shape) == <span class="number">3</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">			H, W, C = img.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">			gray = <span class="literal">False</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">			img = np.expand_dims(img, axis=<span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">			H, W, C = img.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">			gray = <span class="literal">True</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">		<span class="comment">## Zero padding</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">		pad = K_size // <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">		out = np.zeros([H + pad * <span class="number">2</span>, W + pad * <span class="number">2</span>, C], dtype=np.float)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">		out[pad : pad + H, pad : pad + W] = img.copy().astype(np.float)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">		<span class="comment">## prepare Kernel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">		K = np.zeros((K_size, K_size), dtype=np.float)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">for</span> x <span class="keyword">in</span> range(-pad, -pad + K_size):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">for</span> y <span class="keyword">in</span> range(-pad, -pad + K_size):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">				K[y + pad, x + pad] = np.exp( - (x ** <span class="number">2</span> + y ** <span class="number">2</span>) / (<span class="number">2</span> * sigma * sigma))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">		<span class="comment">#K /= (sigma * np.sqrt(2 * np.pi))</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">		K /= (<span class="number">2</span> * np.pi * sigma * sigma)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">		K /= K.sum()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">		tmp = out.copy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># filtering</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">				<span class="keyword">for</span> c <span class="keyword">in</span> range(C):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">					out[pad + y, pad + x, c] = np.sum(K * tmp[y : y + K_size, x : x + K_size, c])</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">		out = np.clip(out, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">		out = out[pad : pad + H, pad : pad + W]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">		out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">if</span> gray:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">			out = out[..., <span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># sobel filter</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sobel_filter</span><span class="params">(img, K_size=<span class="number">3</span>)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">if</span> len(img.shape) == <span class="number">3</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">			H, W, C = img.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">			H, W = img.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># Zero padding</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">		pad = K_size // <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">		out = np.zeros((H + pad * <span class="number">2</span>, W + pad * <span class="number">2</span>), dtype=np.float)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">		out[pad : pad + H, pad : pad + W] = img.copy().astype(np.float)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">		tmp = out.copy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">		out_v = out.copy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">		out_h = out.copy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">		<span class="comment">## Sobel vertical</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">		Kv = [[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">1.</span>],[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>], [<span class="number">-1.</span>, <span class="number">-2.</span>, <span class="number">-1.</span>]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">		<span class="comment">## Sobel horizontal</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">		Kh = [[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">-1.</span>],[<span class="number">2.</span>, <span class="number">0.</span>, <span class="number">-2.</span>],[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">-1.</span>]]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># filtering</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">				out_v[pad + y, pad + x] = np.sum(Kv * (tmp[y : y + K_size, x : x + K_size]))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">				out_h[pad + y, pad + x] = np.sum(Kh * (tmp[y : y + K_size, x : x + K_size]))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">		out_v = np.clip(out_v, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">		out_h = np.clip(out_h, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">		out_v = out_v[pad : pad + H, pad : pad + W]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line">		out_v = out_v.astype(np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line">		out_h = out_h[pad : pad + H, pad : pad + W]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line">		out_h = out_h.astype(np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">97</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">98</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">return</span> out_v, out_h</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">99</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">100</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">101</span></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_edge_angle</span><span class="params">(fx, fy)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">102</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># get edge strength</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">103</span></pre></td><td class="code"><pre><span class="line">		edge = np.sqrt(np.power(fx.astype(np.float32), <span class="number">2</span>) + np.power(fy.astype(np.float32), <span class="number">2</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">104</span></pre></td><td class="code"><pre><span class="line">		edge = np.clip(edge, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">105</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">106</span></pre></td><td class="code"><pre><span class="line">		fx = np.maximum(fx, <span class="number">1e-10</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">107</span></pre></td><td class="code"><pre><span class="line">		<span class="comment">#fx[np.abs(fx) &lt;= 1e-5] = 1e-5</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">108</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">109</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># get edge angle</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">110</span></pre></td><td class="code"><pre><span class="line">		angle = np.arctan(fy / fx)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">111</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">112</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">return</span> edge, angle</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">113</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">114</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">115</span></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">angle_quantization</span><span class="params">(angle)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">116</span></pre></td><td class="code"><pre><span class="line">		angle = angle / np.pi * <span class="number">180</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">117</span></pre></td><td class="code"><pre><span class="line">		angle[angle &lt; <span class="number">-22.5</span>] = <span class="number">180</span> + angle[angle &lt; <span class="number">-22.5</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">118</span></pre></td><td class="code"><pre><span class="line">		_angle = np.zeros_like(angle, dtype=np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">119</span></pre></td><td class="code"><pre><span class="line">		_angle[np.where(angle &lt;= <span class="number">22.5</span>)] = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">120</span></pre></td><td class="code"><pre><span class="line">		_angle[np.where((angle &gt; <span class="number">22.5</span>) &amp; (angle &lt;= <span class="number">67.5</span>))] = <span class="number">45</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">121</span></pre></td><td class="code"><pre><span class="line">		_angle[np.where((angle &gt; <span class="number">67.5</span>) &amp; (angle &lt;= <span class="number">112.5</span>))] = <span class="number">90</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">122</span></pre></td><td class="code"><pre><span class="line">		_angle[np.where((angle &gt; <span class="number">112.5</span>) &amp; (angle &lt;= <span class="number">157.5</span>))] = <span class="number">135</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">123</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">124</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">return</span> _angle</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">125</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">126</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">127</span></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">non_maximum_suppression</span><span class="params">(angle, edge)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">128</span></pre></td><td class="code"><pre><span class="line">		H, W = angle.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">129</span></pre></td><td class="code"><pre><span class="line">		_edge = edge.copy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">130</span></pre></td><td class="code"><pre><span class="line">		</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">131</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">132</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">133</span></pre></td><td class="code"><pre><span class="line">					<span class="keyword">if</span> angle[y, x] == <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">134</span></pre></td><td class="code"><pre><span class="line">							dx1, dy1, dx2, dy2 = <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">135</span></pre></td><td class="code"><pre><span class="line">					<span class="keyword">elif</span> angle[y, x] == <span class="number">45</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">136</span></pre></td><td class="code"><pre><span class="line">							dx1, dy1, dx2, dy2 = <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">137</span></pre></td><td class="code"><pre><span class="line">					<span class="keyword">elif</span> angle[y, x] == <span class="number">90</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">138</span></pre></td><td class="code"><pre><span class="line">							dx1, dy1, dx2, dy2 = <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">139</span></pre></td><td class="code"><pre><span class="line">					<span class="keyword">elif</span> angle[y, x] == <span class="number">135</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">140</span></pre></td><td class="code"><pre><span class="line">							dx1, dy1, dx2, dy2 = <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">141</span></pre></td><td class="code"><pre><span class="line">					<span class="keyword">if</span> x == <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">142</span></pre></td><td class="code"><pre><span class="line">							dx1 = max(dx1, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">143</span></pre></td><td class="code"><pre><span class="line">							dx2 = max(dx2, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">144</span></pre></td><td class="code"><pre><span class="line">					<span class="keyword">if</span> x == W<span class="number">-1</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">145</span></pre></td><td class="code"><pre><span class="line">							dx1 = min(dx1, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">146</span></pre></td><td class="code"><pre><span class="line">							dx2 = min(dx2, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">147</span></pre></td><td class="code"><pre><span class="line">					<span class="keyword">if</span> y == <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">148</span></pre></td><td class="code"><pre><span class="line">							dy1 = max(dy1, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">149</span></pre></td><td class="code"><pre><span class="line">							dy2 = max(dy2, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">150</span></pre></td><td class="code"><pre><span class="line">					<span class="keyword">if</span> y == H<span class="number">-1</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">151</span></pre></td><td class="code"><pre><span class="line">							dy1 = min(dy1, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">152</span></pre></td><td class="code"><pre><span class="line">							dy2 = min(dy2, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">153</span></pre></td><td class="code"><pre><span class="line">					<span class="keyword">if</span> max(max(edge[y, x], edge[y + dy1, x + dx1]), edge[y + dy2, x + dx2]) != edge[y, x]:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">154</span></pre></td><td class="code"><pre><span class="line">							_edge[y, x] = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">155</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">156</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">return</span> _edge</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">157</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">158</span></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">hysterisis</span><span class="params">(edge, HT=<span class="number">100</span>, LT=<span class="number">30</span>)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">159</span></pre></td><td class="code"><pre><span class="line">		H, W = edge.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">160</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">161</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># Histeresis threshold</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">162</span></pre></td><td class="code"><pre><span class="line">		edge[edge &gt;= HT] = <span class="number">255</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">163</span></pre></td><td class="code"><pre><span class="line">		edge[edge &lt;= LT] = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">164</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">165</span></pre></td><td class="code"><pre><span class="line">		_edge = np.zeros((H + <span class="number">2</span>, W + <span class="number">2</span>), dtype=np.float32)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">166</span></pre></td><td class="code"><pre><span class="line">		_edge[<span class="number">1</span> : H + <span class="number">1</span>, <span class="number">1</span> : W + <span class="number">1</span>] = edge</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">167</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">168</span></pre></td><td class="code"><pre><span class="line">		<span class="comment">## 8 - Nearest neighbor</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">169</span></pre></td><td class="code"><pre><span class="line">		nn = np.array(((<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>), (<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>), (<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>)), dtype=np.float32)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">170</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">171</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>, H+<span class="number">2</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">172</span></pre></td><td class="code"><pre><span class="line">				<span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, W+<span class="number">2</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">173</span></pre></td><td class="code"><pre><span class="line">						<span class="keyword">if</span> _edge[y, x] &lt; LT <span class="keyword">or</span> _edge[y, x] &gt; HT:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">174</span></pre></td><td class="code"><pre><span class="line">								<span class="keyword">continue</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">175</span></pre></td><td class="code"><pre><span class="line">						<span class="keyword">if</span> np.max(_edge[y<span class="number">-1</span>:y+<span class="number">2</span>, x<span class="number">-1</span>:x+<span class="number">2</span>] * nn) &gt;= HT:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">176</span></pre></td><td class="code"><pre><span class="line">								_edge[y, x] = <span class="number">255</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">177</span></pre></td><td class="code"><pre><span class="line">						<span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">178</span></pre></td><td class="code"><pre><span class="line">								_edge[y, x] = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">179</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">180</span></pre></td><td class="code"><pre><span class="line">		edge = _edge[<span class="number">1</span>:H+<span class="number">1</span>, <span class="number">1</span>:W+<span class="number">1</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">181</span></pre></td><td class="code"><pre><span class="line">								</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">182</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">return</span> edge</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">183</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">184</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># grayscale</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">185</span></pre></td><td class="code"><pre><span class="line">	gray = BGR2GRAY(img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">186</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">187</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># gaussian filtering</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">188</span></pre></td><td class="code"><pre><span class="line">	gaussian = gaussian_filter(gray, K_size=<span class="number">5</span>, sigma=<span class="number">1.4</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">189</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">190</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># sobel filtering</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">191</span></pre></td><td class="code"><pre><span class="line">	fy, fx = sobel_filter(gaussian, K_size=<span class="number">3</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">192</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">193</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># get edge strength, angle</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">194</span></pre></td><td class="code"><pre><span class="line">	edge, angle = get_edge_angle(fx, fy)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">195</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">196</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># angle quantization</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">197</span></pre></td><td class="code"><pre><span class="line">	angle = angle_quantization(angle)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">198</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">199</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># non maximum suppression</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">200</span></pre></td><td class="code"><pre><span class="line">	edge = non_maximum_suppression(angle, edge)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">201</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">202</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># hysterisis threshold</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">203</span></pre></td><td class="code"><pre><span class="line">	out = hysterisis(edge, <span class="number">100</span>, <span class="number">30</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">204</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">205</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">206</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">207</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">208</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Hough_Line</span><span class="params">(edge, img)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">209</span></pre></td><td class="code"><pre><span class="line">	<span class="comment">## Voting</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">210</span></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">voting</span><span class="params">(edge)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">211</span></pre></td><td class="code"><pre><span class="line">		H, W = edge.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">212</span></pre></td><td class="code"><pre><span class="line">		</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">213</span></pre></td><td class="code"><pre><span class="line">		drho = <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">214</span></pre></td><td class="code"><pre><span class="line">		dtheta = <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">215</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">216</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># get rho max length</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">217</span></pre></td><td class="code"><pre><span class="line">		rho_max = np.ceil(np.sqrt(H ** <span class="number">2</span> + W ** <span class="number">2</span>)).astype(np.int)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">218</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">219</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># hough table</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">220</span></pre></td><td class="code"><pre><span class="line">		hough = np.zeros((rho_max * <span class="number">2</span>, <span class="number">180</span>), dtype=np.int)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">221</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">222</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># get index of edge</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">223</span></pre></td><td class="code"><pre><span class="line">		ind = np.where(edge == <span class="number">255</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">224</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">225</span></pre></td><td class="code"><pre><span class="line">		<span class="comment">## hough transformation</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">226</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">for</span> y, x <span class="keyword">in</span> zip(ind[<span class="number">0</span>], ind[<span class="number">1</span>]):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">227</span></pre></td><td class="code"><pre><span class="line">				<span class="keyword">for</span> theta <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">180</span>, dtheta):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">228</span></pre></td><td class="code"><pre><span class="line">						<span class="comment"># get polar coordinat4s</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">229</span></pre></td><td class="code"><pre><span class="line">						t = np.pi / <span class="number">180</span> * theta</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">230</span></pre></td><td class="code"><pre><span class="line">						rho = int(x * np.cos(t) + y * np.sin(t))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">231</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">232</span></pre></td><td class="code"><pre><span class="line">						<span class="comment"># vote</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">233</span></pre></td><td class="code"><pre><span class="line">						hough[rho + rho_max, theta] += <span class="number">1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">234</span></pre></td><td class="code"><pre><span class="line">							</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">235</span></pre></td><td class="code"><pre><span class="line">		out = hough.astype(np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">236</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">237</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">238</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">239</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># non maximum suppression</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">240</span></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">non_maximum_suppression</span><span class="params">(hough)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">241</span></pre></td><td class="code"><pre><span class="line">		rho_max, _ = hough.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">242</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">243</span></pre></td><td class="code"><pre><span class="line">		<span class="comment">## non maximum suppression</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">244</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(rho_max):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">245</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">180</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">246</span></pre></td><td class="code"><pre><span class="line">				<span class="comment"># get 8 nearest neighbor</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">247</span></pre></td><td class="code"><pre><span class="line">				x1 = max(x<span class="number">-1</span>, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">248</span></pre></td><td class="code"><pre><span class="line">				x2 = min(x+<span class="number">2</span>, <span class="number">180</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">249</span></pre></td><td class="code"><pre><span class="line">				y1 = max(y<span class="number">-1</span>, <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">250</span></pre></td><td class="code"><pre><span class="line">				y2 = min(y+<span class="number">2</span>, rho_max<span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">251</span></pre></td><td class="code"><pre><span class="line">				<span class="keyword">if</span> np.max(hough[y1:y2, x1:x2]) == hough[y,x] <span class="keyword">and</span> hough[y, x] != <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">252</span></pre></td><td class="code"><pre><span class="line">					<span class="keyword">pass</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">253</span></pre></td><td class="code"><pre><span class="line">					<span class="comment">#hough[y,x] = 255</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">254</span></pre></td><td class="code"><pre><span class="line">				<span class="keyword">else</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">255</span></pre></td><td class="code"><pre><span class="line">					hough[y,x] = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">256</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">257</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">return</span> hough</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">258</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">259</span></pre></td><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inverse_hough</span><span class="params">(hough, img)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">260</span></pre></td><td class="code"><pre><span class="line">		H, W, _ = img.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">261</span></pre></td><td class="code"><pre><span class="line">		rho_max, _ = hough.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">262</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">263</span></pre></td><td class="code"><pre><span class="line">		out = img.copy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">264</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">265</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># get x, y index of hough table</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">266</span></pre></td><td class="code"><pre><span class="line">		ind_x = np.argsort(hough.ravel())[::<span class="number">-1</span>][:<span class="number">20</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">267</span></pre></td><td class="code"><pre><span class="line">		ind_y = ind_x.copy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">268</span></pre></td><td class="code"><pre><span class="line">		thetas = ind_x % <span class="number">180</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">269</span></pre></td><td class="code"><pre><span class="line">		rhos = ind_y // <span class="number">180</span> - rho_max / <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">270</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">271</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># each theta and rho</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">272</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">for</span> theta, rho <span class="keyword">in</span> zip(thetas, rhos):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">273</span></pre></td><td class="code"><pre><span class="line">			<span class="comment"># theta[radian] -&gt; angle[degree]</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">274</span></pre></td><td class="code"><pre><span class="line">			t = np.pi / <span class="number">180.</span> * theta</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">275</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">276</span></pre></td><td class="code"><pre><span class="line">			<span class="comment"># hough -&gt; (x,y)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">277</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">278</span></pre></td><td class="code"><pre><span class="line">				<span class="keyword">if</span> np.sin(t) != <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">279</span></pre></td><td class="code"><pre><span class="line">					y = - (np.cos(t) / np.sin(t)) * x + (rho) / np.sin(t)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">280</span></pre></td><td class="code"><pre><span class="line">					y = int(y)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">281</span></pre></td><td class="code"><pre><span class="line">					<span class="keyword">if</span> y &gt;= H <span class="keyword">or</span> y &lt; <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">282</span></pre></td><td class="code"><pre><span class="line">						<span class="keyword">continue</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">283</span></pre></td><td class="code"><pre><span class="line">					out[y, x] = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">284</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">285</span></pre></td><td class="code"><pre><span class="line">				<span class="keyword">if</span> np.cos(t) != <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">286</span></pre></td><td class="code"><pre><span class="line">					x = - (np.sin(t) / np.cos(t)) * y + (rho) / np.cos(t)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">287</span></pre></td><td class="code"><pre><span class="line">					x = int(x)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">288</span></pre></td><td class="code"><pre><span class="line">					<span class="keyword">if</span> x &gt;= W <span class="keyword">or</span> x &lt; <span class="number">0</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">289</span></pre></td><td class="code"><pre><span class="line">						<span class="keyword">continue</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">290</span></pre></td><td class="code"><pre><span class="line">					out[y, x] = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">291</span></pre></td><td class="code"><pre><span class="line">				</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">292</span></pre></td><td class="code"><pre><span class="line">		out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">293</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">294</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">295</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">296</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">297</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># voting</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">298</span></pre></td><td class="code"><pre><span class="line">	hough = voting(edge)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">299</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">300</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># non maximum suppression</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">301</span></pre></td><td class="code"><pre><span class="line">	hough = non_maximum_suppression(hough)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">302</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">303</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># inverse hough</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">304</span></pre></td><td class="code"><pre><span class="line">	out = inverse_hough(hough, img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">305</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">306</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">307</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">308</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">309</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Read image</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">310</span></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"thorino.jpg"</span>).astype(np.float32)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">311</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">312</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Canny</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">313</span></pre></td><td class="code"><pre><span class="line">edge = Canny(img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">314</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">315</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Hough</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">316</span></pre></td><td class="code"><pre><span class="line">out = Hough_Line(edge, img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">317</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">318</span></pre></td><td class="code"><pre><span class="line">out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">319</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">320</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Save result</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">321</span></pre></td><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">"out.jpg"</span>, out)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">322</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"result"</span>, out)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">323</span></pre></td><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">324</span></pre></td><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core.hpp&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// RGB to Gray scale</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">BGR2GRAY</span><span class="params">(cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// BGR -&gt; Gray</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (<span class="keyword">int</span>)((<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">0</span>] * <span class="number">0.0722</span> + \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">1</span>] * <span class="number">0.7152</span> + \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">2</span>] * <span class="number">0.2126</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">clip</span><span class="params">(<span class="keyword">float</span> value, <span class="keyword">float</span> <span class="built_in">min</span>, <span class="keyword">float</span> <span class="built_in">max</span>)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> fmin(fmax(value, <span class="number">0</span>), <span class="number">255</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// gaussian filter</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">gaussian_filter</span><span class="params">(cv::Mat img, <span class="keyword">double</span> sigma, <span class="keyword">int</span> kernel_size)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC3);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (channel == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// prepare kernel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> pad = <span class="built_in">floor</span>(kernel_size / <span class="number">2</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> _x = <span class="number">0</span>, _y = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> kernel_sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// get gaussian kernel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">float</span> kernel[kernel_size][kernel_size];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; kernel_size; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; kernel_size; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">      _y = y - pad;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">      _x = x - pad; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">      kernel[y][x] = <span class="number">1</span> / (<span class="number">2</span> * M_PI * sigma * sigma) * <span class="built_in">exp</span>( - (_x * _x + _y * _y) / (<span class="number">2</span> * sigma * sigma));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">      kernel_sum += kernel[y][x];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; kernel_size; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; kernel_size; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">      kernel[y][x] /= kernel_sum;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// filtering</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// for BGR</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (channel == <span class="number">3</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">          v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> dy = -pad; dy &lt; pad + <span class="number">1</span>; dy++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> dx = -pad; dx &lt; pad + <span class="number">1</span>; dx++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">              <span class="keyword">if</span> (((x + dx) &gt;= <span class="number">0</span>) &amp;&amp; ((y + dy) &gt;= <span class="number">0</span>) &amp;&amp; ((x + dx) &lt; <span class="built_in">width</span>) &amp;&amp; ((y + dy) &lt; <span class="built_in">height</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">                v += (<span class="keyword">double</span>)img.at&lt;cv::Vec3b&gt;(y + dy, x + dx)[c] * kernel[dy + pad][dx + pad];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">              &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">          out.at&lt;cv::Vec3b&gt;(y, x)[c] = (uchar)clip(v, <span class="number">0</span>, <span class="number">255</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// for Gray</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">        v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dy = -pad; dy &lt; pad + <span class="number">1</span>; dy++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> dx = -pad; dx &lt; pad + <span class="number">1</span>; dx++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (((x + dx) &gt;= <span class="number">0</span>) &amp;&amp; ((y + dy) &gt;= <span class="number">0</span>) &amp;&amp; ((x + dx) &lt; <span class="built_in">width</span>) &amp;&amp; ((y + dy) &lt; <span class="built_in">height</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">              v += (<span class="keyword">double</span>)img.at&lt;uchar&gt;(y + dy, x + dx) * kernel[dy + pad][dx + pad];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line">        out.at&lt;uchar&gt;(y, x) = (uchar)clip(v, <span class="number">0</span>, <span class="number">255</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">97</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">98</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">99</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">100</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">101</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">102</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Sobel filter</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">103</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">sobel_filter</span><span class="params">(cv::Mat img, <span class="keyword">int</span> kernel_size, <span class="keyword">bool</span> horizontal)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">104</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">105</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">106</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">107</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">108</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">109</span></pre></td><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">110</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">111</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// prepare kernel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">112</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> kernel[kernel_size][kernel_size] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">113</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">114</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">if</span> (horizontal)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">115</span></pre></td><td class="code"><pre><span class="line">    kernel[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">116</span></pre></td><td class="code"><pre><span class="line">    kernel[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">117</span></pre></td><td class="code"><pre><span class="line">    kernel[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">118</span></pre></td><td class="code"><pre><span class="line">    kernel[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">-2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">119</span></pre></td><td class="code"><pre><span class="line">    kernel[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">120</span></pre></td><td class="code"><pre><span class="line">    kernel[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">121</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">122</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">123</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> pad = <span class="built_in">floor</span>(kernel_size / <span class="number">2</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">124</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">125</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">126</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">127</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// filtering  </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">128</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">129</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">130</span></pre></td><td class="code"><pre><span class="line">      v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">131</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> dy = -pad; dy &lt; pad + <span class="number">1</span>; dy++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">132</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dx = -pad; dx &lt; pad + <span class="number">1</span>; dx++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">133</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">if</span> (((y + dy) &gt;= <span class="number">0</span>) &amp;&amp; (( x + dx) &gt;= <span class="number">0</span>) &amp;&amp; ((y + dy) &lt; <span class="built_in">height</span>) &amp;&amp; ((x + dx) &lt; <span class="built_in">width</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">134</span></pre></td><td class="code"><pre><span class="line">            v += (<span class="keyword">double</span>)img.at&lt;uchar&gt;(y + dy, x + dx) * kernel[dy + pad][dx + pad];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">135</span></pre></td><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">136</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">137</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">138</span></pre></td><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (uchar)clip(v, <span class="number">0</span>, <span class="number">255</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">139</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">140</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">141</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">142</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">143</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">144</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// get edge</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">145</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">get_edge</span><span class="params">(cv::Mat fx, cv::Mat fy)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">146</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">147</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = fx.rows;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">148</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = fx.cols;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">149</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">150</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">151</span></pre></td><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">152</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">153</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> _fx, _fy;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">154</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">155</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">156</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">157</span></pre></td><td class="code"><pre><span class="line">      _fx = (<span class="keyword">double</span>)fx.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">158</span></pre></td><td class="code"><pre><span class="line">      _fy = (<span class="keyword">double</span>)fy.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">159</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">160</span></pre></td><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (uchar)clip(<span class="built_in">sqrt</span>(_fx * _fx + _fy * _fy), <span class="number">0</span>, <span class="number">255</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">161</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">162</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">163</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">164</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">165</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">166</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">167</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// get angle</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">168</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">get_angle</span><span class="params">(cv::Mat fx, cv::Mat fy)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">169</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">170</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = fx.rows;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">171</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = fx.cols;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">172</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">173</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">174</span></pre></td><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">175</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">176</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> _fx, _fy;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">177</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> angle;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">178</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">179</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">180</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">181</span></pre></td><td class="code"><pre><span class="line">      _fx = fmax((<span class="keyword">double</span>)fx.at&lt;uchar&gt;(y, x), <span class="number">0.000001</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">182</span></pre></td><td class="code"><pre><span class="line">      _fy = (<span class="keyword">double</span>)fy.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">183</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">184</span></pre></td><td class="code"><pre><span class="line">      angle = <span class="built_in">atan2</span>(_fy, _fx);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">185</span></pre></td><td class="code"><pre><span class="line">      angle = angle / M_PI * <span class="number">180</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">186</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">187</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span>(angle &lt; <span class="number">-22.5</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">188</span></pre></td><td class="code"><pre><span class="line">        angle = <span class="number">180</span> + angle;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">189</span></pre></td><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (angle &gt;= <span class="number">157.5</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">190</span></pre></td><td class="code"><pre><span class="line">        angle = angle - <span class="number">180</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">191</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">192</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">193</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// quantization</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">194</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (angle &lt;= <span class="number">22.5</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">195</span></pre></td><td class="code"><pre><span class="line">        out.at&lt;uchar&gt;(y, x) = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">196</span></pre></td><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (angle &lt;= <span class="number">67.5</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">197</span></pre></td><td class="code"><pre><span class="line">        out.at&lt;uchar&gt;(y, x) = <span class="number">45</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">198</span></pre></td><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (angle &lt;= <span class="number">112.5</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">199</span></pre></td><td class="code"><pre><span class="line">        out.at&lt;uchar&gt;(y, x) = <span class="number">90</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">200</span></pre></td><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">201</span></pre></td><td class="code"><pre><span class="line">        out.at&lt;uchar&gt;(y, x) = <span class="number">135</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">202</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">203</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">204</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">205</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">206</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">207</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">208</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">209</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">210</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// non maximum suppression</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">211</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">non_maximum_suppression</span><span class="params">(cv::Mat angle, cv::Mat edge)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">212</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = angle.rows;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">213</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = angle.cols;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">214</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = angle.channels();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">215</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">216</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> dx1, dx2, dy1, dy2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">217</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> now_angle;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">218</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">219</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">220</span></pre></td><td class="code"><pre><span class="line">  cv::Mat _edge = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">221</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">222</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">223</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">224</span></pre></td><td class="code"><pre><span class="line">      now_angle = angle.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">225</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// angle condition</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">226</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (now_angle == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">227</span></pre></td><td class="code"><pre><span class="line">        dx1 = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">228</span></pre></td><td class="code"><pre><span class="line">        dy1 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">229</span></pre></td><td class="code"><pre><span class="line">        dx2 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">230</span></pre></td><td class="code"><pre><span class="line">        dy2 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">231</span></pre></td><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(now_angle == <span class="number">45</span>) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">232</span></pre></td><td class="code"><pre><span class="line">        dx1 = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">233</span></pre></td><td class="code"><pre><span class="line">        dy1 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">234</span></pre></td><td class="code"><pre><span class="line">        dx2 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">235</span></pre></td><td class="code"><pre><span class="line">        dy2 = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">236</span></pre></td><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(now_angle == <span class="number">90</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">237</span></pre></td><td class="code"><pre><span class="line">        dx1 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">238</span></pre></td><td class="code"><pre><span class="line">        dy1 = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">239</span></pre></td><td class="code"><pre><span class="line">        dx2 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">240</span></pre></td><td class="code"><pre><span class="line">        dy2 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">241</span></pre></td><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">242</span></pre></td><td class="code"><pre><span class="line">        dx1 = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">243</span></pre></td><td class="code"><pre><span class="line">        dy1 = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">244</span></pre></td><td class="code"><pre><span class="line">        dx2 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">245</span></pre></td><td class="code"><pre><span class="line">        dy2 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">246</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">247</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">248</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (x == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">249</span></pre></td><td class="code"><pre><span class="line">        dx1 = fmax(dx1, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">250</span></pre></td><td class="code"><pre><span class="line">        dx2 = fmax(dx2, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">251</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">252</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (x == (<span class="built_in">width</span> - <span class="number">1</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">253</span></pre></td><td class="code"><pre><span class="line">        dx1 = fmin(dx1, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">254</span></pre></td><td class="code"><pre><span class="line">        dx2 = fmin(dx2, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">255</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">256</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (y == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">257</span></pre></td><td class="code"><pre><span class="line">        dy1 = fmax(dy1, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">258</span></pre></td><td class="code"><pre><span class="line">        dy2 = fmax(dy2, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">259</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">260</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (y == (<span class="built_in">height</span> - <span class="number">1</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">261</span></pre></td><td class="code"><pre><span class="line">        dy1 = fmin(dy1, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">262</span></pre></td><td class="code"><pre><span class="line">        dy2 = fmin(dy2, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">263</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">264</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">265</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// if pixel is max among adjuscent pixels, pixel is kept</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">266</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (fmax(fmax(edge.at&lt;uchar&gt;(y, x), edge.at&lt;uchar&gt;(y + dy1, x + dx1)), edge.at&lt;uchar&gt;(y + dy2, x + dx2)) == edge.at&lt;uchar&gt;(y, x)) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">267</span></pre></td><td class="code"><pre><span class="line">        _edge.at&lt;uchar&gt;(y, x) = edge.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">268</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">269</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">270</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">271</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">272</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> _edge;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">273</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">274</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">275</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// histerisis</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">276</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">histerisis</span><span class="params">(cv::Mat edge, <span class="keyword">int</span> HT, <span class="keyword">int</span> LT)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">277</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = edge.rows;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">278</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = edge.cols;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">279</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> channle = edge.channels();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">280</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">281</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">282</span></pre></td><td class="code"><pre><span class="line">  cv::Mat _edge = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">283</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">284</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> now_pixel;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">285</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">286</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">287</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">288</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// get pixel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">289</span></pre></td><td class="code"><pre><span class="line">      now_pixel = edge.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">290</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">291</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// if pixel &gt;= HT</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">292</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (now_pixel &gt;= HT)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">293</span></pre></td><td class="code"><pre><span class="line">        _edge.at&lt;uchar&gt;(y, x) = <span class="number">255</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">294</span></pre></td><td class="code"><pre><span class="line">      &#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">295</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// if LT &lt; pixel &lt; HT</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">296</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (now_pixel &gt; LT) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">297</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dy = <span class="number">-1</span>; dy &lt; <span class="number">2</span>; dy++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">298</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> dx = <span class="number">-1</span>; dx &lt; <span class="number">2</span>; dx++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">299</span></pre></td><td class="code"><pre><span class="line">            <span class="comment">// if 8 nearest neighbor pixel &gt;= HT</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">300</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">if</span> (edge.at&lt;uchar&gt;(fmin(fmax(y + dy, <span class="number">0</span>), <span class="number">255</span>), fmin(fmax(x + dx, <span class="number">0</span>), <span class="number">255</span>)) &gt;= HT)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">301</span></pre></td><td class="code"><pre><span class="line">              _edge.at&lt;uchar&gt;(y, x) = <span class="number">255</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">302</span></pre></td><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">303</span></pre></td><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">304</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">305</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">306</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">307</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">308</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> _edge;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">309</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">310</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">311</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">312</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Canny</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">313</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">Canny</span><span class="params">(cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">314</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// BGR -&gt; Gray</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">315</span></pre></td><td class="code"><pre><span class="line">  cv::Mat gray = BGR2GRAY(img);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">316</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">317</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// gaussian filter</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">318</span></pre></td><td class="code"><pre><span class="line">  cv::Mat gaussian = gaussian_filter(gray, <span class="number">1.4</span>, <span class="number">5</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">319</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">320</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// sobel filter (vertical)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">321</span></pre></td><td class="code"><pre><span class="line">  cv::Mat fy = sobel_filter(gaussian, <span class="number">3</span>, <span class="literal">false</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">322</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">323</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// sobel filter (horizontal)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">324</span></pre></td><td class="code"><pre><span class="line">  cv::Mat fx = sobel_filter(gaussian, <span class="number">3</span>, <span class="literal">true</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">325</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">326</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// get edge</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">327</span></pre></td><td class="code"><pre><span class="line">  cv::Mat edge = get_edge(fx, fy);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">328</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">329</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// get angle</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">330</span></pre></td><td class="code"><pre><span class="line">  cv::Mat angle = get_angle(fx, fy);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">331</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">332</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// edge non-maximum suppression</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">333</span></pre></td><td class="code"><pre><span class="line">  edge = non_maximum_suppression(angle, edge);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">334</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">335</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// histerisis</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">336</span></pre></td><td class="code"><pre><span class="line">  edge = histerisis(edge, <span class="number">100</span>, <span class="number">30</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">337</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">338</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> edge;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">339</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">340</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">341</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">342</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">343</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//------</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">344</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// hough</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">345</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">346</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ANGLE_T = <span class="number">180</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">347</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> RHO_MAX = <span class="number">320</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">348</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">349</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// hough table</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">350</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct_hough_table</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">351</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> table[RHO_MAX * <span class="number">2</span>][ANGLE_T];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">352</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">353</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">354</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// hough vote</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">355</span></pre></td><td class="code"><pre><span class="line"><span class="function">struct_hough_table <span class="title">Hough_vote</span><span class="params">(struct_hough_table hough_table, cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">356</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">357</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">358</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> rho = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">359</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> angle = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">360</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">361</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">362</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">363</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">364</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// if not edge, skip</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">365</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (img.at&lt;uchar&gt;(y, x) != <span class="number">255</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">366</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">367</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">368</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">369</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// 0 &lt;= angle t &lt; 180</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">370</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; ANGLE_T; t++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">371</span></pre></td><td class="code"><pre><span class="line">        angle = M_PI / <span class="number">180</span> * t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">372</span></pre></td><td class="code"><pre><span class="line">        rho = (<span class="keyword">int</span>)(x * <span class="built_in">cos</span>(angle) + y * <span class="built_in">sin</span>(angle));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">373</span></pre></td><td class="code"><pre><span class="line">        hough_table.table[rho + RHO_MAX][t] ++;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">374</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">375</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">376</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">377</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">378</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> hough_table;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">379</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">380</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">381</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// hough nms</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">382</span></pre></td><td class="code"><pre><span class="line"><span class="function">struct_hough_table <span class="title">Hough_NMS</span><span class="params">(struct_hough_table hough_table)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">383</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// output hough table</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">384</span></pre></td><td class="code"><pre><span class="line">  struct_hough_table output_hough_table;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">385</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">386</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// initialize 0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">387</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> rho = <span class="number">0</span>; rho &lt; RHO_MAX * <span class="number">2</span>; rho++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">388</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; ANGLE_T; t++)&#123; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">389</span></pre></td><td class="code"><pre><span class="line">      output_hough_table.table[rho][t] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">390</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">391</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">392</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">393</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">394</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// top N x, y</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">395</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> N = <span class="number">30</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">396</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> top_N_rho[N], top_N_t[N], top_N_vote[N];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">397</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> tmp_rho, <span class="keyword">tmp_t</span>, tmp_vote, tmp_rho2, tmp_t2, tmp_vote2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">398</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> rho, t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">399</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">400</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; N; n++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">401</span></pre></td><td class="code"><pre><span class="line">    top_N_rho[n] = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">402</span></pre></td><td class="code"><pre><span class="line">    top_N_t[n] = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">403</span></pre></td><td class="code"><pre><span class="line">    top_N_vote[n] = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">404</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">405</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">406</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> rho = <span class="number">0</span>; rho &lt; RHO_MAX * <span class="number">2</span>; rho++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">407</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; ANGLE_T; t++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">408</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (hough_table.table[rho][t] == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">409</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">410</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">411</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">412</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// compare to left top</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">413</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (((t - <span class="number">1</span>) &gt;= <span class="number">0</span>) &amp;&amp; ((rho - <span class="number">1</span>) &gt;= <span class="number">0</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">414</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (hough_table.table[rho][t] &lt; hough_table.table[rho - <span class="number">1</span>][t - <span class="number">1</span>])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">415</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">416</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">417</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">418</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">419</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// comparet to top</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">420</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> ((rho - <span class="number">1</span>) &gt;= <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">421</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (hough_table.table[rho][t] &lt; hough_table.table[rho - <span class="number">1</span>][t])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">422</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">423</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">424</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">425</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">426</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// compare to left top</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">427</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (((t + <span class="number">1</span>) &lt; ANGLE_T) &amp;&amp; ((rho - <span class="number">1</span>) &gt;= <span class="number">0</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">428</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (hough_table.table[rho][t] &lt; hough_table.table[rho - <span class="number">1</span>][t + <span class="number">1</span>])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">429</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">430</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">431</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">432</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">433</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// compare to left</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">434</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> ((t - <span class="number">1</span>) &gt;= <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">435</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (hough_table.table[rho][t] &lt; hough_table.table[rho][t - <span class="number">1</span>])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">436</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">437</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">438</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">439</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">440</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// compare to right</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">441</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> ((t + <span class="number">1</span>) &lt; ANGLE_T)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">442</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (hough_table.table[rho][t] &lt; hough_table.table[rho][t + <span class="number">1</span>])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">443</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">444</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">445</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">446</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">447</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// compare to left bottom</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">448</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (((t - <span class="number">1</span>) &gt;= <span class="number">0</span>) &amp;&amp; ((rho + <span class="number">1</span>) &lt; RHO_MAX * <span class="number">2</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">449</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (hough_table.table[rho][t] &lt; hough_table.table[rho + <span class="number">1</span>][t - <span class="number">1</span>])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">450</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">451</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">452</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">453</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">454</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// compare to bottom</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">455</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> ((rho + <span class="number">1</span>) &lt; RHO_MAX * <span class="number">2</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">456</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (hough_table.table[rho][t] &lt; hough_table.table[rho + <span class="number">1</span>][t])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">457</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">458</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">459</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">460</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">461</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// compare to right bottom</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">462</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (((t + <span class="number">1</span>) &lt; ANGLE_T) &amp;&amp; ((rho + <span class="number">1</span>) &lt; RHO_MAX * <span class="number">2</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">463</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (hough_table.table[rho][t] &lt; hough_table.table[rho + <span class="number">1</span>][t + <span class="number">1</span>])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">464</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">465</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">466</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">467</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">468</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// Select top N votes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">469</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; N; n++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">470</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> (top_N_vote[n] &lt;= hough_table.table[rho][t])&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">471</span></pre></td><td class="code"><pre><span class="line">          tmp_vote = top_N_vote[n];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">472</span></pre></td><td class="code"><pre><span class="line">          tmp_rho = top_N_rho[n];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">473</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">tmp_t</span> = top_N_t[n];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">474</span></pre></td><td class="code"><pre><span class="line">          top_N_vote[n] = hough_table.table[rho][t];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">475</span></pre></td><td class="code"><pre><span class="line">          top_N_rho[n] = rho;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">476</span></pre></td><td class="code"><pre><span class="line">          top_N_t[n] = t;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">477</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">478</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> m = n + <span class="number">1</span>; m &lt; N - <span class="number">1</span>; m++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">479</span></pre></td><td class="code"><pre><span class="line">            tmp_vote2 = top_N_vote[m];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">480</span></pre></td><td class="code"><pre><span class="line">            tmp_rho2 = top_N_rho[m];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">481</span></pre></td><td class="code"><pre><span class="line">            tmp_t2 = top_N_t[m];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">482</span></pre></td><td class="code"><pre><span class="line">            top_N_vote[m] = tmp_vote;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">483</span></pre></td><td class="code"><pre><span class="line">            top_N_rho[m] = tmp_rho;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">484</span></pre></td><td class="code"><pre><span class="line">            top_N_t[m] = <span class="keyword">tmp_t</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">485</span></pre></td><td class="code"><pre><span class="line">            tmp_vote = tmp_vote2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">486</span></pre></td><td class="code"><pre><span class="line">            tmp_rho = tmp_rho2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">487</span></pre></td><td class="code"><pre><span class="line">            <span class="keyword">tmp_t</span> = tmp_t2;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">488</span></pre></td><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">489</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">490</span></pre></td><td class="code"><pre><span class="line">          top_N_vote[N - <span class="number">1</span>] = tmp_vote;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">491</span></pre></td><td class="code"><pre><span class="line">          top_N_rho[N - <span class="number">1</span>] = tmp_rho;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">492</span></pre></td><td class="code"><pre><span class="line">          top_N_t[N - <span class="number">1</span>] = <span class="keyword">tmp_t</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">493</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">494</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">495</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">496</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">497</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">498</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">499</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// get pixel for top N votes</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">500</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; N; n++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">501</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span> (top_N_rho[n] == <span class="number">-1</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">502</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">503</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">504</span></pre></td><td class="code"><pre><span class="line">    rho = top_N_rho[n];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">505</span></pre></td><td class="code"><pre><span class="line">    t = top_N_t[n];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">506</span></pre></td><td class="code"><pre><span class="line">    output_hough_table.table[rho][t] = hough_table.table[rho][t];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">507</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">508</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">509</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> output_hough_table;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">510</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">511</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">512</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inverse hough transformation</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">513</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">Hough_inverse</span><span class="params">(struct_hough_table hough_table, cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">514</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">515</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">516</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">517</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> _cos, _sin;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">518</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> y, x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">519</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">520</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> rho = <span class="number">0</span>; rho &lt; RHO_MAX * <span class="number">2</span>; rho++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">521</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; ANGLE_T; t++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">522</span></pre></td><td class="code"><pre><span class="line">      <span class="comment">// if not vote, skip</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">523</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (hough_table.table[rho][t] &lt; <span class="number">1</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">524</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">525</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">526</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">527</span></pre></td><td class="code"><pre><span class="line">      _cos = <span class="built_in">cos</span>(t * M_PI / <span class="number">180</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">528</span></pre></td><td class="code"><pre><span class="line">      _sin = <span class="built_in">sin</span>(t * M_PI / <span class="number">180</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">529</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">530</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> ((_sin == <span class="number">0</span>) || (_cos == <span class="number">0</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">531</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">532</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">533</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">534</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">535</span></pre></td><td class="code"><pre><span class="line">        y = (<span class="keyword">int</span>)(- _cos / _sin * x + (rho - RHO_MAX) / _sin);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">536</span></pre></td><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">537</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((y &gt;= <span class="number">0</span>) &amp;&amp; (y &lt; <span class="built_in">height</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">538</span></pre></td><td class="code"><pre><span class="line">          img.at&lt;cv::Vec3b&gt;(y, x) = cv::Vec3b(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">539</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">540</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">541</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">542</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">543</span></pre></td><td class="code"><pre><span class="line">        x = (<span class="keyword">int</span>)(- _sin / _cos * y + (rho - RHO_MAX) / _cos);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">544</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">545</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((x &gt;= <span class="number">0</span>) &amp;&amp; (x &lt; <span class="built_in">width</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">546</span></pre></td><td class="code"><pre><span class="line">          img.at&lt;cv::Vec3b&gt;(y, x) = cv::Vec3b(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">547</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">548</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">549</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">550</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">551</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">552</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> img;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">553</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">554</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">555</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// hough line detection</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">556</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">Hough_line</span><span class="params">(cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">557</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// get edge by canny</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">558</span></pre></td><td class="code"><pre><span class="line">  cv::Mat edge = Canny(img);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">559</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">560</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// hough</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">561</span></pre></td><td class="code"><pre><span class="line">  struct_hough_table hough_table;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">562</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">563</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// initialize 0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">564</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> rho = <span class="number">0</span>; rho &lt; RHO_MAX * <span class="number">2</span>; rho++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">565</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; ANGLE_T; t++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">566</span></pre></td><td class="code"><pre><span class="line">      hough_table.table[rho][t] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">567</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">568</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">569</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">570</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// hough vote</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">571</span></pre></td><td class="code"><pre><span class="line">  hough_table = Hough_vote(hough_table, edge);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">572</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">573</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// hough NMS</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">574</span></pre></td><td class="code"><pre><span class="line">  hough_table = Hough_NMS(hough_table);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">575</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">576</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// hough inverse</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">577</span></pre></td><td class="code"><pre><span class="line">  cv::Mat out = Hough_inverse(hough_table, img);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">578</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">579</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">580</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">581</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">582</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">583</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// read image</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">584</span></pre></td><td class="code"><pre><span class="line">  cv::Mat img = cv::imread(<span class="string">"thorino.jpg"</span>, cv::IMREAD_COLOR);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">585</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">586</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// Hough line detection</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">587</span></pre></td><td class="code"><pre><span class="line">  cv::Mat hough = Hough_line(img);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">588</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">589</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">//cv::imwrite("out.jpg", out);</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">590</span></pre></td><td class="code"><pre><span class="line">  cv::imshow(<span class="string">"answer(hough)"</span>, hough);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">591</span></pre></td><td class="code"><pre><span class="line">  cv::waitKey(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">592</span></pre></td><td class="code"><pre><span class="line">  cv::destroyAllWindows();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">593</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">594</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">595</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/25/Image-Process-Morphology/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qiang Chen">
      <meta itemprop="description" content="记录是忘记的第一助手.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="编辑尼撑">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/25/Image-Process-Morphology/" class="post-title-link" itemprop="url">Image-Process-Morphology</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-25 20:41:57 / 修改时间：22:13:41" itemprop="dateCreated datePublished" datetime="2021-07-25T20:41:57+08:00">2021-07-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Image-Processing/" itemprop="url" rel="index">
                    <span itemprop="name">Image Processing</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="图像处理学习"><a href="#图像处理学习" class="headerlink" title="图像处理学习"></a>图像处理学习</h2><p><strong>形态学图像处理</strong></p>
<h4 id="一、膨胀和腐蚀"><a href="#一、膨胀和腐蚀" class="headerlink" title="一、膨胀和腐蚀"></a>一、膨胀和腐蚀</h4><p>A和B是Z<sup>2</sup>(二维整数空间)中的集合，用A&oplus;B表示B对A的<strong>膨胀</strong>，定义为：</p>
<script type="math/tex; mode=display">
A\oplus B=\{z|(\hat B)_z\cap A\neq\varnothing\}，只要结构元\hat B_z与A有交集则并入A,\hat B和A至少有一个元素是重叠的</script><p>在实际进⾏形态学处理的时候，待操作的像素4-近邻与矩阵A相乘，结果⼤于255的话，将中⼼像素设为255。</p>
<p>A和B是Z<sup>2</sup>(二维整数空间)中的集合，用A&ominus;B表示B对A的<strong>腐蚀</strong>，定义为：</p>
<script type="math/tex; mode=display">
A\ominus B=\{z|(B)_z\subseteq A\},B包含在A中的所有的点z的集合，等价于A\ominus B=\{z|(B)_z\cap A^c=\varnothing\},A^c为A的补集</script><p>在实际进⾏形态学处理的时候，待操作的像素4-近邻与矩阵A相乘，结果⼩于 255&times;4的话，将中⼼像素设为0。</p>
<script type="math/tex; mode=display">
A=\left[
\begin{matrix}
0 & 1 & 0\\
1 & 0 & 1 \\
0 & 1 & 0
\end{matrix}
\right]
\tag{3}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Morphology Dalite</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Morphology_Dalite</span><span class="params">(img, Dil_time=<span class="number">1</span>)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	H, W = img.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># kernel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">	MF = np.array(((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">				(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">				(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)), dtype=np.int)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># each dilate time</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">	out = img.copy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(Dil_time):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">		tmp = np.pad(out, (<span class="number">1</span>, <span class="number">1</span>), <span class="string">'edge'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>, H+<span class="number">1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, W+<span class="number">1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">				<span class="keyword">if</span> np.sum(MF * tmp[y<span class="number">-1</span>:y+<span class="number">2</span>, x<span class="number">-1</span>:x+<span class="number">2</span>]) &gt;= <span class="number">255</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">					out[y<span class="number">-1</span>, x<span class="number">-1</span>] = <span class="number">255</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Morphology Erode</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Morphology_Erode</span><span class="params">(img, Erode_time=<span class="number">1</span>)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">	H, W = img.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">	out = img.copy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># kernel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">	MF = np.array(((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">				(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">				(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)), dtype=np.int)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># each erode</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(Erode_time):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">		tmp = np.pad(out, (<span class="number">1</span>, <span class="number">1</span>), <span class="string">'edge'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># erode</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>, H+<span class="number">1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, W+<span class="number">1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">				<span class="keyword">if</span> np.sum(MF * tmp[y<span class="number">-1</span>:y+<span class="number">2</span>, x<span class="number">-1</span>:x+<span class="number">2</span>]) &lt; <span class="number">255</span>*<span class="number">4</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">					out[y<span class="number">-1</span>, x<span class="number">-1</span>] = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Morphology Erode</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">Morphology_Erode</span><span class="params">(cv::Mat img, <span class="keyword">int</span> Erode_time)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.cols;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.rows;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// output image</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  cv::Mat tmp_img;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  cv::Mat out = img.clone();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// for erode time</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Erode_time; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    tmp_img = out.clone();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// each pixel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// check left pixel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((x &gt; <span class="number">0</span>) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y, x - <span class="number">1</span>) == <span class="number">0</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        &#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// check up pixel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((y &gt; <span class="number">0</span>) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y - <span class="number">1</span>, x) == <span class="number">0</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// check right pixel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((x &lt; <span class="built_in">width</span> - <span class="number">1</span>) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y, x + <span class="number">1</span>) == <span class="number">0</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// check left pixel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((y &lt; <span class="built_in">height</span> - <span class="number">1</span>) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y + <span class="number">1</span>, x) == <span class="number">0</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Morphology Dilate</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">Morphology_Dilate</span><span class="params">(cv::Mat img, <span class="keyword">int</span> Dilate_time)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.cols;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.rows;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// output image</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">  cv::Mat tmp_img;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">  cv::Mat out = img.clone();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// for erode time</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Dilate_time; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">    tmp_img = out.clone();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">// each pixel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// check left pixel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((x &gt; <span class="number">0</span>) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y, x - <span class="number">1</span>) == <span class="number">255</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) = <span class="number">255</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">        &#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// check up pixel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((y &gt; <span class="number">0</span>) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y - <span class="number">1</span>, x) == <span class="number">255</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) = <span class="number">255</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// check right pixel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((x &lt; <span class="built_in">width</span> - <span class="number">1</span>) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y, x + <span class="number">1</span>) == <span class="number">255</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) = <span class="number">255</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">        <span class="comment">// check left pixel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((y &lt; <span class="built_in">height</span> - <span class="number">1</span>) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y + <span class="number">1</span>, x) == <span class="number">255</span>))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) = <span class="number">255</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="二、开操作和闭操作"><a href="#二、开操作和闭操作" class="headerlink" title="二、开操作和闭操作"></a>二、开操作和闭操作</h4><p>结构元B对集合A的<strong>开操作</strong>，表示如下：</p>
<script type="math/tex; mode=display">
A\circ B=(A\ominus B)\oplus B</script><p>B对A的开操作就是B对A的腐蚀，紧接着用B对结果进行膨胀。一般会平滑物体的轮廓、断开较窄的狭颈并消除细的突出物。</p>
<p>结构元B对集合A的<strong>闭操作</strong>，表示如下：</p>
<script type="math/tex; mode=display">
A\bullet B=(A\oplus B) \ominus B</script><p>B对A的闭操作就是B对A的膨胀，紧接着用B对结果进行腐蚀。同样具有平滑轮廓的一部分，但与开操作相反，它通常会弥合较窄的间断和细长的沟壑，消除小的孔洞，填补轮廓线中的断裂。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Morphology Erode</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Morphology_Erode</span><span class="params">(img, Erode_time=<span class="number">1</span>)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	H, W = img.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	out = img.copy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># kernel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	MF = np.array(((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">				(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">				(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)), dtype=np.int)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># each erode</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(Erode_time):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">		tmp = np.pad(out, (<span class="number">1</span>, <span class="number">1</span>), <span class="string">'edge'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">		<span class="comment"># erode</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>, H+<span class="number">1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, W+<span class="number">1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">				<span class="keyword">if</span> np.sum(MF * tmp[y<span class="number">-1</span>:y+<span class="number">2</span>, x<span class="number">-1</span>:x+<span class="number">2</span>]) &lt; <span class="number">255</span>*<span class="number">4</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">					out[y<span class="number">-1</span>, x<span class="number">-1</span>] = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Morphology Dilate</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Morphology_Dilate</span><span class="params">(img, Dil_time=<span class="number">1</span>)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">	H, W = img.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># kernel</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">	MF = np.array(((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">				(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>),</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">				(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)), dtype=np.int)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># each dilate time</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">	out = img.copy()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(Dil_time):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">		tmp = np.pad(out, (<span class="number">1</span>, <span class="number">1</span>), <span class="string">'edge'</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>, H+<span class="number">1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, W+<span class="number">1</span>):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">				<span class="keyword">if</span> np.sum(MF * tmp[y<span class="number">-1</span>:y+<span class="number">2</span>, x<span class="number">-1</span>:x+<span class="number">2</span>]) &gt;= <span class="number">255</span>:</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">					out[y<span class="number">-1</span>, x<span class="number">-1</span>] = <span class="number">255</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Opening morphology</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#开运算，即先进⾏N次腐蚀再进⾏N次膨胀。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Morphology_Opening</span><span class="params">(img, time=<span class="number">1</span>)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    out = Morphology_Erode(out, Erode_time=time)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">	out = Morphology_Dilate(img, Dilate_time=time)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Morphology Closing</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line"><span class="comment">#闭运算，即先进⾏N次膨胀再进⾏N次腐蚀。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Morphology_Closing</span><span class="params">(img, time=<span class="number">1</span>)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">    out = Morphology_Dilate(out, Dilate_time=time)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">	out = Morphology_Erode(img, Erode_time=time)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Morphology Erode</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">cv::Mat Morphology_Erode(cv::Mat img, int Erode_time)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">  int height &#x3D; img.cols;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  int width &#x3D; img.rows;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; output image</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">  cv::Mat tmp_img;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">  cv::Mat out &#x3D; img.clone();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; for erode time</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  for (int i &#x3D; 0; i &lt; Erode_time; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    tmp_img &#x3D; out.clone();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; each pixel</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    for (int y &#x3D; 0; y &lt; height; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">      for (int x &#x3D; 0; x &lt; width; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; check left pixel</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        if ((x &gt; 0) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y, x - 1) &#x3D;&#x3D; 255))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) &#x3D; 255;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">          continue;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">        &#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; check up pixel</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">        if ((y &gt; 0) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y - 1, x) &#x3D;&#x3D; 255))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) &#x3D; 255;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">          continue;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; check right pixel</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        if ((x &lt; width - 1) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y, x + 1) &#x3D;&#x3D; 255))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) &#x3D; 255;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">          continue;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; check left pixel</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        if ((y &lt; height - 1) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y + 1, x) &#x3D;&#x3D; 255))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) &#x3D; 255;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">          continue;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">  return out;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Morphology Dilate</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">cv::Mat Morphology_Dilate(cv::Mat img, int Dilate_time)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">  int height &#x3D; img.cols;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">  int width &#x3D; img.rows;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; output image</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">  cv::Mat tmp_img;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">  cv::Mat out &#x3D; img.clone();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; for erode time</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">  for (int i &#x3D; 0; i &lt; Dilate_time; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">    tmp_img &#x3D; out.clone();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">    &#x2F;&#x2F; each pixel</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">    for (int y &#x3D; 0; y &lt; height; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">      for (int x &#x3D; 0; x &lt; width; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; check left pixel</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">        if ((x &gt; 0) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y, x - 1) &#x3D;&#x3D; 0))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">          continue;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">        &#125; </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; check up pixel</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">        if ((y &gt; 0) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y - 1, x) &#x3D;&#x3D; 0))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">          continue;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; check right pixel</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">        if ((x &lt; width - 1) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y, x + 1) &#x3D;&#x3D; 0))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">          continue;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">        &#x2F;&#x2F; check left pixel</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">        if ((y &lt; height - 1) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y + 1, x) &#x3D;&#x3D; 0))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) &#x3D; 0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">          continue;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">  return out;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Morphology opening</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line">cv::Mat Morphology_Opening(cv::Mat img, int open_time)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; Morphology erode</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line">  img &#x3D; Morphology_Erode(img, open_time);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">97</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; Morphology dilate</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">98</span></pre></td><td class="code"><pre><span class="line">  img &#x3D; Morphology_Dilate(img, open_time);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">99</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">100</span></pre></td><td class="code"><pre><span class="line">  return img;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">101</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">102</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">103</span></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Morphology closing</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">104</span></pre></td><td class="code"><pre><span class="line">cv::Mat Morphology_Closing(cv::Mat img, int open_time)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">105</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; Morphology dilate</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">106</span></pre></td><td class="code"><pre><span class="line">  img &#x3D; Morphology_Dilate(img, open_time);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">107</span></pre></td><td class="code"><pre><span class="line">  &#x2F;&#x2F; Morphology erode</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">108</span></pre></td><td class="code"><pre><span class="line">  img &#x3D; Morphology_Erode(img, open_time);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">109</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">110</span></pre></td><td class="code"><pre><span class="line">  return img;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">111</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="三、一些基本的形态学算法"><a href="#三、一些基本的形态学算法" class="headerlink" title="三、一些基本的形态学算法"></a>三、一些基本的形态学算法</h4><h5 id="3-1-边界提取"><a href="#3-1-边界提取" class="headerlink" title="3.1 边界提取"></a>3.1 边界提取</h5><p>表示为&beta;(A)的集合A的边界可以通过先用B对A腐蚀，而后执行A和腐蚀的结果之间的集合之差得到。</p>
<script type="math/tex; mode=display">
\beta(A)=A-(A\ominus B)\\
结构元为B=\left[
\begin{matrix}
1 & 1 & 1\\
1 & 0 & 1 \\
1 & 1 & 1
\end{matrix}
\right]
\tag{3}</script><p>上述的结构元不是唯一的，也可以根据实际情况使用5&times;5大小的结构元，将得到不同宽度的边界。</p>
<h5 id="3-2-孔洞填充"><a href="#3-2-孔洞填充" class="headerlink" title="3.2 孔洞填充"></a>3.2 孔洞填充</h5><p>孔洞定义为由前景像素相连接的边界所包围的一个背景区域。假设每个孔洞区域内有一个已知的点，并标记为1，则可以使用如下的迭代方式进行孔洞填充：</p>
<script type="math/tex; mode=display">
X_k=(X_{k-1}\oplus B)\cap A^c,k=1,2,3,\cdots\\
B=\left[
\begin{matrix}
0 & 1 & 0\\
1 & 0 & 1 \\
0 & 1 & 0
\end{matrix}
\right]
\tag{3}，4-连通</script><ul>
<li>设定一个与包含A的阵列大小相同的阵列X<sub>0</sub>，其中孔洞中有一个给定点被设置为1</li>
<li>使用上面的迭代过程对X<sub>0</sub>进行迭代</li>
<li>如果X<sub>k</sub>=X<sub>k-1</sub>，则算法结束</li>
</ul>
<p>每一步中与A<sup>c</sup>的交集操作将结果限制到感兴趣区域内。</p>
<h5 id="3-3-连通分量的提取"><a href="#3-3-连通分量的提取" class="headerlink" title="3.3 连通分量的提取"></a>3.3 连通分量的提取</h5><ul>
<li>令A是一个包含一个或多个连通分量的集合，形成一个阵列X<sub>0</sub>(该阵列的大小与包含A的阵列大小相同)</li>
<li>A中每个连通分量中，取一个已知点置为1(表示前景)，阵列中的其他元素置为0(表示背景)</li>
<li>使用下列的迭代过程进行迭代</li>
<li>如果X<sub>k</sub>=X<sub>k-1</sub>，则算法结束</li>
</ul>
<script type="math/tex; mode=display">
X_k=(X_{k-1}\oplus B)\cap A,k=1,2,3,\cdots\\
B=\left[
\begin{matrix}
1 & 1 & 1\\
1 & 0 & 1 \\
1 & 1 & 1
\end{matrix}
\right]
\tag{3},8-连通</script><p>X<sub>k</sub>中包含输入图像中的所有的连通分量</p>
<h4 id="四、灰度级形态学"><a href="#四、灰度级形态学" class="headerlink" title="四、灰度级形态学"></a>四、灰度级形态学</h4><h5 id="4-1、腐蚀和膨胀"><a href="#4-1、腐蚀和膨胀" class="headerlink" title="4.1、腐蚀和膨胀"></a>4.1、腐蚀和膨胀</h5><p>当b的原点位于(x,y)处时，用一个平坦的结构元b在(x,y)处对图像f的<strong>腐蚀</strong>定义为图像f中与b重合区域的最小值。腐蚀公式如下：</p>
<script type="math/tex; mode=display">
[f\ominus b](x,y)=\mathop {min}_{(s,t)\in b}\{f(x+s,y+t)\}</script><p>在任何位置的腐蚀由从包含在与b重合区域中的f的所有值中选取的最小值决定。</p>
<p>当b的映像b<sup>^</sup>的原点位于(x,y)处时，用一个平坦的结构元b在(x,y)处对图像f的<strong>膨胀</strong>定义为图像f中与b重合区域的最大值。膨胀公式如下：</p>
<script type="math/tex; mode=display">
[f\oplus b](x,y)=\mathop {max}_{(s,t)\in b}\{f(x-s,y-t)\},\hat b=b(-x,-y)</script><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th>膨胀</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">209</td>
<td style="text-align:center">125</td>
<td style="text-align:center">191</td>
<td style="text-align:center">9</td>
<td style="text-align:center">168</td>
<td style="text-align:center">246</td>
<td style="text-align:center">158</td>
<td></td>
<td style="text-align:center">232</td>
<td style="text-align:center">232</td>
<td style="text-align:center">205</td>
<td style="text-align:center">191</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
</tr>
<tr>
<td style="text-align:center">232</td>
<td style="text-align:center">205</td>
<td style="text-align:center">101</td>
<td style="text-align:center">113</td>
<td style="text-align:center">42</td>
<td style="text-align:center">141</td>
<td style="text-align:center">122</td>
<td></td>
<td style="text-align:center">232</td>
<td style="text-align:center">232</td>
<td style="text-align:center">205</td>
<td style="text-align:center">191</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
</tr>
<tr>
<td style="text-align:center">33</td>
<td style="text-align:center">37</td>
<td style="text-align:center">168</td>
<td style="text-align:center">98</td>
<td style="text-align:center">31</td>
<td style="text-align:center">36</td>
<td style="text-align:center">91</td>
<td></td>
<td style="text-align:center">234</td>
<td style="text-align:center">234</td>
<td style="text-align:center">205</td>
<td style="text-align:center">196</td>
<td style="text-align:center">196</td>
<td style="text-align:center">213</td>
<td style="text-align:center">213</td>
</tr>
<tr>
<td style="text-align:center">234</td>
<td style="text-align:center">108</td>
<td style="text-align:center">44</td>
<td style="text-align:center">196</td>
<td style="text-align:center">128</td>
<td style="text-align:center">39</td>
<td style="text-align:center">213</td>
<td>=&gt;</td>
<td style="text-align:center">235</td>
<td style="text-align:center">235</td>
<td style="text-align:center">235</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
</tr>
<tr>
<td style="text-align:center">162</td>
<td style="text-align:center">235</td>
<td style="text-align:center">181</td>
<td style="text-align:center">204</td>
<td style="text-align:center">246</td>
<td style="text-align:center">66</td>
<td style="text-align:center">150</td>
<td></td>
<td style="text-align:center">235</td>
<td style="text-align:center">235</td>
<td style="text-align:center">235</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
</tr>
<tr>
<td style="text-align:center">25</td>
<td style="text-align:center">203</td>
<td style="text-align:center">9</td>
<td style="text-align:center">48</td>
<td style="text-align:center">88</td>
<td style="text-align:center">216</td>
<td style="text-align:center">141</td>
<td></td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">235</td>
<td style="text-align:center">235</td>
</tr>
<tr>
<td style="text-align:center">72</td>
<td style="text-align:center">246</td>
<td style="text-align:center">71</td>
<td style="text-align:center">126</td>
<td style="text-align:center">150</td>
<td style="text-align:center">66</td>
<td style="text-align:center">235</td>
<td></td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">150</td>
<td style="text-align:center">216</td>
<td style="text-align:center">235</td>
<td style="text-align:center">235</td>
</tr>
</tbody>
</table>
</div>
<h5 id="4-2-形态学梯度"><a href="#4-2-形态学梯度" class="headerlink" title="4.2 形态学梯度"></a>4.2 形态学梯度</h5><p>膨胀和腐蚀可与图像相减结合起来得到一副图像的形态学梯度，由g定义：</p>
<script type="math/tex; mode=display">
g=(f\oplus b)-(f\ominus b)</script><p>膨胀粗化一幅图像中的区域，腐蚀则细化它们。膨胀和腐蚀的差强调了区域间的边界。</p>
<h5 id="4-3-顶帽变换和底帽变换"><a href="#4-3-顶帽变换和底帽变换" class="headerlink" title="4.3 顶帽变换和底帽变换"></a>4.3 顶帽变换和底帽变换</h5><p>图像相减与开操作和闭操作相结合，会产生所谓的顶帽(Top-hat)变换和底帽(Bottom-hat)变换。</p>
<p>灰度级图像f的顶帽变换定义为f减去其开操作：</p>
<script type="math/tex; mode=display">
T_{hat}(f)=f-(f\circ b)</script><p>灰度级图像f的底帽变换定义为f的闭操作减去f：</p>
<script type="math/tex; mode=display">
B_{hat}(f)=(f\bullet b)-f</script><p>主要应用是，用一个结构元通过开操作或闭操作从一幅图像中删除物体，然后，差操作得到一幅仅保留已删除分量的图像。顶帽变换用于暗背景上的亮物体，底帽变换则相反。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/25/Image-Process-Three-Fourier-Transform/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qiang Chen">
      <meta itemprop="description" content="记录是忘记的第一助手.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="编辑尼撑">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/25/Image-Process-Three-Fourier-Transform/" class="post-title-link" itemprop="url">Image-Process-Three-Fourier-Transform</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-25 20:32:11 / 修改时间：23:02:44" itemprop="dateCreated datePublished" datetime="2021-07-25T20:32:11+08:00">2021-07-25</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Image-Processing/" itemprop="url" rel="index">
                    <span itemprop="name">Image Processing</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="图像处理学习"><a href="#图像处理学习" class="headerlink" title="图像处理学习"></a>图像处理学习</h2><h4 id="第一部分-离散傅里叶变换"><a href="#第一部分-离散傅里叶变换" class="headerlink" title="第一部分 离散傅里叶变换"></a>第一部分 离散傅里叶变换</h4><p>这里先引入单变量的离散傅里叶变换(DFT)。</p>
<script type="math/tex; mode=display">
\begin{align}
&假设原始函数为f(x),经过采样后的函数为\tilde{f}(x),采样函数相应的傅里叶变换为\tilde{F}(\mu)\\
&则利用傅里叶变换可得： \\
&\tilde{F}(\mu)=\int_{-\infty}^{\infty}\tilde{f}(x)e^{-j2\pi\mu t}dt \\
&根据数字图像处理p131的式(4.3-1)\\
&\tilde{f}(t)=f(t)s_{\Delta T}(t)=\sum_{n=-\infty}^{\infty}f(t)\delta(t-n\Delta T),代入得： \\
\tilde{F}(\mu)=&\int_{-\infty}^{\infty}\tilde{f}(t)e^{-j2\pi\mu t}dt=\int_{-\infty}^{\infty}\sum_{n=-\infty}^{\infty}f(t)\delta(t-n\Delta T)e^{-j2\pi\mu t}dt \\
=&\sum_{n=-\infty}^{\infty}\int_{-\infty}^{\infty}f(t)\delta(t-n\Delta T)e^{-j2\pi\mu t}dt=\sum_{\infty}^{\infty}f_ne^{-j2\pi\mu n\Delta T}
\end{align}</script><p>上式得最后一步推导有点不理解，下面给出个人的一个理解：</p>
<script type="math/tex; mode=display">
由于单位冲激函数\delta(t)的定义为：\\
\delta(t)=\begin{cases}
\infty & t=0 \\
0 & t\neq0 
\end{cases},那么
\delta(t-t_0)=\begin{cases}
\infty & t-t_0=0 \\
0 & t-t_0\neq0 
\end{cases} \\
又根据取样特性：\int_{-\infty}^{\infty}f(t)\delta(t-t_0)dt=f(t_0)，这里可以直接把\int_{-\infty}^{\infty}f(t)\delta(t-t_0)dt=f(t_0)看成\int_{-\infty}^{\infty}f(t_0)\delta(t-t_0)dt=f(t_0)\\
因为\int_{-\infty}^{\infty}\delta(t-t_0)d(t-t_0)=1， \int_{-\infty}^{\infty}f(t_0)\delta(t-t_0)dt=f(t_0)=f(t_0)\int_{-\infty}^{\infty}\delta(t-t_0)dt=f(t_0)\\
所以，\sum_{n=-\infty}^{\infty}\int_{-\infty}^{\infty}f(t)\delta(t-n\Delta T)e^{-j2\pi\mu t}dt=\sum_{n=-\infty}^{\infty}\int_{-\infty}^{\infty}f(n\Delta T)\delta(t-n\Delta T)e^{-j2\pi\mu t}dt=\sum_{n=-\infty}^{\infty}f(n\Delta T)\int_{-\infty}^{\infty}\delta(t-n\Delta T)e^{-j2\pi\mu t}dt\\
由于数字图像处理p129中例4.2,F(\mu)=\int_{-\infty}^{\infty}\delta(t-t_0)e^{-j2\pi\mu t}dt=e^{-j2\pi\mu t_0},所以上式等于 \\
\sum_{n=-\infty}^{\infty}\int_{-\infty}^{\infty}f(n\Delta T)\delta(t-n\Delta T)e^{-j2\pi\mu t}dt=\sum_{n=-\infty}^{\infty}f(n\Delta T)e^{-j2\pi\mu n\Delta T} \\
因为数字图像处理p132中式(4.3-2),f_k=\int_{-\infty}^{\infty}f(t)\delta(t-k\Delta T)dt=f(k\Delta T) \\
所以，\sum_{n=-\infty}^{\infty}\int_{-\infty}^{\infty}f(n\Delta T)\delta(t-n\Delta T)e^{-j2\pi\mu t}dt=\sum_{n=-\infty}^{\infty}f_ne^{-j2\pi\mu n\Delta T}</script><p>假设想要在周期&mu;=0到&amp;mu=1/&Delta;T之间得到M个等间距的样本，可以通过在如下频率处取样：</p>
<script type="math/tex; mode=display">
\mu=\frac{m}{M\Delta T},m=0,1,2,\cdots,M-1,代入\tilde{F}(\mu)得，F_m=\sum_{n=0}^{M-1}f_ne^{-j2\pi mn/M},M=0,1,2,\cdots,M-1</script><p>根据上面一维离散傅里叶变换得推导，可以扩展到下面得二维离散傅里叶变换得情况。</p>
<p>二维离散傅立叶变换是傅立叶变换在图像处理上的应用方法。通常傅立叶变换用于分离模拟信号或音频等连续一维信号的频率。但是，数字图像使用[0, 255]范围内的离散值表示，范围内的离散值表示，并且图像使用HxW的二维矩阵表示，所以在这里使用二维离散傅立叶变换。二维离散傅立叶变换使用下式计算，其中 表示输入图像：</p>
<script type="math/tex; mode=display">
G(u,v)=\sum^{M-1}_{x=0}\sum^{N-1}_{y=0}I(x,y)e^{-2\cdot \pi\cdot j\cdot (\frac{ux}{M}+\frac{vy}{N})}</script><p>二维傅里叶逆变换从频率分量G按照下式复原图像：</p>
<script type="math/tex; mode=display">
I(x,y)=\frac{1}{M\cdot N}\sum^{M-1}_{x=0}\sum^{N-1}_{y=0}G(u,v)e^{2\cdot \pi\cdot j\cdot (\frac{ux}{M}+\frac{vy}{N})}</script><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># DFT hyper-parameters</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">K, L = <span class="number">128</span>, <span class="number">128</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">channel = <span class="number">3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># DFT</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dft</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">	H, W, _ = img.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># Prepare DFT coefficient</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">	G = np.zeros((L, K, channel), dtype=np.complex)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># prepare processed index corresponding to original image positions</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">	x = np.tile(np.arange(W), (H, <span class="number">1</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">	y = np.arange(H).repeat(W).reshape(H, <span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># dft</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">for</span> c <span class="keyword">in</span> range(channel):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">for</span> l <span class="keyword">in</span> range(L):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">for</span> k <span class="keyword">in</span> range(K):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">				G[l, k, c] = np.sum(img[..., c] * np.exp(<span class="number">-2j</span> * np.pi * (x * k / K + y * l / L))) / np.sqrt(K * L)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">				<span class="comment">#for n in range(N):</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">				<span class="comment">#    for m in range(M):</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">				<span class="comment">#        v += gray[n, m] * np.exp(-2j * np.pi * (m * k / M + n * l / N))</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">				<span class="comment">#G[l, k] = v / np.sqrt(M * N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> G</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># IDFT</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">idft</span><span class="params">(G)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># prepare out image</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">	H, W, _ = G.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">	out = np.zeros((H, W, channel), dtype=np.float32)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># prepare processed index corresponding to original image positions</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">	x = np.tile(np.arange(W), (H, <span class="number">1</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">	y = np.arange(H).repeat(W).reshape(H, <span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># idft</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">for</span> c <span class="keyword">in</span> range(channel):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">for</span> l <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">for</span> k <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">				out[l, k, c] = np.abs(np.sum(G[..., c] * np.exp(<span class="number">2j</span> * np.pi * (x * k / W + y * l / H)))) / np.sqrt(W * H)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># clipping</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">	out = np.clip(out, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">	out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">height</span> = <span class="number">128</span>, <span class="built_in">width</span> = <span class="number">128</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fourier_str</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; coef[<span class="built_in">height</span>][<span class="built_in">width</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// RGB to Gray scale</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">BGR2GRAY</span><span class="params">(cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// BGR -&gt; Gray</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (<span class="keyword">int</span>)((<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">0</span>] * <span class="number">0.0722</span> + \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">1</span>] * <span class="number">0.7152</span> + \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">2</span>] * <span class="number">0.2126</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discrete Fourier transformation</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="function">fourier_str <span class="title">dft</span><span class="params">(cv::Mat img, fourier_str fourier_s)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> I;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> theta;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; val;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="built_in">height</span>; l ++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="built_in">width</span>; k ++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">      val.real(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">      val.imag(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">          I = (<span class="keyword">double</span>)img.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">          theta = <span class="number">-2</span> * M_PI * ((<span class="keyword">double</span>)k * (<span class="keyword">double</span>)x / (<span class="keyword">double</span>)<span class="built_in">width</span> + (<span class="keyword">double</span>)l * (<span class="keyword">double</span>)y / (<span class="keyword">double</span>)<span class="built_in">height</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">          val += <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">cos</span>(theta), <span class="built_in">sin</span>(theta)) * I;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">      val /= <span class="built_in">sqrt</span>(<span class="built_in">height</span> * <span class="built_in">width</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">      fourier_s.coef[l][k] = val;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> fourier_s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inverse Discrete Fourier transformation</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">idft</span><span class="params">(cv::Mat out, fourier_str fourier_s)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> theta;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> g;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; G;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; val;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y ++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x ++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">      val.real(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">      val.imag(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="built_in">height</span>; l ++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="built_in">width</span>; k ++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">          G = fourier_s.coef[l][k];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">          theta = <span class="number">2</span> * M_PI * ((<span class="keyword">double</span>)k * (<span class="keyword">double</span>)x / (<span class="keyword">double</span>)<span class="built_in">width</span> + (<span class="keyword">double</span>)l * (<span class="keyword">double</span>)y / (<span class="keyword">double</span>)<span class="built_in">height</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">          val += <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">cos</span>(theta), <span class="built_in">sin</span>(theta)) * G;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">      g = <span class="built_in">std</span>::<span class="built_in">abs</span>(val) / <span class="built_in">sqrt</span>(<span class="built_in">height</span> * <span class="built_in">width</span>);      </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (uchar)g;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="第二部分-二维傅里叶变换的一些性质"><a href="#第二部分-二维傅里叶变换的一些性质" class="headerlink" title="第二部分 二维傅里叶变换的一些性质"></a>第二部分 二维傅里叶变换的一些性质</h4><h5 id="1、平移"><a href="#1、平移" class="headerlink" title="1、平移"></a>1、平移</h5><script type="math/tex; mode=display">
f(x,y)e^{j2\pi(u_0x/M+v_0y/N)}\Leftrightarrow F(u-u_0,v-v_0),f(x-x_0,y-y_0)\Leftrightarrow F(u,v)e^{-j2\pi(x_0u/M+y_0v/N)}</script><p>上式指出，用指数项乘以f(x,y)将使DFT的原点移到点(u<sub>0</sub>,v<sub>0</sub>)；反之，用负指数乘以F(u,v)将使f(x,y)的原点移到点(x<sub>0</sub>,y<sub>0</sub>)。要证明上式成立，首先需要看清楚指数项所乘的对象，与对应的转换。</p>
<script type="math/tex; mode=display">
\because F(u,v)=\sum^{M-1}_{x=0}\sum^{N-1}_{y=0}f(x,y)e^{-j2\pi(ux/M+vy/N)}</script><script type="math/tex; mode=display">
\therefore \sum^{M-1}_{x=0}\sum^{N-1}_{y=0}f(x,y)e^{-j2\pi(\frac{ux}{M}+\frac{vy}{N})}\times e^{j2\pi(\frac{u_0x}{M}+\frac{v_0y}{N})}=\sum^{M-1}_{x=0}\sum^{N-1}_{y=0}f(x,y)e^{-j2\pi[\frac{(u-u_0)x}{M}+\frac{(v-v_0)y}{N}]}=F(u-u_0,v-v_0)</script><script type="math/tex; mode=display">
同理，\because f(x,y)=\frac{1}{M}\sum^{M-1}_{u=0}\sum^{N-1}_{v=0}F(u,v)e^{j2\pi(ux/M+vy/N}</script><script type="math/tex; mode=display">
\therefore \frac{1}{M}\sum^{M-1}_{u=0}\sum^{N-1}_{v=0}F(u,v)e^{j2\pi(ux/M+vy/N}\times e^{-j2\pi(x_0u/M+y_0v/N)}=\frac{1}{M}\sum^{M-1}_{u=0}\sum^{N-1}_{v=0}F(u,v)e^{j2\pi[(x-x_0)u/M+(v-v_0)y/N)]}=f(x-x_0,y-y_0)</script><p> 除了上面的推导外，从网上看到了另一种推导方式，很漂亮👏。<a href="http://www.kevinnan.org.cn/index.php/archives/637/" target="_blank" rel="noopener">链接</a></p>
<p>简单做一下记录，便于以后回顾：</p>
<script type="math/tex; mode=display">
f(x-x_0,y-y_0)\Leftrightarrow F(u',v') \\
F(u',v')=\int^{\infty}_{-\infty}\int^{\infty}_{-\infty}f(x-x_0,y-y_0)e^{-j2\pi(ux+vy)}dxdy \\
令x-x_0=x',y-y_0=y',则x=x'+x_0,y=y'+y_0;dx=dx',dy=dy' \\
所以，F(u',v')=\int^{\infty}_{-\infty}\int^{\infty}_{-\infty}f(x',y')e^{-j2\pi [u(x'+x_0)+v(y'+y_0)]}dx'dy'=e^{-j2\pi (ux_0+vy_0)}\cdot\int^{\infty}_{-\infty}\int^{\infty}_{-\infty}f(x',y')e^{-j2\pi (ux'+vy')}dx'dy' \\
因此，F(u',v')=F(u,v)\cdot e^{-j2\pi(ux_0+vy_0)}，同理也可以将F(u-u_0,v-v_0)代入求F(u-u_0,v-v_0)\Leftrightarrow f(x',y')*2、旋转</script><h5 id="2、旋转"><a href="#2、旋转" class="headerlink" title="2、旋转"></a>2、旋转</h5><p>若f(x,y)旋转&theta;角，则F(u,v)也往相同的方向旋转相同的角度。</p>
<p>假设直角坐标系中点P(x,y)，绕平面中心旋转&theta;得Q(x’,y’)，用旋转矩阵表示两者得关系：（利用极坐标的表示方法推导下式）</p>
<script type="math/tex; mode=display">
x=r\cos\phi\quad y=r\sin\phi;x'=rcos(\theta+\phi),y=rsin(\theta+\phi)\\
利用三角函数展开，x'=r\cos\theta\cos\phi-r\sin\theta\sin\phi,y'=r\sin\theta\cos\phi+r\cos\theta\sin\phi\\
将x,y代入，即可得，x'=x\cos\theta-y\sin\theta,y'=x\sin\theta+y\cos\theta</script><script type="math/tex; mode=display">
\left[
\begin{matrix}
x\\
y \\
\end{matrix}
\right]
=
\left[
\begin{matrix}
cos\theta & -sin\theta\\
sin\theta & cos\theta \\
\end{matrix}
\right]
\left[
\begin{matrix}
x'\\
y'\\
\end{matrix}
\right]
反向求x',y';
\left[
\begin{matrix}
x'\\
y'\\
\end{matrix}
\right]
=
\left[
\begin{matrix}
cos\theta & sin\theta\\
-sin\theta & cos\theta \\
\end{matrix}
\right]
\left[
\begin{matrix}
x\\
y\\
\end{matrix}
\right]</script><p>上式是利用了旋转矩阵的逆等于旋转矩阵的转置这个性质，即：</p>
<script type="math/tex; mode=display">
假设旋转矩阵为：R=[x^T\quad y^T\quad z^T],其转置矩阵为R^T=\left[
\begin{matrix}
x^T\\
y^T\\
z^T
\end{matrix}
\right]\\
则，R^TR=\left[
\begin{matrix}
xx^T & xy^T & xz^T\\
yx^T & yy^T & yz^T\\
zx^T & zy^T & zz^T
\end{matrix}
\right],由于三角函数的正交特性，只有xx^T=yy^T=zz^T=1,其余为0\\
故R^TR=I=R^{-1}R,即R^R=R^{-1}</script><p>旋转后点f(x’,y’)的傅里叶变换为：</p>
<script type="math/tex; mode=display">
F(u',v')=\int^{\infty}_{-\infty}\int^{\infty}_{-\infty}f(x',y')e^{-j2\pi(ux+vy)}dxdy \\
F(u',v')=\int^{\infty}_{-\infty}\int^{\infty}_{-\infty}e^{-j2\pi[u(cos\theta x'-sin\theta y')+v(sin\theta x'+cos\theta y')]}dx'dy'\\
F(u',v')=\int^{\infty}_{-\infty}\int^{\infty}_{-\infty}e^{-j2\pi[x'(ucos\theta+vsin\theta )+y'(vcos\theta-usin\theta)]}dx'dy'\\
F(u',v')=F(ucos\theta+vsin\theta,-usin\theta+vsin\theta)，由此可得：\\
\left[
\begin{matrix}
u'\\
v'\\
\end{matrix}
\right]
=
\left[
\begin{matrix}
cos\theta & sin\theta\\
-sin\theta & cos\theta \\
\end{matrix}
\right]
\left[
\begin{matrix}
u\\
v\\
\end{matrix}
\right]</script><p>所以，u，v旋转的角度和x，y旋转的角度相同。上面的dx，dy与dx’，dy’的转换使用的是二重积分的变换关系式。<a href="https://zhuanlan.zhihu.com/p/50355468" target="_blank" rel="noopener">参考</a></p>
<h5 id="3、周期性"><a href="#3、周期性" class="headerlink" title="3、周期性"></a>3、周期性</h5><p>如一维情况一样，二维傅里叶变换及其反变换在u方向和v方向是无线周期的，即</p>
<script type="math/tex; mode=display">
F(u,v)=F(u+k_1M,v)=F(u,v+k_2N)=F(u+k1M,v+k_2N)\\
f(x,y)=f(x+k_1M,y)=f(x,y+k_2N)=f(x+k_1M,y+k_2N)</script><p>上式中k<sub>1</sub>,k<sub>2</sub>为整数。</p>
<p>由于在单维离散傅里叶变换表示为：</p>
<script type="math/tex; mode=display">
F_m=\sum^{M-1}_{n=0}f_ne^{-j2\pi mn/M},m=0,1,2,\cdots,M-1\\
当m=\frac{M}{2}时，F_m=\sum^{M-1}_{n=0}f_ne^{-j\pi n}=\sum^{M-1}_{n=0}f_n[\cos(\pi n)-\sin(\pi n)]=\sum^{M-1}_{n=0}f_n\cos(\pi n)</script><p>上式说明，在M/2处，只有半个周期。而采样区间是在[0, M-1]。可见，该区间内是两个周期的各一半，即背靠背的半个周期组成。为了显示和滤波，<strong>在该区间中有一个变换的完整周期会更加方便</strong>。所以需要平移M/2个半周期。根据平移的性质：</p>
<script type="math/tex; mode=display">
f(x)e^{j2\pi(u_0x/M)}\Leftrightarrow F(u-u_0),令u_0=M/2,则指数变为e^{j\pi x}，由于x为整数\\
e^{j\pi x}=\cos(\pi x)=(-1)^x,所以，上式，f(x)(-1)^x=F(u-u_0)</script><p>上式用(-1)<sup>x</sup>乘以f(x)将位于原点的数据F(0)移动到区间[0, M-1]的中心位置。这里做的是<strong>频谱的中心化</strong>，可以扩展到二维离散空间。</p>
<script type="math/tex; mode=display">
f(x,y)(-1)^x\Leftrightarrow F(u-M/2,v-N/2)</script><h4 id="补充部分"><a href="#补充部分" class="headerlink" title="补充部分"></a>补充部分</h4><p>周期冲击串的傅里叶变换</p>
<p>首先，介绍一下冲击串s<sub>&Delta;T</sub>(t)：无限多个分离的周期冲激单元&Delta;T之和</p>
<script type="math/tex; mode=display">
s_{\Delta T}(t)=\sum^{\infty}_{n=-\infty}\delta(t-n\Delta T)</script><p>因为冲击串是一个周期函数，所以可以使用傅里叶级数表示：</p>
<script type="math/tex; mode=display">
s_{\Delta T}(t)=\sum^{\infty}_{n=-\infty}c_ne^{j\frac{2\pi n}{\Delta T}t}</script><p> 其中，</p>
<script type="math/tex; mode=display">
c_n=\frac{1}{\Delta T}\int^{\Delta T/2}_{-\Delta T/2}s_{\Delta T}e^{-j\frac{2\pi n}{\Delta T}t}dt</script><p>由于在区间[-&Delta;T/2，&Delta;T/2]的积分仅包含位于原点的冲激，所以，</p>
<script type="math/tex; mode=display">
c_n=\frac{1}{\Delta T}\int^{\Delta T/2}_{-\Delta T/2}\delta (t)e^{-j\frac{2\pi n}{\Delta T}t}dt=\frac{1}{\Delta T}</script><p>则，</p>
<script type="math/tex; mode=display">
s_{\Delta T}(t)=\frac{1}{\Delta T}\sum^{\infty}_{n=-\infty}e^{j\frac{2\pi n}{\Delta T}t}</script><p>则周期冲激串的傅里叶变换S(&mu;)为：</p>
<script type="math/tex; mode=display">
S(\mu)=\mathscr{F}\{s_{\Delta T(t)}\}=\mathscr{F}\{\frac{1}{\Delta T}\sum^{\infty}_{n=-\infty}e^{j\frac{2\pi n}{\Delta T}t}\}=\frac{1}{\Delta T}\mathscr{F}\{\sum^{\infty}_{n=-\infty}e^{j\frac{2\pi n}{\Delta T}t}\}</script><p> 从上式的最后一项看是对指数函数求和的傅里叶变换，由于求和是线性变换，与傅里叶变换之后求和的结果一致，所以需要求指数函数的傅里叶变换，即：</p>
<script type="math/tex; mode=display">
要求，\mathscr{F}\{e^{j\frac{2\pi n}{\Delta T}t}\}，根据定义\mathscr{F}\{f(t)\}=\int^{\infty}_{-\infty}f(t)e^{-j2\pi\mu t}dt \\
则，\mathscr{F}\{e^{j\frac{2\pi n}{\Delta T}t}\}=\int^{\infty}_{-\infty}e^{j\frac{2\pi n}{\Delta T}t}\cdot e^{-j2\pi\mu t}dt=\int^{\infty}_{-\infty}1\cdot e^{-j2\pi(\mu-\frac{n}{\Delta T})t}dt \\
所以，\mathscr{F}\{e^{j\frac{2\pi n}{\Delta T}t}\}=F(\mu-\frac{n}{\Delta T})=\delta(\mu-\frac{n}{\Delta T}),这里相当于模拟\mu的一个函数</script><h4 id="三、低通滤波器"><a href="#三、低通滤波器" class="headerlink" title="三、低通滤波器"></a>三、低通滤波器</h4><p>低通滤波器在频率中将高频信号滤除，保留更多的低频信号。其中，在傅里叶变换且中心化频率后，中心是平均灰度值，越靠近中心，低频信号越多；越远离，则为高频信号，例如：边界或噪声。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># DFT hyper-parameters</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">K, L = <span class="number">128</span>, <span class="number">128</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">channel = <span class="number">3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># bgr -&gt; gray</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bgr2gray</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">	gray = <span class="number">0.2126</span> * img[..., <span class="number">2</span>] + <span class="number">0.7152</span> * img[..., <span class="number">1</span>] + <span class="number">0.0722</span> * img[..., <span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> gray</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># DFT</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dft</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># Prepare DFT coefficient, complex() 函数用于创建一个值为 real + imag * j 的复数 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">	G = np.zeros((L, K, channel), dtype=np.complex)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># prepare processed index corresponding to original image positions</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">	x = np.tile(np.arange(W), (H, <span class="number">1</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">	y = np.arange(H).repeat(W).reshape(H, <span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># dft</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">for</span> c <span class="keyword">in</span> range(channel):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">for</span> l <span class="keyword">in</span> range(L):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">for</span> k <span class="keyword">in</span> range(K):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">				G[l, k, c] = np.sum(img[..., c] * np.exp(<span class="number">-2j</span> * np.pi * (x * k / K + y * l / L))) / np.sqrt(K * L)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">				<span class="comment">#for n in range(N):</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">				<span class="comment">#    for m in range(M):</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">				<span class="comment">#        v += gray[n, m] * np.exp(-2j * np.pi * (m * k / M + n * l / N))</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">				<span class="comment">#G[l, k] = v / np.sqrt(M * N)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> G</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># IDFT</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">idft</span><span class="params">(G)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># prepare out image</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">	H, W, _ = G.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">	out = np.zeros((H, W, channel), dtype=np.float32)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># prepare processed index corresponding to original image positions</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">	x = np.tile(np.arange(W), (H, <span class="number">1</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">	y = np.arange(H).repeat(W).reshape(H, <span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># idft</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">for</span> c <span class="keyword">in</span> range(channel):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">for</span> l <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">for</span> k <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">				out[l, k, c] = np.abs(np.sum(G[..., c] * np.exp(<span class="number">2j</span> * np.pi * (x * k / W + y * l / H)))) / np.sqrt(W * H)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># clipping</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">	out = np.clip(out, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">	out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># LPF</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lpf</span><span class="params">(G, ratio=<span class="number">0.5</span>)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">	H, W, _ = G.shape	</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># transfer positions</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">	_G = np.zeros_like(G)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">	_G[:H//<span class="number">2</span>, :W//<span class="number">2</span>] = G[H//<span class="number">2</span>:, W//<span class="number">2</span>:]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">	_G[:H//<span class="number">2</span>, W//<span class="number">2</span>:] = G[H//<span class="number">2</span>:, :W//<span class="number">2</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">	_G[H//<span class="number">2</span>:, :W//<span class="number">2</span>] = G[:H//<span class="number">2</span>, W//<span class="number">2</span>:]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">	_G[H//<span class="number">2</span>:, W//<span class="number">2</span>:] = G[:H//<span class="number">2</span>, :W//<span class="number">2</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># get distance from center (H / 2, W / 2)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">	x = np.tile(np.arange(W), (H, <span class="number">1</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">	y = np.arange(H).repeat(W).reshape(H, <span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># make filter</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">	_x = x - W // <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">	_y = y - H // <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">	r = np.sqrt(_x ** <span class="number">2</span> + _y ** <span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">	mask = np.ones((H, W), dtype=np.float32)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">	mask[r &gt; (W // <span class="number">2</span> * ratio)] = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">	mask = np.repeat(mask, channel).reshape(H, W, channel)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># filtering</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">	_G *= mask</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># reverse original positions</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">	G[:H//<span class="number">2</span>, :W//<span class="number">2</span>] = _G[H//<span class="number">2</span>:, W//<span class="number">2</span>:]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">	G[:H//<span class="number">2</span>, W//<span class="number">2</span>:] = _G[H//<span class="number">2</span>:, :W//<span class="number">2</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">	G[H//<span class="number">2</span>:, :W//<span class="number">2</span>] = _G[:H//<span class="number">2</span>, W//<span class="number">2</span>:]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">	G[H//<span class="number">2</span>:, W//<span class="number">2</span>:] = _G[:H//<span class="number">2</span>, :W//<span class="number">2</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> G</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Read image</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">97</span></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imori.jpg"</span>).astype(np.float32)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">98</span></pre></td><td class="code"><pre><span class="line">H, W, C = img.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">99</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">100</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Gray scale</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">101</span></pre></td><td class="code"><pre><span class="line">gray = bgr2gray(img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">102</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">103</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># DFT</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">104</span></pre></td><td class="code"><pre><span class="line">G = dft(img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">105</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">106</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># LPF</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">107</span></pre></td><td class="code"><pre><span class="line">G = lpf(G)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">108</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">109</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># IDFT</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">110</span></pre></td><td class="code"><pre><span class="line">out = idft(G)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">111</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">112</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Save result</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">113</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"result"</span>, out)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">114</span></pre></td><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">115</span></pre></td><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">"out.jpg"</span>, out)</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">height</span> = <span class="number">128</span>, <span class="built_in">width</span> = <span class="number">128</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fourier_str</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; coef[<span class="built_in">height</span>][<span class="built_in">width</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// RGB to Gray scale</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">BGR2GRAY</span><span class="params">(cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// BGR -&gt; Gray</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (<span class="keyword">int</span>)((<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">0</span>] * <span class="number">0.0722</span> + \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">1</span>] * <span class="number">0.7152</span> + \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">2</span>] * <span class="number">0.2126</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discrete Fourier transformation</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="function">fourier_str <span class="title">dft</span><span class="params">(cv::Mat img, fourier_str fourier_s)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> I;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> theta;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; val;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="built_in">height</span>; l ++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="built_in">width</span>; k ++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">      val.real(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">      val.imag(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y ++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x ++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">          I = (<span class="keyword">double</span>)img.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">          <span class="comment">//求欧拉公式中的theta角jxtheta=cos(theta)+jsin(theta)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">          theta = <span class="number">-2</span> * M_PI * ((<span class="keyword">double</span>)k * (<span class="keyword">double</span>)x / (<span class="keyword">double</span>)<span class="built_in">width</span> + (<span class="keyword">double</span>)l * (<span class="keyword">double</span>)y / (<span class="keyword">double</span>)<span class="built_in">height</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">          val += <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">cos</span>(theta), <span class="built_in">sin</span>(theta)) * I;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">      val /= <span class="built_in">sqrt</span>(<span class="built_in">height</span> * <span class="built_in">width</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">      fourier_s.coef[l][k] = val;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> fourier_s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inverse Discrete Fourier transformation</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">idft</span><span class="params">(cv::Mat out, fourier_str fourier_s)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> theta;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> g;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; G;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; val;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y ++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x ++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">      val.real(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">      val.imag(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="built_in">height</span>; l ++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="built_in">width</span>; k ++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">          G = fourier_s.coef[l][k];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">          theta = <span class="number">2</span> * M_PI * ((<span class="keyword">double</span>)k * (<span class="keyword">double</span>)x / (<span class="keyword">double</span>)<span class="built_in">width</span> + (<span class="keyword">double</span>)l * (<span class="keyword">double</span>)y / (<span class="keyword">double</span>)<span class="built_in">height</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">          val += <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">cos</span>(theta), <span class="built_in">sin</span>(theta)) * G;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">      g = <span class="built_in">std</span>::<span class="built_in">abs</span>(val) / <span class="built_in">sqrt</span>(<span class="built_in">height</span> * <span class="built_in">width</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">      g = fmin(fmax(g, <span class="number">0</span>), <span class="number">255</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (uchar)g;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Low pass Filter</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line"><span class="function">fourier_str <span class="title">lpf</span><span class="params">(fourier_str fourier_s, <span class="keyword">double</span> pass_r)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// filtering</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> r = <span class="built_in">height</span> / <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> filter_d = (<span class="keyword">int</span>)((<span class="keyword">double</span>)r * pass_r);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">height</span> / <span class="number">2</span>; j++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">width</span> / <span class="number">2</span>; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> (<span class="built_in">sqrt</span>(i * i + j * j) &gt;= filter_d)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">        fourier_s.coef[j][i] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">        fourier_s.coef[j][<span class="built_in">width</span> - i] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">        fourier_s.coef[<span class="built_in">height</span> - i][i] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">        fourier_s.coef[<span class="built_in">height</span> - i][<span class="built_in">width</span> - i] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> fourier_s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="四、高通滤波器"><a href="#四、高通滤波器" class="headerlink" title="四、高通滤波器"></a>四、高通滤波器</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># DFT hyper-parameters</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">K, L = <span class="number">128</span>, <span class="number">128</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">channel = <span class="number">3</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># bgr -&gt; gray</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bgr2gray</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	gray = <span class="number">0.2126</span> * img[..., <span class="number">2</span>] + <span class="number">0.7152</span> * img[..., <span class="number">1</span>] + <span class="number">0.0722</span> * img[..., <span class="number">0</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> gray</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># DFT</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dft</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># Prepare DFT coefficient</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">	G = np.zeros((L, K, channel), dtype=np.complex)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># prepare processed index corresponding to original image positions</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">	x = np.tile(np.arange(W), (H, <span class="number">1</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">	y = np.arange(H).repeat(W).reshape(H, <span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># dft</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">for</span> c <span class="keyword">in</span> range(channel):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">for</span> l <span class="keyword">in</span> range(L):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">for</span> k <span class="keyword">in</span> range(K):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">				G[l, k, c] = np.sum(img[..., c] * np.exp(<span class="number">-2j</span> * np.pi * (x * k / K + y * l / L))) / np.sqrt(K * L)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> G</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># IDFT</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">idft</span><span class="params">(G)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># prepare out image</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">	H, W, _ = G.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">	out = np.zeros((H, W, channel), dtype=np.float32)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># prepare processed index corresponding to original image positions</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">	x = np.tile(np.arange(W), (H, <span class="number">1</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">	y = np.arange(H).repeat(W).reshape(H, <span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># idft</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">for</span> c <span class="keyword">in</span> range(channel):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">for</span> l <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">			<span class="keyword">for</span> k <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">				out[l, k, c] = np.abs(np.sum(G[..., c] * np.exp(<span class="number">2j</span> * np.pi * (x * k / W + y * l / H)))) / np.sqrt(W * H)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># clipping</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">	out = np.clip(out, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">	out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># HPF</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hpf</span><span class="params">(G, ratio=<span class="number">0.1</span>)</span>:</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">	H, W, _ = G.shape	</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># transfer positions</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">	_G = np.zeros_like(G)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">	_G[:H//<span class="number">2</span>, :W//<span class="number">2</span>] = G[H//<span class="number">2</span>:, W//<span class="number">2</span>:]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">	_G[:H//<span class="number">2</span>, W//<span class="number">2</span>:] = G[H//<span class="number">2</span>:, :W//<span class="number">2</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">	_G[H//<span class="number">2</span>:, :W//<span class="number">2</span>] = G[:H//<span class="number">2</span>, W//<span class="number">2</span>:]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">	_G[H//<span class="number">2</span>:, W//<span class="number">2</span>:] = G[:H//<span class="number">2</span>, :W//<span class="number">2</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># get distance from center (H / 2, W / 2)</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">	x = np.tile(np.arange(W), (H, <span class="number">1</span>))</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">	y = np.arange(H).repeat(W).reshape(H, <span class="number">-1</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># make filter</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">	_x = x - W // <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">	_y = y - H // <span class="number">2</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">	r = np.sqrt(_x ** <span class="number">2</span> + _y ** <span class="number">2</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">	mask = np.ones((H, W), dtype=np.float32)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">	mask[r &lt; (W // <span class="number">2</span> * ratio)] = <span class="number">0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">	mask = np.repeat(mask, channel).reshape(H, W, channel)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># filtering</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">	_G *= mask</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">	<span class="comment"># reverse original positions</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">	G[:H//<span class="number">2</span>, :W//<span class="number">2</span>] = _G[H//<span class="number">2</span>:, W//<span class="number">2</span>:]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">	G[:H//<span class="number">2</span>, W//<span class="number">2</span>:] = _G[H//<span class="number">2</span>:, :W//<span class="number">2</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">	G[H//<span class="number">2</span>:, :W//<span class="number">2</span>] = _G[:H//<span class="number">2</span>, W//<span class="number">2</span>:]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">	G[H//<span class="number">2</span>:, W//<span class="number">2</span>:] = _G[:H//<span class="number">2</span>, :W//<span class="number">2</span>]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">return</span> G</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Read image</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imori.jpg"</span>).astype(np.float32)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">H, W, C = img.shape</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Gray scale</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">gray = bgr2gray(img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># DFT</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line">G = dft(img)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># HPF</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">97</span></pre></td><td class="code"><pre><span class="line">G = hpf(G)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">98</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">99</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># IDFT</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">100</span></pre></td><td class="code"><pre><span class="line">out = idft(G)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">101</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">102</span></pre></td><td class="code"><pre><span class="line"><span class="comment"># Save result</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">103</span></pre></td><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"result"</span>, out)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">104</span></pre></td><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">105</span></pre></td><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">"out.jpg"</span>, out)</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">height</span> = <span class="number">128</span>, <span class="built_in">width</span> = <span class="number">128</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fourier_str</span> &#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; coef[<span class="built_in">height</span>][<span class="built_in">width</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// RGB to Gray scale</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">BGR2GRAY</span><span class="params">(cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// BGR -&gt; Gray</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (<span class="keyword">int</span>)((<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">0</span>] * <span class="number">0.0722</span> + \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">1</span>] * <span class="number">0.7152</span> + \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">2</span>] * <span class="number">0.2126</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Discrete Fourier transformation</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="function">fourier_str <span class="title">dft</span><span class="params">(cv::Mat img, fourier_str fourier_s)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> I;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> theta;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; val;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="built_in">height</span>; l ++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="built_in">width</span>; k ++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">      val.real(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">      val.imag(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y ++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x ++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">          I = (<span class="keyword">double</span>)img.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">          theta = <span class="number">-2</span> * M_PI * ((<span class="keyword">double</span>)k * (<span class="keyword">double</span>)x / (<span class="keyword">double</span>)<span class="built_in">width</span> + (<span class="keyword">double</span>)l * (<span class="keyword">double</span>)y / (<span class="keyword">double</span>)<span class="built_in">height</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">          val += <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">cos</span>(theta), <span class="built_in">sin</span>(theta)) * I;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line">      val /= <span class="built_in">sqrt</span>(<span class="built_in">height</span> * <span class="built_in">width</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">      fourier_s.coef[l][k] = val;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> fourier_s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Inverse Discrete Fourier transformation</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">idft</span><span class="params">(cv::Mat out, fourier_str fourier_s)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> theta;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">double</span> g;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; G;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; val;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y ++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x ++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">      val.real(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">      val.imag(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="built_in">height</span>; l ++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="built_in">width</span>; k ++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">          G = fourier_s.coef[l][k];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">          theta = <span class="number">2</span> * M_PI * ((<span class="keyword">double</span>)k * (<span class="keyword">double</span>)x / (<span class="keyword">double</span>)<span class="built_in">width</span> + (<span class="keyword">double</span>)l * (<span class="keyword">double</span>)y / (<span class="keyword">double</span>)<span class="built_in">height</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">          val += <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">cos</span>(theta), <span class="built_in">sin</span>(theta)) * G;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">      g = <span class="built_in">std</span>::<span class="built_in">abs</span>(val) / <span class="built_in">sqrt</span>(<span class="built_in">height</span> * <span class="built_in">width</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">      g = fmin(fmax(g, <span class="number">0</span>), <span class="number">255</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (uchar)g;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line"><span class="comment">// Band pass Filter</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line"><span class="function">fourier_str <span class="title">bpf</span><span class="params">(fourier_str fourier_s, <span class="keyword">double</span> pass_lower, <span class="keyword">double</span> pass_upper)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">  <span class="comment">// filtering</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> r = <span class="built_in">height</span> / <span class="number">2</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> filter_lower = (<span class="keyword">int</span>)((<span class="keyword">double</span>)r * pass_lower);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">int</span> filter_upper = (<span class="keyword">int</span>)((<span class="keyword">double</span>)r * pass_upper);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">height</span> / <span class="number">2</span>; j++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">width</span> / <span class="number">2</span>; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">      <span class="keyword">if</span> ((<span class="built_in">sqrt</span>(i * i + j * j) &lt; filter_lower) || </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">          (<span class="built_in">sqrt</span>(i * i + j * j) &gt; filter_upper))&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">        fourier_s.coef[j][i] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">        fourier_s.coef[j][<span class="built_in">width</span> - i] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">91</span></pre></td><td class="code"><pre><span class="line">        fourier_s.coef[<span class="built_in">height</span> - i][i] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">92</span></pre></td><td class="code"><pre><span class="line">        fourier_s.coef[<span class="built_in">height</span> - i][<span class="built_in">width</span> - i] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">93</span></pre></td><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">94</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">95</span></pre></td><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">96</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">97</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span> fourier_s;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">98</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/03/CUDA-Programmer-Learn-two/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qiang Chen">
      <meta itemprop="description" content="记录是忘记的第一助手.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="编辑尼撑">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/03/CUDA-Programmer-Learn-two/" class="post-title-link" itemprop="url">CUDA-Programmer-Learn-Two</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-03 23:25:06 / 修改时间：23:33:30" itemprop="dateCreated datePublished" datetime="2021-07-03T23:25:06+08:00">2021-07-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CUDA-Programmer/" itemprop="url" rel="index">
                    <span itemprop="name">CUDA Programmer</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CUDA编程学习笔记"><a href="#CUDA编程学习笔记" class="headerlink" title="CUDA编程学习笔记"></a>CUDA编程学习笔记</h2><p>本笔记主要<a href="https://face2ai.com/program-blog/#GPU%E7%BC%96%E7%A8%8B%EF%BC%88CUDA%EF%BC%89" target="_blank" rel="noopener">参考: 谭升</a>大神的博客进行了部分关键知识的摘录，可能有些地方回去单独查找一些资料进行解释。</p>
<p>GPU中使用CUDA编程的核心部分分为：核函数、内存管理、线程管理和流。</p>
<p>在CUAD编程中特有的功能为：通过组织层次结构在GPU上组织线程的方法；通过组织层次结构在GPU上组织内存的方法。</p>
<p>在实际的CUDA应用开发过程中：需要从三个角度来思考如何解决问题？</p>
<ol>
<li>领域层，根据所要解决的问题的条件，在领域层分析数据和函数</li>
<li>逻辑层，需要考虑线程的层次结构，可以获得良好的可扩展性。</li>
<li>硬件层，通过理解线程如何映射到机器上，能充分帮助我们提高性能。</li>
</ol>
<h4 id="一、内存管理"><a href="#一、内存管理" class="headerlink" title="一、内存管理"></a>一、内存管理</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">标准C函数</th>
<th style="text-align:center">CUDA C函数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">malloc</td>
<td style="text-align:center">cudaMalloc</td>
<td style="text-align:center">内存分配</td>
</tr>
<tr>
<td style="text-align:center">memcpy</td>
<td style="text-align:center">cudaMemcpy</td>
<td style="text-align:center">内存复制</td>
</tr>
<tr>
<td style="text-align:center">memset</td>
<td style="text-align:center">cudaMemset</td>
<td style="text-align:center">内存设置</td>
</tr>
<tr>
<td style="text-align:center">free</td>
<td style="text-align:center">cudaFree</td>
<td style="text-align:center">释放内存</td>
</tr>
</tbody>
</table>
</div>
<h4 id="二、线程管理"><a href="#二、线程管理" class="headerlink" title="二、线程管理"></a>二、线程管理</h4><p>一个核函数只能有一个grid，一个grid可以有很多个块，每个块可以有很多的线程，这种分层的组织结构使得我们的并行过程更加自如灵活。一个线程块block中的线程可以完成同步和内存共享。<strong>不同块内线程不能相互影响，他们是物理隔离的。</strong></p>
<p>每个线程都执行同样的一段串行代码，那么怎么让这段相同的代码对应不同的数据呢？</p>
<p>依靠下面两个内置结构体确定线程标号：blockIdx（线程块在线程网格内的位置索引），threadIdx（线程在线程块内的位置索引）。这两个内置结构体基于 uint3 定义，包含三个无符号整数的结构，通过三个字段来指定：blockIdx.x，blockIdx.y，blockIdx.z，threadIdx.x，threadIdx.y，threadIdx.z。</p>
<p>blockIdx对应的范围为gridDim，threadIdx对应的范围为blockDim。他们是dim3类型(基于uint3定义的数据结构)的变量，也包含三个字段x,y,z。blockDim.x，blockDim.y，blockDim.z。</p>
<p>通过指定grid和block的维度，我们可以配置：1、内核中线程的数目；2、内核中使用的线程布局。可以使用<strong>dim3类型</strong>的grid维度和block维度配置内核，也可以使用int类型的变量，或者常量直接初始化。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">kernel_name&lt;&lt;&lt;<span class="number">4</span>,<span class="number">8</span>&gt;&gt;&gt;(argument <span class="built_in">list</span>);</span></pre></td></tr></table></figure>
<p>上面这条指令的线程布局是：</p>
<p><img src="/2021/07/03/CUDA-Programmer-Learn-two/1.png" alt="CUDA-Program-Lean-Plus"></p>
<p>核函数是同时复制到多个线程执行的，上文我们说过一个对应问题，多个计算执行在一个数据，肯定是浪费时间，所以为了让多线程按照我们的意愿对应到不同的数据，就要给线程一个唯一的标识，由于设备内存是线性的（基本市面上的内存硬件都是线性形式存储数据的）我们观察上图，可以用threadIdx.x 和blockIdx.x 来组合获得对应的线程的唯一标识。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//主机端显示等待设备端执行</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function">cudaError_t <span class="title">cudaDeviceSynchronize</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//主机端隐式等待设备端执行 </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//当核函数启动后的下一条指令就是从设备复制数据回主机端，那么主机端必须要等待设备端计算完成。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function">cudaError_t <span class="title">cudaMemcpy</span><span class="params">(<span class="keyword">void</span>* dst,<span class="keyword">const</span> <span class="keyword">void</span> * src,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">  <span class="keyword">size_t</span> count,cudaMemcpyKind kind)</span></span>;</span></pre></td></tr></table></figure>
<p>所有CUDA核函数的启动都是异步的。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//编写核函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">kernel_name</span><span class="params">(argument <span class="built_in">list</span>)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//CUDA小技巧，当我们进行调试的时候可以把核函数配置成单线程的</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">kernel_name&lt;&lt;&lt;<span class="number">1</span>,<span class="number">1</span>&gt;&gt;&gt;(argument <span class="built_in">list</span>)</span></pre></td></tr></table></figure>
<p><strong>错误处理</strong>，获得每个函数执行后的返回结果，然后对不成功的信息加以处理，CUDA C 的API每个调用都会返回一个错误代码。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK(call) \</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">&#123;\</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">const</span> cudaError_t error=call;\</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span>(error!=cudaSuccess)\</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">	&#123;\</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">		<span class="built_in">printf</span>(<span class="string">"ERROR: %s:%d,"</span>,__FILE__,__LINE__);\</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">		<span class="built_in">printf</span>(<span class="string">"code:%d,reason:%s\n"</span>,error,cudaGetErrorString(error));\</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);\</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">	&#125;\</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><strong>用CPU计时</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cpuSecond</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tp</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">  gettimeofday(&amp;tp,<span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">  <span class="keyword">return</span>((<span class="keyword">double</span>)tp.tv_sec+(<span class="keyword">double</span>)tp.tv_usec*<span class="number">1e-6</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><strong>理论极限最大化</strong></p>
<p>得到了实际操作值，我们需要知道的是我们能优化的极限值是多少，也就是机器的理论计算极限，这个极限我们永远也达不到，但是我们必须明确的知道，比如理论极限是2秒，我们已经从10秒优化到2.01秒了，基本就没有必要再继续花大量时间优化速度了，而应该考虑买更多的机器或者更新的设备。各个设备的理论极限可以通过其芯片说明计算得到。具体的计算指标为：</p>
<ul>
<li>单精度峰值浮点数计算次数</li>
<li>内存带宽峰值</li>
<li>指令比</li>
</ul>
<h4 id="三、组织并行线程"><a href="#三、组织并行线程" class="headerlink" title="三、组织并行线程"></a>三、组织并行线程</h4><p>介绍每一个线程是怎么确定唯一的索引，然后建立并行计算，并且不同的线程组织形式是怎样影响性能的？</p>
<p><strong>使用快和线程建立矩阵索引</strong></p>
<p>多线程的优点就是每个线程处理不同的数据计算，那么怎么分配好每个线程处理不同的数据，而不至于多个不同的线程处理同一个数据，或者避免不同的线程没有组织的乱访问内存。</p>
<p><img src="/2021/07/03/CUDA-Programmer-Learn-two/2.png" alt="CUDA-Program-Learn-Plus"></p>
<p>这里(ix,iy)就是整个线程模型中任意一个线程的索引，或者叫做全局地址，局部地址当然就是(threadIdx.x,threadIdx.y)了，当然这个局部地址目前还没有什么用处，他只能索引线程块内的线程，不同线程块中有相同的局部索引值。</p>
<p>前面讲过CUDA每一个线程执行相同的代码，也就是异构计算中说的多线程单指令，如果每个不同的线程执行同样的代码，又处理同一组数据，将会得到多个相同的结果，显然这是没意义的，为了让不同线程处理不同的数据，CUDA常用的做法是让不同的线程对应不同的数据，也就是用线程的全局标号对应不同组的数据。</p>
<p>设备内存或者主机内存都是线性存在的，比如一个二维矩阵 (8×6)，存储在内存中是这样的：</p>
<p><img src="/2021/07/03/CUDA-Programmer-Learn-two/3.png" alt="CUDA-Program-Learn-Plus"></p>
<p>图像块中数据寻址的计算步骤：</p>
<ul>
<li>线程和块索引（来计算线程的全局索引），矩阵中给定点的坐标（ix,iy）</li>
<li>(ix,iy)对应的线性内存的位置</li>
</ul>
<p>线性位置的计算方法是：</p>
<script type="math/tex; mode=display">
idx=ix+iy∗nx</script><h4 id="四、执行模型"><a href="#四、执行模型" class="headerlink" title="四、执行模型"></a>四、执行模型</h4><p>用CUDA的目的其实说白了就是为计算速度快，所以压榨性能，提高效率其实就是CUDA学习的最终目的。什么时候我们沿着硬件设计的思路设计程序，我们就会得到百战百胜。CUDA执行模型揭示了GPU并行架构的抽象视图，了解CUDA的执行模型，可以帮助我们优化指令吞吐量，和内存使用来获得极限速度。</p>
<p><strong>GPU架构概述：</strong>GPU架构是围绕一个流式多处理器（SM）的扩展阵列搭建的。通过复制这种结构来实现GPU的硬件并行。</p>
<p>下面图中展示了流式多处理器中的一些核心组件：CUDA核心、共享内存/一级缓存、寄存器文件、加载/存储单元、特殊功能单元、线程束调度器。</p>
<p><img src="/2021/07/03/CUDA-Programmer-Learn-two/4.png" alt="CUDA-Program-Learn-Plus"></p>
<p>GPU中每个SM都能支持数百个线程并发执行，每个GPU通常有多个SM，当一个核函数的网格被启动的时候，多个block会被同时分配给可用的SM上执行。</p>
<p><strong>注意:</strong> 当一个blcok被分配给一个SM后，他就只能在这个SM上执行了，不可能重新分配到其他SM上了，多个线程块可以被分配到同一个SM上。在SM上同一个块内的多个线程进行线程级别并行，<strong>而同一线程内，指令利用指令级并行将单个线程处理成流水线。</strong></p>
<p><strong>线程束：</strong>CUDA  采用单指令多线程SIMT架构管理执行线程，不同设备有不同的线程束大小，但是到目前为止基本所有设备都是维持在32，也就是说每个SM上有多个block，一个block有多个线程（可以是几百个，但不会超过某个最大值），但是从机器的角度，在某时刻T，SM上只执行一个线程束，也就是32个线程在同时同步执行，线程束中的每个线程执行同一条指令。</p>
<p><strong>SIMD vs SIMT：</strong>单指令多数据的执行属于向量机，比如我们有四个数字要加上四个数字，那么我们可以用这种单指令多数据的指令来一次完成本来要做四次的运算。这种机制的问题就是过于死板，不允许每个分支有不同的操作，所有分支必须同时执行相同的指令，必须执行没有例外。相比之下单指令多线程SIMT就更加灵活了，虽然两者都是将相同指令广播给多个执行单元，但是SIMT的某些线程可以选择不执行，也就是说同一时刻所有线程被分配给相同的指令，SIMD规定所有人必须执行，而SIMT则规定有些人可以根据需要不执行，这样SIMT就保证了线程级别的并行，而SIMD更像是指令级别的并行。</p>
<p>SIMT包括以下SIMD不具有的关键特性：</p>
<ol>
<li>每个线程都有自己的指令地址计数器</li>
<li>每个线程都有自己的寄存器状态</li>
<li>每个线程可以有一个独立的执行路径</li>
</ol>
<p>而上面这三个特性在编程模型可用的方式就是给每个线程一个唯一的标号（blckIdx,threadIdx），并且这三个特性保证了各线程之间的独立。</p>
<p><strong>问题：如何将线程的标号唯一的对应到SM流式多处理器中的block，对应到block后CUDA核和指令寄存器之间的关系如何确定?</strong></p>
<h4 id="五、CUDA编程的组件与逻辑"><a href="#五、CUDA编程的组件与逻辑" class="headerlink" title="五、CUDA编程的组件与逻辑"></a>五、CUDA编程的组件与逻辑</h4><p>下图从逻辑角度和硬件角度描述了CUDA编程模型对应的组件。</p>
<p><img src="/2021/07/03/CUDA-Programmer-Learn-two/5.png" alt="CUDA-Program-Learn-Plus"></p>
<p>SM中共享内存，和寄存器是关键的资源，线程块中线程通过共享内存和寄存器相互通信协调。寄存器和共享内存的分配可以严重影响性能！</p>
<p>每个SM有<strong>两个线程束调度器，和两个指令调度单元</strong>，当一个线程块被指定给一个SM时，线程块内的所有线程被分成线程束，线程束选择其中两个线程束，在用指令调度器存储两个线程束要执行的指令（就像上面例子中分水果的水果一样，我们这里有两个班，两个班的老师各自控制的自己的水果，老师就是指令调度器）像第一张图上的显示一样，每16个CUDA核心为一个组，还有16个加载/存储单元或4个特殊功能单元。当某个线程块被分配到一个SM上的时候，会被分成多个线程束，线程束在SM上交替执行。</p>
<p><strong>开发高性能计算程序关键的两个步骤：1、保证结果正确，和程序健壮性；2、优化速度。</strong></p>
<p><strong>性能分析的主要关注点：</strong></p>
<ol>
<li>应用程序代码的空间或时间复杂度</li>
<li>特殊指令的使用</li>
<li>函数调用的频率和持续时间</li>
</ol>
<p><strong>性能分析工具：</strong></p>
<ul>
<li>nvvp</li>
<li>nvprop</li>
</ul>
<h4 id="六、线程束和线程块"><a href="#六、线程束和线程块" class="headerlink" title="六、线程束和线程块"></a>六、线程束和线程块</h4><p>线程束是SM中基本的执行单元，当一个网格被启动（网格被启动，等价于一个内核被启动，每个内核对应于自己的网格），网格中包含线程块，线程块被分配到某一个SM上以后，将分为多个线程束，每个线程束一般是32个线程（目前的GPU都是32个线程，但不保证未来还是32个）在一个线程束中，所有线程按照单指令多线程SIMT的方式执行，每一步执行相同的指令，但是处理的数据为私有的数据，下图反应的就是逻辑，实际，和硬件的图形化。</p>
<p><img src="/2021/07/03/CUDA-Programmer-Learn-two/6.png" alt="CUDA-Program-Learn-Plus"></p>
<p><strong>线程束的分化：</strong>那么当一个线程束的32个线程执行这段代码的时候，如果其中16个执行if中的代码段，而另外16个执行else中的代码块，同一个线程束中的线程，执行不同的指令。<strong>线程束分化会产生严重的性能下降。条件分支越多，并行性削弱越严重。</strong>（因为分配命令的调度器就一个，所以满足if条件的线程得到if中的指令执行，不满足的部分等待。当满足if条件的线程执行完后，不满足的线程执行else中的指令，其余线程等待）</p>
<p><strong>如何解决线程束的分化？</strong></p>
<p>根本思路是避免同一个线程束内的线程分化，而让我们能控制线程束内线程行为的原因是线程块中线程分配到线程束是有规律的而不是随机的。这就使得我们根据线程编号来设计分支是可以的，补充说明下，当一个线程束中所有的线程都执行if或者，都执行else时，不存在性能下降；只有当线程束内有分歧产生分支的时候，性能才会急剧下降。线程束内被分配的线程是可以被我们控制的，那么我们就把都执行if的线程塞到一个线程束中，或者让一个线程束中的线程都执行if，另外线程都执行else的这种方式可以将效率提高很多。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//低效的if else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">mathKernel1</span><span class="params">(<span class="keyword">float</span> *c)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">int</span> tid = blockIdx.x* blockDim.x + threadIdx.x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">float</span> a = <span class="number">0.0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">float</span> b = <span class="number">0.0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> (tid % <span class="number">2</span> == <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">		a = <span class="number">100.0f</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">		b = <span class="number">200.0f</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">	c[tid] = a + b;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//高效的if else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">mathKernel2</span><span class="params">(<span class="keyword">float</span> *c)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">int</span> tid = blockIdx.x* blockDim.x + threadIdx.x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">float</span> a = <span class="number">0.0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">float</span> b = <span class="number">0.0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> ((tid/warpSize) % <span class="number">2</span> == <span class="number">0</span>)</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">		a = <span class="number">100.0f</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">else</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">		b = <span class="number">200.0f</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">	c[tid] = a + b;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//上面warpSize表示线程束中线程的大小,比如总64个线程，分到了两个线程束，一个线程束32个线程。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//那么0-31的线程束都是if内的指令，32-63的线程束都是else指令。</span></span></pre></td></tr></table></figure>
<h4 id="七、资源分配"><a href="#七、资源分配" class="headerlink" title="七、资源分配"></a>七、资源分配</h4><p>每个SM上执行的基本单位是线程束，也就是说，单指令通过指令调度器广播给某线程束的全部线程，这些线程同一时刻执行同一命令。对于线程束来说有激活和未激活两个状态，线程束一旦被激活来到片上，那么他就不会再离开SM直到执行结束。而每个SM上有多少个线程束处于激活状态，取决于以下资源：</p>
<ol>
<li>程序计数器</li>
<li>寄存器</li>
<li>共享内存</li>
</ol>
<p>一个SM上被分配多少个线程块和线程束取决于SM中可用的寄存器和共享内存，以及内核需要的寄存器和共享内存大小。</p>
<p>当寄存器和共享内存分配给了线程块，这个线程块处于活跃状态，所包含的线程束称为活跃线程束。活跃的线程束又分为三类：</p>
<ul>
<li>选定的线程束</li>
<li>阻塞的线程束</li>
<li>符合条件的线程束 //32个CUDA核心可以用于执行；执行所需要的资源全部就位</li>
</ul>
<p>当SM要执行某个线程束的时候，执行的这个线程束叫做选定的线程束，准备要执行的叫符合条件的线程束，如果线程束不符合条件还没准备好就是阻塞的线程束。</p>
<h4 id="八、延迟隐藏"><a href="#八、延迟隐藏" class="headerlink" title="八、延迟隐藏"></a>八、延迟隐藏</h4><p>最大化是要最大化硬件，尤其是计算部分的硬件满跑，都不闲着的情况下利用率是最高的，总有人闲着，利用率就会低很多，即最大化功能单元的利用率。<strong>利用率与常驻线程束直接相关。</strong>硬件中线程束调度器负责调度线程束调度，当每时每刻都有可用的线程束供其调度，这时候可以达到计算资源的完全利用，以此来保证通过其他常驻线程束中发布其他指令的，可以隐藏每个指令的延迟。</p>
<p>对于指令的延迟，通常分为两种：算术指令、内存指令。</p>
<p>算数指令延迟是一个算术操作从开始，到产生结果之间的时间，这个时间段内只有某些计算单元处于工作状态，而其他逻辑计算单元处于空闲。算术延迟 10~20   个时钟周期</p>
<p>内存指令延迟很好理解，当产生内存访问的时候，计算单元要等数据从内存拿到寄存器，这个周期是非常长的。内存延迟 400~800 个时钟周期</p>
<p>所需线程束=延迟×吞吐量</p>
<p>同样，与指令周期隐藏延迟类似，内存隐藏延迟是靠内存读取的并发操作来完成的，需要注意的是，指令隐藏的关键目的是使用全部的计算资源，而内存读取的延迟隐藏是为了使用全部的内存带宽，内存延迟的时候，计算资源正在被别的线程束使用，所以我们不考虑内存读取延迟的时候计算资源在做了什么。</p>
<p>所以，延迟的隐藏取决于活动的线程束的数量，数量越多，隐藏的越好，但是线程束的数量又受到上面的说的资源影响。所以这里就需要寻找最优的执行配置来达到最优的延迟隐藏。</p>
<h4 id="九、同步"><a href="#九、同步" class="headerlink" title="九、同步"></a>九、同步</h4><p>块级别的就是同一个块内的线程会同时停止在某个设定的位置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">__syncthread();</span></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/03/CUDA-Programmer-Learn-Two/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qiang Chen">
      <meta itemprop="description" content="记录是忘记的第一助手.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="编辑尼撑">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/03/CUDA-Programmer-Learn-Two/" class="post-title-link" itemprop="url">CUDA-Programmer-Learn-Two</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-03 23:25:06" itemprop="dateCreated datePublished" datetime="2021-07-03T23:25:06+08:00">2021-07-03</time>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/03/CUDA-Programmer-Learn-One/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qiang Chen">
      <meta itemprop="description" content="记录是忘记的第一助手.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="编辑尼撑">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/03/CUDA-Programmer-Learn-One/" class="post-title-link" itemprop="url">CUDA-Programmer-Learn-One</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-07-03 23:21:18" itemprop="dateCreated datePublished" datetime="2021-07-03T23:21:18+08:00">2021-07-03</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-07-04 00:04:58" itemprop="dateModified" datetime="2021-07-04T00:04:58+08:00">2021-07-04</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CUDA-Programmer/" itemprop="url" rel="index">
                    <span itemprop="name">CUDA Programmer</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CUDA编程学习笔记"><a href="#CUDA编程学习笔记" class="headerlink" title="CUDA编程学习笔记"></a>CUDA编程学习笔记</h2><p>本笔记主要<a href="https://face2ai.com/program-blog/#GPU%E7%BC%96%E7%A8%8B%EF%BC%88CUDA%EF%BC%89" target="_blank" rel="noopener">参考: 谭升</a>大神的博客进行了部分关键知识的摘录，可能有些地方回去单独查找一些资料进行解释。</p>
<h4 id="一、编程模型"><a href="#一、编程模型" class="headerlink" title="一、编程模型"></a>一、编程模型</h4><p>1、 <strong>简单介绍线程层级：</strong>CUDA编程是一个多线程编程，数个线程(Thread)组成一个线程块(Block)，所有线程块组成一个线程网格(Grid)。目前的GPU限制一个<strong>线程块</strong>中，最多可以安排1024个线程。由于<strong>32个相邻的线程会组成一个线程束</strong>(Thread Warp)，而一个线程束中的线程会运行同样的指令。因此一般线程块中线程的数量被安排为32的倍数，选用256是比较合适的。</p>
<p>2、<strong>内核函数：</strong>CUDA每个线程执行的函数。关键字为global，返回值的关键字为void。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//kernal definition</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">vecAdd</span><span class="params">(<span class="keyword">float</span>* A, <span class="keyword">float</span>* B, <span class="keyword">float</span>* C)</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i=threadId.x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    C[i]=A[i]+B[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    vecAdd&lt;&lt;&lt;<span class="number">1</span>, N&gt;&gt;&gt;(A, B, C);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">matAdd</span><span class="params">(<span class="keyword">float</span> A[N][N], <span class="keyword">float</span> B[N][N], <span class="keyword">float</span> C[N][N])</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//blockDim代表当前线程块的尺寸</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> i = blockIdx.x * blockDim.x + threadIdx.x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> j = blockIdx.y * blockDim.y + threadIdx.y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(i &lt; N &amp;&amp; j &lt; N)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">        C[j][i] = A[j][i] + B[j][i]</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> main()&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    dim3 threadsPerBlock(<span class="number">16</span>,<span class="number">16</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    <span class="function">dim3 <span class="title">numBlocks</span><span class="params">(N / threadsPerBlock.x, N / threadsPerBlock.y)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    matAdd&lt;&lt;&lt;numBlocks, threadsPerBlock&gt;&gt;&gt;(A, B, C);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><strong>SIMT，相同指令，不同线程</strong></p>
<p>3、<strong>内存层级：</strong>一般主机端内存通过PCI-E总线与设备端内存交换数据。数据交换的速度等于PCI-E总线的速度。</p>
<ol>
<li>寄存器和本地内存绑定到了每个线程，其他线程无法访问。</li>
<li>同一个线程块内的线程，可以访问同一块共享内存。注意，即使两个线程块被调度到了同一个SM上，他们的共享内存也是隔离开的，不能互相访问。</li>
<li>网格中的所有线程都可以自由读写全局内存。</li>
<li>常量内存和纹理内存只能被CPU端修改，GPU内的线程只能读取数据。</li>
</ol>
<p>4、<strong>CPU/GPU混合编程：</strong></p>
<p>CPU和GPU的内存是独立的，如何在两者之间共享数据。</p>
<ul>
<li>主机端(Host，即CPU)执行串行代码，然后调用内核函数，让设备端(Device，即GPU)执行并行代码。如此交错执行。<ul>
<li>一、因此在运行内核函数前，主机端需要调用内存拷贝函数，将数据通过PCI-E总线拷贝到设备端。内核运行结束后，需要CPU再次调用内存拷贝函数，将数据拷回主机端内存。</li>
<li>二、使用统一编址，将设备端的内存和主机端内存编到一起。这样主机就不需要显式的调用函数将数据拷贝到设备端内存了。</li>
</ul>
</li>
<li>除了CPU/GPU交错执行代码的方式外，还可以通过使用事件(event)和流(stream)等方式，让CPU/GPU并行工作，提升整体的效率。</li>
</ul>
<p>5、<strong>计算能力：</strong>指不同的GPU版本，每个版本具有不同的特性，编程也会有所差异。CUDA的版本与计算能力没有关系，只是表示对不同架构的支持。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//CPU、OpenCV、CUDA分别执行图像灰度转换</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/highgui.hpp"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/opencv.hpp"</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//CPU转换</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">cpuConvertGray</span><span class="params">(Mat src, <span class="keyword">int</span> <span class="built_in">height</span>, <span class="keyword">int</span> <span class="built_in">width</span>)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    Mat outImg = zeros(imgHeight, imgWidth, CV_8UC1, Scalar(<span class="number">0</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;<span class="built_in">height</span>; ++y)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="built_in">width</span>; ++x)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">            outImg.at&lt;uchar&gt;(y,x) = <span class="number">0.2126</span> * (<span class="keyword">float</span>)src.at&lt;Vec3b&gt;(y,x)[<span class="number">2</span>] + \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">                <span class="number">0.7152</span> * (<span class="keyword">float</span>)src.at&lt;Vec3b&gt;(y,x)[<span class="number">1</span>] + \</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">                <span class="number">0.0722</span> * (<span class="keyword">float</span>)src.at&lt;Vec3b&gt;(y,x)[<span class="number">0</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> outImg;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//OpenCV转换</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">openCvtGray</span><span class="params">(Mat src)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    Mat out;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    cvtColor(src, out, COLOR_BGR2GRAY);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//CUDA转换</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">gpuConvertGray</span><span class="params">(uchar3* <span class="keyword">const</span> input, <span class="keyword">unsigned</span> <span class="keyword">char</span>* output, <span class="keyword">int</span> <span class="built_in">height</span>, <span class="keyword">int</span> <span class="built_in">width</span>)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = blockIdx.x * blockDim.x + threadIdx.x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> idy = blockIdx.y * blockDim.y + threadIdy.y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(idx &lt; <span class="built_in">width</span> &amp;&amp; idy &lt; <span class="built_in">height</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">        uchar3 rgbImg = input[idy*<span class="built_in">width</span>+idx];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">        output[idy*<span class="built_in">width</span>+idx]=<span class="number">0.299f</span> * rgb.x + <span class="number">0.587f</span> * rgb.y + <span class="number">0.114f</span> * rgb.z;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">clock_t</span> start, <span class="built_in">end</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">    Mat srcImg = imread(imagePath);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> imgHeight = srcImg.rows;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> imgWidth = srcImg.cols;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">    Mat grayImg = zeros(imgHeight, imgWidth, CV_8UC1, Scalar(<span class="number">0</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">    start = clock();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//在CPU上进行图像灰度转化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line">    grayImg = cpuConvertGray(srcImg, imgHeight, imgWidth);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">end</span> = clock();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"Cpu exec time is %.8f\n"</span>, (<span class="keyword">double</span>)(<span class="built_in">end</span>-start)/CLOCKS_PER_SEC);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">54</span></pre></td><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">55</span></pre></td><td class="code"><pre><span class="line">    Mat outImg = zeros(imgHeight, imgWidth, CV_8UC1, Scalar(<span class="number">0</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">56</span></pre></td><td class="code"><pre><span class="line">    uchar3* input;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">57</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* output;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">58</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">59</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//使用opencv转化</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">60</span></pre></td><td class="code"><pre><span class="line">    start = clock();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">61</span></pre></td><td class="code"><pre><span class="line">    grayImg = openCvtGray(srcImg);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">62</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">end</span> = clock();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">63</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"OpenCV exec time is %.8f\n"</span>, (<span class="keyword">double</span>)(<span class="built_in">end</span>-start)/CLOCKS_PER_SEC);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">64</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">65</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//在GPU上分配内存</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">66</span></pre></td><td class="code"><pre><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;input, <span class="built_in">height</span>*<span class="built_in">width</span>*<span class="keyword">sizeof</span>(uchar3));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">67</span></pre></td><td class="code"><pre><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;output, <span class="built_in">height</span>*<span class="built_in">width</span>*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">68</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//将图像数据从host拷贝到gpu上</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">69</span></pre></td><td class="code"><pre><span class="line">    cudaMemcpy(input, src.data, <span class="built_in">height</span>*<span class="built_in">width</span>*<span class="keyword">sizeof</span>(uchar3), cudaMemcpyHostToDevice);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">70</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">71</span></pre></td><td class="code"><pre><span class="line">    <span class="function">dim3 <span class="title">threadsPerBlock</span><span class="params">(<span class="number">32</span>, <span class="number">32</span>)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">72</span></pre></td><td class="code"><pre><span class="line">    <span class="function">dim3 <span class="title">blocksPerGrid</span><span class="params">((imgWidth+threadsPerBlock.x<span class="number">-1</span>) / threadsPerBlock.x, \</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">73</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                       (imgHeight+threadsPerBlock.y<span class="number">-1</span>) / threadsPerBlock.y)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">74</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">75</span></pre></td><td class="code"><pre><span class="line">    start = clock();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">76</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">77</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//启动内核</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">78</span></pre></td><td class="code"><pre><span class="line">    gpuConvertGray&lt;&lt;&lt;blocksPerGrid, threadsPerBlock&gt;&gt;&gt;(input, output, imgHeight, imgWidth);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">79</span></pre></td><td class="code"><pre><span class="line">    <span class="comment">//执行一个内核是一个异步操作，因此需要同步统计时间</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">80</span></pre></td><td class="code"><pre><span class="line">    cudaDeviceSynchronize();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">81</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">end</span> = clock();</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">82</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">83</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"Cuda exec time is %.8f\n"</span>, (<span class="keyword">double</span>)(<span class="built_in">end</span>-start)/CLOCKS_PER_SEC);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">84</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">85</span></pre></td><td class="code"><pre><span class="line">    cudaMemcpy(grayImg.data, output, imgHeight*imgWidth*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>), cudaMemcpyDeviceToHost);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">86</span></pre></td><td class="code"><pre><span class="line">    cudaFree(input);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">87</span></pre></td><td class="code"><pre><span class="line">	cudaFree(output);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">88</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">89</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">90</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>6、<strong>NVCC编译器编译CUDA程序</strong></p>
<p>NVCC提供了简单方便的接口，能够很好的同时处理主机端和设备端代码。</p>
<ul>
<li><p>离线编译</p>
<p><em>分离CUDA程序中的主机端代码(host code)和设备端代码(device code)</em>  将设备端代码编译成一种虚拟汇编文件(名为PTX)，再接着编译成二进制代码(名为cubin) ，将主机端代码中含有”&lt;&lt;&lt;&gt;&gt;&gt;”的代码(即内核调用)替换为CUDA运行库中的函数调用代码。之后NVCC会借助其他编译器(如gcc)将主机端代码编译出来，主机端代码和设备端代码被编译好后，nvcc会将两段代码链接起来。</p>
</li>
<li><p>在线编译</p>
<p>PTX是一个虚拟汇编文件。其形式虽然很像汇编，但里面的每一条指令实际上是一个虚拟的指令，与机器码无法对应。需要编译器或设备驱动程序将其翻译成对应平台的汇编/机器码才能运行。</p>
<p>如果在编译过程中，NVCC不将设备端代码编译为cubin文件，即二进制代码，而是停在PTX代码上。设备驱动(device  driver)会负责在运行时，使用PTX代码生成二进制代码。这个过程被称作在线编译(JIT Compilation, Just-In-Time  Compilation)。</p>
<p>在线编译必然会使得程序启动的时间延长，不过设备驱动程序会自动缓存编译出来的二进制代码(也被称作compute cache)。</p>
</li>
</ul>
<p>7、<strong>CUDA C运行库</strong></p>
<p>7.1 初始化：CUDA运行库没有显式的初始化函数，在调用第一个函数时会自动初始化(设备和版本管理函数不行)。初始化时，会产生一个全局可见的设备上下文(device context)。主机端代码调用了<code>cudaDeviceReset()</code>函数，则会销毁掉这个上下文。注意，销毁的上下文是主机端正在操纵的设备。如要更换，需要使用<code>cudaSetDevice()</code>来进行切换。</p>
<p>7.2 设备内存：</p>
<p>CUDA运行库提供了函数以分配/释放设备端的内存(全局内存+常量内存+纹理内存)，以及与主机端内存传输数据。</p>
<ul>
<li><p>线性存储(linear memory)：在GPU上用40位的地址线寻址</p>
<p>线性内存可以用<code>cudaMalloc()</code>分配，用<code>cudaFree()</code>释放，用<code>cudaMemcpy()</code>复制数据，用<code>cudaMemset()</code>赋值。</p>
<p>对于2D或3D数组，可以使用<code>cudaMallocPitch()</code>和<code>cudaMalloc3D()</code>来分配内存。这两个函数会自动padding，以满足内存对齐的要求，提高内存读写效率。</p>
</li>
<li><p>CUDA arrays—与纹理内存有关</p>
</li>
</ul>
<p>在设备内存中定义全局变量，则需要使用使用<code>__constant__</code>或<code>__device__</code>来修饰，并使用<code>cudaMemcpyToSymbol()</code>和<code>cudaMemcpyFromSymbol()</code>来读写。</p>
<p>实际上，当使用<code>__constant__</code>关键字时，是申请了一块常量内存；而使用<code>__device__</code>时，是普通的全局内存。因此<code>__device__</code>申请的内存需要申请，而<code>__constant__</code>不用。不管是全局内存，还是常量内存，需要用带有<code>Symbol</code>的函数拷贝。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">__constant__ <span class="keyword">float</span> constData[<span class="number">256</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> data[<span class="number">256</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">cudaMemcpyToSymbol(&amp;constData, data, <span class="keyword">sizeof</span>(data));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">cudaMemcpyFromSymbol(&amp;data, constData, <span class="keyword">sizeof</span>(data));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">__device__ <span class="keyword">float</span> devData;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> value = <span class="number">3.14f</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">cudaMemcpyToSymbol(devData, &amp;value, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">__device__ <span class="keyword">float</span>* devPtr;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span>* ptr;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">cudaMalloc(&amp;ptr, <span class="number">256</span>*<span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">cudaMemcpyToSymbol(devPtr, &amp;ptr, <span class="keyword">sizeof</span>(ptr));</span></pre></td></tr></table></figure>
<p>8、<strong>共享内存</strong></p>
<p>不管是全局变量还是局部变量，都需要使用<code>__shared__</code>来修饰。不过需要注意的是，即使定义为全局变量，共享内存依旧只能被同一线程块内的线程可见。但是注意，并不是什么时候都可以使用共享内存来获取加速的。例如内核函数计算出来结果后，如果这个结果只需要传输回主机端，而不需要再次被用到时，直接写回全局内存会比较快。如果先写回共享内存，再写回全局内存，反而会比较缓慢。一般来讲，当需要频繁读写，或是有原子操作时，使用共享内存替代全局内存，会取得比较大的增益。</p>
<p><strong>共享内存只能为线程块内的线程共享。如果需要整个线程网格中线程都能访问，则需要全局内存或常量内存。</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//直方图统计</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">__shared__ <span class="keyword">unsigned</span> <span class="keyword">char</span> hist_shared[<span class="number">256</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">getGrayHistByCudaUsingSharedMem</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> * <span class="keyword">const</span> grayData,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                                               <span class="keyword">unsigned</span> <span class="keyword">int</span> * <span class="keyword">const</span> hist,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                                               uint imgheight,</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="params">                                               uint imgwidth)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>9、<strong>锁页内存</strong></p>
<p>锁页内存指的是主机端上不会被换出到虚拟内存(位于硬盘)上的内存。</p>
<p>锁页内存的分配与释放：在CUDA程序中，使用<code>cudaHostAlloc()</code>，可以分配锁页内存，使用<code>cudaFreeHost()</code>来释放锁页内存，或者使用<code>cudaHostRegister()</code>来将<code>malloc()</code>分配的内存指定为锁页内存。</p>
<p>10、<strong>合并写内存(Write-Combining Memory)</strong></p>
<p>11、<strong>异步并行执行</strong></p>
<ul>
<li><p>主机端/设备端并行：</p>
<ul>
<li>内核启动与执行</li>
<li>设备端内部传输数据</li>
<li>使用流或内存映射传输数据</li>
<li>设备端memset函数cudaMemset())</li>
</ul>
</li>
<li><p>内核并行执行</p>
<ul>
<li>计算能力2.x及以上的设备，支持多个内核函数同时执行。</li>
<li>执行多个内核函数，需要主机端不同的线程启动。如果一个线程依次启动多个内核，则这些内核会串行执行。同一线程的内核函数返回时会触发隐式的同步。</li>
<li>多个内核函数必须位于同一个CUDA上下文(CUDA context)上。不同CUDA上下文上的内核不能并行。</li>
</ul>
</li>
<li><p>数据传输和内核执行并行(需要使用锁页内存)</p>
<ul>
<li>一些设备支持数据传输(主机端/设备端、设备端/设备端)和内核执行并行，可通过检查<code>asyncEngineCount</code>来确认。</li>
</ul>
</li>
<li><p>数据传入核传出并行</p>
</li>
<li><p>流(stream)</p>
<p>可以通过<code>cudaStreamCreateWithPriority()</code>来在创建流时指定流的优先级。可以指定的优先级可由<code>cudaDeviceGetStreamPriorityRange()</code>来获得。</p>
<p>运行时，高优先级stream中的线程块不能打断正在执行的低优先级stream的线程块(即不是抢占式的)。但是当低优先级stream的线程块退出SM时，高优先级stream中的线程块会被优先调度进SM。</p>
<ul>
<li>在CUDA中，流(streams)指的是在GPU上一连串执行的命令。</li>
<li>不同的线程，可以向同一个流填入任务。</li>
<li>同一个流内的任务会按顺序执行。</li>
<li>同一设备上不同的流有可能并行，其执行顺序不会有保证。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//流的创建和销毁</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">cudaStream_t stream[<span class="number">2</span>];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    cudaStreamCreate(&amp;stream[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    cudaStreamDestroy(stream[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//当设备还在执行流中的任务，而用户调用cudaStreamDestroy()函数时，函数会立刻执行(不会阻塞)。之后，当流中的任务完成后，与流相关的资源会自动释放。</span></span></pre></td></tr></table></figure>
<p>12、<strong>显示同步(Explicit Synchronization)</strong></p>
<p><strong>cudaDeviceSynchronize():</strong>  直到<strong>所有线程</strong>向设备端的<strong>所有流</strong>的<strong>所有已送入指令</strong>完成，才会退出阻塞。</p>
<p><strong>cudaStreamSynchronize():</strong> 直到<strong>指定流</strong>的<strong>之前所有已送入指令</strong>完成，才会退出阻塞。</p>
<p><strong>cudaStreamWaitEvent():</strong> 需要stream和event作为输入参数。需要等待该函数等待的事件(Event)发生后，才能执行。</p>
<p>13、<strong>隐式同步(Implicit Synchronization)</strong></p>
<p>一般来讲，不同流内的命令可以并行。但是当任何一个流执行如下的命令时，情况例外，不能并行：</p>
<ul>
<li>锁页内存的分配</li>
<li>设备端内存分配  </li>
<li>设备端内存设置(memset) </li>
<li>设备内部拷贝 </li>
<li>NULL stream内的命令</li>
<li>L1 cache/共享内存空间的重新分配</li>
</ul>
<p>14、<strong>回调函数</strong></p>
<p>可以使用<code>cudaStreamAddCallback()</code>函数，向流中添加callback。该callback会在流中之前所有的任务完成后被调用。如果stream参数设为0，则代表之前的所有stream的任务执行完后就调用该callback。</p>
<p>回调函数和<code>cudaStreamWaitEvent()</code>一样，对于在加在callback之后的指令，必须等待callback<em>执行完成</em>后，才会继续执行。</p>
<p>回调函数中不能直接或间接的执行CUDA函数，否则会因为等待自己完成而造成死锁。</p>
<p>15、<strong>事件(Event)</strong></p>
<p>事件(Event)可以被压入流中以监视流的运行情况，或者用于精确计时。如果向stream 0压入事件，则当压入事件前向所有流压入的任务完成后，事件才被触发。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">cudaEvent_t start, <span class="built_in">stop</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line">cudaEventCreate(&amp;start);   <span class="comment">//创建</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">cudaEventCreate(&amp;<span class="built_in">stop</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">cudaEventDestroy(start);    <span class="comment">//销毁</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">cudaEventDestroy(<span class="built_in">stop</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//计算时间</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">cudaEventRecord(start, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line">    cudaMemcpyAsync(inputDev + i * <span class="built_in">size</span>, inputHost + i * <span class="built_in">size</span>, <span class="built_in">size</span>, cudaMemcpyHostToDevice, stream[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line">    MyKernel&lt;&lt;&lt;<span class="number">100</span>, <span class="number">512</span>, <span class="number">0</span>, stream[i]&gt;&gt;&gt;(outputDev + i * <span class="built_in">size</span>, inputDev + i * <span class="built_in">size</span>, <span class="built_in">size</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    cudaMemcpyAsync(outputHost + i * <span class="built_in">size</span>, outputDev + i * <span class="built_in">size</span>, <span class="built_in">size</span>, cudaMemcpyDeviceToHost, stream[i]);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">cudaEventRecord(<span class="built_in">stop</span>, <span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">cudaEventSynchronize(<span class="built_in">stop</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> elapsedTime;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">cudaEventElapsedTime(&amp;elapsedTime, start, <span class="built_in">stop</span>);</span></pre></td></tr></table></figure>
<p>16、<strong>多设备系统</strong></p>
<ul>
<li>设备枚举</li>
<li>设备选择</li>
<li>流和事件的执行情况<ul>
<li><strong>内核启动</strong>：如果将内核压入不属于当前设备的流中，则内核会启动失败。也就是说，如果要向一个流中压入内核，必须先切换到流所在的设备。</li>
<li><strong>内存拷贝</strong>：如果对一个不属于当前设备的流进行内存拷贝工作，内存拷贝会成功。</li>
<li><strong>cudaEventRecord()</strong>：必须现将设备上下文切换过去，再向流压入事件。</li>
<li><strong>cudaEventElapsedTime()</strong>：计算时间差前，必须先切换设备。</li>
<li><strong>cudaEventSynchronize() and cudaEventQuery()</strong>：即使处于不同的设备，事件同步和事件查询依然有效。</li>
<li><strong>cudaStreamWaitEvent()</strong>：比较特殊，即使函数输入的流和事件不在同一个设备上，也能成功执行。也就是说，可以让流等待另一个设备上(当然当前设备也可以)的事件。这个函数可以用作多个设备间的同步。</li>
</ul>
</li>
<li>内存的访问</li>
<li>(设备间)对等内存访问：计算能力2.0及以上的设备支持设备间对等内存访问，这意味着两个GPU之间的传输和访问可以不经过主机端中转，速度会有提升。</li>
<li>(设备间)对等内存访问：对等设备的地址是统一编址的，可以使用<code>cudaMemcpyPeer()、cudaMemcpyPeerAsync()、cudaMemcpy3DPeer、cudaMemcpy3DPeerAsync()</code>来进行直接拷贝。无需先拷贝会主机端内存，再转到另一块卡上。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//设备枚举</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> deviceCount;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">cudaGetDeviceCount(&amp;deviceCount);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> device;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(device=<span class="number">0</span>; device&lt;deviceCount; device++)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    cudaDeviceProp deviceProp;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    cudaGetDeviceProperties(&amp;deviceProp, device);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"Device %d has compute capability %d.%d.\n"</span>, device, deviceProp.major, deviceProp.minor);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//设备选择</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用cudaSetDevice()选择设备，当不选择时，默认使用设备0。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意，所有的内存分配、内核函数启动、流和事件的创建等，都是针对当前选择的设备的。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="built_in">size</span> = <span class="number">1024</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">cudaSetDevice(<span class="number">0</span>);   <span class="comment">// Set device 0 as current</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span>* p0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">cudaMalloc(&amp;p0, <span class="built_in">size</span>);  <span class="comment">// Allocate memory on device 0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">MyKernel&lt;&lt;&lt;<span class="number">1000</span>, <span class="number">128</span>&gt;&gt;&gt;(p0);    <span class="comment">// Launch kernel on device 0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">cudaSetDevice(<span class="number">1</span>);   <span class="comment">// Set device 1 as current</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span>* p1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">cudaMalloc(&amp;p1, <span class="built_in">size</span>);  <span class="comment">// Allocate memory on device 1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">MyKernel&lt;&lt;&lt;<span class="number">1000</span>, <span class="number">128</span>&gt;&gt;&gt;(p1); <span class="comment">// Launch kernel on device 1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//设备间，对等内存拷贝</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">cudaSetDevice(<span class="number">0</span>);   <span class="comment">// Set device 0 as current</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span>* p0;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="built_in">size</span> = <span class="number">1024</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">cudaMalloc(&amp;p0, <span class="built_in">size</span>);  <span class="comment">// Allocate memory on device 0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">cudaSetDevice(<span class="number">1</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span>* p1;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">cudaMalloc(&amp;p1, <span class="built_in">size</span>);  <span class="comment">// Allocate memory on device 1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">cudaSetDevice(<span class="number">0</span>);       <span class="comment">// Set Device 0 as Current</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">MyKernel&lt;&lt;&lt;<span class="number">1000</span>, <span class="number">128</span>&gt;&gt;&gt;(p0);    <span class="comment">// Launch Kernel on Device 0</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">cudaSetDevice(<span class="number">1</span>);               <span class="comment">// Set Device 1 as Current</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">cudaMemcpyPeer(p1, <span class="number">1</span>, p0, <span class="number">0</span>, <span class="built_in">size</span>); <span class="comment">// Copy p0 to p1</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">MyKernel&lt;&lt;&lt;<span class="number">1000</span>, <span class="number">128</span>&gt;&gt;&gt;(p1);        <span class="comment">// Launch Kernel on Device 1</span></span></pre></td></tr></table></figure>
<p>如果使用的是NULL stream，如果拷贝的双方中的任何一方，在设备拷贝前有任务未完成，则拷贝会被阻塞，直至任务完成。*  只有拷贝结束后，两者的后续任务才能继续执行。</p>
<h4 id="二、性能优化"><a href="#二、性能优化" class="headerlink" title="二、性能优化"></a>二、性能优化</h4><p>性能优化的原则：</p>
<ol>
<li>最大化并行，以提升资源利用率</li>
<li>优化内存排布，以最大化内存吞吐</li>
<li>最大化指令吞吐</li>
</ol>
<p>性能分析工具：CUDA profiler</p>
<p><strong>应用级别并行</strong>： 尽可能让主机端、设备端、PCI-E总线并行工作。对此可以使用异步CUDA函数，以及流(Stream)来实现。</p>
<p>同步操作，以及内存的共享会影响程序的并行性。因此需要仔细设计算法流程，尽量减少同步和内存共享。</p>
<p><strong>设备级别同步：</strong>可以通过流的方式，尽可能的让多个内核并行，提升利用率。</p>
<p><strong>处理器级别并行：</strong>延迟(latency)指的是线程束(从上一个动作开始)到它处于ready状态的时钟数。 例如线程束先提交了一个内存访问请求，然后等了400个时钟周期，内存管理系统才返回数据，线程束可以继续执行。这400个时钟周期称为延迟。</p>
<p>当一个线程束发生延迟时，线程束调度器(warp  scheduler)会将其他处于ready状态的线程束调度到SP上。等到延迟结束后，再将该线程调度回SP继续执行。这样一来，前一个线程束的延迟，就被另一个线程束的执行所隐藏了。 这一过程被称作延迟的隐藏(hidden latency)。  </p>
<p>隐藏延迟是GPU编程的核心概念。由于GPU具有巨大的寄存器空间，线程的切换不存在损耗。因此，通过向GPU上分配足够多的线程，可以让这些线程延迟互相交错，以起到隐藏延迟的作用，提高硬件利用率。</p>
<p><strong>最大化内存吞吐：</strong>主要手段就是少用低带宽的内存。首先要尽可能减少主机端和设备端间的设备传输(PCI-E，特别慢)，其次要尽可能减少全局内存的读写(快于PCI-E，但是相对于片内内存来说，还是挺慢的)；尽可能的使用片内的内存(寄存器、cache、共享内存)。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/03/CUDA-Programmer-Learn-Zero/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qiang Chen">
      <meta itemprop="description" content="记录是忘记的第一助手.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="编辑尼撑">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/03/CUDA-Programmer-Learn-Zero/" class="post-title-link" itemprop="url">CUDA-Programmer-Learn-Zero</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-03 23:14:11 / 修改时间：23:16:39" itemprop="dateCreated datePublished" datetime="2021-07-03T23:14:11+08:00">2021-07-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/CUDA-Programmer/" itemprop="url" rel="index">
                    <span itemprop="name">CUDA Programmer</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="CUDA编程学习笔记"><a href="#CUDA编程学习笔记" class="headerlink" title="CUDA编程学习笔记"></a>CUDA编程学习笔记</h2><h4 id="一、CUDA编程模式的基本概念"><a href="#一、CUDA编程模式的基本概念" class="headerlink" title="一、CUDA编程模式的基本概念"></a>一、CUDA编程模式的基本概念</h4><p>CUDA是一种通用的异构并行计算平台和编程模型，你可以利用CUDA平台像在CPU上那样使用GPU来进行计算。</p>
<p>一般的CUDA(.cu)程序的执行步骤为：</p>
<ol>
<li>分配GPU显存</li>
<li>将待处理的数据从HOST内存拷贝到GPU的显存</li>
<li>调用核函数对存储在GPU显存中的数据进行处理</li>
<li>将结果从GPU显存拷贝到HOST内存</li>
<li>释放GPU显存</li>
</ol>
<h4 id="二、CUDA编程模式的两大重点"><a href="#二、CUDA编程模式的两大重点" class="headerlink" title="二、CUDA编程模式的两大重点"></a>二、CUDA编程模式的两大重点</h4><ol>
<li><p>通过层次结构来组织线程</p>
<p>1.1 线程的管理：<strong>线程网格(Grid)、线程块(Block)、线程束(Warp)和线程(Thread)</strong></p>
<p>1.2 一个内核启动所生成的所有线程称为一个网格，同一网格内的所有线程共享同一块全局内存空间。一个网格有多个线程块构成。一个线程块由一组线程构成</p>
<p>1.3 优势：合理的利用资源，优化性能</p>
</li>
<li><p>通过层次结构来组织内存</p>
<p>2.1 GPU的各级缓存和显存是可以通过程序进行控制的。具体有寄存器、共享内存、常量内存和全局内存等</p>
<p>2.2 <strong>寄存器</strong>是GPU上运行速度最快的内存空间，带宽通常为8TB/s,延时为一个时钟周期。<strong>共享内存</strong>是GPU上可受用户控制的一级缓存，带宽通常为1.5TB/s,延迟为1~32个时钟周期。<strong>全局内存</strong>是GPU中最大的，延迟最高且最常被使用的内存。</p>
<p><img src="/2021/07/03/CUDA-Programmer-Learn-Zero/1.jpg" alt="Cuda-memory-struct"></p>
</li>
</ol>
<h5 id="三、矩阵运算"><a href="#三、矩阵运算" class="headerlink" title="三、矩阵运算"></a>三、矩阵运算</h5><p>1、矩阵索引：在一个二维矩阵加法的核函数中，一个线程通常被分配一个数据元素来处理。首先要完成的任务是如何使用块和线程索引从全局内存中访问指定的数据。</p>
<p><strong>如何映射线程的Id到图像矩阵的坐标上？</strong></p>
<p>可以使用如下的公式将线程网格和线程块的索引映射到矩阵坐标上,称为坐标索引。</p>
<script type="math/tex; mode=display">
ix = blockIdx.x * blockDim.x + threadIdx.x \\
iy = blockIdx.y * blockDim.y + threadIdx.y</script><p>可以使用如下公式将矩阵坐标映射到全局内存的索引/存储单元上，称为全局索引(因为数据在内存的存储往往是一维的，需要地址映射)。</p>
<script type="math/tex; mode=display">
idx = iy*nx + ix,\quad nx表示x维度上元素的个数</script><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">sumMatUsingGPU</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* A, <span class="keyword">unsigned</span> <span class="keyword">char</span>* B, <span class="keyword">unsigned</span> <span class="keyword">char</span>* C, uint <span class="built_in">height</span>, uint <span class="built_in">width</span>)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ix = blockIdx.x * blockDim.x + threadIdx.x;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> iy = blockIdy.y * blockDim.y + threadIdy.y;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = iy * <span class="built_in">width</span> + ix;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">if</span>(ix &lt; <span class="built_in">width</span> &amp;&amp; iy &lt; <span class="built_in">height</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line">        C[idx] = A[idx] + B[idx];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">    uint <span class="built_in">height</span> = <span class="number">5</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">    uint <span class="built_in">width</span> = <span class="number">20</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> byteSize = <span class="built_in">height</span> * <span class="built_in">width</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> nBytes = byteSize * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">float</span> *h_A, *h_B, *h_C;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">    h_A = (<span class="keyword">float</span> *)<span class="built_in">malloc</span>(nBytes);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">    h_B = (<span class="keyword">float</span> *)<span class="built_in">malloc</span>(nBytes);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">    h_C = (<span class="keyword">float</span> *)<span class="built_in">malloc</span>(nBytes);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* A, *B, *C;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    cudaMalloc(&amp;A, byteSize*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">    cudaMalloc(&amp;B, byteSize*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    cudaMalloc(&amp;C, byteSize*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">    cudaMemcpy(A, h_A, nBytes, cudaMemcpyHostToDeviec);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    cudaMemcpy(B, h_B, nBytes, cudaMemcpyHostToDeviec);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    cudaMemcpy(C, h_C, nBytes, cudaMemcpyHostToDeviec);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">    <span class="function">dim3 <span class="title">thread</span><span class="params">(<span class="built_in">height</span>/<span class="number">5</span>,<span class="built_in">width</span>/<span class="number">5</span>)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    <span class="function">dim3 <span class="title">block</span><span class="params">(<span class="built_in">height</span>, <span class="built_in">width</span>)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    sumMatUsingGPU&lt;&lt;&lt;block, thread&gt;&gt;&gt;(A, B, C, <span class="built_in">height</span>, <span class="built_in">width</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    cudaMemcpy(h_c, d_c, nBytes, cudaMemcpyDeviceToHost);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    cudaFree(A);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">    cudaFree(B);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">    cudaFree(C);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line">nvcc -arch=sm_20 sumOnGPU.cu -o sumOnGPU</span></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>限定符</th>
<th>执行</th>
<th>调用</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__global__</code></td>
<td>在设备端执行</td>
<td>可从主机、设备端调用</td>
<td>必须有一个void返回类型</td>
</tr>
<tr>
<td><code>__device__</code></td>
<td>在设备端执行</td>
<td>仅能从设备端调用</td>
<td></td>
</tr>
<tr>
<td><code>__host__</code></td>
<td>在主机端执行</td>
<td>仅能从主机端上调用</td>
<td>可以省略不写</td>
</tr>
</tbody>
</table>
</div>
<h4 id="四、如何提升并行能力"><a href="#四、如何提升并行能力" class="headerlink" title="四、如何提升并行能力"></a>四、如何提升并行能力</h4><ul>
<li>降低延迟，延迟是指操作从开始到结束所需要的时间，一般用微秒计算，延迟越低越好。</li>
<li>提高带宽，带宽是单位时间内处理的数据量，一般用MB/s或者GB/s表示。</li>
<li>提高吞吐量，吞吐量是单位时间内成功处理的运算数量，一般用gflops来表示（十亿次浮点计算），吞吐量和延迟有一定关系，都是反应计算速度的，<strong>一个是时间除以运算次数，得到的是单位次数用的时间–延迟，一个是运算次数除以时间，得到的是单位时间执行次数–吞吐量。</strong></li>
</ul>
<h4 id="五、计算机架构"><a href="#五、计算机架构" class="headerlink" title="五、计算机架构"></a>五、计算机架构</h4><p>划分不同计算机结构的方法有很多，广泛使用的一种被称为佛林分类法Flynn’s Taxonomy，<strong>根据指令和数据进入CPU的方式分类</strong>，分为以下四类：</p>
<ol>
<li>单指令单数据SISD（传统串行计算机，386）</li>
<li>单指令多数据SIMD（并行架构，比如向量机，所有核心指令唯一，但是数据不同，现在CPU基本都有这类的向量指令）</li>
<li>多指令单数据MISD（少见，多个指令围殴一个数据）</li>
<li>多指令多数据MIMD（并行架构，多核心，多指令，异步处理多个数据流，从而实现空间上的并行，MIMD多数情况下包含SIMD，就是MIMD有很多计算核，计算核支持SIMD）</li>
</ol>
<p><strong>根据内存划分</strong>，分为以下两类：</p>
<ol>
<li><p>分布式内存的多节点系统</p>
<p>通常叫做集群，就是一个机房好多机箱，每个机箱都有内存处理器电源等一些列硬件，通过网络互动，这样组成的就是分布式。</p>
</li>
<li><p>共享内存的多处理器系统</p>
<p>单个主板有多个处理器，他们共享相同的主板上的内存，内存寻址空间相同，通过PCIe和内存互动。</p>
<p><strong>多个处理器可以分多片处理器，和单片多核（众核many-core）</strong>，也就是有些主板上挂了好多片处理器，也有的是一个主板上就一个处理器，但是这个处理器里面有几百个核。<strong>GPU就属于众核系统</strong></p>
</li>
</ol>
<ul>
<li>CPU适合执行复杂的逻辑，比如多分支，其核心比较重（复杂）</li>
<li>GPU适合执行简单的逻辑，大量的数据计算，其吞吐量更高，但是核心比较轻（结构简单）</li>
</ul>
<h4 id="六、异构架构"><a href="#六、异构架构" class="headerlink" title="六、异构架构"></a>六、异构架构</h4><p>拥有不同计算机架构体系的硬件相互配合完成高吞吐量工作的系统。例如：CPU我们可以把它看做一个指挥者，主机端，host，而完成大量计算的GPU是我们的计算设备，device。下图来之谭升的知乎</p>
<p><img src="/2021/07/03/CUDA-Programmer-Learn-Zero/2.png" alt="Cuda-memory-struct"></p>
<ul>
<li>左图：一个四核CPU一般有四个ALU，ALU是完成逻辑计算的核心，也是我们平时说四核八核的核，控制单元，缓存也在片上，DRAM是内存，一般不在片上，CPU通过总线访问内存。</li>
<li>右图：GPU，绿色小方块是ALU，我们注意红色框内的部分SM，这一组ALU公用一个Control单元和Cache，<strong>这个部分相当于一个完整的多核CPU</strong>，但是<strong>不同的是ALU多了，control部分变小，可见计算能力提升了，控制能力减弱了，</strong>所以对于控制（逻辑）复杂的程序，一个GPU的SM是没办法和CPU比较的，但是对了逻辑简单，数据量大的任务，GPU更高效。注意，一个GPU有好多个SM，而且越来越多。</li>
</ul>
<p>CPU和GPU之间通过PCIe总线连接，用于传递指令和数据，这部分也是后面要讨论的性能瓶颈之一。</p>
<p>一个异构应用包含两种以上架构，所以分为主机端代码和设备端代码。主机代码在主机端运行，被<strong>编译成主机架构的机器码</strong>，设备端的在设备上执行，<strong>被编译成设备架构的机器码</strong>，所以主机端的机器码和设备端的机器码是隔离的，自己执行自己的，没办法交换执行。</p>
<p>主机端代码主要是<strong>控制设备，完成数据传输等控制类工作</strong>，设备端主要的任务就是<strong>计算</strong>。</p>
<p>NVIDIA目前有多种计算平台，每个平太针对不同的应用场景，比如Tegra用于嵌入式，Geforce是我们平时打游戏用到，Tesla主要用于计算。</p>
<p>衡量GPU计算能力的主要靠下面两种<strong>容量特征</strong>：<strong>CUDA核心数和内存大小</strong>。<strong>计算能力的性能指标</strong>：<strong>峰值计算能力和内存带宽</strong>。下图来之谭升的知乎</p>
<p><img src="/2021/07/03/CUDA-Programmer-Learn-Zero/3.png" alt="Cuda-memory-struct"></p>
<p>CPU和GPU线程的区别：</p>
<ol>
<li>CPU线程是重量级实体，操作系统交替执行线程，线程上下文切换花销很大。</li>
<li>GPU线程是轻量级的，GPU应用一般包含成千上万的线程，多数在排队状态，线程之间切换基本没有开销。</li>
<li>CPU的核被设计用来尽可能减少一个或两个线程运行时间的延迟，而GPU核则是大量线程，最大幅度提高吞吐量。</li>
</ol>
<p>CUDA nvcc编译器会自动分离你代码里面的不同部分，如图中主机代码用C写成，使用本地的C语言编译器编译，设备端代码，也就是核函数，用CUDA C编写，通过nvcc编译，链接阶段，在内核程序调用或者明显的GPU设备操作时，添加运行时库。</p>
<p>可以用到的工具：</p>
<ul>
<li>Nvidia Nsight集成开发环境</li>
<li>CUDA-GDB 命令行调试器</li>
<li>性能分析可视化工具</li>
<li>CUDA-MEMCHECK工具</li>
<li>GPU设备管理工具</li>
</ul>
<p><a href="https://face2ai.com/program-blog/#GPU%E7%BC%96%E7%A8%8B%EF%BC%88CUDA%EF%BC%89" target="_blank" rel="noopener">学习参考资料</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/346910129" target="_blank" rel="noopener">总结性资料</a></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

        
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block home" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2021/07/03/Principles-Of-Computer-Composition-Zero/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Qiang Chen">
      <meta itemprop="description" content="记录是忘记的第一助手.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="编辑尼撑">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          
            <a href="/2021/07/03/Principles-Of-Computer-Composition-Zero/" class="post-title-link" itemprop="url">Principles-Of-Computer-Composition-Zero</a>
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-07-03 23:06:30 / 修改时间：23:13:35" itemprop="dateCreated datePublished" datetime="2021-07-03T23:06:30+08:00">2021-07-03</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Principles-Of-Computer-Composition/" itemprop="url" rel="index">
                    <span itemprop="name">Principles-Of-Computer-Composition</span>
                  </a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="计算机组成原理部分知识学习笔记"><a href="#计算机组成原理部分知识学习笔记" class="headerlink" title="计算机组成原理部分知识学习笔记"></a>计算机组成原理部分知识学习笔记</h2><h4 id="一、线程绑定CPU核心的意义"><a href="#一、线程绑定CPU核心的意义" class="headerlink" title="一、线程绑定CPU核心的意义"></a>一、线程绑定CPU核心的意义</h4><p>在多核CPU中合理的调度线程在各个核上运行可以获得更高的性能。在多线程编程中，<strong>每个线程处理的任务优先级是不一样</strong>的，对于<strong>要求实时性比较高</strong>的线程或者是<strong>主线程</strong>，对于这种线程可以<strong>在创建线程时指定其绑定到某个CPU核</strong>上，以后这个核就专门处理该线程。这样可以使得该线程的任务可以得到较快的处理(<strong>因为减少了线程上下文在多核间切换时候的开销)</strong>，特别是和用户直接交互的任务，较短的响应时间可以提升用户的体验感。<br>原文链接：<a href="https://blog.csdn.net/weixin_42031299/article/details/114376419" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42031299/article/details/114376419</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE             <span class="comment">/* See feature_test_macros(7) */</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setaffinity_np</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">size_t</span> cpusetsize, <span class="keyword">const</span> <span class="keyword">cpu_set_t</span> *cpuset)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_getaffinity_np</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">size_t</span> cpusetssoize, <span class="keyword">cpu_set_t</span> *cpuset)</span></span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译和链接的时候需要在Makefile中添加 -pthread动态so库</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/bandaoyu/article/details/113700713</span></span></pre></td></tr></table></figure>
<h4 id="二、进程绑定CPU核心"><a href="#二、进程绑定CPU核心" class="headerlink" title="二、进程绑定CPU核心"></a>二、进程绑定CPU核心</h4><p>在Linux系统中，进程的调度切换是由内核自动完成的，在多核CPU上，进程有可能在不同的CPU核上来回切换执行，这对CPU的缓存不是很有利。</p>
<p><img src="/2021/07/03/Principles-Of-Computer-Composition-Zero/1.png" alt="CPU"></p>
<p>在多核CPU结构中，每个核心有各自的L1、L2缓存，而L3缓存是共用的。如果一个进程在核心间来回切换，各个<strong>核心的缓存命中率</strong>就会受到影响。相反如果进程不管如何调度，都始终可以在一个核心上执行，那么其数据的L1、L2 缓存的命中率可以显著提高。如下为绑定CPU的具体实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//1、使用 **CPU_**系列函数，必须定义 _GNU_SOURCE 宏，告诉编译器启用这些函数。</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//2、首先声明一个 cpu_set_t，然后用 CPU_ZERO()初始化bit数据：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//The cpu_set_t data type is implemented as a bitset. </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="keyword">cpu_set_t</span> mask;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//将cpu_set_t结构体清零，Clears set, so that it contains no CPUs. </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line">CPU_ZERO(&amp;mask);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//接下来把进程绑定到某几个CPU核心，这要用CPU_SET()来设置cpu_set_t中相应的bit位，比如想让进程只在核心1或核心5上执行：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line">CPU_SET(<span class="number">1</span>, &amp;mask); <span class="comment">//Add CPU cpu to set. </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//最后用sched_setaffinity完成实际的绑定：</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//sched_setaffinity(pid_t pid, unsigned int cpusetsize, cpu_set_t *mask) </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//该函数设置进程为pid的这个进程,让它运行在mask所设定的CPU上.如果pid的值为0,则表示指定的是当前进程,使当前进程运行在mask所设定的那些CPU上.第二个参数cpusetsize是mask所指定的数的长度.通常设定为sizeof(cpu_set_t).如果当前pid所指定的进程此时没有运行在mask所指定的任意一个CPU上,则该指定的进程会从其它CPU上迁移到mask的指定的一个CPU上运行. </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">cpu_set_t</span>), &amp;mask);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//sched_getaffinity获取绑定关系</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//Remove CPU cpu from set. </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">CPU_CLR()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//Test to see if CPU cpu is a member of set.  </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">CPU_ISSET()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//Return the number of CPUs in set.</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">CPU_COUNT()</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//The constant CPU_SETSIZE (currently 1024) specifies a value one greater than the maximum CPU number that can be stored in cpu_set_t. </span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">num = sysconf(_SC_NPROCESSORS_CONF);  <span class="comment">//获取核数</span></span></pre></td></tr></table></figure>
<p>举例：假定有一台双核机器，这段程序我们起了20个进程，从0开始每个进程分配一个进程号（注意是这里值我们自己起的进程号，不是进程pid），奇数进程号绑定绑定在 Core 0上执行，偶数号的进程绑定在 Core 1上执行。<br>链接：<a href="https://www.jianshu.com/p/f59d7df06432" target="_blank" rel="noopener">https://www.jianshu.com/p/f59d7df06432</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _GNU_SOURCE</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100000</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">11</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> core)</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">12</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">13</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">cpu_set_t</span> mask;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">14</span></pre></td><td class="code"><pre><span class="line">	CPU_ZERO(&amp;mask);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">15</span></pre></td><td class="code"><pre><span class="line">	CPU_SET(core, &amp;mask);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">16</span></pre></td><td class="code"><pre><span class="line">    设置亲和性</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">17</span></pre></td><td class="code"><pre><span class="line">	sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">cpu_set_t</span>), &amp;mask);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">18</span></pre></td><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">19</span></pre></td><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">20</span></pre></td><td class="code"><pre><span class="line">	gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">21</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">long</span> <span class="built_in">begin</span>=tv.tv_sec * <span class="number">1000</span> * <span class="number">1000</span> + tv.tv_usec;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">22</span></pre></td><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">23</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">int</span> i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">24</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> arr[N];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">25</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i != N; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">26</span></pre></td><td class="code"><pre><span class="line">        arr[i] = i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">27</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">28</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">29</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i != N; i++) &#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">30</span></pre></td><td class="code"><pre><span class="line">        sum += arr[i];</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">31</span></pre></td><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">32</span></pre></td><td class="code"><pre><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">33</span></pre></td><td class="code"><pre><span class="line">    <span class="keyword">long</span> <span class="built_in">end</span> = tv.tv_sec * <span class="number">1000</span> * <span class="number">1000</span>+ tv.tv_usec;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">34</span></pre></td><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>, <span class="built_in">end</span> - <span class="built_in">begin</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">35</span></pre></td><td class="code"><pre><span class="line">	<span class="comment">//for(int i=0; i&lt;2; i++)&#123;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">36</span></pre></td><td class="code"><pre><span class="line">	<span class="comment">//	printf("%d, %d\n",pid,sched_getcpu());</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">37</span></pre></td><td class="code"><pre><span class="line">	<span class="comment">//&#125;</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">38</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">39</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">40</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">41</span></pre></td><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">42</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">int</span> i;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">43</span></pre></td><td class="code"><pre><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">20</span>; ++i)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">44</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">pid_t</span> pid = fork(); <span class="comment">//fork函数</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">45</span></pre></td><td class="code"><pre><span class="line">		<span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">46</span></pre></td><td class="code"><pre><span class="line">			<span class="built_in">run</span>(i, i%<span class="number">2</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">47</span></pre></td><td class="code"><pre><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">48</span></pre></td><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">49</span></pre></td><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">50</span></pre></td><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">51</span></pre></td><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">52</span></pre></td><td class="code"><pre><span class="line"><span class="comment">//Makefile编译和链接</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">53</span></pre></td><td class="code"><pre><span class="line">g++ thread_bind_cpu.cpp -o thread_bind_cpu</span></pre></td></tr></table></figure>
<p>测试的部分结果，得出绑定对应的CPU对计算性能有一定的提升。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>次数</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>绑CPU核</td>
<td>849/us</td>
<td>838/us</td>
<td>835/us</td>
<td>818/us</td>
<td>834/us</td>
<td>819/us</td>
<td>838/us</td>
<td>819/us</td>
<td>841/us</td>
<td>823/us</td>
</tr>
<tr>
<td>不绑定核</td>
<td>868/us</td>
<td>903/us</td>
<td>943/us</td>
<td>918/us</td>
<td>954/us</td>
<td>981/us</td>
<td>985/us</td>
<td>987/us</td>
<td>1025/us</td>
<td>960/us</td>
</tr>
</tbody>
</table>
</div>
<p><a href="https://linux.die.net/man/3/cpu_set" target="_blank" rel="noopener">cpu_set_t的参考链接</a>  | <a href="https://linux.die.net/man/2/sched_setaffinity" target="_blank" rel="noopener">sched_setaffinity的参考链接</a>  </p>
<p><strong>Linux中的fork()函数</strong></p>
<p><strong>一个进程</strong>，<strong>包括代码、数据和分配给进程的资源</strong>。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事。一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。在<strong>fork函数执行完毕后</strong>，<strong>如果创建新进程成功</strong>，<strong>则出现两个进程，一个是子进程，一个是父进程</strong>。<strong>在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID</strong>。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。用大神的话说“其实就相当于链表，进程形成了链表，父进程的fpid(p 意味point)指向子进程的进程id, 因为子进程没有子进程，所以其fpid为0。</p>
<p>fork出错可能有两种原因：1、当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。2、系统内存不足，这时errno的值被设置为ENOMEM。</p>
<p>创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程<strong>执行没有固定的先后顺序</strong>，哪个进程先执行要看系统的进程调度策略。 <strong>每个进程都有一个独特（互不相同）的进程标识符（process ID），可以通过getpid（）函数获得</strong>，还有一个记录父进程pid的变量，可以通过getppid（）函数获得变量的值。</p>
<p><strong>注意：</strong> <strong>fork()不是从#include处开始复制代码的</strong>，这是因为fork是把进程当前的情况拷贝一份，执行fork时，进程已经执行完了int count=0;fork只拷贝下一个要执行的代码到新的进程。</p>
<p><a href="https://www.cnblogs.com/dongguolei/p/8086346.html" target="_blank" rel="noopener">原文链接</a></p>
<h4 id="三、对上面一、二的补充"><a href="#三、对上面一、二的补充" class="headerlink" title="三、对上面一、二的补充"></a>三、对上面一、二的补充</h4><p>1、查看绑定情况</p>
<p>查看进程的绑定核情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line">taskset -p pid</span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; pid xxx<span class="string">'s current affinity mask: 6 //6的二进制表示为110,则表示该pid在cpu1和cpu2上运行，从0开始计数</span></span></span></pre></td></tr></table></figure>
<p>2、程序启动时绑定</p>
<p>3、程序启动后绑定</p>
<p>4、查看cpu的核数</p>
<p>使用<code>cat /proc/cpuinfo</code>查看cpu信息: processor指明第几个cpu处理器，cpu cores指明每个处理器的核数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">2</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">3</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysconf</span><span class="params">(_SC_NPROCESSORS_CONF)</span></span>;<span class="comment">/* 返回系统可以使用的核数，但是其值会包括系统中禁用的核的数目，因 此该值并不代表当前系统中可用的核数 */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">4</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysconf</span><span class="params">(_SC_NPROCESSORS_ONLN)</span></span>;<span class="comment">/* 返回值真正的代表了系统当前可用的核数 */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">5</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">6</span></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 以下两个函数与上述类似 */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">7</span></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sysinfo.h&gt;</span></span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">8</span></pre></td><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="gutter"><pre><span class="line">9</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_nprocs_conf</span> <span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">/* 可用核数 */</span></span></pre></td></tr><tr><td class="gutter"><pre><span class="line">10</span></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_nprocs</span> <span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">/* 真正的反映了当前可用核数 */</span></span></pre></td></tr></table></figure>
<p>原文链接：<a href="https://blog.csdn.net/bandaoyu/article/details/113700713" target="_blank" rel="noopener">https://blog.csdn.net/bandaoyu/article/details/113700713</a></p>
<h4 id="四、简述Opaque-不透明类型"><a href="#四、简述Opaque-不透明类型" class="headerlink" title="四、简述Opaque(不透明类型)"></a>四、简述Opaque(不透明类型)</h4><p>在计算机科学中，<strong>不透明数据类型</strong>(opaque is a data type)是其具体<strong>数据结构未在接口中定义</strong>的数据类型。 这会<strong>强制隐藏信息</strong>，因为<strong>它的值</strong>只能<strong>通过调用有权访问</strong>缺失信息<strong>的子例程</strong>来操作。 类型的<strong>具体表示对其用户是隐藏的</strong>，<strong>可见的实现是不完整的</strong>。 <strong>如果</strong>表示可见的数据类型称为透明，<strong>否则</strong>称为不透明类型。 不透明数据类型经常用于实现抽象数据类型。 </p>
<p>不透明数据类型的<strong>典型示例</strong>包括操作系统向应用软件提供的资源句柄。 例如，线程的 POSIX 标准定义了一个基于许多不透明类型的应用程序编程接口，这些类型代表线程或同步原语，如<strong>互斥锁或条件变量</strong>。</p>
<p><a href="https://en.wikipedia.org/wiki/Opaque_data_type" target="_blank" rel="noopener">参考Wiki</a></p>
<h4 id="五、缓存相关学习笔记"><a href="#五、缓存相关学习笔记" class="headerlink" title="五、缓存相关学习笔记"></a>五、缓存相关学习笔记</h4><p>主要参考来自于<a href="https://www.cnblogs.com/ricks/p/12400900.html" target="_blank" rel="noopener">此</a></p>
<h5 id="1、基础知识："><a href="#1、基础知识：" class="headerlink" title="1、基础知识："></a>1、基础知识：</h5><p>现在的CPU多核技术，都会有几级缓存，老的CPU会有两级内存（L1和L2），新的CPU会有三级内存（L1，L2，L3 ），如下图所示：</p>
<p><img src="/2021/07/03/Principles-Of-Computer-Composition-Zero/2.png" alt="cache-architecture"></p>
<p>其中：</p>
<ul>
<li>L1缓分成两种，一种是指令缓存，一种是数据缓存。L2缓存和L3缓存不分指令和数据。</li>
<li>L1和L2缓存在每一个CPU核中，L3则是所有CPU核心共享的内存。</li>
<li>L1、L2、L3的越离CPU近就越小，速度也越快，越离CPU远，速度也越慢。</li>
</ul>
<p>再往后面就是内存，内存的后面就是硬盘，如下为各级的存取速度：</p>
<ul>
<li>L1 的存取速度：<strong>4 个CPU时钟周期</strong></li>
<li>L2 的存取速度： <strong>11 个CPU时钟周期</strong></li>
<li>L3 的存取速度：<strong>39 个CPU时钟周期</strong></li>
<li>RAM内存的存取速度<strong>：107 个CPU时钟周期</strong></li>
</ul>
<p>数据就从内存向上，先到L3，再到L2，再到L1，最后到寄存器进行CPU计算。为什么会设计成三层？这里有下面几个方面的考虑：</p>
<ul>
<li>一个方面是物理速度，如果要更大的容量就需要更多的晶体管，除了芯片的体积会变大，更重要的是大量的晶体管会导致速度下降，因为访问速度和要访问的晶体管所在的位置成反比，也就是当信号路径变长时，通信速度会变慢。这部分是物理问题。</li>
<li>另外一个问题是，多核技术中，数据的状态需要在多个CPU中进行同步，并且，我们可以看到，cache和RAM的速度差距太大，所以，多级不同尺寸的缓存有利于提高整体的性能。</li>
</ul>
<p>同时会产生两个比较重要的问题：</p>
<ul>
<li>一个是比较简单的缓存的命中率的问题。</li>
<li>另一个是比较复杂的缓存更新的一致性问题。</li>
</ul>
<h5 id="2、缓存命中-计算机组成原理"><a href="#2、缓存命中-计算机组成原理" class="headerlink" title="2、缓存命中(计算机组成原理)"></a>2、缓存命中(计算机组成原理)</h5><p>缓存基本上来说就是把后面的数据加载到离自己近的地方，对于CPU来说，它是不会一个字节一个字节的加载的，因为这非常没有效率，<strong>一般来说都是要一块一块的加载的</strong>，对于这样的一块一块的数据单位，术语叫<strong>“Cache Line”</strong>，一般来说，一个主流的CPU的Cache Line 是 64  Bytes（也有的CPU用32Bytes和128Bytes），64Bytes也就是16个32位的整型，这就是CPU从内存中捞数据上来的最小数据单位。</p>
<p><strong>比如：</strong>Cache Line是最小单位（64Bytes），所以先把Cache分成多个Cache Line，比如：L1有32KB，那么，32KB/64B = 512 个 Cache Line。</p>
<p>一方面，缓存需要把内存里的数据放到放进来，英文叫 <strong>CPU  Associativity</strong>。Cache的数据<strong>放置的策略</strong>决定了内存中的数据块会拷贝到CPU  Cache中的哪个位置上，因为Cache的大小远远小于内存，所以，需要有一种<strong>地址关联</strong>的算法，能够让内存中的数据可以被映射到Cache中来。</p>
<p>基本上来说，会有如下的一些方法：</p>
<ul>
<li>一种方法是，任何一个内存地址的数据可以被缓存在任何一个Cache Line里，这种方法是最灵活的，<strong>但是</strong>，如果我们要知道一个内存是否存在于Cache中，我们就需要进行O(n)复杂度的Cache遍历，这是很没有效率的。<strong>（全相联方式）</strong></li>
<li>另一种方法，为了降低缓存搜索算法，我们需要使用像Hash Table这样的数据结构，最简单的hash table就是做“求模运算”，比如：我们的L1 Cache有512个Cache Line，那么，公式：<code>（内存地址 mod 512）* 64</code> 就可以直接找到所在的Cache地址的偏移了。<strong>但是</strong>，这样的方式需要我们的程序对内存地址的访问要非常地平均，不然<strong>冲突就会非常严重</strong>。<strong>（直接相联方式）</strong></li>
<li>为了避免上述的两种方案的问题，于是就要容忍一定的hash冲突，也就出现了 <strong>N-Way 关联</strong>。也就是把连续的N个Cache Line绑成一组，然后，先把找到相关的组，然后再在这个组内找到相关的Cache Line。这叫 <strong>Set Associativity</strong>。<strong>但是</strong>，但是实现难度和造价要比直接映像方式高。<strong>（组相联映像方式）</strong></li>
</ul>
<p><img src="/2021/07/03/Principles-Of-Computer-Composition-Zero/3.png" alt="cache-associative-fill-both"></p>
<p>N-ways  Set-Associative，这个n=1，就是直接映射；n=cache大小，就是全相关映射。我们从上面知道两者都不好，而n最好取中间某个值。那么n到底该选几呢？这比较复杂，和Cache的速度和大小、内存的速度、主频等等很多都相关，在很多情况下都是个经验值，也是大量pre-silicon实验的结果。</p>
<p>TLB可以看作页表的Cache，<strong>CPU每次转换地址都会查看TLB</strong>，<strong>如果有了就不用去取内存页表了</strong>。<strong>那么TLB和Cache有什么关系呢？</strong>可以说TLB命中是Cache命中的基本条件。TLB不命中，会更新TLB项，这个代价非常大，Cache命中的好处基本都没有了。<strong>在TLB命中的情况下，物理地址才能够被选出，Cache的命中与否才能够达成。</strong>可以看出，只有在TLB命中的前提下，才有可能获得虚拟地址对应的物理地址，知道了物理地址才能得知Cache是否命中。<a href="https://zhuanlan.zhihu.com/p/31859105" target="_blank" rel="noopener">段落参考</a></p>
<p>在知道物理地址的情况下，如何分析Cache是否命中？</p>
<p>如下图：根据物理页地址的24位找到对应Cache中的组，也即Directory。然后根据6bits(2<sup>6</sup>=64)的Set Index查找一路中的Cache Line索引(因为一路中包含多个Cache Line)，6bits(2<sup>6</sup>=64)的Offset Into cache line表示在Cache Line 里的偏移量。</p>
<p><img src="/2021/07/03/Principles-Of-Computer-Composition-Zero/4.png" alt="cache-associative-fill-both"></p>
<p>（图片来自《<a href="https://manybutfinite.com/post/intel-cpu-caches/" target="_blank" rel="noopener">Cache: a place for concealment and safekeeping</a>》）</p>
<p>上面的图说明L1Cache可以映射到36bits的内存地址，一共2<sup>36</sup>=64GB的内存。当CPU要访问一个内存的时候，通过这个内存的前24bits 和中间的6bits可以直接定位相应的Cache Line。这里的64GB是处理器可以寻址 64GB 的物理 RAM。同时由于页面一般为4KB。所以需要寻址的位为 64GB / 4KB =2<sup>24</sup>，因此我们的标签需要 24 位 。</p>
<p>此外，当有数据没有命中缓存的时候，CPU就会以最小为Cache  Line的单元向内存更新数据。当然，CPU并不一定只是更新64Bytes，因为访问主存实在是太慢了，所以，一般都会多更新一些。好的CPU会有一些预测的技术，如果找到一种pattern的话，就会预先加载更多的内存，包括指令也可以预加载。这叫 Prefetching 技术 （参看，Wikipedia 的 <a href="https://en.wikipedia.org/wiki/Cache_prefetching" target="_blank" rel="noopener">Cache Prefetching</a> 和 <a href="http://compas.cs.stonybrook.edu/~nhonarmand/courses/sp16/cse502/slides/13-prefetch.pdf" target="_blank" rel="noopener">纽约州立大学的 Memory Prefetching</a>）。比如，你在for-loop访问一个连续的数组，你的步长是一个固定的数，内存就可以做到prefetching。<a href="https://www.cnblogs.com/ricks/p/12400900.html" target="_blank" rel="noopener">段落参考</a></p>
<h4 id="六、缓存的一致性"><a href="#六、缓存的一致性" class="headerlink" title="六、缓存的一致性"></a>六、缓存的一致性</h4><p>对于主流的CPU来说，缓存的写操作基本上是两种策略：</p>
<ul>
<li>一种是Write Back，写操作只要在cache上，然后再flush到内存上。</li>
<li>一种是Write Through，写操作同时写到cache和内存上。</li>
</ul>
<p>为了提高写的性能，一般来说，主流的CPU（如：Intel Core i7/i9）采用的是Write Back的策略，因为直接写内存实在是太慢了。<strong>现在问题来了</strong>，如果有一个<strong>数据 x 在 CPU 第0核的缓存上被更新了</strong>，那么<strong>其它CPU核上对于这个数据 x 的值也要被更新</strong>，这就是缓存一致性的问题。（当然，对于我们上层的程序我们不用关心CPU多个核的缓存是怎么同步的，这对上层的代码来说都是透明的）。</p>
<p>一般来说，在CPU硬件上的解决方法有两种方法：</p>
<ul>
<li><strong>Directory 协议：</strong>这种方法的典型实现是要设计一个集中式控制器，它是主存储器控制器的一部分。其中有一个目录存储在主存储器中，其中包含有关各种本地缓存内容的全局状态信息。当单个CPU Cache 发出读写请求时，这个集中式控制器会检查并发出必要的命令，以在主存和CPU Cache之间或在CPU  Cache自身之间进行数据同步和传输。</li>
<li><strong>Snoopy 协议：</strong>这种协议更像是一种数据通知的总线型的技术。CPU Cache通过这个协议可以识别其它Cache上的数据状态。如果有数据共享的话，可以通过广播机制将共享数据的状态通知给其它CPU Cache。这个协议要求每个CPU Cache 都可以<strong>窥探</strong>数据事件的通知并做出相应的反应。<a href="https://www.cnblogs.com/ricks/p/12400900.html" target="_blank" rel="noopener">段落参考</a></li>
</ul>
<h4 id="七、程序虚拟地址和实际物理地址的映射"><a href="#七、程序虚拟地址和实际物理地址的映射" class="headerlink" title="七、程序虚拟地址和实际物理地址的映射"></a>七、程序虚拟地址和实际物理地址的映射</h4><p>指令里面的地址是程序空间（虚拟空间）的虚拟地址（程序地址）。所以当 程序真正运行起来的时候，每个虚拟地址必然要对应着一个物理地址（实际存在）。</p>
<p>分页内存管理机制将虚拟内存和物理内存都分成大小一样大的部分，我们称为页，然后按页进行内存分配。一般页的大小有4KB、8KB、16KB。在该管理机制下内存分配单位化而且不需要空闲连续在一起即可使用。<strong>虚拟地址的页号表示和物理地址页号表示是从0开始的</strong>。</p>
<p><strong>内存的两种视角</strong></p>
<ul>
<li>虚拟地址(线性地址)，进程看到的内存地址称为虚拟地址，他们不对应任何物理实体，每个进程有自己的地址空间。</li>
<li>物理地址，内存系统看到的地址称为物理地址，他们用实际的地址去查找和存储内容。</li>
</ul>
<p><strong>为什么？</strong>如果运行多个进程，直接将内容映射到物理地址的话可能会存在访问冲突。所以需要相对地址，进而保护进行。因此，在早期的时候设置了地址空间，利用<strong>动态重定位技术</strong>用两个寄存器分别为<strong>基址寄存器</strong>和<strong>界限寄存器</strong>，将进程的起始地址放到基址寄存器中，进程占据内存的长度存到界限寄存器中，这样就相当于为进程划清了界限。<strong>(要求为内存空间连续)。</strong>但是会遇到什么问题？当进程很多的时候，内存中放不下，那么只能利用<strong>内存的交换技术(swapping)</strong>将一部分<strong>进程</strong>暂时放到磁盘中，但是在交换的过程中会出现大量的<strong>内存空洞</strong>，所以需要将内存中的<strong>进程向低地址移动</strong>，以便留出更大的空间，称为<strong>内存紧缩</strong>。但是会耗费大量的CPU时间。<strong>一个更好的方法</strong>，将进程所需的内存切成一个个小块，比如4KB大小，称为一页，其中只有一部分的页在内存中，当cpu需要方位的地址不在内存中时，可以从磁盘加载对应的部分，同时内存不够时也可以把长期不访问的页面保存到磁盘中，然后删除内存中的部分。这种做法称为虚拟内存。</p>
<p>内存如何管理？查看是否有足够大的内存能够满足进程的要求</p>
<ol>
<li>位图：将内存划分为单位小区域，每个区域由0/1表示状态（空闲/占用）。当一个进程需要加载内存是，需要扫描连续为0的空闲区域，作为进程的内存区域。缺点查找比较耗时。</li>
<li>链表：为了规避位图耗时的问题，每一块连续的区域分别由一个节点表示，节点有4个值，第一个若为P，则表示这块区域是有进程的，H则代表空闲区。第二个值指向对应区域的起始位置，第三个值对应的是区域的长度，第四个值是个指针指向下一个节点。进程加载内存是扫描第一个值，称为首次适配算法。此外，还是有最佳适配算法等。</li>
</ol>
<p>介绍一下整个地址映射的关系：</p>
<p>首先程序对应的是逻辑地址，其中包括代码、数据、堆(从低地址往高地址寻址)、栈(从高地址往低地址寻址)。例如：栈地址需要根据逻辑地址(虚拟地址)selector:offset，根据selector从GDT(Global Descriptor Table)中获取段描述符其中包含Base Address，结合逻辑地址中的offset能够计算出线性地址。最后，根据线性地址(22-31位)，从CR3寄存器中获取到页目录的地址(Base Address)，线性地址中记载了页目录的offset，加上offset得到页表的Base Address，加上线性地址中(12-22位)的offset，得到物理地址中的基地址，加上偏移量(线性地址)中的(0-12位)得到物理地址中的第几页。</p>
<p>程序虚拟空间中的虚拟地址<strong>通过分段机制</strong>得到虚拟地址/线性地址，线性地址<strong>通过分页机制</strong>（需要用到页表(page table)，每次地址转换都要查看内存页表太浪费时间了。现代计算机为了加速这一过程，转译后备缓冲区TLB）得到真实的物理地址。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

  </div>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/page/8/">8</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Qiang Chen</p>
  <div class="site-description" itemprop="description">记录是忘记的第一助手.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">78</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">13</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">22</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/chenaing19" title="GitHub → https://github.com/chenaing19" rel="noopener" target="_blank"><i class="fa fa-fw fa-github"></i>GitHub</a>
      </span>
      <span class="links-of-author-item">
        <a href="/765206494@qq.com" title="E-Mail → 765206494@qq.com"><i class="fa fa-fw fa-envelope"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Qiang Chen</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v4.0.0
  </div>
  <span class="post-meta-divider">|</span>
  <div class="theme-info">主题 �?<a href="https://mist.theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> v7.5.0
  </div>
    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>



        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    <span class="post-meta-item" id="busuanzi_container_site_uv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item" id="busuanzi_container_site_pv" style="display: none;">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>








        
      </div>
    </footer>
  </div>

  
  
  <script color='0,0,255' opacity='0.5' zIndex='-1' count='99' src="/lib/canvas-nest/canvas-nest.min.js"></script>
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script>
<script src="/js/schemes/muse.js"></script>
<script src="/js/next-boot.js"></script>



  




  <script src="/js/local-search.js"></script>













  

  
      
<script type="text/x-mathjax-config">

  MathJax.Hub.Config({
    tex2jax: {
      inlineMath: [ ['$', '$'], ['\\(', '\\)'] ],
      processEscapes: true,
      skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    },
    TeX: {
      equationNumbers: {
        autoNumber: 'AMS'
      }
    }
  });

  MathJax.Hub.Register.StartupHook('TeX Jax Ready', function() {
    MathJax.InputJax.TeX.prefilterHooks.Add(function(data) {
      if (data.display) {
        var next = data.script.nextSibling;
        while (next && next.nodeName.toLowerCase() === '#text') {
          next = next.nextSibling;
        }
        if (next && next.nodeName.toLowerCase() === 'br') {
          next.parentNode.removeChild(next);
        }
      }
    });
  });

  MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for (i = 0; i < all.length; i += 1) {
      element = document.getElementById(all[i].inputID + '-Frame').parentNode;
      if (element.nodeName.toLowerCase() == 'li') {
        element = element.parentNode;
      }
      element.classList.add('has-jax');
    }
  });
</script>
<script>
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mathjax@2/MathJax.js?config=TeX-AMS-MML_HTMLorMML', () => {
    MathJax.Hub.Typeset();
  }, window.MathJax);
</script>

    

  


  
  <!-- ҳ����С���� -->
  
  
    <script src="/js/cursor/love.min.js"></script><!-- hexo-inject:begin --><!-- hexo-inject:end -->
  



</body>
</html>
