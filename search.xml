<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Neural-Network</title>
    <url>/2022/01/09/Neural-Network/</url>
    <content><![CDATA[<h2 id="第五章-神经网络（西瓜书学习-笔记）"><a href="#第五章-神经网络（西瓜书学习-笔记）" class="headerlink" title="第五章 神经网络（西瓜书学习-笔记）"></a>第五章 神经网络（西瓜书学习-笔记）</h2><h4 id="一、神经元模型"><a href="#一、神经元模型" class="headerlink" title="一、神经元模型"></a>一、神经元模型</h4><p><img src="/2022/01/09/Neural-Network/M-P-0.png" alt="ML"></p>
<p>在生物神经网络中，每个神经元与其他神经元相连，当它”兴奋”时，就会向相连的神经元发送化学物质，从而改变这些神经元内的电位；如果某神经元的电位超过了一个”阈值”，那么它就会被激活，即“兴奋”起来，向其他神经元发送化学物质。</p>
<p>在M-P神经元模型中，神经元接收到来自n个其他神经元传递过来的输入信号，这些输入信号通过带权重的连接进行传递，神经元接收到的总输入值将于神经元的阈值进行比较，然后通过激活函数处理以产生神经元的输出。</p>
<p>理想的激活函数是阶跃函数，它将输入值映射为输出值0和1，其中1对于神经元兴奋，0对于神经元抑制。然而，阶跃函数具有不连续、不光滑等不太好的性质。因此，常用sigmoid函数作为激活函数。</p>
<p><img src="/2022/01/09/Neural-Network/M-P-1.png" alt="ML"></p>
<h4 id="二、感知机与多层网络"><a href="#二、感知机与多层网络" class="headerlink" title="二、感知机与多层网络"></a>二、感知机与多层网络</h4><p>感知机由两层神经元组成，能容易地实现逻辑与、或、非运算。但是只能处理线性可分的问题，对于非线性可分问题，需要考虑使用多层功能神经元，即多层前馈神经网络。</p>
<p><img src="/2022/01/09/Neural-Network/M-P-2.png" alt="ML"></p>
<h4 id="三、误差逆传播算法"><a href="#三、误差逆传播算法" class="headerlink" title="三、误差逆传播算法"></a>三、误差逆传播算法</h4><script type="math/tex; mode=display">
给定训练集D=\{(x_1,y_1),(x_2,y_2),...,(x_m,y_m)\},x_i\in R^d,y_i\in R^l\\
即输入示例由d个属性描述，输出l维实值向量。</script><p><img src="/2022/01/09/Neural-Network/M-P-3.png" alt="ML"></p>
<script type="math/tex; mode=display">
\begin{align}&上图显示了一个拥有d个输入神经元，l个输出神经元，q个隐层神经元的多层前馈神经网络。\\&其中输出层第j个神经元的阈值为\theta_j,隐层第h个神经元的阈值用\gamma_h表示。\\
&输入层第i个神经元与隐层第h个神经元之间的连接权为v_{ih},隐层第h个神经元与输出层第j个神经元之间的连接权为w_{hj}\\
&记隐层第h个神经元接收到的输入为\alpha_h=\sum^{d}_{i=1}v_{ih}x_i,输出层第j个神经元接收到的输入为\beta_j=\sum^{q}_{h=1}w_{hj}b_h\\
&其中b_h为隐层第h个神经元的输出。如果假设隐层和输出层神经元使用sigmoid函数\\
&对训练例(x_k,y_k)，假定神经网络的输出为\hat{y}_k=(\hat{y}^k_1,\hat{y}^k_2,...,\hat{y}^k_l),即：\hat{y}^k_j=f(\beta_j-\theta_j)\\
&则网络在(x_k,y_k)上的均方误差为：E_k=\frac{1}{2}\sum^{l}_{j=1}(\hat{y}^k_j-y^k_j)^2\\
&上图共有d\times q(输入到隐层权值)+l\times q(隐层到输出层权值) + q(隐藏层阈值) + l(输出层阈值)个参数
\end{align}</script><p>BP算法基于梯度下降(gradient descent)策略，以目标的负梯度方向对参数进行调整。</p>
<script type="math/tex; mode=display">
\begin{align}
&给定误差E_k, 学习率\eta,则\Delta w_{hj}=-\eta\frac{\partial E_k}{\partial w_{hj}}\\
&注意到w_{hj}先影响到第j个输出层的神经元的输入值\beta_j，再影响到输出值\hat{y}^k_j,然后影响到E_k\\
&也就是根据链式法则有：\frac{\partial E_k}{\partial w_{hj}}=\frac{\partial E_k}{\partial \hat{y}^k_j}\cdot\frac{\partial \hat{y}^k_j}{\partial \beta_j}\cdot\frac{\partial \beta_j}{\partial w_{hj}}\\
&\because Sigmoid函数有一个很好的性质：f'(x)=f(x)(1-f(x)),又\beta_j=\sum^{q}_{h=1}w_{hj}b_h \therefore \frac{\partial \beta_j}{\partial w_{hj}}=b_h\\
&令g_j=-\frac{\partial E_k}{\partial \hat{y}^k_j}\cdot\frac{\partial \hat{y}^k_j}{\partial \beta_j}=-(\hat{y}^k_j-y^k_j)f'(\beta_j-\theta_j)=(y^k_j-\hat{y}^k_j)[f(\beta_j-\theta_j)(1-f(\beta_j-\theta_j))]=(y^k_j-\hat{y}^k_j)\hat{y}^k_j(1-\hat{y}^k_j) \\
&由上式可得BP算法关于w_{hj}的更新公式\Delta w_{hj}=\eta g_j b_h\\
&类似可得：\Delta\theta_j=-\eta g_j; \Delta v_{ih}=\eta e_hx_i;\Delta \gamma_h=-\eta e_h\\
&e_h=-\frac{\partial E_k}{\partial b_k}\cdot\frac{\partial b_h}{\partial \alpha_h}=-\sum^{l}_{j=1}\frac{\partial E_k}{\partial \beta_j}\cdot\frac{\partial \beta_j}{\partial b_h}f'(\alpha_h-\gamma_h)=\sum^{l}_{j=1}w_{hj}g_jf'(\alpha_h-\gamma_h)=b_h(1-b_h)\sum^{l}_{j=1}w_{hj}g_j
\end{align}</script><p><strong>如何缓解神经网络过拟合？</strong></p>
<ol>
<li>早停，将数据分成训练集和验证集，训练集用来计算梯度、更新连接权和阈值，验证集用来估计误差，若训练集误差降低，但验证集误差升高，则停止训练，同时返回具有最小验证集误差的连接权和阈值。</li>
<li>正则化，在误差目标函数中增加一个用于描述网络复杂度的部分，例如，连接权和阈值的平方和。</li>
</ol>
<script type="math/tex; mode=display">
E=\lambda\frac{1}{m}\sum^{m}_{k=1}E_k+(1-\lambda)\sum_{i}w^2_i</script><p>&lambda;&in;(0,1)用于对经验误差与网络复杂度这两项进行折中。</p>
<p><strong>累积BP算法</strong>基于<strong>所有样本的累积误差</strong>进行权重更新，<strong>标准BP算法</strong>每次更新只针对<strong>单个样例</strong>，参数更新非常频繁，而且对不同样例进行更新的效果可能出现抵消现象。因此，为了达到同样的累积误差极小点，标准BP算法往往需进行更多次数的迭代。累积BP算法直接针对累积误差最小化，在读取整个训练集D一遍后才对参数进行更新，其参数更新的频率低得多。但在很多任务中，累积误差下降到一定程度之后，进一步下降会非常缓慢，这时标准BP往往会更快获得较好的解。</p>
<h4 id="四、全局最小与局部极小"><a href="#四、全局最小与局部极小" class="headerlink" title="四、全局最小与局部极小"></a>四、全局最小与局部极小</h4><p>由于负梯度方向是函数值下降最快的方向，因此梯度下降法就是沿着负梯度方向搜索最优解。但误差函数如果到达局部极小，更新量将为零，则参数的迭代更新将在此停止。对于存在多个局部极小值点的情况，<strong>如何跳出局部极小，尽量向全局最小靠近呢？</strong></p>
<ul>
<li>以多组不同参数值初始化多个神经网络，按标准方法训练后，取其中误差最小的解作为最终参数。这相当于从多个不同的初始点开始搜索，这样就可能陷入不同的局部极小，从中进行选择有可能获得更接近全局最小的结果。</li>
<li>使用“模拟退化”技术，模拟退火在每一步都以一定的概率接受比当前解更差的结果，从而有助于跳出局部极小。在每步迭代过程中，接受次优解的概率要随着时间的推移而逐渐降低，从而保证算法稳定。</li>
<li>使用随机梯度下降。与标准梯度下降法精确计算梯度不同，随机梯度下降法在计算梯度时加入随机因素。于是，即便陷入局部极小点，它计算处的梯度仍可能不为零，这样就可能跳出局部极小值继续搜索。</li>
</ul>
<p>上述用于跳出局部极小的计算大多是启发式，理论上缺乏保证。</p>
]]></content>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/01/09/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post-location-source-gt-post-directory"><a href="#Create-a-new-post-location-source-gt-post-directory" class="headerlink" title="Create a new post, location: source-&gt;_post directory"></a>Create a new post, location: source-&gt;_post directory</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span></pre></td></tr></table></figure>
<h3 id="Create-a-new-draft-location-source-gt-drafts-directory"><a href="#Create-a-new-draft-location-source-gt-drafts-directory" class="headerlink" title="Create a new draft, location: source-&gt;_drafts directory"></a>Create a new draft, location: source-&gt;_drafts directory</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new  draft <span class="string">"My New Draft"</span></span></pre></td></tr></table></figure>
<h3 id="Preview-a-new-draft-shut-down-old-server"><a href="#Preview-a-new-draft-shut-down-old-server" class="headerlink" title="Preview a new draft (shut down old server)"></a>Preview a new draft (shut down old server)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server --draft</span></pre></td></tr></table></figure>
<h3 id="publish-a-new-draft-shut-down-old-server"><a href="#publish-a-new-draft-shut-down-old-server" class="headerlink" title="publish a new draft (shut down old server)"></a>publish a new draft (shut down old server)</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo publish <span class="string">"My New draft"</span></span></pre></td></tr></table></figure>
<h3 id="Create-a-new-normal-location-source-gt-c-directory"><a href="#Create-a-new-normal-location-source-gt-c-directory" class="headerlink" title="Create a new normal, location: source-&gt;c directory"></a>Create a new normal, location: source-&gt;c directory</h3><h4 id="normal-is-not-blog-page-it-likes-about-or-contact-us-page"><a href="#normal-is-not-blog-page-it-likes-about-or-contact-us-page" class="headerlink" title="normal is not blog page, it likes about or contact us page."></a>normal is not blog page, it likes about or contact us page.</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new page <span class="string">"My new Normal"</span></span></pre></td></tr></table></figure>
<h3 id="Preview-a-new-normal"><a href="#Preview-a-new-normal" class="headerlink" title="Preview a new normal"></a>Preview a new normal</h3><p><a href="http://localhost:4000/c/" target="_blank" rel="noopener">http://localhost:4000/c/</a></p>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="Clean-cache"><a href="#Clean-cache" class="headerlink" title="Clean cache"></a>Clean cache</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span></pre></td></tr></table></figure>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<p>If you want to show Chinese, you must make sure md is saved with utf-8</p>
]]></content>
  </entry>
  <entry>
    <title>OS-Summary</title>
    <url>/2022/01/09/OS-Summary/</url>
    <content><![CDATA[<div class="pdf" target="./OS-Summary/os-summary.pdf" height></div>
]]></content>
  </entry>
  <entry>
    <title>Cloud-Paas-Learn</title>
    <url>/2021/09/12/Cloud-Paas-Learn/</url>
    <content><![CDATA[<h2 id="云计算Paas学习"><a href="#云计算Paas学习" class="headerlink" title="云计算Paas学习"></a>云计算Paas学习</h2><h4 id="一、如何使用postman进行登录"><a href="#一、如何使用postman进行登录" class="headerlink" title="一、如何使用postman进行登录"></a>一、如何使用postman进行登录</h4><ol>
<li>找到登录的<strong>login-processing-url</strong>：/api/v1/auth/login/verify。</li>
<li>查看<strong>Request</strong>的方式，一般为”POST”。</li>
<li>在postman界面的Body中添加<strong>用户名</strong>和<strong>密码</strong>等信息，可以通过Google在部署的开发服务器上获得。</li>
<li>发送请求，如果成功，在<strong>Response</strong>的<strong>Header</strong>中，可以找到”x-auth-header”的字段，里面的内容就是token值。</li>
<li>利用token的值请求别的页面，在请求的Header中添加”x-auth-header”以及对应的token值。</li>
</ol>
<h4 id="二、认证和鉴权的实践"><a href="#二、认证和鉴权的实践" class="headerlink" title="二、认证和鉴权的实践"></a>二、认证和鉴权的实践</h4><p>当postman发送登陆<strong>验证</strong>的请求时：下面认证的接口会被调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (postOnly &amp;&amp; !<span class="string">"POST"</span>.equals(request.getMethod())) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> AuthenticationServiceException(<span class="string">"Authentication method not supported: "</span> + request.getMethod());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// 获取提交的JSON数据</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ServletInputStream ris = request.getInputStream();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    StringBuilder content = <span class="keyword">new</span> StringBuilder();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> lens;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> ((lens = ris.read(b)) &gt; <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        content.append(<span class="keyword">new</span> String(b, <span class="number">0</span>, lens));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    JSONObject dataObject = JSON.parseObject(content.toString(), JSONObject<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    TenantAuthenticationToken authRequest = <span class="keyword">new</span> TenantAuthenticationToken(dataObject, <span class="string">""</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    authRequest.setDetails(authenticationDetailsSource.buildDetails(request));</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.getAuthenticationManager().authenticate(authRequest);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>当postman发送查看资源或别的非登陆页面的请求时：下面授权的接口会被调用</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> ObjectMapper objectMapper;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">throws</span> ServletException, IOException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">String token = request.getHeader(jwtTokenUtil.getHeader());</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (!StringUtils.isEmpty(token)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Integer userId = jwtTokenUtil.getUserIdFromToken(token);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (userId != <span class="keyword">null</span> &amp;&amp; SecurityContextHolder.getContext().getAuthentication() == <span class="keyword">null</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">SecuritySessionUser securitySessionUser = <span class="keyword">new</span> SecuritySessionUser();</span></pre></td></tr><tr><td class="code"><pre><span class="line">securitySessionUser.setUserId(userId);</span></pre></td></tr><tr><td class="code"><pre><span class="line">securitySessionUser.setUsername(jwtTokenUtil.getUsernameFromToken(token));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (jwtTokenUtil.validateToken(token, securitySessionUser)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 将用户信息存入 authentication，方便后续校验</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">UsernamePasswordAuthenticationToken authentication = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(</span></pre></td></tr><tr><td class="code"><pre><span class="line">securitySessionUser, <span class="keyword">null</span>, securitySessionUser.getAuthorities());</span></pre></td></tr><tr><td class="code"><pre><span class="line">authentication.setDetails(<span class="keyword">new</span> WebAuthenticationDetailsSource().buildDetails(request));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 将 authentication 存入 ThreadLocal，方便后续获取用户信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">SecurityContextHolder.getContext().setAuthentication(authentication);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">response.setContentType(<span class="string">"application/json;charset=UTF-8"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">response.getWriter().write(objectMapper.writeValueAsString(MessageUtil.error(<span class="number">401</span>,<span class="string">"token已失效"</span>)));</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">chain.doFilter(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>当认证授权通过后，可以使用如下接口获取用户信息</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">getSessionUserId</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        SecuritySessionUser user = (SecuritySessionUser) SecurityContextHolder.getContext().getAuthentication()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .getPrincipal();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> user.getUserId();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        log.error(<span class="string">"获取登录用户id失败:"</span>, e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(<span class="string">"请先登录"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="三、用户信息从哪里来"><a href="#三、用户信息从哪里来" class="headerlink" title="三、用户信息从哪里来"></a>三、用户信息从哪里来</h4><p>上面使用了SecurityContextHolder.getContext().getAuthentication()获取用户的信息。<strong>那么为什么这个接口能够获取用户的信息呢？</strong></p>
<p>可以看到用户的信息是从SecurityContextHolder中，先get到Context，在get到认证信息。那么首先在谈谈SecurityContextHolder。</p>
<p>SecurityContextHolder 中的数据，本质上是保存在<code>ThreadLocal</code>中，<code>ThreadLocal</code>的一个特点是如果一个线程往<code>ThreadLocal</code>中存数据，那么只有该线程可以取。那么又有一个问题，当不同的请求进入到服务端之后，由不同的 thread 去处理，按理说后面的请求就可能无法获取到登录请求的线程存入的数据。例如登录请求在线程 A 中将登录用户信息存入 <code>ThreadLocal</code>，后面的请求来了，在线程 B 中处理，那此时就无法获取到用户的登录信息。但是我们每次都能获取到相应的<strong>用户信息</strong>，这个是为什么呢？</p>
<p>首先，得谈谈<code>SecurityContextPersistenceFilter</code>这是一个滤波器，Spring Security的一系列功能都是有一个个的过滤器来完成的。那么<code>SecurityContextPersistenceFilter</code>这个过滤器是用来干嘛的？先看看部分源码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityContextPersistenceFilter</span> <span class="keyword">extends</span> <span class="title">GenericFilterBean</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest req, ServletResponse res, FilterChain chain)</span><span class="keyword">throws</span> IOException, ServletException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		HttpServletRequest request = (HttpServletRequest) req;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		HttpServletResponse response = (HttpServletResponse) res;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		HttpRequestResponseHolder holder = <span class="keyword">new</span> HttpRequestResponseHolder(request,response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		SecurityContext contextBeforeChainExecution = repo.loadContext(holder);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">try</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			SecurityContextHolder.setContext(contextBeforeChainExecution);</span></pre></td></tr><tr><td class="code"><pre><span class="line">			chain.doFilter(holder.getRequest(), holder.getResponse());</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">finally</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			SecurityContext contextAfterChainExecution = SecurityContextHolder.getContext();</span></pre></td></tr><tr><td class="code"><pre><span class="line">			SecurityContextHolder.clearContext();</span></pre></td></tr><tr><td class="code"><pre><span class="line">			repo.saveContext(contextAfterChainExecution, holder.getRequest(),holder.getResponse());</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>这里列出来了比较关键的几个部分：</p>
<ol>
<li><code>SecurityContextPersistenceFilter</code> 继承自<code>GenericFilterBean</code>，而 <code>GenericFilterBean</code> 则是 Filter 的实现，所以 <code>SecurityContextPersistenceFilter</code> 作为一个过滤器，它里边最重要的方法就是 doFilter 了。</li>
<li>在 doFilter 方法中，它首先会从 repo 中读取一个 <code>SecurityContext</code> 出来，这里的 repo 实际上就是 <code>HttpSessionSecurityContextRepository</code>，读取 <code>SecurityContext</code>的操作会进入到 <code>readSecurityContextFromSession</code>方法中，在这里我们看到了读取的核心方法 <code>Object contextFromSession = httpSession.getAttribute(springSecurityContextKey);</code>，这里的 <code>springSecurityContextKey</code> 对象的值就是 <code>SPRING_SECURITY_CONTEXT</code>，读取出来的对象最终会被转为一个 <code>SecurityContext</code>对象。</li>
<li><code>SecurityContext</code>是一个接口，它有一个唯一的实现类 <code>SecurityContextImpl</code>，这个实现类其实就是用户信息在 session 中保存的 value。</li>
<li>在拿到<code>SecurityContext</code> 之后，通过<code>SecurityContextHolder.setContext</code>方法将这个<code>SecurityContext</code>设置到 <code>ThreadLocal</code>中去，这样，在当前请求中，Spring Security  的后续操作，我们都可以直接从 <code>SecurityContextHolder</code>中获取到用户信息了。</li>
<li>接下来，通过 chain.doFilter 让请求继续向下走（这个时候就会进入到 <code>UsernamePasswordAuthenticationFilter</code> 过滤器中了）。</li>
<li>在过滤器链走完之后，数据响应给前端之后，finally中还有一步收尾操作，这一步很关键。这里从SecurityContextHolder<code>中获取到</code>SecurityContext<code>，获取到之后，会把</code>SecurityContextHolder<code>清空，然后调用  repo.saveContext 方法将获取到的</code>SecurityContext` 存入 session 中。</li>
</ol>
<h4 id="四、RequestInterceptor"><a href="#四、RequestInterceptor" class="headerlink" title="四、RequestInterceptor"></a>四、RequestInterceptor</h4><p>微服务之前调用的时候请求不会传递参数，通过实现RequestInterceptor接口,完成对所有的Feign请求,传递请求头和请求参数。常见的使用是传递token。apply方法往RequestTemplate添加自定义名称的header。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignHeaderInterceptor</span> <span class="keyword">implements</span> <span class="title">RequestInterceptor</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(RequestTemplate requestTemplate)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ServletRequestAttributes attributes = (ServletRequestAttributes)RequestContextHolder.getRequestAttributes();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(<span class="keyword">null</span> == attributes) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        	<span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        HttpServletRequest request = attributes.getRequest();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        requestTemplate.header(<span class="string">"x-auth-header"</span>, request.getHeader(<span class="string">"x-auth-header"</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="五、定制化Spring-Security"><a href="#五、定制化Spring-Security" class="headerlink" title="五、定制化Spring Security"></a>五、定制化Spring Security</h4><p>使用Spring Security为的就是写最少的代码，实现更多的功能，在定制化Spring Security，核心思路就是：重写某个功能，然后配置。</p>
<ul>
<li>比如你要查自己的用户表做登录，那就实现<code>UserDetailsService</code>接口；</li>
<li>比如前后端分离项目，登录成功和失败后返回json，那就实现<code>AuthenticationFailureHandler/AuthenticationSuccessHandler</code>接口；</li>
<li>比如扩展token存放位置，那就实现<code>HttpSessionIdResolver</code>接口；</li>
</ul>
<p>将上述做的更改配置到security里。套路就是这个套路。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomSecurityConfigurer</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 * 自定义验证提供者</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">private</span> AdminAuthenticationProvider adminAuthenticationProvider;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">private</span> TenantAuthenticationProvider tenantAuthenticationProvider; <span class="comment">// 自定义登录AuthenticationProvider</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 * 验证失败处理器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">private</span> CustomAuthenticationFailureHandler customAuthenticationFailureHandler;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 * 验证成功处理器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">private</span> CustomAuthenticationSuccessHandler customAuthenticationSuccessHandler;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 * 退出成功处理器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">private</span> CustomLogoutSuccessHandle customLogoutSuccessHandle;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 * 访问拒绝处理器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">private</span> CustomAccessDeniedHandler customAccessDeniedHandler;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 * 未登录时处理器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">private</span> CustomAuthenticationEntryPoint customAuthenticationEntryPoint;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 * 配置信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">private</span> CustomSecurityConfig customSecurityConfig;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">private</span> JwtAuthenticationTokenFilter jwtAuthenticationTokenFilter;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="meta">@Qualifier</span>(<span class="string">"authenticationManagerBean"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">private</span> AuthenticationManager authenticationManager;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(WebSecurity web)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		web.ignoring().antMatchers(toArrays(customSecurityConfig.getIgnoring()));</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">//web.ignoring().anyRequest(); //这个尽量不要全打开，网上说会使登陆的处理链接失效，从而不被认证 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		http.addFilterBefore(jwtAuthenticationTokenFilter, UsernamePasswordAuthenticationFilter<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		http.addFilterBefore(citictAuthenticationProcessingFilter(), AbstractPreAuthenticatedProcessingFilter<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		http.addFilterBefore(usernamePasswordAuthenticationFilter(), AbstractPreAuthenticatedProcessingFilter<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// "/", "/index", "/mylogin", "/static/**"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		http.authorizeRequests()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .antMatchers(toArrays(customSecurityConfig.getPermitAll()))</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .permitAll()<span class="comment">// 定义不需要认证就可以访问</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			.antMatchers(</span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="string">"/v2/api-docs"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="string">"/swagger-resources"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="string">"/swagger-resources/**"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="string">"/configuration/ui"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="string">"/configuration/security"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="string">"/swagger-ui.html/**"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="string">"/webjars/**"</span>).permitAll()</span></pre></td></tr><tr><td class="code"><pre><span class="line">			.anyRequest().authenticated()<span class="comment">// 其余所有请求都需要登录认证才能访问</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			.and()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .formLogin()</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment">// 自定义认证成功或者失败的返回json</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			.successHandler(customAuthenticationSuccessHandler).failureHandler(customAuthenticationFailureHandler)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			.permitAll() <span class="comment">//允许用户访问Spring Security自带的/login页面，当然也可以自己写</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            .and()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .logout().logoutUrl(customSecurityConfig.getLogoutUrl())<span class="comment">// 自定义退出url</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			.logoutSuccessHandler(customLogoutSuccessHandle)<span class="comment">// 设置了登出成功的Handler</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			.invalidateHttpSession(<span class="keyword">true</span>).permitAll();</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// .and().rememberMe()// 记住我</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// .rememberMeParameter("rememberMe")</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// .tokenRepository(persistentTokenRepository())</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// .tokenValiditySeconds(60 * 60 * 24); //token生效的时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">// 默认都会产生一个hiden标签 里面有安全相关的验证 防止请求伪造 因为使用了jwt所以这里不需要csrf</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		http.csrf().disable();</span></pre></td></tr><tr><td class="code"><pre><span class="line">		http.exceptionHandling().authenticationEntryPoint(customAuthenticationEntryPoint);<span class="comment">// 未登录</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		http.exceptionHandling().accessDeniedHandler(customAccessDeniedHandler); <span class="comment">// 无权访问</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		http.httpBasic();</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">//禁用session,而使用token		</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		http.sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		auth.authenticationProvider(adminAuthenticationProvider);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		auth.authenticationProvider(tenantAuthenticationProvider);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 这个必须重写，才能使用AuthenticationManager，在成员变量注入进来，再注入过滤器中</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> AuthenticationManager <span class="title">authenticationManagerBean</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> <span class="keyword">super</span>.authenticationManagerBean();</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 下面就是默认的过滤器UsernamePasswordAuthenticationFilter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 配置一下拦截地址、认证成功失败处理器、authenticationManager</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 * 默认用户名密码认证过滤器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 * </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 * <span class="doctag">@Author</span> guomh 2019/12/02</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 * <span class="doctag">@return</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> UserAuthenticationProcessingFilter <span class="title">usernamePasswordAuthenticationFilter</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		UserAuthenticationProcessingFilter filter = <span class="keyword">new</span> UserAuthenticationProcessingFilter();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		filter.setAuthenticationManager(authenticationManager);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		filter.setAuthenticationSuccessHandler(customAuthenticationSuccessHandler);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		filter.setAuthenticationFailureHandler(customAuthenticationFailureHandler);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		filter.setFilterProcessesUrl(customSecurityConfig.getAdminLoginProcessingUrl());</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> filter;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 * 字符串collection转数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 *</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 * <span class="doctag">@param</span> collection</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 *            字符串集合</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 * <span class="doctag">@return</span> 字符串数组</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> String[] toArrays(List&lt;String&gt; collection) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> (CollectionUtils.isEmpty(collection)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">return</span> <span class="keyword">new</span> String[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		String[] array = <span class="keyword">new</span> String[collection.size()];</span></pre></td></tr><tr><td class="code"><pre><span class="line">		array = collection.toArray(array);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> array;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">public</span> TenantAuthenticationProcessingFilter <span class="title">citictAuthenticationProcessingFilter</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		TenantAuthenticationProcessingFilter filter = <span class="keyword">new</span> TenantAuthenticationProcessingFilter();</span></pre></td></tr><tr><td class="code"><pre><span class="line">		filter.setAuthenticationManager(authenticationManager);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		filter.setAuthenticationSuccessHandler(customAuthenticationSuccessHandler);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		filter.setAuthenticationFailureHandler(customAuthenticationFailureHandler);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		filter.setFilterProcessesUrl(customSecurityConfig.getLoginProcessingUrl());</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> filter;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="六、微服务中服务之间调用是否需要鉴权"><a href="#六、微服务中服务之间调用是否需要鉴权" class="headerlink" title="六、微服务中服务之间调用是否需要鉴权"></a>六、微服务中服务之间调用是否需要鉴权</h4><p>在微服务中进行权限控制时，通常将资源服务全部放到内网环境中，将API网关暴露在公网。这时<strong>服务间的调用</strong>分为两种情况，一种情况是<strong>将资源放到内网</strong>中， 则服务之间调用不需要鉴权，另一种是通过<strong>API网关发送调用请求</strong>，这时必须经过API网关进行鉴权。</p>
<p><img src="/2021/09/12/Cloud-Paas-Learn/1.png" alt="Service-Request"></p>
<p>现在假设有三个服务：分别是用户服务、订单服务和产品服务。用户如果购买产品，则需要调用产品服务生成订单，那么我们在这个调用过程中有必要鉴权吗？答案是否定的，因为这些资源服务放在内网环境中，完全不用考虑安全问题。<a href="https://cloud.tencent.com/developer/article/1661115" target="_blank" rel="noopener">图片来源</a></p>
<p><strong>那么服务间的调用如何区分是公网的API网关的请求，还是内网中服务的请求呢？</strong></p>
<p>为了减少代码的冗余(分别写不同的接口)和请求的冗余(不同的请求参数)，可以<strong>在请求的header中添加一个参数</strong>来区分。</p>
<p>单体业务简化版业务图：<a href="https://www.cnblogs.com/study-everyday/p/7754596.html" target="_blank" rel="noopener">图片来源</a></p>
<p><img src="/2021/09/12/Cloud-Paas-Learn/2.png" alt="Service-Request"></p>
<p>分布式应用简化版架构图：</p>
<p><img src="/2021/09/12/Cloud-Paas-Learn/3.png" alt="Service-Request"></p>
<p><a href="https://cloud.tencent.com/developer/article/1612175" target="_blank" rel="noopener">参考链接</a></p>
<p><a href="https://mp.weixin.qq.com/s/yrRPz6SZIoHCHThxHpLChw" target="_blank" rel="noopener">定制化Spring Security的参考链接</a></p>
]]></content>
      <categories>
        <category>Cloud Compute</category>
      </categories>
      <tags>
        <tag>Cloud Compute</tag>
      </tags>
  </entry>
  <entry>
    <title>Wen-Servlet</title>
    <url>/2021/09/12/Web-Servlet/</url>
    <content><![CDATA[<h2 id="Web学习记录"><a href="#Web学习记录" class="headerlink" title="Web学习记录"></a>Web学习记录</h2><p>学框架spring cloud和spring boot有点一知半解，从头开始快速理一遍吧！</p>
<h4 id="一、tomcat"><a href="#一、tomcat" class="headerlink" title="一、tomcat"></a>一、tomcat</h4><h5 id="1-1-tomcat简述"><a href="#1-1-tomcat简述" class="headerlink" title="1.1 tomcat简述"></a>1.1 tomcat简述</h5><p>tomcat是一个开源的web服务器，将自己的web项目放到tomcat目录中的webapps中，并且在bin目录中开启tomcat后，就可以通过浏览器去访问web中的资源。下面创建一个简单的项目：</p>
<ul>
<li>在webapps中建立文件夹，如webexample<ul>
<li>创建WEB-INF文件夹，用于存放项目的核心内容，外部不能访问<ul>
<li>创建classes，用于存放.class文件</li>
<li>创建lib，用于存放jar文件</li>
<li>创建web.xml，项目配置文件(到ROOT项目[解压tomcat后自带了5个样例]下的WEB-INF复制即可)</li>
</ul>
</li>
<li>把网页等静态资源复制到webexample文件中，与WEB-INF在同级目录，如hell.html</li>
</ul>
</li>
</ul>
<h5 id="1-2-URL访问资源"><a href="#1-2-URL访问资源" class="headerlink" title="1.2 URL访问资源"></a>1.2 URL访问资源</h5><p>URL主要由4部分组成：协议、主机、端口、资源路径。<a href="https://www.bilibili.com/video/BV1Jz4y1d7K7?p=5&amp;spm_id_from=pageDriver" target="_blank" rel="noopener">下图来自</a></p>
<p><img src="/2021/09/12/Web-Servlet/TOMCAT-0.png" alt="TOMCAT-0"></p>
<p>tomcat响应流程：</p>
<ul>
<li>用户通过url访问资源</li>
<li>根据主机和端口，在tomcat中找对应的资源</li>
<li>找到后将资源返回给客户端浏览器</li>
<li>浏览器对资源进行解析</li>
</ul>
<p><img src="/2021/09/12/Web-Servlet/TOMCAT-1.png" alt="TOMCAT-1"></p>
<h5 id="1-3-常见问题"><a href="#1-3-常见问题" class="headerlink" title="1.3 常见问题"></a>1.3 常见问题</h5><ol>
<li><p>Tomcat闪退</p>
<p>由于JAVA_HOME配置导致的，检查JAVA_HOME配置是否正确</p>
</li>
<li><p>404</p>
<p>访问的资源不存在</p>
</li>
</ol>
<h4 id="二、Servlet"><a href="#二、Servlet" class="headerlink" title="二、Servlet"></a>二、Servlet</h4><h5 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h5><p>Servlet：Server Applet的简称，是服务器端的程序(代码、功能实现)。JavaWeb程序开发的基础，JavaEE规范(一套接口)的一个组成部分。包括如下作用：</p>
<ul>
<li>可交互式的处理客户端发送到服务端的请求，并完成操作响应</li>
<li>动态网页技术（页面数据可变）例如，不同人访问淘宝的页面里面的内容不一样，推荐系统会推荐不同的喜好内容</li>
<li>将包含操作结果的动态网页响应给客户端</li>
</ul>
<h5 id="2-2-搭建开发环境"><a href="#2-2-搭建开发环境" class="headerlink" title="2.2 搭建开发环境"></a>2.2 搭建开发环境</h5><p>将Servlet相关的jar包(tomcat/lib/servlet-api.jar)配置到环境变量的classpath中。因为在编写servlet接口的时候，需要用到servlet-api.jar中的内容，需要需要让程序找到对应的jar包。</p>
<h5 id="2-3-编写Servlet"><a href="#2-3-编写Servlet" class="headerlink" title="2.3 编写Servlet"></a>2.3 编写Servlet</h5><ul>
<li>实现javax.servlet.Servlet</li>
<li>重写5个主要方法</li>
<li>在核心的service()方法中编写输出语句，打印访问结果</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.Servlet;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletConfig;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletRequest;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> javax.servlet.ServletResponse;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.IOException;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest request, ServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h5 id="2-4-部署servlet"><a href="#2-4-部署servlet" class="headerlink" title="2.4 部署servlet"></a>2.4 部署servlet</h5><ul>
<li>在命令行窗口执行javac MyServlet，生成MyServlet.class</li>
<li>将MyServlet.class放到tomcat/webapps/projectName/WEB-INF/classes文件中</li>
</ul>
<h5 id="2-5-配置Servlet"><a href="#2-5-配置Servlet" class="headerlink" title="2.5 配置Servlet"></a>2.5 配置Servlet</h5><p>上面生成.classes不同通过web浏览器直接访问，需要通过配置做文件映射。··修改WEB-INF下项目配置文件web.xml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">                      http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">version</span>=<span class="string">"3.1"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">  <span class="attr">metadata-complete</span>=<span class="string">"true"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- 1. 添加servlet节点 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>my<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>MyServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="comment">&lt;!-- 2. 添加servlet-mapping节点 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>my<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- url-pattern配置的内容就是浏览器地址栏输入的URL中项目名称后资源的内容 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/myservlet<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span></pre></td></tr></table></figure>
<h5 id="2-6-运行测试"><a href="#2-6-运行测试" class="headerlink" title="2.6 运行测试"></a>2.6 运行测试</h5><p>启动tomcat，在浏览器地址栏中输入<a href="http://localhost:8080/myweb/myservlet" target="_blank" rel="noopener">http://localhost:8080/myweb/myservlet</a> 访问，在servlet的service函数中打印内容，会在命令行窗口中显示。</p>
<h5 id="2-7-常见错误"><a href="#2-7-常见错误" class="headerlink" title="2.7 常见错误"></a>2.7 常见错误</h5><p>500：servlet文件编写错误导致了服务端出现异常。</p>
<p>注意：servlet更新后需要重启tomcat</p>
<h4 id="三、HTTP协议"><a href="#三、HTTP协议" class="headerlink" title="三、HTTP协议"></a>三、HTTP协议</h4><h5 id="3-1-HTTP协议的特点"><a href="#3-1-HTTP协议的特点" class="headerlink" title="3.1 HTTP协议的特点"></a>3.1 HTTP协议的特点</h5><ul>
<li>支持客户端（浏览器）/ 服务器模式</li>
<li>简单快速：客户端只向服务器发送请求方法和路径，服务器即可响应数据，通信速度快。</li>
<li>灵活：HTTP运行传输任意类型的数据，传输的数据类型由Content-Type标识</li>
<li>无连接：每次TCP连接只处理一个或多个请求<ul>
<li>HTTP1.0版本是一个请求响应之后，直接断开连接。称为短连接</li>
<li>HTTP1.1版本之后，等几秒钟，如果有新的请求，那么还是通过之前的连接通道来手法消息。如果几秒内没有新的请求，则断开连接。称为长连接</li>
</ul>
</li>
<li>无状态</li>
</ul>
<h5 id="3-2-http请求报文"><a href="#3-2-http请求报文" class="headerlink" title="3.2 http请求报文"></a>3.2 http请求报文</h5><p>当浏览器向web服务器发出请求时，它向服务器传递了一个数据库，也就是请求信息(请求报文)，由下面4部分组成：</p>
<ol>
<li>请求行—请求方法/地址 URL协议/版本</li>
<li>请求头(Request Header)，一些属性以键值对的形式存储</li>
<li>空行—为了分割请求头和请求正文</li>
<li>请求正文</li>
</ol>
<p><img src="/2021/09/12/Web-Servlet/HTTP-0.png" alt="HTTP-0"></p>
<h5 id="3-3-http响应报文"><a href="#3-3-http响应报文" class="headerlink" title="3.3 http响应报文"></a>3.3 http响应报文</h5><p>由下面4部分组成：</p>
<ol>
<li>状态行</li>
<li>响应头</li>
<li>空行—为了分割状态行和响应正文</li>
<li>响应正文</li>
</ol>
<p><img src="/2021/09/12/Web-Servlet/HTML-1.png" alt="HTML-1"></p>
<h5 id="3-4-常见状态码"><a href="#3-4-常见状态码" class="headerlink" title="3.4 常见状态码"></a>3.4 常见状态码</h5><div class="table-container">
<table>
<thead>
<tr>
<th>状态码</th>
<th>状态描述</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>200</td>
<td>OK</td>
<td>客户端请求成功</td>
</tr>
<tr>
<td>302</td>
<td>Found</td>
<td>临时重定向</td>
</tr>
<tr>
<td>403</td>
<td>Forbidden</td>
<td>服务器收到请求，但是拒绝提供服务。服务器通常会在响应正文中给出不提供服务的原因</td>
</tr>
<tr>
<td>404</td>
<td>Not Found</td>
<td>请求的资源不存在</td>
</tr>
<tr>
<td>500</td>
<td>Internal Server Error</td>
<td>服务器发生不可预期的错误，导致无法完成客户端的请求</td>
</tr>
</tbody>
</table>
</div>
<h4 id="四、Servlet详解"><a href="#四、Servlet详解" class="headerlink" title="四、Servlet详解"></a>四、Servlet详解</h4><h5 id="4-1-Servlet核心接口和类"><a href="#4-1-Servlet核心接口和类" class="headerlink" title="4.1 Servlet核心接口和类"></a>4.1 Servlet核心接口和类</h5><p>Servlet体系结构中，除了实现Servlet接口，还可以通过集成GenericServlet或HttpServlet类，完成编写。</p>
<p>Servlet接口：在Servlet API中最重要的是servlet接口，所有Servlet都是直接或间接的与该接口发生联系，或是直接实现该接口，或间接继承自实现了该接口的类。</p>
<p>GenericServlet(抽象类)：使编写Servlet变得更容易。要编写一般的Servlet，只需要写抽象的Service方法即可。</p>
<p>HttpServlet[推荐]：是继承GenericServlet的基础上进一步的扩展，根据不同的请求方式做不同的处理，doGet、doPost等。</p>
<p>常见错误：</p>
<ul>
<li>HTTP Status 404 资源找不到<ul>
<li>第一种情况：地址书写错误</li>
<li>地址没有问题，需要将IDEA项目中out目录删除，然后重新运行</li>
</ul>
</li>
<li>Servlet地址配置重复</li>
<li>Servlet地址配置错误</li>
</ul>
<h5 id="4-2-Servlet两种配置方式"><a href="#4-2-Servlet两种配置方式" class="headerlink" title="4.2 Servlet两种配置方式"></a>4.2 Servlet两种配置方式</h5><ol>
<li><p>使用web.xml</p>
<p>url-pattern定义匹配规则，取值说明</p>
<ul>
<li>精确匹配： /具体的名称  只有url后面是具体的名称的时候才会触发Servlet</li>
<li>后缀匹配:   *.xxx      只有是以xxx结尾的就匹配触发Servlet</li>
<li>通配符匹配:  /*    匹配所有请求，包含服务器的所有资源</li>
<li>通配符匹配： /    匹配所有请求，包含服务器的所有资源，不包括.jsp</li>
</ul>
</li>
<li><p>使用注解</p>
<p>使用@WebServlet注解</p>
<ul>
<li>name: Servlet名字(可选)</li>
<li>value: 配置url路径，可以配置多个</li>
<li>urlPatterns: 配置url路径，和value作用一样，不能同时使用</li>
<li>loadOnStartup: 配置Servlet的创建的时机，如果是0或者正数启动程序是创建，如果是负数或不写，则访问是创建。数值越小权限越高</li>
</ul>
</li>
</ol>
<h5 id="4-3-Servlet请求"><a href="#4-3-Servlet请求" class="headerlink" title="4.3 Servlet请求"></a>4.3 Servlet请求</h5><p>Servlet中用来处理客户端请求需要用doGet或doPost方法中的request方法。</p>
<p><img src="/2021/09/12/Web-Servlet/SERVLET-2.png" alt="SERVLET-2"></p>
<p><strong>get/post的区别</strong></p>
<p>get请求：</p>
<ul>
<li>get提交的数据会放在URL之后，以？分割URL和传输数据，参数之间以&amp;相连</li>
<li>get方式明文传递，数据量小，不安全</li>
<li>效率高，浏览器默认请求方式为GET请求</li>
<li>对应的Servlet的方式是doGet</li>
</ul>
<p>post请求：</p>
<ul>
<li>post方法是把提交的数据放在HTTP包的body中</li>
<li>密文传递数据，数据量大，安全</li>
<li>效率相对没有GET高</li>
<li>对应的Servlet的方法是doPost</li>
</ul>
<p><strong>request主要方法</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>String getParameter(String name)</td>
<td>根据表单组件名称获取提交数据</td>
</tr>
<tr>
<td>void setCharacterEncoding(String charset)</td>
<td>指定每个请求的编码</td>
</tr>
</tbody>
</table>
</div>
<h5 id="4-4-request应用"><a href="#4-4-request应用" class="headerlink" title="4.4 request应用"></a>4.4 request应用</h5><p>假如，用户在页面上是通过表单请求的Servlet</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="tag">&lt;<span class="name">meta</span> <span class="attr">cjarset</span>=<span class="string">"UTF-8"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>欢迎页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>欢迎你<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">""</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>姓名：<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"name"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">label</span>&gt;</span>年龄：<span class="tag">&lt;/<span class="name">label</span>&gt;</span><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"age"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(<span class="string">"/HelloServlet"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="title">extend</span> <span class="title">HTTPServlet</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1L</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//获取表单提交的姓名</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        String name = request.getParameter(<span class="string">"name"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//获取年龄</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        String age = request.getParameter(<span class="string">"age"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//服务端打出打印</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(request.getRemoteAddr() + <span class="string">"发来信息：姓名"</span> + name + <span class="string">"；年龄："</span> + age);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpervletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException　</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        doGet(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><strong>get请求收参问题：</strong>产生乱码是因为服务器和客户端沟通的编码不一致造成的，因此解决办法是：在客户端和服务器之间设置一个统一的编码，之后就按照此编码进行数据传输和接受。</p>
<p><strong>get中文乱码：</strong>Tomcat7及以下版本，客户端以UTF-8的编码传输数据到服务器端，而服务器端的request对象使用的是ISO8859-1这个字符编码来接受数据，服务器和客户端沟通的编码不一致因此造成了中文乱码。</p>
<p><strong>解决方法：</strong>在接受到数据后，先获取request对象以ISO8859-1字符编码接受到的原始数据的字节数组，然后通过字节数组以指定的编码构建字符串。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String name = request.getParameter(<span class="string">"name"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">name = <span class="keyword">new</span> String(name.getBytes(<span class="string">"ISO8859-1"</span>),<span class="string">"UTF-8"</span>);</span></pre></td></tr></table></figure>
<p>Tomcat8的版本中get方式不会出现乱码，因为服务器对url的编码格式可以进行自动转换。</p>
<p><strong>post中文乱码：</strong>由于客户端是以UTF-8字符编码将表单数据传输到服务器端的，因此服务器也需要设置以UTF-8字符编码进行接受。</p>
<p><strong>解决方法：</strong>使用从ServletRequest接口继承而来的setCharacterEncoding(charset)方法进行统一的编码设置。</p>
<h5 id="4-5-response应用"><a href="#4-5-response应用" class="headerlink" title="4.5 response应用"></a>4.5 response应用</h5><p>response对象用于响应客户请求并向客户端输出信息。</p>
<p><img src="/2021/09/12/Web-Servlet/RESPONSE-0.png" alt="RESPONSE-0"></p>
<p>response主要方法：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名称</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>setHeader(name, value)</td>
<td>设置响应信息头</td>
</tr>
<tr>
<td>setContentType(String)</td>
<td>设置响应文件类型、响应式的编码格式</td>
</tr>
<tr>
<td>setCharacterEncoding(String)</td>
<td>设置服务端响应内容编码格式</td>
</tr>
<tr>
<td>getWriter()</td>
<td>获取字符输出流</td>
</tr>
</tbody>
</table>
</div>
<p>响应数据给客户端：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//resp.setCharacterEncoding("utf-8"); //设置服务端的编码格式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//resp.setHeader("Content-Type", "text/html;charset=utf-8"); //为了解决客户端中文乱码问题</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">resp.setContentType(<span class="string">"text/html;charset=utf-8"</span>); <span class="comment">//方法二</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">PrintWriter printWriter = resp.getWriter();</span></pre></td></tr><tr><td class="code"><pre><span class="line">printWriter.println(<span class="string">"success!"</span>);</span></pre></td></tr></table></figure>
<h4 id="五、转发与重定向"><a href="#五、转发与重定向" class="headerlink" title="五、转发与重定向"></a>五、转发与重定向</h4><p>将业务逻辑和界面显示的servlet代码分离开后，需要解决两个问题：</p>
<ul>
<li>逻辑处理servlet处理完后，如果跳转到响应的servlet中</li>
<li>响应的servlet中，如何获取逻辑处理servlet中的数据</li>
</ul>
<h5 id="5-1-转发"><a href="#5-1-转发" class="headerlink" title="5.1 转发"></a>5.1 转发</h5><p>转发的作用在服务器端，将请求发送给服务器上的其他资源，以共同完成一次请求的处理。</p>
<h6 id="5-1-1-页面跳转"><a href="#5-1-1-页面跳转" class="headerlink" title="5.1.1 页面跳转"></a>5.1.1 页面跳转</h6><p>在调用业务逻辑的Servlet中，编写一下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">"/目标URL-pattern"</span>).forword(request,response);</span></pre></td></tr></table></figure>
<p>注意：使用forward调转时，是在服务器内部跳转，地址栏不发生变化，属于同一次请求。</p>
<p><img src="/2021/09/12/Web-Servlet/REQUEST-1.png" alt="REQUEST-1"></p>
<h6 id="5-1-2-数据传递"><a href="#5-1-2-数据传递" class="headerlink" title="5.1.2 数据传递"></a>5.1.2 数据传递</h6><p>forward表示一次请求，是在服务器内部跳转，可以共享同一次request作用域中的数据</p>
<ul>
<li>request作用域：拥有存储数据的空间，作用范围是一次请求有效(一次请求可以经过多次转发)<ul>
<li>可以将数据存入request后，在一次请求过程中的任何位置进行获取</li>
<li>可传递任何数据类型(基本数据类型、对象、数据和集和等)</li>
</ul>
</li>
<li>存数据： request.setAttribute(key, value)<ul>
<li>以键值对形式存储在request作用域中。key为String类型，value为Object类型</li>
</ul>
</li>
<li>取数据：request.getAttribute(key)<ul>
<li>通过String类型的key访问Object类型的value</li>
</ul>
</li>
</ul>
<h6 id="5-1-2-转发特点"><a href="#5-1-2-转发特点" class="headerlink" title="5.1.2 转发特点"></a>5.1.2 转发特点</h6><ul>
<li>转发是服务器行为</li>
<li>转发是浏览器只做了一次访问请求</li>
<li>转发浏览器地址不变</li>
<li>转发两次跳转之间传输的信息不会丢失，所以可以通过request进行数据传递</li>
<li>转发只能将请求转发给同一个Web应用中的组件</li>
</ul>
<h5 id="5-2-重定向"><a href="#5-2-重定向" class="headerlink" title="5.2 重定向"></a>5.2 重定向</h5><p>重定向作用在客户端，客户端将请求发送给服务器后，服务器响应给客户端一个新的请求地址，客户端重新发送新请求。</p>
<h6 id="5-2-1-页面跳转"><a href="#5-2-1-页面跳转" class="headerlink" title="5.2.1 页面跳转"></a>5.2.1 页面跳转</h6><p>在调用业务逻辑的servlet中，编写以下代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">"目标URI"</span>);</span></pre></td></tr></table></figure>
<p>URI：统一资源定位符(Uniform Resource Identifier)，用来表示服务器中定位一个资源，资源在web项目中的路径(/project/source)</p>
<p><img src="/2021/09/12/Web-Servlet/REQUEST-2.png" alt="REQUEST-2"></p>
<h6 id="5-2-2-数据传递"><a href="#5-2-2-数据传递" class="headerlink" title="5.2.2 数据传递"></a>5.2.2 数据传递</h6><p>sendRedirect跳转时，地址栏改变，代表客户端重新发送请求。属于两次请求，所以数据没法共享。</p>
<ul>
<li>response没有作用域，两次request请求中的数据无法共享</li>
<li>传递数据：通过URI的拼接进行数据传递(“/project/source?username=tom”);  #<strong>只能是String类型，而且是明文</strong></li>
<li>过去数据：request.getParametre(“username”);</li>
</ul>
<p>注意：重定向可以指向任何资源，包括当前应用程序中的其他资源、同一个站点上的其他应用程序中的资源、其他站点的资源。</p>
<h4 id="六、Servlet的生命周期"><a href="#六、Servlet的生命周期" class="headerlink" title="六、Servlet的生命周期"></a>六、Servlet的生命周期</h4><h5 id="6-1-实例化"><a href="#6-1-实例化" class="headerlink" title="6.1 实例化"></a>6.1 实例化</h5><p>当用户第一次访问Servlet时，由容器调用Servlet的构造器创建具体的Servlet对象。也可以在容器启动之后立刻创建实例(受<load-on-startup>1&lt;/load-on-startup&gt;的影响)。<strong>只执行一次</strong></load-on-startup></p>
<h5 id="6-2-初始化"><a href="#6-2-初始化" class="headerlink" title="6.2 初始化"></a>6.2 初始化</h5><p>在初始化阶段，init()方法会被调用。这个方法在javax.servlet.Servlet接口中定义。<strong>只执行一次</strong></p>
<h5 id="6-3-服务"><a href="#6-3-服务" class="headerlink" title="6.3 服务"></a>6.3 服务</h5><p>当客户端有一个请求时，容器就会将请求ServletRequest与响应ServletResponse对象转给Servlet，以参数的形式传给service方法。<strong>此方法会执行多次</strong></p>
<h5 id="6-4-销毁"><a href="#6-4-销毁" class="headerlink" title="6.4 销毁"></a>6.4 销毁</h5><p>当Servlet容器停止或者重新启动都会引起销毁Servlet对象并调用destroy方法。<strong>destroy方法执行一次</strong></p>
<p><img src="/2021/09/12/Web-Servlet/REQUEST-3.png" alt="REQUEST-3"></p>
<h4 id="七、Servlet特性"><a href="#七、Servlet特性" class="headerlink" title="七、Servlet特性"></a>七、Servlet特性</h4><h5 id="7-1-线程安全问题"><a href="#7-1-线程安全问题" class="headerlink" title="7.1 线程安全问题"></a>7.1 线程安全问题</h5><p>Servlet在访问之后，会执行实例化操作，创建一个Servlet对象。而Tomcat容器可以同时多个线程并发访问同一个Servlet。如果在方法中对成员变量做修改操作，就会有线程安全的问题。</p>
<h5 id="7-2-如何保证线程安全"><a href="#7-2-如何保证线程安全" class="headerlink" title="7.2 如何保证线程安全"></a>7.2 如何保证线程安全</h5><ul>
<li>synchronized<ul>
<li>将存在线程安全问题的代码放到同步代码块中</li>
</ul>
</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//共享变量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> String value = <span class="string">""</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//下执行逻辑</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<ul>
<li>实现SingleThreadModel接口<ul>
<li>servlet实现SingleThreadModel接口后，每个线程都会创建servlet实例，这样每个客户端请求就不存在共享资源的问题，但是servlet响应客户端请求的效率太低，所以已经淘汰</li>
<li>尽可能使用局部变量</li>
</ul>
</li>
</ul>
<h4 id="八、状态管理"><a href="#八、状态管理" class="headerlink" title="八、状态管理"></a>八、状态管理</h4><p>HTTP是无状态的，不能保存每次提交的信息。如果用户发来一个新的请求，服务器无法知道它是否与上次得请求有联系。对于那些需要多次提交数据才能完成得Web操作，就存在问题。</p>
<p>所以需要将浏览器与web服务器之间多次交互当作一个整体来处理，并且将多次交互所涉及得数据(即状态)保存下来。</p>
<p>状态管理分类：</p>
<ul>
<li>客户端状态管理技术：将状态保存在客户端。代表性的有Cookie技术</li>
<li>服务器状态管理技术：将状态保存在服务器端。代表性的是session技术。</li>
</ul>
<p>用户登录成功后，服务器端会生成session信息，并将session的ID发送给客户端，客户端将sessionID保存在Cookie中，在之后的请求中只需要带着sessionID去做认证和授权就可以。</p>
<p><strong>什么是Cookie？</strong></p>
<ul>
<li>Cookie是在浏览器访问web服务器的某个资源时，由Web服务器在HTTP响应消息头中附带传送给浏览器的一小段数据；</li>
<li>一旦Web浏览器保存了某个Cookie，那么它在以后每次访问该Web服务器时，都应在HTTP请求头中将这个Cookie回传给Web服务器；</li>
<li>一个Cookie主要由标识该信息的名称和值组成。</li>
</ul>
<p>下面显示了Cookie的原理：</p>
<p><img src="/2021/09/12/Web-Servlet/Cookie-0.png" alt="Cookie-0"></p>
<p><strong>什么是Session?</strong></p>
<ul>
<li>Session用于记录用户的状态。Session指的是在一段时间内，单个客户端与Web服务器的一连串相关的交互过程。</li>
<li>在一个Session中，客户可能会多次请求访问同一资源，也有可能请求访问各种不同的服务器资源。</li>
</ul>
<p><strong>Session原理</strong></p>
<ul>
<li>服务器会为每一次会话分配一个Session对象</li>
<li>同一个浏览器发起的多次请求，同属一次会话</li>
<li>首次使用到Session时，服务器会自动创建Session，并创建Cookie存储SessionId发送给客户端</li>
</ul>
<p><strong>Session使用</strong></p>
<ul>
<li>Session作用域：拥有存储数据的空间，作用范围是一次会话有效<ul>
<li>一次会话是使用同一浏览器发送的多次请求。一旦浏览器关闭，则结束会话</li>
<li>可以将数据存入Session中，在一次会话的任意位置进行获取</li>
<li>可传递任何数据类型(基本数据类型、对象、集合、数组)</li>
</ul>
</li>
</ul>
<p><strong>获取Session</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.println(session.getId());<span class="comment">//唯一标记</span></span></pre></td></tr></table></figure>
<p><strong>Session生命周期</strong></p>
<ul>
<li>开始：第一次使用到Session的请求产生，则创建Session</li>
<li>结束：<ul>
<li>浏览器关闭，则失效</li>
<li>Session超时，则失效<ul>
<li>session.setMaxInactiveInterval(seconds);//设置最大有效时间(单位：秒)</li>
</ul>
</li>
<li>手工销毁，则失效<ul>
<li>session.invalidate(); //登录退出、注销</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="九、ServletContext对象"><a href="#九、ServletContext对象" class="headerlink" title="九、ServletContext对象"></a>九、ServletContext对象</h4><h6 id="9-1-ServletContext概述"><a href="#9-1-ServletContext概述" class="headerlink" title="9.1 ServletContext概述"></a>9.1 ServletContext概述</h6><ul>
<li>全局对象，拥有作用域，对应一个tomcat中的web应用</li>
<li>当Web服务器启动时，会为每一个Web应用程序创建一块共享的存储区域(ServletContext)</li>
<li>ServletContext在Web服务器启动时创建，服务器关闭时销毁</li>
</ul>
<h6 id="9-2-获取ServletContext对象"><a href="#9-2-获取ServletContext对象" class="headerlink" title="9.2 获取ServletContext对象"></a>9.2 获取ServletContext对象</h6><ul>
<li>GenericServlet提供了getServletContext()方法。this.getServletContext()</li>
<li>HttpServletRequest提供了getServletContext()方法</li>
<li>HttpSession提供了getServletContext()方法</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//通过this.getServletContext()</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ServletContext servletContext = <span class="keyword">this</span>.getServletContext();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//通过request对象获取</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ServletContext servletContext1 = request.getServletContext();</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//通过session对象获取</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">HttpSession session = request.getSession();</span></pre></td></tr><tr><td class="code"><pre><span class="line">ServletContext servletContext2 = session.getServletContext();</span></pre></td></tr></table></figure>
<h6 id="9-3-ServletContext作用"><a href="#9-3-ServletContext作用" class="headerlink" title="9.3 ServletContext作用"></a>9.3 ServletContext作用</h6><ol>
<li>获取项目真实路径</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String realPath = servletContext.getRealPath(<span class="string">"/"</span>);</span></pre></td></tr></table></figure>
<ol>
<li>获取项目上下文路径(应用程序名称)</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String contextPath = servletContext.getContextPath();</span></pre></td></tr></table></figure>
<ol>
<li><p>全局容器</p>
<p>有作用域，可以存储数据到全局容器中</p>
<ul>
<li>存储数据：servletContext.setAttribute(“name”, value);</li>
<li>获取数据：servletContext.getAttribute(“name”);</li>
<li>移除数据：servletContext.removeAttribute(“name”);</li>
</ul>
</li>
</ol>
<h6 id="9-4-特点"><a href="#9-4-特点" class="headerlink" title="9.4 特点"></a>9.4 特点</h6><ul>
<li>唯一性：一个应用对应一个ServletContext</li>
<li>生命周期：只要容器不关闭或者应用不卸载，ServletContext就一直存在</li>
</ul>
<h4 id="十、过滤器"><a href="#十、过滤器" class="headerlink" title="十、过滤器"></a>十、过滤器</h4><p>因为servlet中有冗余的代码，所以需要用到过滤器。</p>
<h5 id="10-1-概念"><a href="#10-1-概念" class="headerlink" title="10.1 概念"></a>10.1 概念</h5><p>过滤器(Filter)是出于客户端与服务器目标资源之间的一道过了技术。</p>
<p><img src="/2021/09/12/Web-Servlet/FILTER-0.png" alt="FILTER-0"></p>
<p>注意：请求前和请求后都需要经过过滤器。</p>
<h5 id="10-2-过滤器作用"><a href="#10-2-过滤器作用" class="headerlink" title="10.2 过滤器作用"></a>10.2 过滤器作用</h5><ul>
<li>执行地位在Servlet之前，客户端发送请求时，会先经过Filter，再到达目标Servlet中；响应时，会根据执行流程再次反向执行Filter。</li>
<li>可以解决多个Servlet共性代码的冗余问题 (如：乱码处理、登录验证)。</li>
</ul>
<h5 id="10-3-编写过滤器"><a href="#10-3-编写过滤器" class="headerlink" title="10.3 编写过滤器"></a>10.3 编写过滤器</h5><p>Servlet API中提供了一个Filter接口，开发人员编写一个java类实现这个接口(过滤器类)即可。</p>
<ul>
<li>编写Java类实现Filter接口</li>
<li>在doFilter方法中编写拦截逻辑</li>
<li>设置拦截路径</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@WebFilter</span>(value = <span class="string">"/target"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFilter</span> <span class="keyword">implements</span> <span class="title">Filter</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(FiltrConfig filterConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilter</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"--MyFilter start--"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//让请求继续传递</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        filterChain.doFilter(servletRequest, servletResponse);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"--MyFilter end--"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"TargetServlet"</span>, value = <span class="string">"/target"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TargetServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"--Target--"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        doPost(request, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h5 id="10-4-过滤器配置"><a href="#10-4-过滤器配置" class="headerlink" title="10.4 过滤器配置"></a>10.4 过滤器配置</h5><ol>
<li><p>注解配置</p>
<p>@WebFilter(value = “/过滤器目标资源”)</p>
</li>
<li><p>xml配置</p>
</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 过滤器的xml配置 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- 名称 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- 过滤器类全城 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>xx.xx.xx<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 映射路径配置 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- 名称 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>xx<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!-- 过滤器的url匹配规则 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span></pre></td></tr></table></figure>
<h5 id="10-5-过滤器链和优先级"><a href="#10-5-过滤器链和优先级" class="headerlink" title="10.5 过滤器链和优先级"></a>10.5 过滤器链和优先级</h5><ol>
<li><p>过滤器链</p>
<p>客户端对服务器请求之后，服务器调用Servlet之前会执行一组过滤器(多个过滤器)，那么这组过滤器就称为一条过滤器链。</p>
<p>每个过滤器实现某个特定的功能，当第一个Filter的doFilter方法被调用时，Web服务器会创建一个代表Filter链的FilterChain对象传递给该方法。在doFilter方法中，开发人员如果调用了FilterChain对象的doFilter方法，则Web服务器会检查FilterChain对象中是否还有filter，如果有，则调用第二个Filter，如果没有，则调用目标资源。</p>
</li>
</ol>
<p><img src="/2021/09/12/Web-Servlet/FILTER-2.png" alt="FILTER-2"></p>
<ol>
<li>过滤器优先级<ul>
<li>如果为注解的话，是按照类全名称的字符串顺序决定作用顺序</li>
<li>如果是web.xml，按照filter-mapping注册顺序，从上往下</li>
<li>web.xml配置高于注解方式</li>
<li>如果注解和web.xml同时配置，会创建多个过滤器对象，造成过滤多次</li>
</ul>
</li>
</ol>
<h5 id="10-6-关于拦截路径"><a href="#10-6-关于拦截路径" class="headerlink" title="10.6 关于拦截路径"></a>10.6 关于拦截路径</h5><p>过滤器拦截路径通常有三种形式：</p>
<ul>
<li>精确拦截匹配：如： /index.jsp</li>
<li>后缀拦截匹配：如： *.jsp</li>
<li>通配符拦截匹配/*，表示拦截所有</li>
</ul>
]]></content>
      <categories>
        <category>Cloud Compute</category>
      </categories>
      <tags>
        <tag>Cloud Compute</tag>
      </tags>
  </entry>
  <entry>
    <title>YOLOv4</title>
    <url>/2021/09/12/YOLOv4/</url>
    <content><![CDATA[<h2 id="YOLOv4-Optimal-Speed-and-Accuracy-of-Object-Detection"><a href="#YOLOv4-Optimal-Speed-and-Accuracy-of-Object-Detection" class="headerlink" title="YOLOv4: Optimal Speed and Accuracy of Object Detection"></a>YOLOv4: Optimal Speed and Accuracy of Object Detection</h2><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>通俗的讲，YOLO-v4算法是在原有YOLO目标检测架构的基础上，采用了近些年CNN领域中最优秀的优化策略，从<strong>数据处理、主干网络、网络训练、激活函数、损失函数</strong>等各个方面都进行了不同程度的优化。</p>
<p><strong>主要贡献点：</strong></p>
<ul>
<li>开发了一个高效而强大的模型，使得任何人都可以使用一张1080Ti或者2080Ti GPU去训练一个超级快速和精确的目标检测器。</li>
<li>在训练期间验证了state-of-art中Bag-of-Freebies和Bag-of-Specials方法的影响。</li>
<li>修改了state-of-the-art方法，使得他们在使用单个GPU进行训练时更加有效和适配，包括CBN，PAN，SAM等。</li>
</ul>
<p>现代检测器通常由两部分组成，在 ImageNet 上<strong>预训练的主干</strong>和用于<strong>预测对象类别和边界框的头部</strong>。对于那些在 GPU 平台上运行的检测器，它们的主干可以是 <code>VGG</code> 、<code>ResNet</code> 、<code>ResNeXt</code> 或 <code>DenseNet</code> 。对于那些在 CPU 平台上运行的检测器，它们的主干可以是 <code>SqueezeNet</code>、<code>MobileNet</code> 或 <code>ShuffleNet</code>。对于头部，通常分为两类，即一级物体检测器和二级物体检测器。最具代表性的两阶段物体检测器是<code>R-CNN</code>系列，包括<code>Fast R-CNN</code>、<code>Faster R-CNN</code>、<code>R-FCN</code>和<code>Libra R-CNN</code> .也可以将两阶段物体检测器变成anchor free 物体检测器，例如 <code>RepPoints</code>。对于单级目标检测器，最具代表性的模型是 <code>YOLO</code>、<code>SSD</code> 和 <code>RetinaNet</code>。近年来，开发了anchor free 单阶段目标检测器。这类检测器有 <code>CenterNet</code>、<code>CornerNet</code>、<code>FCOS</code> 等。 近年来开发的目标检测器经常在主干和头部之间插入一些层，这些层通常用于从不同的阶段收集特征图。我们可以称之为目标检测器的颈部。通常，一个脖子由几个自下而上的路径和几个自上而下的路径组成。配备这种机制的网络包括特征金字塔网络<code>FPN</code>、路径聚合网络 <code>PAN</code>、<code>BiFPN</code> 和 <code>NAS-FPN</code>。 </p>
<p><img src="/2021/09/12/YOLOv4/YOLOV4-0.png" alt="YOLOV4"></p>
<p>综上所述，一个普通的物体检测器由几部分组成： </p>
<ul>
<li><strong>Input:</strong> Image, Patches, Image Pyramid</li>
<li><strong>Backbones:</strong> VGG16, ResNet-50, SpineNet, EfficientNet-B0/B7, CSPResNeXt50</li>
<li><strong>Neck:</strong> <ul>
<li><strong>Additional blocks:</strong> SPP, ASPP, RFB, SAM</li>
<li><strong>Path-aggregation blocks:</strong> FPN, PAN, NAS-FPN, Fully-connected FPN, BiFPN, ASFF, SFAM</li>
</ul>
</li>
<li><strong>Heads:</strong> <ul>
<li><strong>Dense Prediction (one-stage)</strong><ul>
<li>RPN, SSD, YOLO, RetinaNet (anchor based)</li>
<li>CornerNet, CenterNet, MatrixNet, FCOS (anchor free)</li>
</ul>
</li>
<li><strong>Sparse Prediction (two-stage)</strong><ul>
<li>Faster R-CNN, R-FCN, Mask R-CNN (anchor based)</li>
<li>RepPoints (anchor free)</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="二、Bag-of-freebies"><a href="#二、Bag-of-freebies" class="headerlink" title="二、Bag of freebies"></a>二、Bag of freebies</h4><h5 id="2-1-数据增强"><a href="#2-1-数据增强" class="headerlink" title="2.1 数据增强"></a>2.1 数据增强</h5><p>通常，传统的物体检测器是<strong>离线训练</strong>的。因此，研究人员总是喜欢利用这一优势，开发更好的训练方法，使目标检测器在<strong>不增加推理成本的情况下获得更好的准确性</strong>。将这些<strong>只会改变训练策略或只会增加训练成本的方法</strong>称为“<strong>一袋免费赠品</strong>”(Bag of freebies)。对象检测方法经常采用并符合免费赠品袋定义的是<strong>数据增强</strong>。数据增强的目的是<strong>增加输入图像的可变性</strong>，使设计的目标检测模型对<strong>不同环境下获得的图像具有更高的鲁棒性</strong>。例如，<strong>光度失真</strong>和<strong>几何失真</strong>是两种常用的数据增强方法，它们绝对有利于目标检测任务。在处理<strong>光度失真</strong>时，我们<strong>调整图像的亮度、对比度、色调、饱和度和噪声</strong>。对于<strong>几何失真，添加了随机缩放、裁剪、翻转和旋转</strong>。 </p>
<h5 id="2-2-遮挡问题的处理方法"><a href="#2-2-遮挡问题的处理方法" class="headerlink" title="2.2 遮挡问题的处理方法"></a>2.2 遮挡问题的处理方法</h5><p>上面提到的数据增强方法都是逐像素调整的，并且保留了调整区域内的所有原始像素信息。此外，一些从事数据增强的研究人员将重点放在模拟<strong>对象遮挡问题</strong>上。他们在图像分类和目标检测方面取得了很好的效果。例如，<code>random erase</code>和<code>CutOut</code>可以随机选择图像中的矩形区域并填充随机值或补零。至于<code>hide-and-seek</code>和<code>grid mask</code>，它们随机或均匀地选择图像中的多个矩形区域并将它们替换为全零。如果将类似的概念应用于特征图，则有 <code>DropOut</code>、<code>DropConnect</code> 和 <code>DropBlock</code>方法。此外，一些研究人员提出了<strong>将多个图像一起使用来进行数据增强</strong>的方法。例如，<code>MixUp</code>使用两幅图像以不同的系数比例相乘叠加，然后用这些叠加比例调整标签。至于<code>CutMix</code>，就是将裁剪后的图像覆盖到其他图像的矩形区域，并根据混合区域的大小调整标签。除了上述方法外，风格迁移 <code>GAN</code>也被用于数据增强，这种用法可以有效减少 CNN 学习到的纹理偏差。 </p>
<h5 id="2-3-类别不平衡的处理方法"><a href="#2-3-类别不平衡的处理方法" class="headerlink" title="2.3 类别不平衡的处理方法"></a>2.3 类别不平衡的处理方法</h5><p>与上面提出的各种方法不同，其他一些<strong>Bag of freebies</strong>方法专门用于解决<strong>数据集中语义分布可能存在偏差的问题</strong>。在处理语义分布偏差问题时，一个非常重要的问题是<strong>不同类之间存在数据不平衡的问题</strong>，在两阶段物体检测器中，这个问题通常通过<strong>硬负例挖掘</strong>或<strong>在线硬例挖掘</strong>来解决。但是<strong>示例挖掘方法不适用于单级目标检测器</strong>，因为这种检测器属于密集预测架构。因此有人提出了<code>focal loss</code>来解决各个类之间存在的数据不平衡问题。另一个非常重要的问题是，用one-hot hard表示很难表达不同类别之间的关联程度的关系。这种表示方案通常在执行标注时使用。 <strong>标签平滑被提出将硬标签转换为软标签进行训练</strong>，可以使模型更加鲁棒。为了获得更好的软标签，引入了<strong>知识蒸馏的概念来设计标签细化网络</strong>。 </p>
<h5 id="2-4-边界框回归的目标函数"><a href="#2-4-边界框回归的目标函数" class="headerlink" title="2.4 边界框回归的目标函数"></a>2.4 边界框回归的目标函数</h5><p>最后一类<strong>Bag of freebies</strong>是边界框 (BBox) 回归的目标函数。<strong>传统的物体检测器通常使用均方误差</strong>（MSE）直接对BBox的中心点坐标和高宽进行回归，即<script type="math/tex">\{x_{center},y_{center},w,h\}</script>，或者左上点和右下点点，即<script type="math/tex">\{x_{top\_left}, y_{top\_left}, x_{bottom\_right}, y_{bottom\_right}\}</script> 。对于anchor-based方法，就是估计对应的偏移量，例如<script type="math/tex">\{x_{center\_offset}, y_{center\_offset}, w_{offset}, h_{offset}\}</script>和<script type="math/tex">\{x_{top\_left \_offset}, y_{top\_left\_offset}, x_{bottom\_right\_offset}, y_{bottom\_right\_offset}\}</script>。但是，直接估计BBox每个点的坐标值，就是把这些点当成自变量，实际上并没有考虑对象本身的完整性。为了更好地处理这个问题，最近有研究人员提出了<code>IoU loss</code>，它考虑了预测 BBox 区域和地面实况 BBox 区域的覆盖范围。 IoU 损失计算过程会通过触发BBox 四个坐标点与ground truth的IOU的计算，然后将生成的结果连接成一个完整的代码。由于IoU是尺度不变的表示，可以解决传统方法计算{x,y,w,h}的l1或l2损失时，损失会随着尺度增加的问题。最近，一些研究人员继续改进 IoU 损失。例如，<code>GIoU loss</code>除了覆盖区域外，还包括物体的形状和方向。他们提出寻找可以同时覆盖预测BBox和ground truth BBox的最小面积BBox，并用这个BBox作为分母来代替原来在IoU loss中使用的分母。至于<code>DIoU loss</code>，它额外考虑了物体中心的距离，而<code>CIoU loss</code>，另一方面同时考虑了重叠区域、中心点之间的距离和纵横比。 CIoU 在 BBox 回归问题上可以达到更好的收敛速度和精度。 </p>
<h4 id="三、Bag-of-specials"><a href="#三、Bag-of-specials" class="headerlink" title="三、Bag of specials"></a>三、Bag of specials</h4><p>对于那些<strong>只增加少量推理成本</strong>但可以<strong>显着提高目标检测精度</strong>的<strong>插件模块</strong>和<strong>后处理方法</strong>，我们称之为“特价包”(Bag of specials)。 一般来说，这些插件模块是为了增强模型中的某些属性，比如<strong>扩大感受野</strong>，<strong>引入注意力机制</strong>，或者<strong>加强特征整合能力</strong>等，后处理是一种筛选模型预测结果的方法。 </p>
<h5 id="3-1-扩大感受野"><a href="#3-1-扩大感受野" class="headerlink" title="3.1 扩大感受野"></a>3.1 扩大感受野</h5><p>可用于增强感受野的常见模块有<code>SPP</code>、<code>ASPP</code>和<code>RFB</code>。 SPP模块起源于<code>Spatial Pyramid Matching</code>（SPM），SPM的原始方法是将特征图分割成几个d×d相等的块，其中d可以是{1,2,3,…}，因此形成空间金字塔，然后提取词袋特征。 SPP 将 SPM 集成到 CNN 中并使用最大池化操作而不是词袋操作。</p>
<h5 id="3-2-注意力机制"><a href="#3-2-注意力机制" class="headerlink" title="3.2 注意力机制"></a>3.2 注意力机制</h5><p>物体检测中经常使用的注意力模块主要分为<code>channel-wise attention</code>和<code>point-wise attention</code>，这两种注意力模型的代表是<code>Squeeze-and-Excitation</code>（SE）和<code>Spatial Attention Module</code>（SAM），分别。 虽然 SE 模块可以将 ResNet50 在 ImageNet 图像分类任务中的能力提高 1% top-1 准确率，代价是只增加 2% 的计算量，<strong>但在 GPU 上通常会增加大约 10% 的推理时间， 所以更适合用在移动设备上</strong>。 但对于 SAM 来说，它只需要额外支付 0.1% 的计算，就可以将 ResNet50-SE 在 ImageNet 图像分类任务上的 top-1 准确率提高 0.5%。 <strong>最重要的是，它根本不会影响 GPU 上的推理速度。</strong> </p>
<h5 id="3-3-特征整合"><a href="#3-3-特征整合" class="headerlink" title="3.3 特征整合"></a>3.3 特征整合</h5><p>在<strong>特征整合</strong>方面，早期的做法是使用skip connection或hyper-column将低级物理特征整合到高级语义特征。 随着FPN等多尺度预测方法的流行，许多集成不同特征金字塔的轻量级模块被提出。 这类模块包括 <code>SFAM</code>、<code>ASFF</code>和 <code>BiFPN</code>。</p>
<h5 id="3-4-激活函数"><a href="#3-4-激活函数" class="headerlink" title="3.4 激活函数"></a>3.4 激活函数</h5><p>在深度学习的研究中，有人把重点放在<strong>寻找好的激活函数</strong>上。一个好的激活函数可以<strong>让梯度更有效地传播，同时不会造成太多额外的计算成本</strong>。 2010 年，Nair 和 Hinton 提出 <code>ReLU</code> 来实质性地解决传统 <code>tanh</code> 和 <code>sigmoid</code> 激活函数中经常遇到的梯度消失问题。随后，<code>LReLU</code>、<code>PReLU</code>、<code>ReLU6</code>、<code>Scaled Exponential Linear Unit (SELU)</code>、<code>Swish</code>、<code>hard-Swish</code>和 <code>Mish</code>等，其中也用于解决梯度消失问题。 <code>LReLU</code>和<code>PReLU</code>的主要目的是解决输出小于零时<code>ReLU</code>梯度为零的问题。至于 <code>ReLU6</code> 和 <code>hard-Swish</code>，它们是专门为<strong>量化网络</strong>设计的。为了自归一化神经网络，提出了<code>SELU</code>激活函数来满足目标。需要注意的一件事是 <code>Swish</code> 和 <code>Mish</code> 都是连续可微的激活函数。 </p>
<h5 id="3-5-后处理方法"><a href="#3-5-后处理方法" class="headerlink" title="3.5 后处理方法"></a>3.5 后处理方法</h5><p>基于深度学习的物体检测常用的后处理方法是<code>NMS</code>，它可以用来过滤那些对同一物体预测不好的BBox，只保留响应较高的候选BBox。 NMS 尝试改进的方式与优化目标函数的方法一致。 NMS 提出的原始方法没有考虑上下文信息，因此，在R-CNN中增加了分类置信度分数作为参考，按照置信度分数的顺序，按照从高分到低分的顺序进行<strong>贪婪的NMS</strong>。对于 <strong>soft NMS</strong>，它考虑了在具有 IoU 分数的 greedy NMS 中对象的遮挡可能导致置信度下降的问题。 <strong>DIoU NMS</strong> 开发者的思路是在软 NMS 的基础上，在 BBox 筛选过程中加入中心点距离信息。<strong>由于上述后处理方法都没有直接参考捕获的图像特征，因此在后续开发anchor-free方法时不再需要进行后处理。</strong> </p>
<h4 id="四、YOLOv4"><a href="#四、YOLOv4" class="headerlink" title="四、YOLOv4"></a>四、YOLOv4</h4><p>对于分类而言最佳的参考模型对于检测器而言并不总是最佳的。 与分类器相比，检测器需要以下内容： </p>
<ul>
<li>更高的输入网络尺寸（分辨率）—用于检测多个小尺寸物体 </li>
<li>更多层 - 用于更高的感受野以覆盖增加的输入网络大小 </li>
<li>更多参数 - 提高模型在单个图像中检测多个不同大小对象的能力 </li>
</ul>
<p>可以假设应该选择具有更大感受野大小（具有更大数量的卷积层 3 × 3）和更多参数的模型作为主干。</p>
<p><img src="/2021/09/12/YOLOv4/YOLOV4-1.png" alt="YOLOV4"></p>
<p>不同大小感受野的影响总结如下: </p>
<ul>
<li>达到对象大小 - 允许查看整个对象 </li>
<li>最大网络大小 - 允许查看对象周围的上下文 </li>
<li>超过网络大小 - 增加图像点和最终激活之间的连接数 </li>
</ul>
<p>YOLOv4在 <code>CSPDarknet53</code> 上添加了 <code>SPP</code> 块，因为它显着增加了感受野，分离出最重要的上下文特征，并且几乎不会降低网络运行速度。 并且使用 <code>PANet</code> 作为不同检测器级别的不同主干级别的参数聚合方法，而不是 YOLOv3 中使用的 <code>FPN</code>。 </p>
<p>最后，YOLOv4选择 <code>CSPDarknet53</code> <strong>主干</strong>、<code>SPP</code> <strong>附加模块</strong>、<code>PANet 路径聚合</code> <strong>颈部</strong>和 <code>YOLOv3</code>（基于锚点）<strong>头部 </strong>作为 YOLOv4 的架构。 </p>
<p><img src="/2021/09/12/YOLOv4/YOLOV4-3.png" alt="YOLOV4"></p>
<h4 id="五、Selection-of-BoF-and-BoS"><a href="#五、Selection-of-BoF-and-BoS" class="headerlink" title="五、Selection of BoF and BoS"></a>五、Selection of BoF and BoS</h4><p>为了改进目标检测训练，CNN 通常使用以下内容： </p>
<ul>
<li>激活：ReLU、leaky-ReLU、参数化 ReLU、ReLU6、SELU、Swish 或 Mish</li>
<li>边界框回归损失：MSE、IoU、GIoU、CIoU、DIoU</li>
<li>数据增强：CutOut、MixUp、CutMix</li>
<li>正则化方法：DropOut、DropPath、Spatial DropOut 或 DropBlock</li>
<li>通过均值和方差对网络激活进行归一化：批归一化 (BN) [32]、跨 GPU 批归一化（CGBN 或 SyncBN）、滤波器响应归一化 (FRN) 或交叉迭代批处理 归一化 (CBN) </li>
<li>跳过连接：残差连接、加权残差连接、多输入加权残差连接或跨阶段部分连接 (CSP) </li>
</ul>
<p>为了使设计的检测器更适合在单GPU上训练，作者做了如下额外的设计和改进： </p>
<ul>
<li>引入了数据增强(Mosaic)混合了4个训练图像和Self-Adversarial Training (SAT) 的新方法</li>
<li>在应用遗传算法的同时选择最佳超参数 </li>
<li>修改了一些现有的方法，使我们的设计适合高效的训练和检测-修改的 SAM、修改的 PAN 和交叉小批量归一化 (CmBN) </li>
</ul>
<p>Mosaic 代表了一种新的数据增强方法，它混合了四张训练图像，使其按一定比例组合成一张图像，使模型学会在更小的范围内识别对象。 因此混合了 4 个不同的上下文，而 CutMix 仅混合了 2 个输入图像。 这允许检测正常上下文之外的对象。 此外，批量归一化计算每层 4 个不同图像的激活统计数据。 这显着减少了对大 mini-batch 大小的需求。 </p>
<p><img src="/2021/09/12/YOLOv4/YOLOV4-5.png" alt="YOLOV4"></p>
<p>自我对抗训练 (SAT) 也代表了一种新的数据增强技术，它在 2 个前向后向阶段中运行。 在第一阶段，神经网络改变原始图像而不是网络权重。 通过这种方式，神经网络对自身执行对抗性攻击，改变原始图像以制造图像上没有所需对象的欺骗。 在第二阶段，训练神经网络以正常方式检测此修改图像上的对象。 </p>
<p><img src="/2021/09/12/YOLOv4/YOLOV4-2.png" alt="YOLOV4"></p>
<p><a href="https://arxiv.org/pdf/2004.10934v1.pdf" target="_blank" rel="noopener">论文地址</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/137393450" target="_blank" rel="noopener">参考内容1</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/161083602" target="_blank" rel="noopener">参考内容2</a></p>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>YOLOv3</title>
    <url>/2021/09/12/YOLOv3/</url>
    <content><![CDATA[<h2 id="YOLOv3-An-Incremental-Improvement"><a href="#YOLOv3-An-Incremental-Improvement" class="headerlink" title="YOLOv3: An Incremental Improvement"></a>YOLOv3: An Incremental Improvement</h2><p>YOLOv3没有太多的创新，主要是借鉴一些好的方案融合到YOLO里面。在保持速度优势的前提下，提升了预测精度，尤其是加强了对小物体的识别能力。<a href="https://www.jianshu.com/p/d13ae1055302" target="_blank" rel="noopener">论文地址</a></p>
<h4 id="一、YOLOv3的改进"><a href="#一、YOLOv3的改进" class="headerlink" title="一、YOLOv3的改进"></a>一、YOLOv3的改进</h4><h5 id="1-1-多尺度预测-类FPN，特征金字塔网络"><a href="#1-1-多尺度预测-类FPN，特征金字塔网络" class="headerlink" title="1.1 多尺度预测(类FPN，特征金字塔网络)"></a>1.1 多尺度预测(类FPN，特征金字塔网络)</h5><p><img src="/2021/09/12/YOLOv3/YOLOV3.png" alt="YOLOv3"></p>
<p>为了识别更多的物体，尤其小物体，YOLOv3使用三个不同尺度进行预测。三个不同尺度步幅分别是32、16和8。如果输入416&times;416大小的图像，检测尺度分别为13&times;13，26&times;26和52&times;52。YOLOv3使用k-means从coco数据集的anchor box中预测了9个不同尺寸的先验框，然后均分给三个不同的预测尺寸。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>特征图</th>
<th style="text-align:center">13 <script type="math/tex">\ast</script>13</th>
<th style="text-align:center">26 <script type="math/tex">\ast</script>26</th>
<th style="text-align:center">52 <script type="math/tex">\ast</script>52</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>感受野</strong></td>
<td style="text-align:center">大</td>
<td style="text-align:center">中</td>
<td style="text-align:center">小</td>
</tr>
<tr>
<td><strong>先验框</strong></td>
<td style="text-align:center">(116<script type="math/tex">\times</script>90)</td>
<td style="text-align:center">(156<script type="math/tex">\times</script>198)</td>
<td style="text-align:center">(373<script type="math/tex">\times</script>326)</td>
<td>(30<script type="math/tex">\times</script>61)</td>
<td>(62<script type="math/tex">\times</script>45)</td>
<td>(59<script type="math/tex">\times</script>119)</td>
<td>(10<script type="math/tex">\times</script>13)</td>
<td>(16<script type="math/tex">\times</script>30)</td>
<td>(33<script type="math/tex">\times</script>23)</td>
</tr>
</tbody>
</table>
</div>
<h5 id="1-2-使用了更好的基础分类网络-类ResNet-和分类器"><a href="#1-2-使用了更好的基础分类网络-类ResNet-和分类器" class="headerlink" title="1.2 使用了更好的基础分类网络(类ResNet)和分类器"></a>1.2 使用了更好的基础分类网络(类ResNet)和分类器</h5><p><img src="/2021/09/12/YOLOv3/YOLOV3-1.png" alt="YOLOV3"></p>
<p><a href="https://www.cnblogs.com/makefile/p/YOLOv3.html" target="_blank" rel="noopener">上图来自</a>其中网络相比YOLOv2更加复杂了，去除了pooling层，改用stride=2的卷积层代替，并且添加了residual block。</p>
<p><strong>评分函数(score function):</strong> 原始图像数据到类别分值的映射。</p>
<p>多分类问题，一般使用Softmax分类器(Softmax层)，对应的表达式为：</p>
<script type="math/tex; mode=display">
S=\frac{e^s}{\sum^{C}_{j=1}e^{s_j}}</script><p><strong>损失函数(loss function):</strong> 用来量化预测分类标签的得分与真实标签之间一致性。</p>
<p>Sofemax一般对应log损失，表达式如下：</p>
<script type="math/tex; mode=display">
L=-\log\frac{e^s}{\sum^{C}_{j=1}e{^s_j}}=-s+\,\log\sum^{C}_{j=1}e^{s_j}</script><p>YOLOv3中不使用Softmax分类器，而是使用使用<strong>独立的多个logistic分类器</strong>替代，<strong>分类损失</strong>使用binary cross-entropy loss。</p>
<p><strong>Logistic回归(LR)</strong>，是一种常用语处理二分类问题的模型。</p>
<script type="math/tex; mode=display">
h_{\theta}(x)=g(\theta^Tx)=\frac{1}{1+\,\,e^{-\theta^Tx}},g(z)=\frac{1}{1+e^{-z}}(sigmoid\,\,函数),x代表样本的特征向量</script><script type="math/tex; mode=display">h_{\theta}(x)$$可看做预测为正类的概率，即后验概率$$h_{\theta}(x)=p(y=1|x;\theta),h_\theta(x)\in(0,1)</script><script type="math/tex; mode=display">
判别类型：\begin{cases}
h_{\theta}\ge0.5,预测\hat{y}=1,\quad if\,\,\theta^Tx\gt0\\
h_{\theta}\lt0.5,预测\hat{y}=0,\quad if\,\,\theta^Tx\lt0\\
\end{cases}\\
损失函数：J(\theta)=\frac{1}{m}\sum^{m}_{i=1}cost(h_{\theta}(x^i),y^i)\\
cost(h_{\theta}(x^i),y^i)=\begin{cases}
-\log(h_{\theta(x)})\quad if\,\,y=1\\
-\log(1-h_{\theta(x)})\quad if\,\,y=0\\
\end{cases}\\
J(\theta)=\frac{1}{m}\sum^{m}_{i=1}[-j^{(i)}\log(h_{\theta}(x^{(i)}))-(1-y^{(i)})\log(1-h_{\theta}(x^{(i)}))]</script><p>上式<script type="math/tex">J(\theta)</script>称为对数似然损失函数，也称作交叉熵损失函数(cross entropy loss)。</p>
<p>Logistic为了防止过拟合，不仅要对输入的数据进行处理，还需要对超参数做正则化处理。</p>
<script type="math/tex; mode=display">
J(\theta)=\frac{1}{m}\sum^{m}_{i=1}[-j^{(i)}\log(h_{\theta}(x^{(i)}))-(1-y^{(i)})\log(1-h_{\theta}(x^{(i)}))]+\,\frac{\lambda}{2m}\sum^{n}_{j=1}\theta^2_j</script><p><strong>Softmax回归</strong>，处理多分类问题。</p>
<script type="math/tex; mode=display">
h_{\theta}(x^{(i)})=\begin{bmatrix}
p(y^{(i)}=1 | x^{(i)};\theta)\\
p(y^{(i)}=2 | x^{(i)};\theta)\\
{\vdots}\\
p(y^{(i)}=k | x^{(i)};\theta)\\
\end{bmatrix}=\frac{1}{\sum^{k}_{j=1}e^{\theta^T_jx^{(i)}}}\begin{bmatrix}
e^{\theta^T_1x^{(i)}}\\
e^{\theta^T_2x^{(i)}}\\
{\vdots}\\
e^{\theta^T_kx^{(i)}}\\
\end{bmatrix}</script><p>上式中，k为待分类的类别数。<script type="math/tex">\frac{1}{\sum^{k}_{j=1}e^{\theta^T_jx^{(i)}}}</script>对概率分布进行归一化，所有概率和为1。损失函数为：</p>
<script type="math/tex; mode=display">
J(\theta)=-\frac{1}{m}\Big[\sum^{m}_{i=1}\sum^{k}_{j=1}1\{y^{(i)}=j\}\log\frac{e^{\theta^T_jx^{(i)}}}{\sum^{k}_{l=1}e^{\theta^T_lx^{(i)}}}\Big]</script><p>同样，需要对参数进行正则化，因为对参数<script type="math/tex">\theta</script>减去一个参数，对结果没影响，即模型不唯一。加入正则项后的loss函数为：</p>
<script type="math/tex; mode=display">
J(\theta)=-\frac{1}{m}\Big[\sum^{m}_{i=1}\sum^{k}_{j=1}1\{y^{(i)}=j\}\log\frac{e^{\theta^T_jx^{(i)}}}{\sum^{k}_{l=1}e^{\theta^T_lx^{(i)}}}\Big]+\,\frac{\lambda}{2}\sum^{k}_{i=1}\sum^{n}_{j=0}\theta^2_{ij}</script><p>上面分别介绍了Logistic回归和Softmax回归的处理逻辑，那么Logistic常用与二分类问题，要实现多分类问题，则需要改进。有两种方法：</p>
<ul>
<li>直接根据每个类别，分别建立一个二分类器，带有正确类别的样本标记为1，其他类别的样本标记为0。那么针对k个类别，最后得到k个logistic分类器。<ul>
<li>挑选出标记为<script type="math/tex">c(c\le k)</script>的样本，将挑选出来的带有标记c的样本的标记置为1，将剩下的不带有标记c的样本的标记置为0。然后就用这些数据训练出一个分类器；</li>
<li>重复此步骤，最终得到k个不同的分类器；</li>
<li>针对一个测试样本，需要找到这k个分类函数输出值最大的那一个，即为测试样本的标记：<script type="math/tex">arg\,\max_{c}h_c(x)\quad c=1,2,...,k</script>。</li>
</ul>
</li>
<li>修改logistic回归的损失函数，让其适应多分类，即softmax回归。</li>
</ul>
<p>对于选择softmax分类器还是k个logistic分类器，取决于所有类别之间是否互斥。所有类别之间明显互斥用softmax分类器，所有类别之间不互斥有交叉的情况下最好用k个logistic分类器。</p>
<h4 id="二、YOLOv3损失函数"><a href="#二、YOLOv3损失函数" class="headerlink" title="二、YOLOv3损失函数"></a>二、YOLOv3损失函数</h4><p>YOLOv3最大的变动是分类损失换成了<strong>二分交叉熵</strong>，这是由于yolov3中剔除了softmax改用logistic。</p>
<script type="math/tex; mode=display">
Loss=\lambda_{coord}\sum^{S^2}_{i=0}\sum^{B}_{j=0}I^{obj}_{ij}[(x_i-\hat{x}_i^j)^2+(y_i-\hat{y}_i^j)^2]+\\\lambda_{coord}\sum^{S^2}_{i=0}\sum^{B}_{j=0}I^{obj}_{ij}[(\sqrt{w^j_i}-\sqrt{\hat{w}^j_i})^2+(\sqrt{h}^j_i-\sqrt{\hat{h}^j_i})^2]-\\
\sum^{S^2}_{i=0}\sum^{B}_{j=0}I^{obj}_{ij}[\hat{C}^j_i\log(C^j_i)+(1-\hat{C}^j_i)\log(1-C^j_i)]-\\
\lambda_{noobj}\sum^{S^2}_{i=0}\sum^{B}_{j=0}I^{noobj}_{ij}[\hat{C}^j_i\log(C^j_i)+\,(1-\hat{C}^j_i)\log(1-C^j_i)-\\
\sum^{S^2}_{i=0}I^{obj}_{ij}\sum_{c\in classes}([\hat{P}^j_i\log(P^j_i)+\,(1-\hat{P}^j_i)\log(1-P^j_i)])</script><p>网格一共是 S ∗ S 个，每个网格产生 B 个候选框anchor box，每个候选框会经过网络最终得到相应的bounding box。最终会得到 S ∗ S ∗ B 个bounding box。<script type="math/tex">I_{ij}^{obj}</script>表示第i个网格的第j个anchor box是否负责这个object。如果负责<script type="math/tex">I_{ij}^{obj}=1</script>，否则为0。<strong>那么如何定义负责呢？</strong>第i个网格的B个anchor box中与目标的ground truth的IOU最大的anchor负责预测这个目标，此时<script type="math/tex">I_{ij}^{obj}=1</script>。其中，<script type="math/tex">\lambda_{coord}=2-w\ast h</script>为了加大对小框的损失，更好的检测出小目标。</p>
<p><strong>YOLOv3的误差分为四项</strong>，分别是：</p>
<ol>
<li><p>中心坐标误差</p>
<p>当第 i 个网格的第 j 个anchor box负责某一个真实目标时，网络输出为<script type="math/tex">t_x,t_y</script>,然后通过<script type="math/tex">\sigma(t_x),\sigma(t_y)</script>转换后乘以多次的卷积步长，就可以映射到416&times;416大小的训练图像上的目录了。最后与ground truth计算误差。<script type="math/tex">\sigma为sigmoid</script>函数</p>
</li>
<li><p>宽高坐标误差</p>
<p>当第 i 个网格的第 j 个anchor box负责某一个真实目标时，公式中的宽和高<script type="math/tex">w^j_i=t_w\ast stride,h^j_i=t_h\ast stride</script>。</p>
</li>
<li><p>置信度误差</p>
<p>置信度误差使用交叉熵来表示，不管anchor box是否负责某个目标，都会计算置信度误差。因为置信度表示：框出的box内确实有物体的自信程度和框出的box将整个物体的所有特征都包括进来的自信程度。</p>
<p>损失函数分为两部分：<strong>有物体，没有物体</strong>。其中没有物体损失部分还增加了权重系数<script type="math/tex">\lambda_{noobj}</script>。添加权重系数的原因是，对于一幅图像，一般而言大部分内容是不包含待检测物体的，这样会导致没有物体的计算部分贡献会大于有物体的计算部分，这会导致网络倾向于预测单元格不含有物体。因此，要减少没有物体计算部分的贡献权重，可以取值为0.5。</p>
</li>
<li><p>分类误差</p>
<p>分类误差也是选择交叉熵作为损失函数。当第 i i i个网格的第 j j j个anchor box负责某一个真实目标时，那么这个anchor box所产生的bounding box才会去计算分类损失函数。</p>
</li>
</ol>
<h4 id="三、anchor-box的计算"><a href="#三、anchor-box的计算" class="headerlink" title="三、anchor box的计算"></a>三、anchor box的计算</h4><p>网络预测的bounding box为<script type="math/tex">t_x，t_y，t_w，t_h</script>,而真实需要与Ground Truth进行计算误差的预测box为<script type="math/tex">b_x,b_y,b_w,b_h</script>(训练时需要将GT逆运算转为<script type="math/tex">g_x,g_y,g_w,g_h</script>)。那么两者之间如何转换呢？</p>
<script type="math/tex; mode=display">c_x,c_y$$的坐标范围是针对grid cell的，也就是将原图划分成13&times;13，则$$c_x,c_y$$坐标为:</script><p>\begin{pmatrix}<br>(0,0)&amp;(0,1)&amp;(0,2)&amp;\cdots&amp;(0,12)\\<br>(1,0)&amp;(1,1)&amp;(1,2)&amp;\cdots&amp;(1,12)\\<br>\vdots&amp;\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\<br>(12,0)&amp;(12,1)&amp;(12,2)&amp;\cdots&amp;(12,12)\\<br>\end{pmatrix}</p>
<script type="math/tex; mode=display">
对于宽、高$$b_w=a_we^{t_w},b_h=a_he^{t_h},a_w和a_h为anchor\,\,box(prior)的宽和高，t_w和t_h为网络预测的宽和高，b_w和b_h为转换后预测的宽、高。</script><p>对于x和y，<script type="math/tex">b_x=\sigma(t_x)+c_x,b_y=\sigma(t_y)+c_y</script>。为什么要使用<script type="math/tex">\sigma,sigmoid</script>函数将网络预测的坐标压缩到[0,1]呢？</p>
<ol>
<li>为了更好的在训练时候让模型收敛；</li>
<li>让坐标位于每个grid cell中，更加精确的计算偏移量，以及将box确切分配负责到某一个目标。如13 ∗ 13 的feature map中，某个目标的中心点预测为(0.4,0.7)【<strong>都小于1</strong>】，它的<script type="math/tex">c_x，c_y</script>即中心落入的grid cell坐标是(6,6)，则该物体的在feature map中的中心实际坐标显然是(6.4,6.7)，不能大于1。</li>
</ol>
<p><strong>最后一层feature map中的特征如何与GT中的目标对应？</strong></p>
<p>将原始图像分割为最后预测图维度大小的网格。如下图所示，输入图像维度为416&times;416，步幅为32（最后的预测图降采样32倍），最后预测图维度为13&times;13，所以将原始图像划分为13&times;13的网格。图中原始图中的红框是GT的中心，所以该cell负责对目标进行预测，对应到feature map中的那个红点。</p>
<p><img src="/2021/09/12/YOLOv3/YOLOV3-2.png" alt="YOLOV3"></p>
<p>那么feature map中的红点会预测k个prior bounding box。具体选用那个呢？需要计算与GT 的IOU，选取最大的那个。与GT匹配的anchor box计算坐标误差、置信度误差（此时target为0）以及分类误差，而其他anchor box只计算置信度误差（此时target为0）。</p>
<p>至于为什么需要k-means预测prior bounding box, 因为目标有不同的形状和长宽比，所以，需要预先预测一些先验的anchor box的长和宽。在网络预测出<script type="math/tex">t_w和t_h</script>之后，对框做一些约束。YOLOv2开始引入anchor机制后，不再与YOLOv1那样直接预测框的坐标，而是预测偏移值，<strong>通过学习偏移值，就可以通过网络原始定的anchor box坐标经过线性回归微调去逐渐靠近GT框</strong>。</p>
<p>注意：<strong>位置上不使用anchor框，宽高上使用anchor框。</strong>位置是根据与gird左上角坐标的偏移值预测的。</p>
<p><strong>多尺度预测</strong></p>
<p><img src="/2021/09/12/YOLOv3/YOLOV3-3.png" alt="YOLOV3"></p>
<p><strong>为什么在计算Ground Truth的<script type="math/tex">t_w,t_h</script>时需要缩放到对数空间？</strong></p>
<p>不直接回归bounding box的长宽，而是<strong>为避免训练带来不稳定的梯度</strong>，将尺度缩放到对数空间。 如果直接预测相对形变tw 和 th，那么要求tw,th&gt;0，因为框的宽高不可能是负数，这样的话是在做一个有不等式条件约束的优化问题，没法直接用SGD来做，所以先取一个对数变换，将其不等式约束去掉就可以了。</p>
<p><a href="https://blog.csdn.net/weixin_41065383/article/details/89413819" target="_blank" rel="noopener">参考：CNN损失函数</a></p>
<p><a href="https://blog.csdn.net/guo1988kui/article/details/79540508" target="_blank" rel="noopener">参考：线性分类器和损失函数</a></p>
<p><a href="https://blog.csdn.net/qq_43211132/article/details/102668037" target="_blank" rel="noopener">参考：Logistic和Softmax详细介绍</a></p>
<p><a href="https://blog.csdn.net/weixin_43384257/article/details/100986249" target="_blank" rel="noopener">参考：YOLOV3损失函数详细讲解</a></p>
<p><a href="https://www.jianshu.com/p/043966013dde" target="_blank" rel="noopener">参考：YOLOV3</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/367395847" target="_blank" rel="noopener">参考：YOLOV3查漏补缺</a></p>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Object-Detection-Survey</title>
    <url>/2021/09/12/Object-Detection-Survey/</url>
    <content><![CDATA[<h2 id="目标检测的简单综述"><a href="#目标检测的简单综述" class="headerlink" title="目标检测的简单综述"></a>目标检测的简单综述</h2><p>下面是对目标检测综述性论文的总结学习笔记</p>
<p>Deep Learning for Generic Object Detection: A Survey <a href="https://arxiv.org/pdf/1809.02165v1.pdf" target="_blank" rel="noopener">论文链接</a></p>
<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p><strong>目标检测</strong>的目标是<strong>确定在某个给定图像中是否存在来自给定类别</strong>（例如人类、汽车、自行车、狗和猫）的任何对象实例，<strong>如果存在，则返回每个对象实例的空间位置和范围。</strong>在<strong>通用的目标检测</strong>中，它更加强调<strong>检测范围广泛的自然类别</strong>，而不是特定对象类别检测，在特定对象类别检测中，可能只存在较窄的预定义的感兴趣类别（例如，人脸、行人或汽车）。 尽管在我们生活的视觉世界中占据着数以千计的物体，但目前研究界主要对<strong>高度结构化物体</strong>（例如汽车、人脸、自行车和飞机）和<strong>铰接物体</strong>（例如人类、奶牛和 马）而不是<strong>非结构化的场景</strong>（如天空、草和云）。</p>
<p><strong>复杂场景的发展：</strong>图像级对象分类-&gt;单个对象定位-&gt;通用对象检测-&gt;像素级对象分割。</p>
<h4 id="1、面对的挑战："><a href="#1、面对的挑战：" class="headerlink" title="1、面对的挑战："></a>1、<strong>面对的挑战：</strong></h4><ul>
<li><p><strong>高准确性</strong>：必须准确定位和识别图像或视频帧中的对象，以便可以区分现实世界中种类繁多的对象类别。</p>
<ul>
<li><p>大量的类内变化</p>
<ul>
<li>内在因素：每个对象类别可以有许多不同的对象实例，可能在颜色、纹理、材料、形状和大小中的一个或多个方面有所不同。</li>
<li>成像条件：由成像条件的变化和不受约束的环境引起。不同的时间、地点、天气条件、相机、背景、照明、视点和观看距离。 所有这些条件都会产生物体外观的显着变化，例如照明、姿势、比例、遮挡、背景杂乱、阴影、模糊和运动。此外， 数字化伪影、噪声破坏、分辨率差和滤波失真可能会增加进一步的挑战。 </li>
</ul>
</li>
<li><p>大量的对象类别 </p>
<p>数量级为 10<sup>4</sup>-10<sup>5</sup> 的大量对象类别需要检测器的强大辨别能力来区分细微不同的类间变化。</p>
</li>
</ul>
</li>
<li><p><strong>高效率</strong>：要求整个检测任务以足够高的帧率运行，并具有可接受的内存和存储使用率。</p>
<ul>
<li>图像数量呈指数级增长，需要高效且可扩展的检测器。 社交媒体网络和移动/可穿戴设备的流行导致对视觉数据分析的需求不断增加。 然而，移动/可穿戴设备的计算能力和存储空间有限，在这种情况下，高效的物体检测器至关重要。 </li>
<li>可扩展性：检测器应该能够处理看不见的物体、未知的情况和快速增加的图像数据。随着图像数量和类别数量越来越大，手动注释它们可能变得不可能，迫使算法更多地依赖弱监督训练数据。</li>
</ul>
</li>
</ul>
<h4 id="2、发展历程"><a href="#2、发展历程" class="headerlink" title="2、发展历程"></a>2、<strong>发展历程</strong></h4><ol>
<li>对象识别的早期研究基于<strong>模板匹配技术</strong>和<strong>基于简单部件的模型</strong>，重点关注<strong>空间布局大致刚性的特定对象</strong>，例如人脸。 1990 年之前，对象识别的主要范式是<strong>基于几何表示</strong>，后来重点从<strong>几何和先验模型</strong>转向使用基于<strong>外观特征的统计分类器</strong>（例如神经网络、SVM  和 Adaboost )  。这个成功的目标检测器系列为该领域的大多数后续研究奠定了基础。</li>
<li>在 1990 年代末和 2000 年代初，目标检测研究取得了显着进展。其中最重要的两个算法是SIFT和DCNN。<strong>外观特征</strong>从<strong>全局</strong>表示<strong>转移到局部</strong>表示，这些表示对于平移、缩放、旋转、照明、视点和遮挡的变化是不变的。从尺度不变特征变换 (SIFT) 特征开始，<strong>手工制作的局部不变特征获得了极大的欢迎</strong>，各种视觉识别任务的进展主要基于<strong>局部描述符</strong>的使用，例如 Haar like特征，SIFT，Shape Context，梯度直方图(HOG)和局部二元模式(LBP)，协方差。这些局部特征通常通过简单的<strong>串联或特征池</strong>编码器聚合。</li>
<li>直到 2012 年的重大转折点，<strong>深度卷积神经网络</strong> (DCNN) 在图像分类中的成功应用转移到对象检测，从而产生了 Girshicketal 的里程碑式<strong>基于区域</strong>的 CNN (RCNN) 检测器。从那时起，对象检测领域发生了巨大的发展，并且开发了许多基于深度学习的方法，这在一定程度上要归功于<strong>可用的GPU计算资源</strong>以及<strong>大规模数据集</strong>的可用性和挑战。</li>
</ol>
<h4 id="3、检测器的分类"><a href="#3、检测器的分类" class="headerlink" title="3、检测器的分类"></a>3、<strong>检测器的分类</strong></h4><ul>
<li><p>两阶段检测框架，其中包括区域提议的预处理步骤，使整个管道成为两阶段。 </p>
<p>在基于区域的框架中，从图像中<strong>生成与类别无关的区域提议</strong>，从这些区域中提取CNN特征，然后使用<strong>特定类别的分类器来确定提议的类别标签</strong>。 </p>
</li>
<li><p>单阶段检测框架，或无区域提议框架，这是一种不分离检测提议的单一提议方法，使整个管道成为单个阶段。 </p>
</li>
</ul>
<h4 id="4、部分两阶段检测器框架"><a href="#4、部分两阶段检测器框架" class="headerlink" title="4、部分两阶段检测器框架"></a>4、部分两阶段检测器框架</h4><p><strong>RCNN：</strong></p>
<ul>
<li>类别不可知的<strong>区域提议(region proposals)</strong>，即可能包含对象的候选区域，通过<strong>selective search</strong>获得； </li>
<li>从图像中<strong>裁剪(crop)</strong>并<strong>变形(warp)</strong>区域提议为适合网络输入的尺寸，用作<strong>微调</strong>使用大规模数据集(如 ImageNet)<strong>预训练的CNN模型</strong>的<strong>输入</strong>；</li>
<li>使用CNN提取的<strong>固定长度特征</strong>训练一组<strong>特定于类的线性SVM分类器</strong>，<strong>取代</strong>通过<strong>微调学习的soft-max分类器</strong>；</li>
<li>使用CNN特征为每个对象类学习边界框回归。 </li>
</ul>
<p>下面为整个RCNN的训练和测试过程，不同的箭头代表了不同的阶段。</p>
<p><img src="/2021/09/12/Object-Detection-Survey/rcnn.png" alt="Object-Detection"></p>
<p><strong>缺点：</strong></p>
<ul>
<li>训练是一个多阶段的复杂管道，它不优雅、缓慢且难以优化，因为每个阶段都必须单独训练。 </li>
<li>需要从外部检测大量仅提供粗略定位的区域建议。 </li>
<li>训练 SVM 分类器和边界框回归在磁盘空间和时间上都是昂贵的，因为 CNN 特征是从每个图像的每个区域提议中独立提取的，这对大规模检测提出了巨大挑战，特别是非常深的 CNN 网络。 </li>
<li>测试很慢，因为每个测试图像中的每个对象建议都提取了 CNN 特征。 </li>
</ul>
<p><strong>SPPNet：</strong>在测试期间，CNN 特征提取是 RCNN 检测管道的主要瓶颈，它需要从图像的数千个warped<strong>区域建议</strong>中提取CNN特征。注意到这些明显的缺点，Heet al.将传统的空间金字塔池化 (SPP) 引入CNN架构。由于卷积层接受任意大小的输入，因此 <strong>CNN 中对固定大小图像的要求仅是由于全连接 (FC) 层</strong>，Heet al.发现了这一事实并在<strong>最后一个卷积</strong> (CONV) 之上添加了一个 <strong>SPP 层</strong>获得FC层的固定长度特征。使用这个 SPPnet，RCNN 在不牺牲任何检测质量的情况下获得了显着的加速，因为它只需要在整个测试图像上运行一次卷积层即可为任意大小的区域提议生成固定长度的特征。<strong>虽然</strong> SPPnet 将 RCNN 评估加速了几个数量级，但它并没有导致<strong>检测器训练</strong>被加速。此外，SPPnet中的微调无法在 SPP 层之前更新卷积层，这限制了非常深网络的准确性。 </p>
<p>SPPNet为了解决任意尺度图像进行训练得问题引入了<code>spatial pyramid pooling layer</code>，如下图：</p>
<p><img src="/2021/09/12/Object-Detection-Survey/sppnet.png" alt="SPPNet"></p>
<p>在最后的卷积层和全连接层之间加入SPP层。具体做法是，在conv5层得到的特征图是256层，每层都做一次spatial pyramid pooling。先把每个特征图分割成多个不同尺寸的网格，比如网格分别为4x4、2x2、1x1,然后每个网格做max  pooling，这样256层特征图就形成了16x256，4x256，1x256维特征，他们连起来就形成了一个固定长度的特征向量，将这个向量输入到后面的全连接层。</p>
<p><strong>那么网络如何训练呢？</strong></p>
<p>多阶段多尺寸训练方法，<strong>具体对SPPNet网络得介绍单独写一份学习笔记</strong></p>
<p><strong>Fast RCNN：</strong>Girshick 提出了 Fast RCNN，它解决了 RCNN 和 SPPnet 的一些缺点，同时提高了它们的<strong>检测速度和质量</strong>。<strong>Fast RCNN 通过开发流线型训练过程，使用多任务损失，同时学习 softmax 分类器和特定类别的边界框回归，从而实现端到端检测器训练</strong>（当忽略区域提议生成过程时，完全end-to-end），而不是像在 RCNN/SPPnet 中那样在三个不同的阶段训练 softmax 分类器、SVM 和 BBR。 Fast RCNN采用了<strong>跨区域proposal共享卷积计算</strong>的思想，在最后一个CONV层和第一个FC层之间增加了一个<strong>Region of Interest (RoI)池化层</strong>，为每个region proposal提取一个固定长度的特征（即RoI）。本质上，RoI pooling 使用特征级别的变形来近似图像级别的变形。 RoI 池化层之后的特征被送入一系列 FC 层，最终分支到<strong>两个兄弟输出层</strong>：用于<strong>对象类别预测的 softmax 概率</strong>和用于<strong>建议细化的特定于类的边界框回归偏移</strong>。与 RCNN/SPPnet 相比，Fast RCNN 显着提高了效率——通常<strong>训练速度快 3 倍</strong>，<strong>测试速度快 10 倍</strong>。总之，Fast RCNN 具有较高的检测质量、更新所有网络层的单阶段训练过程以及特征缓存不需要存储等吸引人的优势。 </p>
<p><strong>Faster RCNN：</strong>尽管 Fast RCNN 显着加快了检测过程，但它仍然依赖于外部区域提议。 区域提议计算被暴露为 Fast RCNN 中的新瓶颈。 最近的工作表明，CNN 具有在 CONV 层中定位对象的卓越能力，这种能力在 FC 层中被弱化。 因此，在产生区域建议时，CNN 可以代替选择性搜索。 Faster RCNN框架中提出了一种高效准确的区域提议网络（RPN）来生成区域提议。 他们利用单个网络来完成<strong>区域提议的 RPN</strong> 和<strong>区域分类的 Fast RCNN</strong> 任务。 在 Faster RCNN 中，RPN 和 fast RCNN 共享大量卷积层。 来自最后一个共享卷积层的特征被用于不同的分支来实现区域提议和区域分类。 </p>
<p>RPN 首先在每个 CONV 特征图位置初始化 k n × n 个不同尺度和纵横比的参考框（即所谓的锚点）。 每个 n × n 锚点映射到一个较低维度的向量（例如，ZF 为 256，VGG 为 512），该向量被输入到两个兄弟 FC 层—一个对象类别分类层和一个框回归层。 与 Fast RCNN 不同，RPN 中用于回归的特征具有相同的大小。 RPN 与 Fast RCNN 共享 CONV 特征，从而实现高效的区域提议计算。 RPN 实际上是一种全卷积网络 (FCN)； 因此，Faster RCNN 是一个纯粹基于 CNN 的框架，不使用手工制作的特征。 对于非常深的 VGG16 模型。</p>
<p><strong>R-FCN</strong>：通过使用一组专门的 CONV 层作为 FCN 输出构建了一组位置敏感的分数图，在其顶部添加了一个位置敏感的 RoI 池化层，实现了几乎所有的计算都在整个图像上共享，提升了训练速度和检测精度。</p>
<p><strong>Mask RCNN</strong>，通过扩展 Faster RCNN 来解决像素级对象实例分割问题。 Mask RCNN 采用相同的两阶段流水线，具有相同的第一阶段 (RPN)。 在第二阶段，在预测类别和框偏移的同时，Mask RCNN 添加了一个分支，为每个 RoI 输出一个二进制掩码。 新分支是在 CNN 特征图之上的全卷积网络 (FCN) 。 为了避免原始 RoI 池化 (RoIPool) 层造成的错位，提出了一个 RoIAlign 层来保留像素级空间对应关系。</p>
<h4 id="5、统一的Pipeline-一阶段目标检测器"><a href="#5、统一的Pipeline-一阶段目标检测器" class="headerlink" title="5、统一的Pipeline(一阶段目标检测器)"></a>5、统一的Pipeline(一阶段目标检测器)</h4><p>统一管道是使用单个前馈 CNN 网络直接从完整图像预测类概率和边界框偏移的架构，不涉及区域提议生成或后分类。因此可以直接在检测性能上进行端到端的优化。</p>
<p><strong>YOLO:</strong> 一种统一的检测器，将目标检测作为从图像像素到空间分离的边界框和相关类概率的回归问题。在YOLO中放弃了区域提议阶段，直接使用子小组候选区域来预测待检测的目标。由于 YOLO 在进行预测时会看到整个图像，因此它隐式编码了有关对象类别的上下文信息，并且不太可能预测背景中的误报。但由于边界框位置、比例和纵横比的粗划分，YOLO 会产生更多的定位错误。</p>
<p><strong>SSD:</strong> SSD结合了Faster R-CNN中anchor的思想预先对feature map的每个点产生prior box，其次，采用了多尺度feature maps进行检测的方法，从而实现了快速检测，同时保持较高的检测质量。由于SSD类似于YOLO不需要进行两次分类，剔除了RPN中对anchor的预计，所以也是Single shot类的检测方法。</p>
<p><img src="/2021/09/12/Object-Detection-Survey/Detect-0.png" alt="Detector"></p>
<h4 id="二、检测过程中的子问题"><a href="#二、检测过程中的子问题" class="headerlink" title="二、检测过程中的子问题"></a>二、检测过程中的子问题</h4><h5 id="2-1-DCNN-bases-Object-Representation-特征表示"><a href="#2-1-DCNN-bases-Object-Representation-特征表示" class="headerlink" title="2.1 DCNN bases Object Representation(特征表示)"></a>2.1 DCNN bases Object Representation(特征表示)</h5><p>作为任何检测器的主要组件之一，良好的特征表示在目标检测中是最重要的。 过去，大量的努力致力于设计局部描述子（例如，SIFT和 HOG）并探索方法（例如，Bag of Words 和 Fisher Vector）来分组并将描述子抽象为更高级别的表示，以允许区分对象部分开始出现(将数据转换到更高的维度，从而简化所需解决的问题，非线性支持向量机中的核函数很好的解释了这一点)，但是这些特征表示方法需要仔细的工程和相当多的领域专业知识。</p>
<p>相比之下，由多个处理层组成的深度学习方法（尤其是深度 CNN 或 DCNN）可以直接从原始图像中学习具有多层次抽象的强大特征表示。 由于学习过程减少了传统特征工程所需的特定领域知识和复杂过程的依赖性，特征表示的负担已转移到更好的网络架构设计上。 人们普遍认为，CNN 表征起着至关重要的作用，而 CNN 架构是检测器的引擎。 因此，最近在检测精度方面的大部分改进都是通过研究新型网络的发展来实现的。 因此，这里首先回顾通用对象检测中使用的流行 CNN 架构，然后回顾致力于改进对象特征表示的工作，例如开发不变特征以适应对象尺度、姿态、视点、部分变形和执行多尺度的几何变化 分析以改进各种尺度上的对象检测。 </p>
<h6 id="2-1-1-Popular-CNN-Architecture"><a href="#2-1-1-Popular-CNN-Architecture" class="headerlink" title="2.1.1 Popular CNN Architecture"></a>2.1.1 Popular CNN Architecture</h6><p>简而言之，CNN 具有层次结构，由卷积、非线性、池化等多个层组成。 从更细到更粗的层，图像反复进行滤波卷积，每一层都有感受野（支持区域） 这些过滤器的数量增加。 例如，开创性的 AlexNet有五个卷积层和两个全连接层。 一般来说，第一个 CNN 层提取低级特征（例如边缘），中间层提取复杂性增加的特征，例如低级特征的组合，然后卷积层将对象检测为早期部分的组合。 </p>
<p>架构演进的趋势是网络越来越深：<code>AlexNet</code> 由 8 层组成，<code>VGGNet 16</code> 层，最近 <code>ResNet</code> 和 <code>DenseNet</code> 都超过了 100 层大关。特别是，它表明增加深度可以提高深度网络的表示能力。 有趣的是，<code>AlexNet</code>、<code>OverFeat</code>、<code>ZFNet</code> 和 <code>VGGNet</code> 等网络具有大量参数，尽管只有几层深，因为大部分参数来自 <code>FC</code> 层。 因此，较新的网络，如 <code>Inception</code>、<code>ResNet</code> 和 <code>DenseNet</code>，虽然具有非常大的网络深度，但由于避免使用 FC 层，因此参数少得多。 </p>
<p>CNN 的训练需要具有足够标签和类内多样性的大型标记数据集。与图像分类不同，检测需要从图像中定位（可能很多）对象。<code>DeepIDNet</code> 表明使用具有对象级注释（例如 ImageNet 分类和定位数据集）的大规模数据集来预训练深度模型，而不仅仅是图像级注释，可以提高检测性能。然而，收集边界框标签是昂贵的，尤其是对于数十万个类别。一个常见的场景是在带有图像级标签的大型数据集（通常具有大量视觉类别）上对 CNN 进行预训练；然后可以将预训练的 CNN 直接应用于小数据集，作为通用特征提取器，可以支持更广泛的视觉识别任务。对于检测，预训练的网络通常在给定的检测数据集上进行微调。</p>
<h5 id="2-1-2-Methods-For-Improving-Object-Representation"><a href="#2-1-2-Methods-For-Improving-Object-Representation" class="headerlink" title="2.1.2 Methods For Improving Object Representation"></a>2.1.2 Methods For Improving Object Representation</h5><p>基于深度 CNN 的检测器，例如 RCNN、Fast RCNN、Faster RCNN 和 YOLO，通常使用深度 CNN 架构作为骨干网络，并使用来自顶层的特征 CNN 作为对象表示，但是在大范围内检测对象是一项基本挑战。 解决这个问题的经典策略是在多个缩放的输入图像（例如，图像金字塔）上运行检测器，这通常会产生更准确的检测，但是推理时间和内存有明显的限制 . 相比之下，CNN 逐层计算其特征层次，特征层次中的子采样层导致固有的多尺度金字塔。 </p>
<p>这种固有的特征层次会产生不同空间分辨率的特征图，但在结构上存在固有问题。较晚（或更高）的层具有较大的感受野和强语义，并且对诸如此类的变化像物体姿态、光照和部分变形具有鲁棒性，但分辨率低，几何细节丢失。相反，较早（或较低）的层具有较小的感受野和丰富的几何细节，但分辨率较高且对语义不太敏感。直观上，对象的语义概念可以出现在不同的层中，这取决于对象的大小。因此，如果目标对象很小，则它在较早的层中需要精细的细节信息，而在较晚的层中很可能会消失，原则上使小对象检测变得非常具有挑战性，为此使用扩张卷积或多孔卷积等技巧提出。另一方面，如果目标对象很大，那么语义概念将出现在更晚的层中。显然，仅使用一层的特征来预测不同尺度的对象并不是最佳选择，因此已经提出了许多方法通过利用多个 CNN 层来提高检测精度，大致分为三种类型多尺度目标检测： </p>
<ol>
<li><p><strong>Detecting with combined features of multiple CNN layers</strong></p>
<p>试图在进行预测之前组合来自多个层的特征。代表性方法包括 <code>Hypercolumns</code> 、<code>HyperNet</code> 和 <code>ION</code> 。这种特征组合通常通过跳跃连接来完成，这是一种经典的神经网络思想，它跳过网络中的某些层并将前一层的输出作为输入提供给后一层，这种架构最近在语义分割中变得流行。组合特征更具描述性，更有利于定位和分类，但增加了计算复杂度。 </p>
</li>
</ol>
<p><img src="/2021/09/12/Object-Detection-Survey/Detector-1.png" alt="Detector"></p>
<ol>
<li><p><strong>Detecting at multiple CNN layers</strong></p>
<p>通过平均分割概率将来自多个层的粗到细预测结合起来。 <code>SSD</code> 和 <code>MSCNN</code>、<code>RBFNet</code>  和 <code>DSOD</code> 结合来自多个特征图的预测来处理各种大小的对象。 SSD 将不同尺度的默认框分布到 CNN 中的多个层，并强制每一层专注于预测特定尺度的对象。<code>RFBNet</code>简单地用感受野块 (RFB) 替换了 SSD 的后期卷积层，以增强特征的可辨别性和鲁棒性。 RFB 是一个多分支卷积块，类似于 <code>Inception</code> 块，但将多个分支与不同的内核和卷积层组合在一起。<code>MSCNN</code> 在 CNN 的多个层上应用反卷积以提高特征图分辨率，然后再使用这些层来学习区域提议和池特征。 </p>
</li>
<li><p><strong>Combination of the above two methods</strong></p>
<p>一方面，通过简单地将skip connect特征结合到检测中，如<code>UNet</code>、<code>Hypercolumns</code>、<code>HyperNet</code>和 <code>ION</code>，因为高维超特征表示的效用并没有产生显着的改进。另一方面，从具有大感受野的较晚层检测大目标，并使用具有小感受野的较早层来检测小目标；然而，简单地从较早的层检测对象可能会导致性能低下，因为较早的层拥有较少的语义信息。因此，为了结合两者，最近的一些工作提出了在多层检测目标，并且通过组合来自不同层的特征来获得每个检测层的特征。代表性方法包括<code>SharpMask</code>、<code>Deconvolutional Single Shot Detector</code> 、<code>Feature Pyramid Network</code> 、<code>Top Down Modulation</code>、<code>Reverse connection with Objectness prior Network</code>、<code>ZIP</code>、<code>Scale Transfer Detection Network</code>、<code>RefineDet</code> 和 <code>StairNet</code>。</p>
</li>
</ol>
<p><img src="/2021/09/12/Object-Detection-Survey/Detector-2.png" alt="Detector"></p>
<p><img src="/2021/09/12/Object-Detection-Survey/Detector-3.png" alt="Detector"></p>
<ol>
<li><p><strong>Model Geometric Transformations</strong></p>
<p>DCNN 本质上仅限于对重要的几何变换进行建模。为了增强 CNN 表示的鲁棒性，需要学习关于不同类型变换的不变 CNN 表示，例如尺度、旋转等。可变形卷积网络(DCN)设计了一个可变形卷积层和一个可变形 RoI 池化层，这两个层都基于使用附加位置偏移量增加特征图中的常规网格采样位置并通过卷积学习偏移量的思想。</p>
</li>
</ol>
<h5 id="2-2-Context-Modeling-上下文信息挖掘"><a href="#2-2-Context-Modeling-上下文信息挖掘" class="headerlink" title="2.2 Context Modeling(上下文信息挖掘)"></a>2.2 Context Modeling(上下文信息挖掘)</h5><p>人们认识到，适当的上下文建模有助于对象检测和识别，特别是当由于对象尺寸小、遮挡或图像质量差而导致对象外观特征不足时。</p>
<ol>
<li>Semantic context: 在某些场景中找到目标但在其他场景中找不到的可能性；</li>
<li>Spatial context: 相对于场景中的其他物体，在某个位置找到一个物体而不是其他位置的可能性； </li>
<li>Scale context: 目标相对于场景中的其他对象具有一组有限的大小 。</li>
</ol>
<p>目标检测的当前技术水平无需明确利用任何上下文信息即可检测目标。 人们普遍同意，DCNN 隐式地使用上下文信息，因为它们学习具有多个抽象级别的分层表示。 尽管如此，在基于 DCNN 的检测器中明确探索上下文信息仍然有价值，因此以下回顾最近在基于 DCNN 的目标检测器中利用上下文线索的工作，组织成全局和局部上下文的类别。</p>
<p><strong>Global context:</strong>  指的是图像或场景级别的上下文，可以作为对象检测的线索（例如，卧室将预测床的存在）。 在<code>DeepIDNet</code>中，图像分类分数被用作上下文特征，并与对象检测分数连接以改善检测结果。 <code>ION</code>中建议使用空间循环神经网络 (RNN) 来探索整个图像的上下文信息。 在 <code>SegDeepM</code>中提出了一个 <code>MRF</code>模型，该模型对每次检测的外观和上下文进行评分，并允许每个候选框选择一个片段并对它们之间的一致性进行评分。 在<code>Contextual priming and feedback forFaster RCNN</code>中，语义分割被用作上下文启动的一种形式。 </p>
<p><strong>Local context:</strong> 考虑目标关系中的局部环境，即目标与其周围区域之间的相互作用。一般来说，建模目标关系具有挑战性，需要对不同类别、位置、尺度等的边界框进行推理。在深度学习时代，明确建模对象关系的研究非常有限，代表性的研究是空间记忆网络<code>SMN</code>、对象关系网络和结构推理网络<code>SIN</code>。还有一些简单方法，通常是通过扩大检测窗口大小来提取某种形式的局部上下文。 代表性方法包括<code>MRCNN</code>、<code>Gated BiDirectional CNN</code> (GBDNet)、<code>Attention to Context CNN</code> (ACCNN) 、<code>CoupleNet</code> 和<code>Pedestrian detection with unsupervised multistage feature learnin</code>。</p>
<p><img src="/2021/09/12/Object-Detection-Survey/Detector-4.png" alt="Detector"></p>
<h5 id="2-3-Detection-Proposal-Methods-区域提议"><a href="#2-3-Detection-Proposal-Methods-区域提议" class="headerlink" title="2.3 Detection Proposal Methods(区域提议)"></a>2.3 Detection Proposal Methods(区域提议)</h5><p>目标可以位于图像中的任何位置和比例。 在手工特征描述符（例如，SIFT、HOG和LBP）的鼎盛时期，词袋（BoW）和DPM使用了滑动窗口技术。 然而，窗口的数量很大并且随着图像中像素的数量而增长，并且需要在多个尺度和纵横比下进行搜索，从而进一步显着增加了搜索空间。 因此，应用更复杂的分类器在计算上过于昂贵。 </p>
<p>2011 年左右，研究人员提出通过使用检测建议来缓解计算易处理性和高检测质量之间的紧张关系。 源于<code>What is an object</code>提出的目标性思想，目标提议是图像中可能包含目标的一组候选区域。 检测建议通常用作预处理步骤，以通过限制检测器需要评估的区域数量来降低计算复杂度。 因此，一个好的检测方案应该具备以下特点： </p>
<ol>
<li>召回率高，只需要很少的proposal就可以实现； </li>
<li>提案尽可能准确地匹配对象； </li>
<li>效率高。 </li>
</ol>
<p>在基于传统低级线索（例如，颜色、纹理、边缘和梯度）的目标提议方法中，选择性搜索、<code>MCG</code> 和 <code>EdgeBoxes</code>是比较流行的。 随着该领域的快速发展，传统的对象提议方法（例如选择性搜索）被用作独立于检测器的外部模块，成为检测管道的瓶颈。 一类新兴的使用 <code>DCNN</code>的对象提议算法引起了广泛关注。 </p>
<p><strong>Bounding Box Proposal Methods:</strong> RPN 通过在最后一个共享 CONV 层的特征图上滑动一个小网络来预测对象建议。 在每个滑动窗口位置，它通过使用 k 个锚框同时预测 k 个提议，其中每个锚框 以图像中的某个位置为中心，并与特定的比例和纵横比相关联。</p>
<p><img src="/2021/09/12/Object-Detection-Survey/Detector-5.png" alt="Detector"></p>
<p><img src="/2021/09/12/Object-Detection-Survey/Detector-6.png" alt="Detector"></p>
<p><strong>Object Segment Proposal Methods:</strong> 旨在生成可能与目标对应的segment提议。分割建议比边界框建议提供更多信息，并且朝着对象实例分割更进一步，其中<code>DeepMask</code> 是一项开创性工作。此外，<code>SharpMask</code>增强了<code>DeepMask</code>可以有效地将早期特征的空间丰富信息与后期编码的强语义信息相结合，以生成高保真对象掩码。 </p>
<h4 id="三、评估标准"><a href="#三、评估标准" class="headerlink" title="三、评估标准"></a>三、评估标准</h4><p>评估检测算法性能的三个标准：检测速度（Frames Per Second，FPS）、精度和召回率。 最常用的指标是平均精度 (AP)，源自精度和召回率。 AP通常以特定于类别的方式进行评估，即分别为每个对象类别计算。 在通用对象检测中，通常根据检测多个对象类别来测试检测器。 为了比较所有对象类别的性能，采用所有对象类别的平均 AP (mAP) 作为性能的最终衡量标准。 有关这些指标的更多详细信息。</p>
<p>应用于测试图像<script type="math/tex">I</script>的检测器的标准输出是预测检测<script type="math/tex">\{b_j,c_j,p_j\}_j</script> ，由 j 索引。 给定的检测 (b,c,p)（为了符号简单省略 j）表示预测位置（即边界框，BB）b 及其预测类别标签 c 和置信水平 p。 预测的检测 (b,c,p) 被视为真阳性 (TP)，如果:</p>
<ul>
<li>预测的类标签 c 与ground truth标签<script type="math/tex">c_g</script>相同。 </li>
<li>预测的 BB b 和ground truth的 <script type="math/tex">b_g</script> 之间的重叠率 IOU（Intersection Over Union）不小于预定义的阈值 ε。 这里 <script type="math/tex">area(b\cap b^g)</script> 表示预测和ground trueh BBs 的交集，以及 <script type="math/tex">area(b\cup b^g)</script> 它们的并集。 ε 的典型值为 0.5。 </li>
</ul>
<script type="math/tex; mode=display">
IOU(b,b^g)=\frac{area(b\cap b^g)}{area(b\cup b^g)}</script><p>否则，它被视为误报（FP）。 通常将置信水平 p 与某个阈值 β 进行比较，以确定是否接受预测的类标签 c 。</p>
<p><img src="/2021/09/12/Object-Detection-Survey/Detector-7.png" alt="Detector"></p>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>YOLOv2-YOLO9000</title>
    <url>/2021/09/12/YOLOv2-YOLO9000/</url>
    <content><![CDATA[<h2 id="YOLOv2-and-YOLO9000"><a href="#YOLOv2-and-YOLO9000" class="headerlink" title="YOLOv2 and YOLO9000"></a>YOLOv2 and YOLO9000</h2><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>由于检测数据集相对分类任务的数据集而言要少几个的多，并且为检测数据集打标签的耗费十分大。所以作者提出了一种新的<strong>数据组合方法</strong>来利用已有的大量分类数据，并使用它来扩展当前检测系统的范围。 通过使用目标分类的分层视图，允许将不同的数据集组合在一起。 </p>
<p>此外，作者还提出了一种<strong>联合训练算法</strong>，允许在检测和分类数据上训练目标检测器。 联合训练方法利用标记检测图像来学习精确定位对象，同时使用分类图像来增加其词汇量和鲁棒性 </p>
<h4 id="二、Better"><a href="#二、Better" class="headerlink" title="二、Better"></a>二、Better</h4><p>与最先进的检测系统相比，YOLO 存在各种缺点。 YOLO 与 Fast R-CNN 相比YOLO 会产生大量定位错误。 此外，与基于区域提议的方法相比，YOLO 的召回率相对较低。 因此，论文中主要关注点在保持分类准确性的同时提高召回率和定位。 </p>
<p>与计算机视觉中大多数趋向于更大、更深的网络不同。为了得到更准确、速度更快的检测器。作者简化了网络，使目标的表征更容易被学习。</p>
<h5 id="2-1-Batch-Normalization"><a href="#2-1-Batch-Normalization" class="headerlink" title="2.1 Batch Normalization"></a>2.1 Batch Normalization</h5><p>批量归一化显着提高了网络的收敛性，同时消除了对其他形式的正则化的需要。 通过在 YOLO 中的<strong>所有卷积层</strong>上添加批量归一化，在 mAP 上获得了超过 2% 的改进。 批量归一化还有助于规范模型。 通过批量归一化，可以从模型中移除 dropout 而不会过拟合。</p>
<h5 id="2-2-High-Resolution-Classifier"><a href="#2-2-High-Resolution-Classifier" class="headerlink" title="2.2 High Resolution Classifier"></a>2.2 High Resolution Classifier</h5><p><strong>原始YOLO</strong>以224×224训练分类器网络并将分辨率提高到448进行检测。 这意味着网络必须同时切换到学习目标检测并调整到新的输入分辨率。 </p>
<p><strong>对于 YOLOv2</strong>，首先在 ImageNet 上以 448 × 448 的全分辨率<strong>微调分类网络 10 个时期</strong>。 这使网络有时间调整其过滤器以更好地处理更高分辨率的输入。 然后在检测时微调生成的网络。 这个高分辨率的分类网络增加了近 4% 的 mAP。 </p>
<h5 id="2-3-Convolutional-With-Anchor-Boxes"><a href="#2-3-Convolutional-With-Anchor-Boxes" class="headerlink" title="2.3 Convolutional With Anchor Boxes"></a>2.3 Convolutional With Anchor Boxes</h5><p><strong>YOLO</strong> 直接使用卷积特征提取器之上的<strong>全连接层</strong>来<strong>预测边界框</strong>的坐标。<code>Faster R-CNN</code>不是直接预测坐标，而是使用精选的先验预测边界框。 <code>Faster R-CNN</code> 中的区域提议网络 (RPN) 仅使用卷积层来预测锚框的偏移量和置信度。由于预测层是卷积层，因此 RPN 在特征图中的每个位置预测这些偏移量。<strong>预测偏移而不是坐标可以简化问题并使网络更容易学习</strong>。 </p>
<p><strong>YOLOv2</strong>从 <code>YOLO</code> 中<strong>移除了全连接层</strong>，并<strong>使用锚框来预测边界框</strong>。首先，<strong>消除了一个池化层</strong>，使网络<strong>卷积层</strong>的<strong>输出分辨率更高</strong>。同时还<strong>缩小了网络输入尺寸到416</strong>而不是 <code>448×448</code> 进行操作。这样做是因为想要在<strong>特征图中有奇数个位置</strong>，从而只有一个中心单元。因为大目标往往会占据图像的中心，所以最好在中心有一个位置来预测这些目标，而不是四个都在附近的位置。 YOLO 的卷积层对图像进行了 32 倍的下采样，因此通过使用 416 的输入图像，得到了 <code>13 × 13</code> 的<strong>输出特征图</strong>。 </p>
<p>当使用锚框时，还将<strong>类预测机制与空间位置解耦</strong>，为每个锚框预测类和目标。 在 YOLO 之后，<strong>objectness 预测</strong>仍然预测 ground truth 和提出的 box 的IOU，<strong>类预测</strong>，预测当目标存在时该类的条件概率。</p>
<p><strong>使用锚框的性能分析：</strong>使用锚框后准确率会略有下降。 YOLO 每张图像只预测 98 个框(7&times;7&times;2)，但YOLOv2模型预测超过 1000 个锚框。 在没有锚框的情况下，中间模型获得了 69.5 mAP，召回率为 81%。 使用锚框，YOLOv2模型获得 69.2 mAP，召回率为 88%。 即使 mAP 下降，召回率的增加也意味着升级后的模型有更多的改进空间。 </p>
<h5 id="2-4-Dimension-Clusters"><a href="#2-4-Dimension-Clusters" class="headerlink" title="2.4 Dimension Clusters"></a>2.4 Dimension Clusters</h5><p>将<code>Ahchor Boxes</code>与 <code>YOLO</code> 一起使用时，会遇到了两个问题：</p>
<ul>
<li><p>如何选取Anchor: 首先是box尺寸是手工挑选的。 网络可以学习适当地调整框，但如果为网络选择更好的先验box，则可以让网络更容易学习预测好的检测。</p>
<p>如何选择先验，在训练集边界框上运行 k-means 聚类以自动找到好的先验。 如果使用欧氏距离的标准 k 均值，较大的框会比较小的框产生更多的错误。 然而，真正想要的是导致良好 IOU 分数的先验，这与框的大小无关。 因此，对于使用如下的距离度量：</p>
</li>
</ul>
<script type="math/tex; mode=display">
d(box,centroid)=1-IOU(box,centroid)</script><ul>
<li>模型不稳定: 作者说RPN中用于定位的坐标，在训练时不受约束，所以任何锚框都可以在图像中的任何一点结束，而不管预测框的位置如何。 通过随机初始化，模型需要很长时间才能稳定以预测合理的偏移量。 </li>
</ul>
<h5 id="2-5-Direct-location-prediction"><a href="#2-5-Direct-location-prediction" class="headerlink" title="2.5 Direct location prediction"></a>2.5 Direct location prediction</h5><p>由于上述说的模型不稳定的问题，在YOLOv2中，还是遵循 YOLO 的方法，预测相对于网格单元位置的位置坐标。 这限制了真实值落在 0 和 1 之间。并使用逻辑激活来限制网络的预测落在这个范围内。 </p>
<p>网络在<strong>输出特征图</strong>中的<strong>每个单元格</strong>预测 5 个边界框。 网络为每个边界框预测 5 个坐标，t<sub>x</sub>、t<sub>y</sub>、t<sub>w</sub>、t<sub>h</sub> 和 t<sub>o</sub>。 如果单元格从图像的左上角偏移 (cx,cy) 并且边界框先验具有宽度和高度 p<sub>w</sub>, p<sub>h</sub>，则预测对应于: </p>
<script type="math/tex; mode=display">
\begin{align}b_x=&\sigma(t_x)+c_x\\b_y=&\sigma(t_y)+\,c_y\\b_w=&p_we^{t_w}\\b_h=&p_h e^{t_h}\end{align}\\P_r(object)\ast IOU(b,object)=\sigma(t_o)</script><p>由于上面约束了位置预测，因此参数化更容易学习，使网络更稳定。 与使用锚框的版本相比，使用维度集群以及直接预测边界框中心位置将 YOLO 提高了近 5%。 </p>
<p><img src="/2021/09/12/YOLOv2-YOLO9000/YOLOv2-0.png" alt="YOLOV2"></p>
<h5 id="2-6-Fine-Grained-Features"><a href="#2-6-Fine-Grained-Features" class="headerlink" title="2.6 Fine-Grained Features"></a>2.6 Fine-Grained Features</h5><p>虽然这对于大型物体来说，在YOLO 预测的 <code>13 × 13</code> 特征图上的检测已经足够了。但为了定位较小物体的细粒度特征，YOLOv2简单地添加一个传递层，以 26 × 26 的分辨率从较早的层中引入特征。 </p>
<p>passthrough layer通过将相邻特征<strong>concatenates</strong>到不同的通道<strong>而不是</strong>空间位置，将高分辨率特征与低分辨率特征连接起来，类似于 ResNet 中的身份映射。 这将 26 ×26 ×512 的特征图变成了 13 ×13 ×2048 的特征图，可以与原始特征连接。 检测器运行在这个扩展的特征图之上，以便它可以访问细粒度的特征。 这将适度提高 1% 的性能。 </p>
<p><img src="/2021/09/12/YOLOv2-YOLO9000/YOLOv2-4.png" alt="YOLOV2"></p>
<h5 id="2-7-Multi-Scale-Training"><a href="#2-7-Multi-Scale-Training" class="headerlink" title="2.7 Multi-Scale Training"></a>2.7 Multi-Scale Training</h5><p>训练时不是使用固定输入的图像大小，而是每隔几次迭代就更改网络。 每 <code>10</code> 个批次，网络随机选择一个新的图像尺寸。 由于模型下采样了 <code>32</code> 倍，所以从以下 32 的倍数中提取：{320,352,…,608}。 因此最小的选项是 <code>320 ×320</code>，最大的选项是 <code>608 ×608</code>。 将网络调整到那个维度并继续训练。</p>
<h4 id="三、Faster"><a href="#三、Faster" class="headerlink" title="三、Faster"></a>三、Faster</h4><h5 id="3-1-Darknet-19"><a href="#3-1-Darknet-19" class="headerlink" title="3.1 Darknet-19"></a>3.1 Darknet-19</h5><p>作者提出了一种新的分类模型，用作 YOLOv2 的基础。 该模型建立在先前的网络设计工作以及该领域的常识的基础上。 与 VGG 模型类似，该模型主要使用 <code>3 × 3</code> 过滤器，并在每个池化步骤后将通道数加倍。 继 <code>Network in Network (NIN)</code> 的工作之后，使用全局平均池化进行预测，并使用 <code>1 ×1</code> 过滤器来压缩 <code>3 ×3</code> 卷积之间的特征表示 。 同时使用批量归一化来稳定训练，加速收敛，并对模型进行正则化。 最终模型称为<code>Darknet-19</code>，有 19 个卷积层和 5 个最大池化层。</p>
<p><img src="/2021/09/12/YOLOv2-YOLO9000/YOLOv2-1.png" alt="YOLOV2"></p>
<h5 id="3-2-Training-for-classification"><a href="#3-2-Training-for-classification" class="headerlink" title="3.2 Training for classification"></a>3.2 Training for classification</h5><p>在标准 ImageNet 1000 类分类数据集上使用 <code>Darknet</code> 神经网络框架训练网络 160 个epoch，使用随机梯度下降，起始学习率为 0.1，多项式速率衰减为 4，权重衰减为 0.0005，动量为 0.9 。 训练期间使用标准的数据增强技巧，包括随机裁剪、旋转、色调、饱和度和曝光转换。</p>
<p>此外，在对 <code>224 × 224</code> 的图像进行初始训练分类网络后，以更大的尺寸(448&times;448)微调<code>Darknet</code>网络。对于这种微调，使用上述参数进行训练，但仅训练 10 个epoch，并以 10<sup>-1</sup> 的学习率开始。在这个更高分辨率下，网络达到了 76.5% 的 top-1 准确率和 93.3% 的 top-5 准确率。 </p>
<h5 id="3-3-Training-for-detection"><a href="#3-3-Training-for-detection" class="headerlink" title="3.3 Training for detection"></a>3.3 Training for detection</h5><p>通过删除最后一个卷积层来修改该网络以进行检测。添加了三个 3 × 3 卷积层，每个卷积层具有 1024 个过滤器，然后是最终的 1 × 1 卷积层，其中包含需要检测的输出数量。 </p>
<p>对于 VOC，预测 5 个盒子，每个盒子有 5 个坐标，每个盒子有 20 个类，所以需要 5个boxes&times;(5个坐标+20个类) = 125个过滤器。 此外，还从最后的 3 ×3 ×512 层到倒数第二个卷积层添加了一个直通层，以便模型可以使用细粒度特征。</p>
<p>以 10<sup>-3</sup> 的起始学习率训练网络 160 个epoch，在 60 和 90 个epoch将其除以 10。 使用 0.0005 的权重衰减和 0.9 的动量。 并且使用与 YOLO 和 SSD 类似的数据增强，随机裁剪、颜色偏移等。</p>
<h4 id="四、Stronger"><a href="#四、Stronger" class="headerlink" title="四、Stronger"></a>四、Stronger</h4><p>作者提出了一种<strong>联合训练分类和检测数据</strong>的机制。 其中使用标记为<strong>检测的图像</strong>来<strong>学习</strong>特定于<strong>检测的信息</strong>，例如边界框坐标预测和对象性以及如何对常见对象进行分类。 它使用<strong>只有类别标签的图像</strong>来<strong>扩展</strong>它<strong>可以检测的类别数量</strong>。 </p>
<p>在训练期间，<strong>混合</strong>来自检测和分类数据集的图像。 当网络看到标记为检测的图像时，可以基于完整的 YOLOv2 损失函数进行反向传播。 当它看到分类图像时，只从架构的特定分类部分反向传播损失。 </p>
<p>大多数分类方法使用<strong>跨所有可能类别</strong>的 softmax 层来计算最终概率分布。 <strong>使用 softmax 假设这些类是互斥的</strong>。 这给组合数据集带来了问题，例如，您不希望使用此模型组合 ImageNet 和 COCO，因为类“Norfolk terrier”和“dog”并不相互排斥(Norfolk terrier是dog的一个品种)。 可以改为使用<strong>多标签模型</strong>来组合不假设互斥的数据集。</p>
<p>为了解决上述出现的问题，作者借鉴WordNet，提出了一种视觉概念的分层模型称为WordTree。如果想计算特定节点的绝对概率，只需沿着树到根节点的路径，乘以条件概率。 所以如果想知道一张图片是否是Norfolk，使用如下的计算公式(联合概率)：</p>
<script type="math/tex; mode=display">
Pr(Norfolk \,\,terrier)=Pr(Norfolk\,\,terrier|terrier)\ast Pr(terrier|hunting\,\,dog)\ast ...\ast Pr(mammal|Pr(animal))\ast Pr(animal|physical\,\,object)</script><p><img src="/2021/09/12/YOLOv2-YOLO9000/YOLOv2-2.png" alt="YOLOV2"></p>
<p>上图显示了如果使用WordTree对同一枝干中的属性计算softmax。</p>
<p><img src="/2021/09/12/YOLOv2-YOLO9000/YOLOv2-3.png" alt="YOLOV2"></p>
<p>上图显示了对不同数据集的整合。图像来源于论文<a href="https://arxiv.org/pdf/1612.08242.pdf" target="_blank" rel="noopener">YOLO9000:Better, Faster, Stronger</a>。</p>
<p><a href="https://zhuanlan.zhihu.com/p/47575929" target="_blank" rel="noopener">参考博客</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/93632171" target="_blank" rel="noopener">参考博客</a></p>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>YOLOv1</title>
    <url>/2021/09/12/YOLOv1/</url>
    <content><![CDATA[<h2 id="YOLO-You-Only-Look-Once"><a href="#YOLO-You-Only-Look-Once" class="headerlink" title="YOLO (You Only Look Once)"></a>YOLO (You Only Look Once)</h2><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>YOLO，一种统一的检测器，将目标检测作为从图像像素到空间分离的边界框和相关类概率的回归问题。在YOLO中放弃了区域提议阶段，直接使用子小组候选区域来预测待检测的目标。由于 YOLO 在进行预测时会看到整个图像，因此它隐式编码了有关对象类别的上下文信息，并且不太可能预测背景中的误报。但由于边界框位置、比例和纵横比的粗划分，YOLO 会产生更多的定位错误。</p>
<p>简单概括就是：单个神经网络预测边界框和类别概率 ，不需要像Faster R-CNN系列需要重新利用分类器做检测。</p>
<p><img src="/2021/09/12/YOLOv1/YOLO-0.png" alt="YOLO"></p>
<p><strong>YOLO优点：</strong></p>
<ul>
<li>非常快，YOLO 不需要复杂的Pipeline。</li>
<li>背景误判很少：YOLO 在进行预测时会对图像进行全局推理，隐式编码了关于类及其外观的上下文信息。</li>
<li>应用范围广： YOLO学习对象的可泛化表示，因此在应用于新领域或意外输入时不太可能崩溃。 </li>
</ul>
<p><strong>YOLO缺点：</strong>YOLO 在准确性方面仍然落后于最先进的检测系统。 虽然它可以快速识别图像中的物体，但它很难精确定位一些物体，尤其是小物体。</p>
<h4 id="二、Unified-Detection"><a href="#二、Unified-Detection" class="headerlink" title="二、Unified Detection"></a>二、Unified Detection</h4><p>系统将输入图像划分为 <strong>S ×S 网格</strong>。 如果对象的中心落入网格单元中，则该网格单元负责检测该对象。 <strong>每个网格单元</strong>预测 <strong>B 个边界框</strong>和<strong>这些框的置信度分数</strong>。 这些置信度分数反映了模型对盒子包含对象的信心程度，以及它认为盒子预测的准确度。置信度表示为：</p>
<script type="math/tex; mode=display">
Pr(Object)\ast IOU^{truth}_{pred}</script><p>每个边界框由 5 个预测组成：x、y、w、h 和置信度。 (x,y) 坐标表示相对于网格单元边界的框中心。 宽度和高度是相对于整个图像预测的。 最后，置信度预测表示预测框和任何ground truth之间的 IOU。</p>
<p><strong>每个网格单元</strong>还预测 C 个条件类概率，Pr(Class<sub>i</sub>|Object)。 <strong>这些概率以包含目标的网格单元为条件</strong>。 我们只预测每个网格单元的一组类概率，而不管框 B 的数量。 </p>
<p>在测试时，将条件类概率和单个框置信度预测相乘，表达式如下：</p>
<script type="math/tex; mode=display">
Pr(Class_i|Object)\ast Pr(Object)\ast IOU^{truth}_{pred}=Pr(Class_i)\ast IOU^{truth}_{pred}</script><p>上式提供了每个框特定于类的置信度分数。 这些分数编码了该类出现在框中的概率以及预测的框与对象的匹配程度。 </p>
<p><img src="/2021/09/12/YOLOv1/YOLO-1.png" alt="YOLO"></p>
<h4 id="三、网络设计"><a href="#三、网络设计" class="headerlink" title="三、网络设计"></a>三、网络设计</h4><p>网络的初始卷积层从图像中提取特征，而全连接层预测输出概率和坐标。 网络架构受到用于图像分类的 GoogLeNet 模型的启发，有 24 个卷积层，后跟 2 个全连接层，有使用 GoogLeNet 使用的初始模块，而是简单地使用 1 × 1 缩减层和 3 × 3 卷积层。</p>
<p><img src="/2021/09/12/YOLOv1/YOLO-2.png" alt="YOLO"></p>
<p>训练的时候，先用ImageNet-1000数据集预训练上面的前20层网络+average-pooling层+一个全连接层。然后转换模型以执行检测。 论文《Object detection networks on convolutional feature maps》表明将卷积层和连接层添加到预训练网络可以提高性能。 所以添加了四个卷积层和两个具有随机初始化权重的全连接层。 检测通常需要细粒度的视觉信息，因此将网络的输入分辨率从 224 × 224 增加到 448 × 448。 </p>
<p>最后一层预测类别概率和边界框坐标，过图像的宽度和高度对边界框的宽度和高度进行归一化，使它们落在 0 和 1 之间。边界框的 x 和 y 坐标参数化为特定网格单元位置的偏移量，因此它们也被限制在 0 和 1 之间 。对最后一层使用线性激活函数，所有其他层使用以下Leaky rectified线性激活： </p>
<script type="math/tex; mode=display">
\phi(x)=\begin{cases}
        x,  & \text{if $x$ >0} \\
        0.1x, & \text{otherwise}
        \end{cases}</script><p>针对模型输出中的平方和误差进行了优化。 其中使用平方和误差是因为它很容易优化，但是它并不完全符合最大化平均精度的目标。 它将定位误差与可能不理想的分类误差同等加权。 此外，在每个图像中，许多网格单元不包含任何对象。 这会将这些单元格的“置信度”分数推向零，通常会压倒包含对象的单元格的梯度。 这可能会导致模型不稳定，从而导致训练早期出现分歧。 为了解决这个问题，增加了边界框坐标预测的损失，并减少了不包含对象的框的置信度预测的损失。引入两个参数&lambda;<sub>coord</sub>=5，&lambda;<sub>noobj</sub>=0.5。</p>
<p>Sum-squared error 也同样加权大框和小框的错误。 误差度量时小的偏差对于小框的重要性应该大于大框。 为了部分解决这个问题，预测边界框宽度和高度的平方根，而不是直接预测宽度和高度。 </p>
<p>训练时优化的损失函数如下：</p>
<script type="math/tex; mode=display">
\lambda_{coord}\sum^{S^2}_{i=0}\sum^{B}_{j=0}I^{obj}_{ij}[(x_i-\hat{x_i})^2+(y_i-\hat{y_i})^2]+\lambda_{coord}\sum^{S^2}_{i=0}\sum^{B}_{j=0}I^{obj}_{ij}[(\sqrt {w_i} - \sqrt{\hat{w}_i})^2+(\sqrt {h_i} - \sqrt{\hat{h}_i})^2]+\\\sum^{S^2}_{i=0}\sum^{B}_{j=0}I^{obj}_{ij}(C_i-\hat{C}_i)^2+\lambda_{noobj}\sum^{S^2}_{i=0}\sum^{B}_{j=0}I^{noobj}_{ij}(C_i-\hat{C}_i)^2+\sum^{S^2}_{i=0}I^{obj}_{i}\sum_{c\in classes}(p_i(c)-\hat{p_i}(c))^2\\
I^{obj}_{i}指出物体出现在第i个cell中，I^{obj}_{ij}指出第i个cell中的第j个边界框负责预测，分别对x,y,w,h,置信度(目标/非目标)，类别六个变量计算损失</script><p>为了避免过拟合，在训练是使用了dropout=0.5和数据增强等方法<a href="https://arxiv.org/pdf/1506.02640.pdf" target="_blank" rel="noopener">论文</a>。</p>
<h4 id="四、YOLO的限制"><a href="#四、YOLO的限制" class="headerlink" title="四、YOLO的限制"></a>四、YOLO的限制</h4><ul>
<li>YOLO 对边界框预测施加了很强的空间约束，因为每个网格单元只预测两个框并且只能有一个类。 这种空间约束限制了模型可以预测的附近物体的数量。 使得模型难以处理成群出现的小物体，例如成群的鸟。 </li>
<li>由于模型学习从数据中预测边界框，因此它很难泛化到具有新的或不寻常的纵横比或配置的对象。 此外，输入图像会进行多次的下采样操作，这使模型使用相对粗略的特征来预测边界框。</li>
<li>训练一个近似检测性能的损失函数时，损失函数对小边界框和大边界框的错误处理方式相同。 </li>
</ul>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>SSD-Detector</title>
    <url>/2021/09/12/SSD-Detector/</url>
    <content><![CDATA[<h2 id="SSD-Single-Shot-MultiBox-Detector"><a href="#SSD-Single-Shot-MultiBox-Detector" class="headerlink" title="SSD: Single Shot MultiBox Detector"></a>SSD: Single Shot MultiBox Detector</h2><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>SSD是为了兼顾检测速度和检测精度而提出的，即将一阶段的速度和二阶段的精度都考虑进来。为了检测小目标，其在多个尺度的特征图上进行边界框和类别的学习。</p>
<h5 id="1-1-SSD的贡献如下："><a href="#1-1-SSD的贡献如下：" class="headerlink" title="1.1 SSD的贡献如下："></a>1.1 SSD的贡献如下：</h5><ul>
<li>是一种用于多个类别的单次检测器，它比之前的单次检测器 (YOLO) 的最新技术更快，而且准确度更高。</li>
<li>SSD 的核心是使用应用于特征图的小卷积滤波器为一组固定的默认边界框预测类别分数和框偏移量。 </li>
<li>为了实现高检测精度，我们从不同尺度的特征图生成不同尺度的预测，并按纵横比明确分离预测。 </li>
<li>这些设计特性导致简单的端到端训练和高精度，即使在输入低分辨率的图像上，也能进一步提高速度与精度的权衡。</li>
</ul>
<h5 id="1-2-SSD和YOLO的区别："><a href="#1-2-SSD和YOLO的区别：" class="headerlink" title="1.2 SSD和YOLO的区别："></a>1.2 SSD和YOLO的区别：</h5><ul>
<li>SSD<strong>采用卷积直接做检测，</strong>YOLO在全连接层之后做检测</li>
<li><strong>SSD提取了不同尺度的特征图来做检测</strong>，大尺度特征图（较靠前的特征图）可以用来检测小物体，而小尺度特征图（较靠后的特征图）用来检测大物体</li>
<li>SSD采用了<strong>不同尺度</strong>和<strong>长宽比的先验框</strong>(Prior boxes, Default boxes，在Faster R-CNN中叫做锚，Anchors)</li>
</ul>
<h4 id="二、The-Single-Shot-Detector-SSD"><a href="#二、The-Single-Shot-Detector-SSD" class="headerlink" title="二、The Single Shot Detector (SSD)"></a>二、The Single Shot Detector (SSD)</h4><p><img src="/2021/09/12/SSD-Detector/SSD.png" alt="SSD"></p>
<p>SSD 方法基于前馈卷积网络，该网络生成固定大小的<strong>边界框集合</strong>和这些框内目标类<strong>实例存在的分数</strong>，然后是非最大抑制步骤以产生最终检测。在高精度分类网络backbone上，添加辅助结构以产生具有以下关键特征的检测： </p>
<h5 id="2-1-Multi-scale-feature-maps-for-detection"><a href="#2-1-Multi-scale-feature-maps-for-detection" class="headerlink" title="2.1 Multi-scale feature maps for detection"></a>2.1 Multi-scale feature maps for detection</h5><p>在截断的基础网络的末尾添加了<strong>卷积特征层</strong>。 这些层的大小逐渐减小，并允许在多个尺度上进行检测预测。 用于预测检测的卷积模型对于每个特征层都是不同的。</p>
<h5 id="2-2-Convolutional-predictors-for-detection"><a href="#2-2-Convolutional-predictors-for-detection" class="headerlink" title="2.2 Convolutional predictors for detection"></a>2.2 Convolutional predictors for detection</h5><p><strong>每个添加的特征层（或可选地来自基础网络的特征层）可以使用一组卷积滤波器产生一组固定的检测预测</strong>。对于具有 p 个通道的大小为 m ×n 的特征层，预测潜在检测参数的基本元素是一个 3 ×3 ×p 的小kernel，它产生<strong>类别的分数</strong>，或<strong>相对于默认框坐标的形状偏移量</strong>。 在每一个应用kernel的 m×n 个位置，它都会产生一个输出值。 边界框偏移量输出值是相对于每个特征图位置的默认框位置测量的。</p>
<h5 id="2-3-Default-boxes-and-aspect-ratios"><a href="#2-3-Default-boxes-and-aspect-ratios" class="headerlink" title="2.3 Default boxes and aspect ratios"></a>2.3 Default boxes and aspect ratios</h5><p>由于网络会添加多尺度的特征层用于多尺度检测，所以每个feature map对应一组<strong>默认边界框</strong>。<strong>什么是默认边界框？</strong>参考上图1。<strong>那么默认边界框与feature map的关系是什么？</strong>将默认边界框以卷积的方式平铺feature map(比如，feature map大小为m&times;n，那么在每一个点就有k个默认边界框，类似Faster R-CNN中的anchor)，这样每个框相对于其对应feature map中的cell的位置是固定的。在每个特征图单元格中，会预测相对于单元格中<strong>默认框</strong>形状的<strong>偏移量</strong>，以及每类的分数，这些分数表明每个框内是否存在类实例。</p>
<p>具体来说，对于给定位置 k 中的每个框，计算 c 类分数和相对于原始默认框形状的 4 个偏移量。这导致总共 (c + 4)k 个过滤器应用于特征图中的每个位置，为 m ×n 特征图产生 (c + 4)kmn 输出。默认框类似于 Faster R-CNN中使用的锚框，但是SSD中将它们应用于多个不同分辨率的特征图。在几个特征图中允许不同的默认框形状，可以有效地离散化可能的输出框形状的空间。 </p>
<p><img src="/2021/09/12/SSD-Detector/SDD-1.png" alt="SSD"></p>
<p><code>SSD 300</code>中输入图像的大小是<code>300x300</code>，特征提取部分使用了<code>VGG16</code>的卷积层，并将<code>VGG16</code>的两个全连接层转换成了普通的卷积层（图中conv6和conv7），之后又接了多个卷积（conv8_1，conv8_2，conv9_1，conv9_2，conv10_1，conv10_2），最后用一个<code>Global Average Pool</code>来变成1x1的输出（conv11_2）。</p>
<h5 id="2-1-Matching-strategy"><a href="#2-1-Matching-strategy" class="headerlink" title="2.1 Matching strategy"></a>2.1 Matching strategy</h5><p>在训练期间，需要确定<strong>哪些默认框</strong>用于ground Truth的检测并相应地训练网络。 对于每个ground truth，从位置、纵横比和比例不同的默认框中进行选择。 </p>
<ul>
<li>首先，寻找与每一个ground truth box有最大的jaccard overlap的default  box，这样就能保证每一个groundtruth box与唯一的一个default box对应起来。</li>
<li>SSD之后又将剩余还没有配对的default box与任意一个groundtruth box尝试配对，只要两者之间的jaccard overlap大于阈值，就认为match（SSD 300 阈值为0.5）。</li>
</ul>
<p>其中，配对到GT的default box就是positive，没有配对到GT的default box就是negative。</p>
<script type="math/tex; mode=display">
J(A,B)=\frac{|A\cap B|}{|A\cup B|}=\frac{|A\cap B|}{|A|+|B|-|A\cap B|}</script><p><img src="/2021/09/12/SSD-Detector/SSD-3.png" alt="SDD"></p>
<p>上图来自<a href="https://blog.csdn.net/qq_38622495/article/details/82289814" target="_blank" rel="noopener">博客</a>-多层级上的anchor回归。<strong>通过同时对多个层级上的anchor计算IOU，就能找到与ground truth的尺寸、位置最接近（即IOU最大）的一批anchor，在训练时也就能达到最好的准确度。</strong></p>
<h5 id="2-2-训练过程"><a href="#2-2-训练过程" class="headerlink" title="2.2 训练过程"></a>2.2 训练过程</h5><p>整体目标损失函数是定位损失 (loc) 和分类损失 (conf) 的加权和： </p>
<script type="math/tex; mode=display">
L(x,c,l,g)=\frac{1}{N}(L_{conf}(x,c)+\alpha L_{loc}(x,l,g))\\
N是匹配到的默认框的数量，当N=0时，损失为0\\
定位损失是预测框l和ground\,\,truth\,\,box(g)之间的Smooth\,\,L1\,\,loss</script><script type="math/tex; mode=display">
L_{loc}(x,l,g)=\sum^{N}_{i\in Pos}\sum_{m\in\{cx,cy,w,h\}}x^k_{ij}smooth_{L1}(l^m_i-\hat{g}^m_j)\\
\hat{g}^{cx}_j=(g^{cx}_{j}-d^{cx}_i)/d^w_i;\,\hat{g}^{cy}_j=(g^{cy}_{j}-d^{cy}_i)/d^h_i;\,\hat{g}^w_j=\log\Big(\frac{g^w_j}{d^w_i}\Big);\,\hat{g}^h_j=\log\Big(\frac{g^h_j}{d^h_i}\Big)</script><p>分类损失是多类置信度 (c) 上的 softmax 损失。 权重项α通过交叉验证设置为1。 </p>
<script type="math/tex; mode=display">
L_{conf}(x,c)=-\sum^{N}_{i\in Pos}x^p_{ij}log(\hat{c}^p_i)-\sum_{i\in Neg}log(\hat{c}^0_i)\,\,where\,\, \hat{c}^p_i=\frac{exp(c^p_i)}{\sum_{p}exp(c^p_i)}\\
x^p_{ij}=\{0,1\}表示第i个默认框(anchor)与第j个ground\,\,truth的类别p是否匹配\\
上面,log(\hat{c}^0_i)=x_{ij}^0\times;log(\hat{c}^0_i)，第0类为背景类，所以x_{ij}^0=1,其余x_{ij}^{p\ne0}=0,每个anchor都对应c+1类</script><p>L<sub>conf</sub>是前景的分类loss和背景的分类loss的和。L<sub>loc</sub>(x, l, g)是所有用于前景分类的anchor的位置坐标的回归loss。</p>
<h5 id="2-3-Choosing-scales-and-aspect-ratios-for-default-boxes"><a href="#2-3-Choosing-scales-and-aspect-ratios-for-default-boxes" class="headerlink" title="2.3 Choosing scales and aspect ratios for default boxes"></a>2.3 Choosing scales and aspect ratios for default boxes</h5><p>已知网络内不同层的特征图具有不同的（经验）感受野大小。 在 SSD 框架内，默认框不需要对应每一层的实际感受野。 因为设计了默认框的平铺，以便特定的特征图学会对目标的特定比例做出响应。 假设要使用第 m 个特征图进行预测。 每个特征图的默认框的比例计算如下： </p>
<script type="math/tex; mode=display">
s_k=s_{min}+\frac{s_{max}-s_{min}}{m-1}(k-1),\,\,k\in[1,m]\\
s_{min}=0.2,s_{max}=0.9,这意味着最低层的尺度为 0.2，最高层的尺度为 0.9，并且中间的所有层都是规则间隔的。\\
default\,\,boxes有不同的纵横比，a_r\in\{1,2,3,\frac{1}{2},\frac{1}{3}\},default\,\,box的宽、高使用w^a_k=s_k\sqrt{a_r}，h^a_k=s_k/\sqrt{a_r}计算得到\\
每个default\,\,box的中心设置为\Big(\frac{i+\,0.5}{|f_k|},\frac{j+\,0.5}{|f_k|}\Big),f_k是第k个正方形的feature \,\,map的大小</script><p>SSD从Conv4_3开始，共提取6个特征图(m=6)，因为Conv4_3是单独设置的，所以上面的线性递增规则需要m-1。s<sub>k</sub>表示先验框大小相对于输入图片的比例。</p>
<p>SSD按照如下规则生成prior box：</p>
<ul>
<li>以feature map上每个点的中点为中心，生成一些列同心的prior box</li>
<li>正方形prior box最小边长为和最大边长为min_size=s<sub>k</sub>，max_size=s<sub>k+1</sub></li>
<li>根据不同的ratio，可以得到不同的长方形anchor</li>
</ul>
<script type="math/tex; mode=display">
width = \sqrt{ratio}\,\,\ast min\_size; height = 1/\sqrt{ratio}\,\,\ast min\_size</script><p><img src="/2021/09/12/SSD-Detector/SSD-4.png" alt="SSD"></p>
<p>默认情况下，每个默认情况下，每个特征图会有一个 <script type="math/tex">a_r= 1</script> 且尺度为 <script type="math/tex">s_k</script>  的先验框，除此之外，还会设置一个尺度为 <script type="math/tex">s_k'=\sqrt{s_ks_{k+1}}</script> 且  <script type="math/tex">a_r= 1</script> 的先验框，这样每个特征图都设置了两个长宽比为1但大小不同的正方形先验框。</p>
<h5 id="2-4-Hard-negative-mining"><a href="#2-4-Hard-negative-mining" class="headerlink" title="2.4 Hard negative mining"></a>2.4 Hard negative mining</h5><p>一般情况下negative default boxes数量&gt;&gt;positive default boxes数量，直接训练会导致网络过于重视负样本，从而loss不稳定。所以需要采取：</p>
<ul>
<li>所以SSD在训练时会依据confidience score排序default box，挑选其中confidence高的box进行训练，控制 positive : negative = 1 : 3</li>
</ul>
<h5 id="2-5-SSD的数据流"><a href="#2-5-SSD的数据流" class="headerlink" title="2.5 SSD的数据流"></a>2.5 SSD的数据流</h5><p><img src="/2021/09/12/SSD-Detector/SSD-5.jpg" alt="SSD"></p>
<p>多尺度feature maps和Prior Box如何组合在一起进行forwards/backwards。需要用到Permute，Flatten和Concat这3种层。上图以conv4_3和fc7为例分析SSD是如何将不同size的feature map组合在一起进行prediction。那么为何要在softmax前后都接一个reshape layer？其实只是为了便于softmax分类，至于具体原因这就要从caffe的实现形式说起了。<a href="https://zhuanlan.zhihu.com/p/31427288" target="_blank" rel="noopener">参考博客-白棠</a></p>
<p><img src="/2021/09/12/SSD-Detector/SSD-2.png" alt="SSD"></p>
<p>上图来自<a href="https://blog.csdn.net/qq_38622495/article/details/82289814" target="_blank" rel="noopener">博客</a></p>
<p><a href="https://arxiv.org/pdf/1512.02325.pdf" target="_blank" rel="noopener">论文</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/31427288" target="_blank" rel="noopener">参考博客-1</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/79854543" target="_blank" rel="noopener">参考博客-2</a></p>
<p><a href="https://blog.csdn.net/qianqing13579/article/details/82106664" target="_blank" rel="noopener">强推的博客</a></p>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Light-Head-R-CNN</title>
    <url>/2021/09/12/Light-Head-R-CNN/</url>
    <content><![CDATA[<h2 id="Light-Head-R-CNN学习笔记"><a href="#Light-Head-R-CNN学习笔记" class="headerlink" title="Light-Head R-CNN学习笔记"></a>Light-Head R-CNN学习笔记</h2><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>首先研究了为什么典型的两阶段方法不如单阶段快速检测器（如 YOLO 系列）那么快。发现 Faster R-CNN和 R-FCN 在 RoI 变形之后或之前执行密集计算。 Faster R-CNN 涉及两个用于 RoI 识别的全连接层，而 R-FCN 产生一个大的分数图。</p>
<p>因此，由于架构中的heavy head设计，这些网络的速度很慢。 即使，使用更轻量级的backbone，计算成本也不能相应地大幅降低。为此，作者设计了一种thin feature map和一个cheap R-CNN子网络，一边网络的头尽可能的轻。</p>
<p>最近基于 CNN 的物体检测器可以分为<strong>单级检测器</strong>和<strong>两级检测器</strong>。 单级探测器通常瞄准速度非常快且准确度相当高的最佳位置。 两阶段检测器将任务分为两步：第一步（body）生成许多proposals，第二步（head）专注于对proposals的识别。 通常，为了达到最佳精度，头部的设计很重。 两级检测器具有<strong>（相对）较慢的速度</strong>和<strong>非常高的准确性</strong>。</p>
<p>在本文中，作者提出了一种轻量设计来构建高效而准确的两级检测器。 应用<strong>大核可分离卷积</strong>来生成具有<strong>小通道数</strong>的“薄”特征图（实验中使用了 α ×p ×p，α ≤10）。 这种设计大大减少了后续 RoI-wise 子网的计算量，并使检测系统内存友好。 一个廉价的单全连接层附加到池化层，它很好地利用了分类和回归的特征表示。 </p>
<h4 id="二、Light-Head-R-CNN"><a href="#二、Light-Head-R-CNN" class="headerlink" title="二、Light-Head R-CNN"></a>二、Light-Head R-CNN</h4><p>Head是指连接到我们骨干基础网络的结构。 更具体地说，将有两个组件：R-CNN 子网和 ROI warp。</p>
<h5 id="2-1-R-CNN-subnet"><a href="#2-1-R-CNN-subnet" class="headerlink" title="2.1 R-CNN subnet"></a>2.1 R-CNN subnet</h5><p>Faster R-CNN 采用强大的 R-CNN，它利用两个大的全连接层或整个 Resnet stage 5 作为第二级分类器，这有利于检测性能。然而，计算可能会很密集，尤其是当对象提议的数量很大时。为了加快 RoI-wise 子网的速度，R-FCN 首先为每个区域生成一组得分图，其通道数将为 #classes ×p ×p（p 是随后的池化大小），然后沿着每个 RoI 池化并求平均值 投票最后的预测。</p>
<p> Light-Head R-CNN 中，作者建议 <code>R-CNN</code> 子网使用一个简单、廉价的全连接层，这在性能和计算速度之间进行了很好的权衡。</p>
<p><img src="/2021/09/12/Light-Head-R-CNN/Light-Head-R-CNN.png" alt="Light-Head-R-CNN"></p>
<h5 id="2-2-Thin-feature-maps-for-RoI-warping"><a href="#2-2-Thin-feature-maps-for-RoI-warping" class="headerlink" title="2.2 Thin feature maps for RoI warping"></a>2.2 Thin feature maps for RoI warping</h5><p>在将提案输入 R-CNN 子网之前，涉及 RoI 变形以使特征图的形状固定。 在实验中，作者发现薄特征图上的 RoI 变形不仅可以提高准确性，而且可以在训练和推理过程中节省内存和计算量。在薄特征图上的使用PSRoI 池化，可以带来更多的计算来加强 R-CNN 并减少通道。</p>
<h4 id="三、Light-Head-R-CNN-for-Object-Detection"><a href="#三、Light-Head-R-CNN-for-Object-Detection" class="headerlink" title="三、Light-Head R-CNN for Object Detection"></a>三、Light-Head R-CNN for Object Detection</h4><ul>
<li>设置“L”以验证算法与大型骨干网络集成时的性能，大型网络采用ResNet101去提取Basic feature；</li>
<li>设置“S”以验证算法在使用小型主干网络时的有效性和效率,小型网络采用类Xception。</li>
</ul>
<h5 id="3-1-Thin-feature-maps"><a href="#3-1-Thin-feature-maps" class="headerlink" title="3.1 Thin feature maps"></a>3.1 Thin feature maps</h5><p>在C<sub>5</sub>上采用大的可分离卷积层，结构如下图所示(图像来源于<a href="https://arxiv.org/pdf/1711.07264.pdf" target="_blank" rel="noopener">论文</a>)：</p>
<p><img src="/2021/09/12/Light-Head-R-CNN/Light-Head-R-CNN-1.png" alt="Light-Head-R-CNN"></p>
<p>设置k=15，在S型模型中，设置C<sub>mid</sub>=64，在L型模型中，设置C<sub>mid</sub>=256。减少C<sub>out</sub>=10&times;p&times;p。受益于大内核带来的更大的有效感受野，汇集的特征图更强大。 </p>
<h5 id="3-2-R-CNN-subnet"><a href="#3-2-R-CNN-subnet" class="headerlink" title="3.2 R-CNN subnet"></a>3.2 R-CNN subnet</h5><p>仅仅使用了2048通道的单个全连接层，没有dropout。然后是两个兄弟全连接层来预测 RoI 分类和回归。因为共享不同类别之间的回归，每个边界框位置仅应用 4 个通道。</p>
<p>这篇文章的主要内容总结：借鉴R-FCN中的思想， 在Position Sensitive maps那块将每个map对应的类别数由81个channal，固定成10个channl，所以显著的降低了输出的通道数，由(C+1)K<sup>2</sup>变成了10K<sup>2</sup>。那么丢失了类别判断的信息，所以在最后增加了一层全连接层用于类别判断。那么这样其实损失了很多信息，为了提升算法的精度，作者在共享卷积后，使用大核可分离卷积获取更大的感受野，以提升检测的性能。</p>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Detector-Net</title>
    <url>/2021/09/12/Detector-Net/</url>
    <content><![CDATA[<h2 id="Detector-Net-学习笔记"><a href="#Detector-Net-学习笔记" class="headerlink" title="Detector-Net(学习笔记)"></a>Detector-Net(学习笔记)</h2><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>该方法提出了一个简单而强大的对象检测公式，作为对象边界框掩码的回归问题。 并且定义了一个多尺度推理过程，它能够通过一些网络应用程序以低成本产生高分辨率的目标检测。</p>
<p>作者制定了一个基于 <code>DNN</code> 的回归，它输出对象边界框的二进制掩码(以及边界框)，如图 1 所示。此外，他们采用简单的边界框推理从掩码中提取检测。 为了提高定位精度，在完整图像和少量大图像裁剪上以多尺度方式应用 DNN 掩码生成，然后进行细化步骤，如图2所示。 </p>
<p><img src="/2021/09/12/Detector-Net/Detector-Net.png" alt="Detector-Net"></p>
<p>作者通过实验证明了基于 <code>DNN</code> 的回归能够学习不仅有利于分类的特征，而且还能够捕获强大的几何信息。在实验中使用AlexNet作为Backbone，并用回归层替换掉最后一层。其次，作者引入了多尺度框推理，然后是细化步骤以产生精确的检测。通过这种方式，该 DNN 可以预测受输出层大小限制的低分辨率掩码。</p>
<h4 id="二、Detection-as-DNN-Regression"><a href="#二、Detection-as-DNN-Regression" class="headerlink" title="二、Detection as DNN Regression"></a>二、Detection as DNN Regression</h4><p>首先，作者还是使用AlexNet作为Backbone，沿用了其中的网络架构，只不过将最后一层softmax分类器换成了回归层用于生成目标的二进制掩膜。DNN(x; Θ) ∈ R<sup>N</sup> ，其中 Θ 是网络参数，N 是输出层像素总数。 由于网络的输出具有固定的维度，网络预测了一个固定大小 N = d ×d 的掩码。 在调整到图像大小后，生成的二进制掩码代表一个或多个对象：如果该像素位于给定类的对象的边界框内，则它在特定像素处的值应为 1，否则为 0。 </p>
<p>通过最小化 L<sub>2</sub> 误差来训练网络，以预测图像 x 的真实掩码 m ∈ [0,1]<sup>N</sup>： </p>
<script type="math/tex; mode=display">
\min_{\Theta}\sum_{(x,m)\in D}||(Diag(m)+\lambda I)^{1/2}(DNN(x;\Theta)-m)||^2_2</script><p>其中总和范围在包含边界框目标的图像的训练集 D 上，这些目标表示为二进制掩码。 由于使用的基础网络是高度<strong>非凸</strong>的并且无法保证最优性，因此有时需要根据ground truth掩码对每个输出使用不同的权重来正则化损失函数。 </p>
<p>直觉是，大多数目标相对于图像大小来说很小，并且网络很容易被为每个输出分配零值的简单解决方案所困(容易陷入局部极小值)。 为了避免这种不良行为，通过参数 λ ∈ R<sup>+</sup>增加与真实掩码中的非零值对应的输出的权重是有帮助的。如果 λ 选择的小，那么真实值为 0 的输出上的错误受到的惩罚明显小于 1 的错误，因此即使信号很弱，也鼓励网络预测非零值。 </p>
<p>在实验中，作者使用了感受野为 225 × 225 的网络，并输出预测大小为 d × d 的掩码（d = 24）。 </p>
<h4 id="三、存在的问题"><a href="#三、存在的问题" class="headerlink" title="三、存在的问题"></a>三、存在的问题</h4><ul>
<li>单个对象掩码可能不足以消除彼此相邻放置的对象的歧义(就是有接触或者距离较小的目标没法分开)</li>
<li>生成的掩码远小于原始图像的大小，不足以精确定位对象，尤其是在目标很小的情况下。例如：文中举例：对于大小为 400 × 400 且 d = 24 的图像，每个输出将对应于大小为 16 × 16 的单元格。</li>
</ul>
<h5 id="3-1-Multiple-Masks-for-Robust-Localization"><a href="#3-1-Multiple-Masks-for-Robust-Localization" class="headerlink" title="3.1 Multiple Masks for Robust Localization"></a>3.1 Multiple Masks for Robust Localization</h5><p>为了处理多个触摸着的目标，作者生成的不是一个而是多个掩码，每个掩码代表整个目标或部分目标。由于最终目标是生成一个边界框，作者使用一个网络来预测目标框掩码，并使用四个额外的网络来预测框的四半：下半部、上半部、左半部和右半部。均用 m<sup>h</sup> 表示，h ∈ { 完整，底部，顶部，左侧，左侧}。此外，如果相同类型的两个对象彼此相邻放置，则所产生的五个掩码中的至少两个将不会合并目标，这将允许消除它们的歧义。 这将能够检测多个目标。</p>
<p>在训练时，需要将目标框转换为这五个掩码。 由于掩码可能比原始图像小得多，需要将ground truth掩码缩小到网络输出的大小。网络输出d&times;d中的(i，j)对应每一个T(i，j)。每一个矩形的左上角坐标为：</p>
<script type="math/tex; mode=display">
\Big(\frac{d_1}{d}(i-1),\frac{d_2}{d}(j-1)\Big),矩形的大小为\frac{d_1}{d}\times\frac{d_2}{d}，i\in(0,\frac{d_1}{d}-1),j\in(0,\frac{d_2}{d}-1)</script><p>其中，d是输出mask的size，d<sub>1</sub>和d<sub>2</sub>是原始图像的height和width。训练时指定m<sup>h</sup>(i，j)作为真实框bb覆盖T(i,j)的预测值，为：</p>
<script type="math/tex; mode=display">
m^h(i,j;bb)=\frac{area(bb(h)\cap T(i,j))}{area(T(i,j))}</script><p>其中 bb(full) 对应于ground truth目标框。 对于值h，bb(h) 对应于ground truth框的四半。 </p>
<p>请注意，论文中使用完整的目标框以及框的上半部、下半部、左半部和右半部来定义总共五种不同的覆盖类型。 ground truth框 bb 的结果 m<sup>h</sup>(bb) 在训练时用于类型 h 的网络。 </p>
<h5 id="3-2-Object-Localization-from-DNN-Output"><a href="#3-2-Object-Localization-from-DNN-Output" class="headerlink" title="3.2 Object Localization from DNN Output"></a>3.2 Object Localization from DNN Output</h5><p>为了完成检测过程，需要为每个图像估计一组边界框。 尽管输出分辨率小于输入图像，但可以将二进制掩码重新缩放为输入图像的分辨率。 目标是估计边界框 bb = (i,j,k,l) 在输出掩码坐标中由其左上角 (i,j) 和右下角 (k,l) 的坐标。</p>
<p>为此，使用分数 S 表示每个边界框 bb 与掩码的一致性，并推断得分最高的框。 一个自然的想法是测量边界框的哪一部分被预测的mask覆盖：</p>
<script type="math/tex; mode=display">
S(bb,m)=\frac{1}{area(bb)}\sum_{(i,j)}m(i,j)area(bb\cap T(i,j))</script><p> 对由 (i,j) 索引的所有网络输出求和，并用 m = DNN(x) 表示输出 的网络。 如果将上述分数扩展到所有五种掩码类型，则最终分数为： </p>
<script type="math/tex; mode=display">
S(bb)=\sum_{h\in halves}(S(bb(h),m^h)-S(bb(\bar{h}),m^h)),\bar{h}是h相反的另一半，这里是为了指出每个部分尽量只负责其对应的一块</script><p>其中，halves={full,botton,top,left,right}索引完整的框及其四半。</p>
<h5 id="3-3-Multi-scale-Refinement-of-DNN-Localizer"><a href="#3-3-Multi-scale-Refinement-of-DNN-Localizer" class="headerlink" title="3.3 Multi-scale Refinement of DNN Localizer"></a>3.3 Multi-scale Refinement of DNN Localizer</h5><p>网络输出分辨率不足的问题通过两种方式解决：</p>
<ol>
<li>在多个尺度和几个大子窗口上应用 DNN 定位器； </li>
<li>通过在顶部推断的边界框上应用 DNN 定位器来改进检测。</li>
</ol>
<p><img src="/2021/09/12/Detector-Net/Detector-Net-1.png" alt="DL"></p>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Model-Acceleration-tools</title>
    <url>/2021/08/15/Model-Acceleration-tools/</url>
    <content><![CDATA[<h2 id="模型推理工具学习"><a href="#模型推理工具学习" class="headerlink" title="模型推理工具学习"></a>模型推理工具学习</h2><h4 id="一、MLPerf"><a href="#一、MLPerf" class="headerlink" title="一、MLPerf"></a>一、MLPerf</h4><p><strong>Benchmark</strong>在计算机领域应用最成功的就是性能测试，主要测试负载的<strong>执行时间、传输速度、吞吐量、资源占用率</strong>等。</p>
<p>性能调优的两大利器是<strong>Benchmark和profile工具</strong>。<strong>Benchmark</strong>用压力测试挖掘整个系统的<strong>性能状况</strong>，而<strong>profile工具</strong>最大限度地呈现系统的运行状态和性能指标，方便用户诊断性能问题和进行调优。</p>
<p><strong>Benchmark的组成</strong></p>
<p>Benchmark中除了dataset，应该还包括做对比的基准算法，以及评估标准。有点像做对比实验的感觉。</p>
<p>Benchmark的核心由3部分组成：数据集、 工作负载、度量指标。</p>
<ul>
<li><p>数据集：数据类型分为结构化数据、半结构化数据和非结构化数据。</p>
<ul>
<li>结构化数据：传统的关系数据模型</li>
<li>半结构化数据：类似XML、HTML之类</li>
<li>非结构化数据：各种文档、图片、视频和音频等</li>
</ul>
</li>
<li><p>工作负载</p>
<ul>
<li>密集计算类型：CPU密集型计算、IO密集型计算、网络密集型计算</li>
<li>计算范式：SQL、批处理、流计算、图计算、机器学习；</li>
<li>计算延迟：在线计算、离线计算、实时计算</li>
<li>应用领域：搜索引擎、社交网络、电子商务、地理位置、媒体、游戏</li>
</ul>
</li>
<li><p>度量指标</p>
<ul>
<li>工具的使用：perf，nmon等工具和命令</li>
<li>度量指标：浮点型操纵密度、整数型操纵密度、指令中断、cache命中率、TLB命中率</li>
</ul>
<p><a href="https://www.cnblogs.com/sddai/p/7642738.html" target="_blank" rel="noopener">参考资料</a></p>
</li>
</ul>
<h5 id="一、介绍"><a href="#一、介绍" class="headerlink" title="一、介绍"></a>一、介绍</h5><p><code>MLPerf</code>是一套用于测量和提高机器学习软硬件性能的通用基准。主要用来测量<code>训练</code>和<code>推理</code>不同神经网络所需要的时间。<code>MLPerf</code>测试集包含了不同领域的Benchmark子项，主要包括图像分类、物体识别、翻译、推荐、语音识别、情感分析以及强化学习。</p>
<h5 id="二、MLPerf-Training"><a href="#二、MLPerf-Training" class="headerlink" title="二、MLPerf Training"></a>二、MLPerf Training</h5><p><strong>对于MLPerf Training测试</strong>，每个Benchmark的评价标准是：在特定数据集上训练一个模型使其达到Quality Target时的Clock time。由于机器学习任务的训练时间有很大差异，因此，MLPerf 的最终训练结果是由指定次数的基准测试时间平均得出的，其中会去掉最低和最高的数字，一般是运行5次取平均值，Train测试时间包含了模型构建，数据预处理，训练以及质量测试等时间。</p>
<p>MLPerf training可以分为封闭模型分区（Closed Model Division）和开放模型分区（Open Model Division）。</p>
<p><strong>Closed Model Division</strong>具体要求如下：MLPerf为每个领域的Benchmark测试都提供了参考实例</p>
<ol>
<li><strong>预处理</strong>必须采用与参考实例相同的预处理步骤，图像必须与参考实现中的大小相同。</li>
<li><strong>权重和偏差</strong>必须使用与参考实例相同的常数或随机值分布进行初始化。</li>
<li><strong>损失函数</strong>必须使用与参考实例相同的损失函数。</li>
<li><strong>优化器</strong>必须使用与参考实例相同的优化器。</li>
<li>RL环境也需要与参考实例相同，参数相同。</li>
<li>超参数是可以自己选择的。</li>
</ol>
<p><strong>Open Model Division</strong>：</p>
<p>开放模型分区要求使用相同的数据集解决相同的问题，允许使用任意预处理，模型或训练方法。它旨在推进ML模型和优化的创新。</p>
<p><strong>MLPerfTraining Result</strong>:</p>
<p>MLPerf Result被定义为将模型训练到目标质量的时间，这个时间包括模型构建，数据预处理，训练以及质量测试等时间，它通常是数小时或数天。</p>
<p>加速比: 加速比是当前测试结果和使用一块Pascal P100显卡在未进行任何优化情况下的测试结果的比值。即当前测试结果和参考基准的比值。</p>
<p><strong>具体的步骤</strong>：</p>
<ul>
<li>环境构建</li>
<li>准备数据</li>
<li>运行Benchmark</li>
</ul>
<h5 id="三、MLPerf-Inference"><a href="#三、MLPerf-Inference" class="headerlink" title="三、MLPerf Inference"></a>三、MLPerf Inference</h5><p><strong>对于MLPerf Inference测试</strong>，每个Benchmark的评价标准是：<code>在特定数据集上测量模型的推理性能，包括延时和吞吐量。</code></p>
<p>在MLPerf Inference中，主要分为三个部分：</p>
<ul>
<li><p>Load Generator: Load Generator是MLPerf的负载生成器，用于启动和控制Inference Benchmark测试。</p>
<p>MLPerf Inference有三个基本概念: SUT(被测系统)、Sample(inference单位，图像或词)和query(一次推理的样本数)。</p>
<p>在Inference测试中，LoadGen主要负责以下事情：</p>
<ol>
<li>根据测试某个场景生成query</li>
<li>跟踪query的Latency</li>
<li>验证结果的准确性</li>
<li>计算最终的metric</li>
</ol>
</li>
<li><p>Cloud: 云业务场景，MLPerf Inference计划为Cloud环境提供6个领域的Benchmark</p>
</li>
<li><p>Edge:  边缘端的业务场景，MLPerf Inference计划为Edge环境提供6个领域的Benchmark</p>
</li>
</ul>
<p>MLPerf Inference也分为封闭分区（Closed Division）和开放分区（Open Division）。</p>
<ul>
<li><p>封闭分区需要使用等同于参考实现的预处理，后处理和模型。封闭分区允许校准量化，不允许任何再训练。</p>
</li>
<li><p>开放分区只限制使用相同的数据集，它允许使用任意的预处理或后处理和模型，包括再培训</p>
</li>
</ul>
<p><a href="https://blog.csdn.net/han2529386161/article/details/102723482" target="_blank" rel="noopener">参考链接</a></p>
<h4 id="二、MPI"><a href="#二、MPI" class="headerlink" title="二、MPI"></a>二、MPI</h4><p>在程序中，不同的进程需要相互的数据交换，特别是在科学计算中，需要大规模的计算与数据交换，集群可以很好解决单节点计算力不足的问题，但在集群中大规模的数据交换是很耗费时间的，因此需要一种在多节点的情况下能快速进行数据交流的标准，这就是MPI。</p>
<p>MPI是一组用于多节点数据通信的标准，而非一种语言或者接口。具体的使用方法需要依赖它的具体实现(mpich or openmpi等)。</p>
<p>mpi的目标是</p>
<ol>
<li>实现较高的通信性能</li>
<li>好的程序移植性</li>
<li>强大的功能</li>
</ol>
<p><strong>进程</strong></p>
<p>通俗的说，进程就是运行的程序。一个程序可以含有多个进程，但一个进程不能同属于多个程序。进程拥有独立的运行环境(内存，寄存器，CPU执行时间等)，是操作系统中独立存在的可执行的基本单位。每个进程所占有的资源都是独立的，不与其他的进程共享，不能访问其他进程内存空间，其他进程也无法访问该进程内存空间。但可以通过消息传递来进行通信。</p>
<p><strong>进程组</strong></p>
<p>指一个mpi程序中的所有(n个)进程的集合。该程序中所有进程编号从0到n-1，主要是为了标识不同的进程，可以通过进程的编号来索引该进程。不同进程组的进程的编号可以相同。</p>
<p><strong>通信器(MPI_Comm)</strong></p>
<p>可以理解为一组进程间可以通信的进程组，通信函数必须在通信器内调用。</p>
<p><strong>消息</strong></p>
<p>需要通信的数据。</p>
<p><strong>mpi对象</strong></p>
<p>mpi内存的数据结构，包括数据类型(MPI_DOUBLE)，通信器(MPI_COMM)等</p>
<p><a href="https://zhuanlan.zhihu.com/p/69497154" target="_blank" rel="noopener">参考资料</a></p>
<h4 id="三、GPU-Director"><a href="#三、GPU-Director" class="headerlink" title="三、GPU Director"></a>三、GPU Director</h4><p>当前深度学习模型越来越复杂，计算数据量暴增，对于大规模深度学习训练任务，单机已经无法满足计算要求，多机多卡的分布式训练成为了必要的需求，这个时候多机间的通信成为了分布式训练性能的重要指标。</p>
<p><strong>RDMA介绍</strong></p>
<p>我们先来看看RDMA技术是什么？RDMA即Remote DMA，是Remote Direct Memory Access的英文缩写。</p>
<p><strong>DMA原理</strong></p>
<p>DMA（直接内存访问）技术是Offload CPU负载的一项重要技术。DMA的引入，使得原来设备内存与系统内存的数据交换必须要CPU参与，变为交给DMA控制来进行数据传输。</p>
<p> 直接内存访问(DMA)方式，是一种完全由硬件执行I/O交换的工作方式。在这种方式中，  DMA控制器从CPU完全接管对总线的控制，数据交换不经过CPU，而直接在内存和IO设备之间进行。DMA工作时，由DMA  控制器向内存发出地址和控制信号，进行地址修改，对传送字的个数计数，并且以中断方式向CPU 报告传送操作的结束。</p>
<p>使用DMA方式的目的是减少大批量数据传输时CPU 的开销。采用专用DMA控制器(DMAC) 生成访存地址并控制访存过程。优点有操作均由硬件电路实现，传输速度快；CPU 基本不干预，仅在初始化和结束时参与，CPU与外设并行工作，效率高。</p>
<p>传统的TCP/IP协议，应用程序需要要经过多层复杂的协议栈解析，才能获取到网卡中的数据包，而使用RDMA协议，应用程序可以直接旁路内核获取到网卡中的数据包。</p>
<p>RDMA可以简单理解为利用相关的硬件和网络技术，服务器1的网卡可以直接读写服务器2的内存，最终达到高带宽、低延迟和低资源利用率的效果。</p>
<p>GPUDirect  RDMA，就是计算机1的GPU可以直接访问计算机2的GPU内存。而在没有这项技术之前，GPU需要先将数据从GPU内存搬移到系统内存，然后再利用RDMA传输到计算机2，计算机2的GPU还要做一次数据从系统内存到GPU内存的搬移动作。GPUDirect RDMA技术使得进一步减少了GPU通信的数据复制次数，通信延迟进一步降低。</p>
<p><a href="https://blog.csdn.net/weixin_33709609/article/details/89687048" target="_blank" rel="noopener">参考资料</a></p>
]]></content>
      <categories>
        <category>Model Acceleration</category>
      </categories>
      <tags>
        <tag>Model Acceleration</tag>
      </tags>
  </entry>
  <entry>
    <title>Model-Acceleration-Zero</title>
    <url>/2021/08/15/Model-Acceleration-Zero/</url>
    <content><![CDATA[<h2 id="模型加速"><a href="#模型加速" class="headerlink" title="模型加速"></a>模型加速</h2><h4 id="一、pytorch-JIT浅解析"><a href="#一、pytorch-JIT浅解析" class="headerlink" title="一、pytorch JIT浅解析"></a>一、pytorch JIT浅解析</h4><p>Torch脚本是一种从PyTorch代码创建可序列化和可优化模型的方法。用Torch脚本编写的代码可以从Python进程中保存，并在没有Python依赖的进程中加载。</p>
<p>Torch Script中的核心数据结构是ScriptModule。 它是<strong>Torch的nn.Module的类似物</strong>，代表整个模型作为子模块树。 与普通模块一样，ScriptModule中的每个单独模块都可以包含子模块，参数和方法。 在nn.Modules中，方法是作为Python函数实现的，但在ScriptModules方法中通常实现为Torch Script函数，这是一个<strong>静态类型的Python子集</strong>，包含PyTorch的所有内置Tensor操作。 这种差异允许您运行ScriptModules代码而无需Python解释器。</p>
<p><strong>ScriptModules和Torch Script函数可以通过两种方式创建：</strong></p>
<p><strong>Tracing:</strong> 使用torch.jit.trace，可以获取现有模块或python函数，提供示例输入，然后运行该函数，记录在所有张量上执行的操作。</p>
<p>由于跟踪仅记录张量上的操作，因此它不会记录任何控制流操作，如if语句或循环。 当这个控制流在你的模块中保持不变时，这很好，它通常只是内联配置决策。 但有时控制流实际上是模型本身的一部分。 例如，序列到序列转换中的波束搜索是输入的（变化的）序列长度上的循环。 在这种情况下，跟踪不合适，并且应使用脚本编写波束搜索。<br>        <strong>Scripting:</strong>可以使用Python语法直接编写Torch Script代码，以在ScriptModule的子类上使用torch.jit.script批注（对于函数）或torch.jit.script_method批注（对于方法）来执行此操作。</p>
<p>为什么需要JIT(即时编译)？</p>
<p>是一种程序优化的方法，JIT 到底带来了哪些好处。</p>
<ol>
<li><p>模型部署</p>
<p>PyTorch 的 1.0 版本发布的最核心的两个新特性就是 JIT 和 C++ API，这两个特性一起发布不是没有道理的，JIT 是  Python 和 C++ 的桥梁，我们可以使用 Python 训练模型，然后通过 JIT 将模型转为语言无关的模块，从而让 C++  可以非常方便得调用，从此「使用 Python 训练模型，使用 C++ 将模型部署到生产环境」对 PyTorch  来说成为了一件很容易的事。而因为使用了 C++，我们现在几乎可以把 PyTorch 模型部署到任意平台和设备上：树莓派、iOS、Android  等等</p>
</li>
<li><p>性能提升</p>
<p>既然是为部署生产所提供的特性，那免不了在性能上面做了极大的优化，如果推断的场景对性能要求高，则可以考虑将模型（torch.nn.Module）转换为 TorchScript Module，再进行推断。</p>
</li>
<li><p>模型可视化</p>
<p>TensorFlow 或 Keras  对模型可视化工具（TensorBoard等）非常友好，因为本身就是静态图的编程模型，在模型定义好后整个模型的结构和正向逻辑就已经清楚了；但  PyTorch 本身是不支持的，所以 PyTorch 模型在可视化上一直表现得不好，但 JIT 改善了这一情况。现在可以使用 JIT 的  trace 功能来得到 PyTorch 模型针对某一输入的正向逻辑，通过正向逻辑可以得到模型大致的结构，但如果在 <code>forward</code>  方法中有很多条件控制语句，这依然不是一个好的方法，所以 PyTorch JIT 还提供了 Scripting 的方式。</p>
</li>
</ol>
<p><a href="https://zhuanlan.zhihu.com/p/370455320" target="_blank" rel="noopener">优秀的参考</a></p>
<h4 id="二、模型量化"><a href="#二、模型量化" class="headerlink" title="二、模型量化"></a>二、模型量化</h4><p><strong>一种有效降低模型大小和计算量的方法</strong></p>
<p>模型量化就是将网络中的参数【weight、bias、activation value】从高精度转换成低精度的操作过程，同时我们期望转换后的模型准确率与转换前的相近。</p>
<h5 id="1、-为什么量化有用？"><a href="#1、-为什么量化有用？" class="headerlink" title="1、 为什么量化有用？"></a>1、 为什么量化有用？</h5><p>网络模型在量化过程中会引入量化噪声，而CNN网络对噪声并不敏感，因此模型量化方法对CNN网络是有效的。</p>
<h5 id="2、为什么用量化？"><a href="#2、为什么用量化？" class="headerlink" title="2、为什么用量化？"></a>2、为什么用量化？</h5><ul>
<li>模型太大，比如alexnet就200MB，存储压力大</li>
<li>每个层的weights范围基本都是确定的，且波动不大，适合量化压缩</li>
<li>既减少访存又减少计算量</li>
<li>降低设备的功耗</li>
</ul>
<h5 id="3、为什么不直接训练低精度的模型？"><a href="#3、为什么不直接训练低精度的模型？" class="headerlink" title="3、为什么不直接训练低精度的模型？"></a>3、为什么不直接训练低精度的模型？</h5><ul>
<li>因为你训练是需要反向传播和梯度下降的，int8就非常不好做了，举个例子就是我们的学习率一般都是零点几零点几的，int8没法做。</li>
<li>大部分模型都是浮点类型的，可以直接转换</li>
</ul>
<p><a href="https://github.com/Ewenwan/MVision/tree/master/CNN/Deep_Compression/quantization" target="_blank" rel="noopener">量化综述</a></p>
<h5 id="4、int8量化原理"><a href="#4、int8量化原理" class="headerlink" title="4、int8量化原理"></a>4、int8量化原理</h5><p><img src="/2021/08/15/Model-Acceleration-Zero/quantified-0.jpg" alt="ML"></p>
<p>非饱和量化是最本质也是最暴力的方法。即通过统计网络模型中每一个layer中weight或activation value的absmax value计算出缩放因子scale。然后使用线性映射的方式将原始的浮点数据转换到INT8的数据域中，量化公式如下所示：</p>
<script type="math/tex; mode=display">
R=scale*(q-z)</script><p>当模型数据分布不均匀的时候，使用这种量化方式，会导致量化后的模型精度与量化前的模型精度相差甚远，为了解决该问题，很多情况下是采用饱和方式进行量化：</p>
<p><img src="/2021/08/15/Model-Acceleration-Zero/quantified-1.jpg" alt="ML"></p>
<p>该量化方法是从浮点数据分布中寻找一个最优阈值T作为absmax value的值，然后采用上述公式进行量化。大概的最优阈值的选取过程如下：</p>
<ul>
<li>收集激活值得直方图</li>
<li>基于不用的阈值产生不同的量化分布</li>
<li>计算每个分布与元分布的相对熵，然后选择熵最少的一个</li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/362976429" target="_blank" rel="noopener">参考资料</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/71881443" target="_blank" rel="noopener">参考资料</a></p>
]]></content>
      <categories>
        <category>Model Acceleration</category>
      </categories>
      <tags>
        <tag>Model Acceleration</tag>
      </tags>
  </entry>
  <entry>
    <title>Faster-R-CNN-Code-Analyse</title>
    <url>/2021/08/15/Faster-R-CNN-Code-Analyse/</url>
    <content><![CDATA[<h2 id="Faster-R-CNN源码分析-1"><a href="#Faster-R-CNN源码分析-1" class="headerlink" title="Faster R-CNN源码分析(1)"></a>Faster R-CNN源码分析(1)</h2><h4 id="一、预备知识"><a href="#一、预备知识" class="headerlink" title="一、预备知识"></a>一、预备知识</h4><h5 id="1、Cython构建python的build-in模块"><a href="#1、Cython构建python的build-in模块" class="headerlink" title="1、Cython构建python的build-in模块"></a>1、Cython构建python的build-in模块</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Cython库可将已有的Python代码转化为C语言的代码，并作为Python的built-in模块扩展。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">python setup.py build_ext --inplace</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#build_ext把ext_modules指定的一些模块，编译和链接成动态库</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#--inplace指示 将编译后的扩展模块直接放在与setup.py同级的目录中</span></span></pre></td></tr></table></figure>
<p>目前Python代码的执行过程是将Python代码转变成一行行指令，然后解释器解释指令的执行，调用到C代码层。如果去掉指令解释这个阶段，直接进入C代码层，效率就比较高了。Cython 是 Python 编程语言和扩展 Cython 编程语言（基于 Pyrex）的优化静态编译器。 它使得为 Python 编写 C 扩展就像 Python 本身一样简单。 </p>
<p><strong>整个Cython工作的流程分两步：</strong></p>
<ol>
<li>.py文件使用Cython被编译为.c文件；</li>
<li>.c文件使用C编译器生成.pyd(windos)或.so(linux)文件。</li>
</ol>
<p><img src="/2021/08/15/Faster-R-CNN-Code-Analyse/Cython.png" alt="Cython"></p>
<p>上图来自博客园<a href="https://home.cnblogs.com/u/SsoZhNO-1/" target="_blank" rel="noopener">SsoZh</a></p>
<p><a href="https://www.jianshu.com/p/cfcc2c04a6f5" target="_blank" rel="noopener">Cythhon入门经典</a></p>
<p><strong>构建Cython代码的几种方法：</strong></p>
<ul>
<li>写一个 distutils / setuptools setup.py。推荐的方式(下面主要学习这种方式)<ul>
<li>如果您使用 setuptools 而不是 distutils，则需要注意，运行python setup.py install时的默认操作是创建一个压缩的egg文件，当您尝试从依赖包中使用它们时，这些文件无法与pxd文件一起用于pxd文件。为防止这种情况，请在setup()的参数中包含zip_safe=False。使用 setuptools 时，您应该在 Cython 之前导入它，因为 setuptools 可能会替换 distutils 中的Extension类</li>
</ul>
</li>
<li>使用 Pyximport，导入 Cython .pyx文件就像它们是.py文件一样</li>
<li>手动运行cython命令行实用程序，从.pyx文件生成.c文件，然后手动将.c文件编译成适合从 Python 导入的共享库或 DLL</li>
<li>使用 [Jupyter] 笔记本或 [Sage] 笔记本，两者都允许 Cython 代码内联</li>
</ul>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#distutils 构建 Cython 模块</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">setup(</span></pre></td></tr><tr><td class="code"><pre><span class="line">	name = <span class="string">""</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ext_module = ext_modues,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cmdclass = &#123;&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#name: site-package安装文件夹下的egg文件。假设不指定，将会以UNKNOW命名：/usr/lib64/python2.6/site-packages/UNKNOWN-0.0.0-py3.8.egg-info</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#ext_module: 是一个包括Extension实例的列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#Extension实力列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#1. name: 扩展包的名字，供python导入import时使用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#2. source: 源文件组成的列表，源文件能够是C，C++等特定的资源文件或其他有build_ext确定的Python扩展，如.pyx文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#3. language：扩展语言名称，默认是c,如果要用C++，可以改成C++</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#4. include_dirs： 提供搜索C/C++头文件的文件夹组成的列表（比方：*.h），gcc的-I参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#5. library_dirs：提供搜索C/C++库文件的文件夹组成的列表（比方：*.a），gcc的-L参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#6. libraries：库名组成的列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#7. extra_cpmpile_args: 就是传给 gcc 的额外的编译参数，比方说你可以传一个 -std=c++11</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#8. extra_link_args: 就是传给 gcc 的额外的链接参数,如：-pthread</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#cmdclass: 定制化命令，通过继承 setuptools.command 下的命令类来进行定制化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UploadCommand</span><span class="params">(Command)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"""Support setup.py upload."""</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            self.status(<span class="string">'Removing previous builds…'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            rmtree(os.path.join(here, <span class="string">'dist'</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">except</span> OSError:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">pass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.status(<span class="string">'Building Source and Wheel (universal) distribution…'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        os.system(<span class="string">'&#123;0&#125; setup.py sdist bdist_wheel --universal'</span>.format(sys.executable))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.status(<span class="string">'Uploading the package to PyPI via Twine…'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        os.system(<span class="string">'twine upload dist/*'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.status(<span class="string">'Pushing git tags…'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        os.system(<span class="string">'git tag v&#123;0&#125;'</span>.format(about[<span class="string">'__version__'</span>]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        os.system(<span class="string">'git push --tags'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        sys.exit()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">setup(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># $ setup.py publish support.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cmdclass=&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="string">'upload'</span>: UploadCommand,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#这样可以通过 python setup.py upload 运行打包上传代码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#如果您需要指定编译器选项、要链接的库或其他链接器选项，您将需要手动创建扩展实例Extension（请注意，仍然可以使用 glob 语法在一行中指定多个扩展）： </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> setuptools <span class="keyword">import</span> Extension, setup</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> Cython.Build <span class="keyword">import</span> cythonize</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">extensions = [</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Extension(<span class="string">"primes"</span>, [<span class="string">"primes.pyx"</span>],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        include_dirs=[...],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        libraries=[...],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        library_dirs=[...]),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># Everything but primes.pyx is included here.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Extension(<span class="string">"*"</span>, [<span class="string">"*.pyx"</span>],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        include_dirs=[...],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        libraries=[...],</span></pre></td></tr><tr><td class="code"><pre><span class="line">        library_dirs=[...]),</span></pre></td></tr><tr><td class="code"><pre><span class="line">]</span></pre></td></tr><tr><td class="code"><pre><span class="line">setup(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name=<span class="string">"My hello app"</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ext_modules=cythonize(extensions),</span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#from Cython.Distutils import build_ext</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#通过自定义类继承build_ext，来自定义distutils构建方式,如下：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">custom_build_ext</span><span class="params">(build_ext)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">build_extensions</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">#self.compiler是Cython.Distutils-》build_ext中的属性</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        customize_compiler_for_nvcc(self.compiler)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        build_ext.build_extensions(self)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">setup(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name=<span class="string">'faster_rcnn'</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ext_modules=ext_modules,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># inject our custom trigger</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cmdclass=&#123;<span class="string">'build_ext'</span>: custom_build_ext&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr></table></figure>
<p><a href="https://zhuanlan.zhihu.com/p/24311879" target="_blank" rel="noopener">优秀的参考资料</a></p>
<p><a href="https://www.bookstack.cn/read/cython-doc-zh/docs-29.md" target="_blank" rel="noopener">Cython 3.0中文文档</a></p>
<p><a href="https://stackoverflow.com/questions/41169711/python-setuptools-distutils-custom-build-for-the-extra-package-with-makefile" target="_blank" rel="noopener">具有非常大的参考价值的链接</a></p>
<p><a href="https://github.com/python/cpython/blob/main/Lib/distutils/command/build_ext.py" target="_blank" rel="noopener">Distutils-Cammond源码</a></p>
<h5 id="2、NVCC编译学习"><a href="#2、NVCC编译学习" class="headerlink" title="2、NVCC编译学习"></a>2、NVCC编译学习</h5><p>下图给出了NVCC支持的编译阶段的命令以及输出的文件格式</p>
<p><img src="/2021/08/15/Faster-R-CNN-Code-Analyse/nvcc-0.png" alt="NVCC"></p>
<p>CUDA 编译的工作原理如下：输入程序经过预处理以供Device编译器编译，并编译为 CUDA 二进制（cubin）和/或 PTX 中间代码，这些代码放在一个 fatbinary 中。 输入程序再次预处理以供HOST编译，并与嵌入的fatbinary合成在一起，并将 CUDA 特定 C++ 扩展转换为标准 C++ 构造。 然后 C++ 主机编译器将带有嵌入的 fatbinary 的合成主机代码编译成主机Object。 为实现这一目标所遵循的确切步骤如图 1 所示。 </p>
<p><img src="/2021/08/15/Faster-R-CNN-Code-Analyse/nvcc-1.png" alt="NVCC"></p>
<p>上图来自于Nvidia官网<a href="https://docs.nvidia.com/cuda/cuda-compiler-driver-nvcc/index.html" target="_blank" rel="noopener">入口</a></p>
<p>每个 <strong>nvcc 选项</strong>都有一个<strong>长名称</strong>和一个<strong>短名称</strong>，它们可以相互互换。 这两种变体的区别在于选项名称前面必须有多少个连字符：长名称前面必须有两个连字符，而短名称前面必须有一个连字符。 例如，-I 是 —include-path 的简称。长名称描述性价值更高，短名称交互性价值更高。</p>
<p><strong>nvcc</strong> 识别<strong>三种类型的命令选项</strong>：布尔选项、单值选项和列表选项。 </p>
<p>布尔选项没有参数； 它们要么在命令行上指定，要么不指定(就是要么有这个选项或者没有，如：加—verbosse或不加)。 单值选项最多只能指定一次(不能出现多次，如：—output-file xxx —output-file xxx)，列表选项可以重复。 每个选项类型的示例分别是：—verbose（切换到详细模式）、—output-file（指定输出文件）和—include-path（指定包含路径）。 </p>
<p><strong>单值选项</strong>和<strong>列表选项</strong>必须有参数，该参数必须跟在选项本身的名称后面，后面是多个空格之一或等号字符。 当使用<strong>单字符短名称</strong>（例如 -I、-l 和 -L）时，<strong>选项的值也可以紧跟在选项本身之后，而不用空格或等号字符分隔</strong>。 列表选项的各个值可以在选项的单个实例中用逗号分隔，或者选项可以重复，或者这两种情况的任意组合。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">合法的例子</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">-o file</span></pre></td></tr><tr><td class="code"><pre><span class="line">-o=file</span></pre></td></tr><tr><td class="code"><pre><span class="line">-Idir1,dir2 -I=dir3 -I dir4,dir5</span></pre></td></tr></table></figure>
<p><strong>File and Path Specifications</strong></p>
<ol>
<li>—output-file <em>file</em> (-o)：指定输出文件的名称和位置。 </li>
<li>—pre-include file,…,(-include): 指定在预处理期间必须预先包含的头文件。</li>
<li>—library library,… (-l): 指定要在链接阶段使用的库，不带库文件扩展名。 在使用选项 —library-path 指定的库搜索路径上搜索库。</li>
<li>—define-macro def,… (-D): 定义要在预处理期间使用的宏。 def 可以是 name 或 name=definition。 </li>
<li>—undefine-macro def,… (-D): 在预处理或编译期间取消定义现有宏。 </li>
<li>—include-path path,… (-I): 指定包含搜索路径。 </li>
<li>—system-include path,… (isystem): 指定系统包含搜索路径。 </li>
<li>—library-path path,… (-L): 指定库搜索路径。</li>
<li>—cudart {none | shared | static} (-cudart): 指定要使用的 CUDA 运行时库的类型：无 CUDA 运行时库、共享/动态 CUDA 运行时库或静态 CUDA 运行时库。 </li>
<li>—cudadevrt {none | static } {-cudadevrt}: 指定要使用的 CUDA 设备运行时库的类型：无 CUDA 设备运行时库或静态 CUDA 设备运行时库。 </li>
</ol>
<p><strong>Options for Specifying the Compilation Phase</strong></p>
<p>此类别的选项指定输入文件必须编译到哪个阶段。 </p>
<ol>
<li>—link (-link): 指定默认行为：编译并链接所有输入文件。 </li>
<li>—lib (-lib): 如有必要，将所有输入文件编译为目标文件，并将结果添加到指定的库输出文件中。 </li>
<li>—device-link (-dlink): 将具有可重定位设备代码的目标文件和 .ptx、.cubin 和 .fatbin 文件链接到具有可执行设备代码的目标文件中，该目标文件可以传递给主机链接器。 </li>
<li>—device-c (-dc): 将每个 .c、.cc、.cpp、.cxx 和 .cu 输入文件编译为包含可重定位设备代码的目标文件。 </li>
<li>—device-w (-dw): 将每个 .c、.cc、.cpp、.cxx 和 .cu 输入文件编译为包含可执行设备代码的目标文件。 </li>
<li>—cuda (-cuda): 将每个 .cu 输入文件编译为 .cu.cpp.ii 文件。 </li>
<li>—compile (-c): 将每个 .c、.cc、.cpp、.cxx 和 .cu 输入文件编译为目标文件。 </li>
<li>—fatbin (-fatbin): 将所有 .cu、.ptx 和 .cubin 输入文件编译为仅限设备的 .fatbin 文件。 。nvcc 使用此选项丢弃每个 .cu 输入文件的主机代码。</li>
<li>—cubin (-cubin): 将所有 .cu 和 .ptx 输入文件编译为仅限设备的 .cubin 文件。 nvcc 使用此选项丢弃每个 .cu 输入文件的主机代码。 </li>
<li>—ptx (-ptx): 将所有 .cu 输入文件编译为仅限设备的 .ptx 文件。 nvcc 使用此选项丢弃每个 .cu 输入文件的主机代码。</li>
<li>—preprocess (-E): 预处理所有 .c、.cc、.cpp、.cxx 和 .cu 输入文件。 </li>
<li>—generate-dependencies (-M): 为 .c、.cc、.cpp、.cxx 和 .cu 输入文件生成可包含在 Makefile 中的依赖文件。 </li>
<li>—run (-run): 将所有输入文件编译并链接到一个可执行文件中，然后执行它。 </li>
</ol>
<p><strong>Options for Passing Specific Phase Options(用于传递特定阶段选项的选项 )</strong></p>
<p>说白了就是，比如nvcc中没有的一些执行，但要使用的话可以通过该选项中的一些参数进行传递。这些允许将特定选项直接传递给 nvcc 封装的内部编译工具，而不会给 nvcc 带来关于这些工具的过于详细的知识。</p>
<ol>
<li>—compiler-options options,… (-Xcompiler): 直接向编译器/预处理器指定选项。 如：-Xcompiler -fPIC</li>
<li>—linker-options options,… (-Xlinker): 直接为主机链接器指定选项。 </li>
<li>—archive-options options,… (-Xarchive): 直接向库管理器指定选项。 </li>
<li>—ptxas-options options,… (-Xptxas): 直接为 PTX 优化汇编器 ptxas 指定选项。 </li>
<li>—nvlink-options options,… (-Xnvlink): 直接为设备链接器 nvlink 指定选项。 </li>
</ol>
<p><strong>Option for Specifying Behavior of Compiler/Linker(用于指定编译器/链接器行为的选项 )</strong></p>
<ol>
<li>—profile (-pg): 仪器生成的代码/可执行文件供 gprof 使用。 </li>
<li>—debug (-g): 为主机代码生成调试信息。 </li>
<li>—device-debug (-G): 为设备代码生成调试信息。 此选项关闭对设备代码的所有优化。 它不用于分析； 使用 —generate-line-info 代替分析。 </li>
<li>—optimize level (-O): 指定主机代码的优化级别。 </li>
<li>—shared (-shared): 在链接期间生成共享库。 </li>
<li>—x {c | c++ | cu} (-x): 明确指定输入文件的语言，而不是让编译器根据文件名后缀选择默认语言。 </li>
<li>—std {c++03 | c++11 | c++14 | c++17} (-std): 选择一个特定的C++ Dialect。</li>
<li>—machine {32 | 64} (-m): 指定 32 位与 64 位架构。 </li>
</ol>
<p><strong>Options for Guiding the Compiler Driver(引导编译器驱动程序的选项 )</strong></p>
<ol>
<li>—dont-use-profile (-noprof): 不要使用 nvcc.profile 文件中的配置进行编译。 </li>
<li>—threads number (-t): 指定用于并行执行编译步骤的最大线程数。 多架构编译时，该选项可用于提高编译速度。 编译器创建多个线程来并行执行编译步骤。 如果 number 为=1，则忽略此选项。 如果 number = 0，则使用的线程数是机器上的 CPU 数。 </li>
<li>—dryrun (-dryrun): 列出编译子命令而不执行它们。</li>
<li>—verbose (-v): 在执行时列出编译子命令。 </li>
<li>—keep (-keep): 保留在内部编译步骤中生成的所有中间文件。 </li>
<li>—keep-dir directory (-keep-dir): 将内部编译步骤中生成的所有中间文件保存在此目录中。 </li>
</ol>
<p><strong>Opetions for Steering GPU Code Generation(用于引导 GPU 代码生成的选项 )</strong></p>
<ol>
<li>—gpu-architecture arch (-arch): 指定编译 CUDA 输入文件的 NVIDIA 虚拟 GPU 架构类的名称。通常，单独使用此选项不会触发为真实架构组装生成的 PTX，它的目的是控制 PTX 输入的预处理和编译。如果未指定选项 —gpu-code 的值，则此选项的值默认为 —gpu-architecture 的值。 在这种情况下，作为上述描述的唯一例外，为 —gpu-architecture 指定的值可能是真实架构（例如 sm_50），在这种情况下，nvcc 使用指定的真实架构及其最接近的虚拟架构作为有效架构 值。 例如，nvcc —gpu-architecture=sm_50 等价于 nvcc —gpu-architecture=compute_50 —gpu-code=sm_50,compute_50。 </li>
<li>—gpu-code code,… (-code): 指定要为其组装和优化 PTX 的 NVIDIA GPU 的名称。 nvcc 在生成的每个指定代码架构的可执行文件中嵌入一个编译后的代码映像，它是每个真实架构（例如 sm_50）的真正二进制加载映像，以及虚拟架构（例如 compute_50）的 PTX 代码。 在运行时，如果没有找到当前 GPU 的二进制加载图像，则 CUDA 运行时系统会动态编译此类嵌入式 PTX 代码。 </li>
<li>—generate-code specification (-gencode): 此选项提供了 —gpu-architecture=arch —gpu-code=code,… 选项组合的概括，用于指定与代码生成相关的 nvcc 行为。 使用前面的选项为不同的真实架构生成代码，而 PTX 用于相同的虚拟架构，选项 —generate-code 允许为不同的虚拟架构生成多个 PTX。 事实上， —gpu-architecture=arch —gpu-code=code,… 等价于 —generate-code=arch=arch,code=code,… 。 </li>
</ol>
<p><strong>Generic Tool Options</strong></p>
<ol>
<li>—disable-warnings (-w): 禁止所有警告消息。 </li>
<li>—Wno-deprecated-gpu-targets (-Wno-deprecated-gpu-targets): 禁止有关已弃用的 GPU 目标架构的警告。 </li>
<li>—Wno-deprecated-declarations (-Wno-deprecated-declarations): 禁止在使用已弃用实体时发出警告。 </li>
</ol>
<p><strong>NVCC Environment Variables</strong></p>
<p>如果设置了以下环境变量，可以使用以下环境变量来扩充 nvcc 命令行标志： </p>
<p>NVCC_PREPEND_FLAGS: 在正常 nvcc 命令行之前注入的标志。 </p>
<p>NVCC_APPEND_FLAGS: 在正常 nvcc 命令行之后注入的标志。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">export NVCC_PREPEND_FLAGS='-G -keep -arch=sm_60'</span></pre></td></tr><tr><td class="code"><pre><span class="line">export NVCC_APPEND_FLAGS='-DNAME=" foo "'</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">The following invocation(以下调用): </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">nvcc foo.cu -o foo</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">Becomes equivalent to:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">nvcc -G -keep -arch=sm_60 foo.cu -o foo -DNAME=" foo "</span></pre></td></tr></table></figure>
<p><strong>兼容性</strong></p>
<p>CPU各代之间的二进制代码兼容性，以及已发布的指令集体系结构，是确保该领域的分布式应用程序在新版本CPU成为主流时继续运行的常用机制。</p>
<p>这种情况对于 GPU 来说是不同的，因为 NVIDIA 无法在不牺牲 GPU 改进的常规机会的情况下保证二进制兼容性。 相反，正如图形编程领域的常规做法，nvcc 依赖于两阶段编译模型来确保应用程序与未来 GPU 代的兼容性。 </p>
<p><img src="/2021/08/15/Faster-R-CNN-Code-Analyse/nvcc-2.png" alt="NVCC"></p>
<p><strong>Further Mechanisms</strong></p>
<ul>
<li>Just-in-Time Compilation(即时编译)</li>
<li>Fatbinaries</li>
</ul>
<p><strong>NVCC Example</strong></p>
<p>nvcc 提供选项 —gpu-architecture 和 —gpu-code 用于指定两个转换阶段的目标架构。 除了下面描述的允许的简写外，—gpu-architecture 选项采用单个值，该值必须是虚拟计算架构的名称，而选项 —gpu-code 则采用一个值列表，这些值都必须是虚拟计算架构的名称 实际的 GPU。 nvcc 为这些 GPU 中的每一个执行阶段 2 转换，并将结果嵌入到编译结果中（通常是主机目标文件或可执行文件）。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">nvcc x.cu --gpu-architecture=compute_50 --gpu-code=sm_50,sm_52</span></pre></td></tr></table></figure>
<h5 id="3、Pytorch扩展"><a href="#3、Pytorch扩展" class="headerlink" title="3、Pytorch扩展"></a>3、Pytorch扩展</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">torch.utils.ffi.create_extension(name, headers, sources, verbose&#x3D;True, with_cuda&#x3D;False, package&#x3D;False, relative_to&#x3D;&#39;.&#39;, **kwargs)</span></pre></td></tr></table></figure>
<p>创建并配置一个cffi.FFI对象,用于PyTorch的扩展。参数解析如下：</p>
<ul>
<li><strong>name</strong> (<em>str</em>) – 包名。可以是嵌套模块，例如 <code>.ext.my_lib</code>。</li>
<li><strong>headers</strong> (<em>str</em> or List[<em>str</em>]) – 只包含导出函数的头文件列表</li>
<li><strong>sources</strong> (List[<em>str</em>]) – 用于编译的sources列表</li>
<li><strong>verbose</strong> (<em>bool</em>, optional) – 如果设置为False，则不会打印输出（默认值：<code>True</code>）。</li>
<li><strong>with_cuda</strong> (<em>bool</em>, optional) – 设置为True以使用CUDA头文件进行编译（默认值：<code>False</code>）。</li>
<li><strong>package</strong> (<em>bool</em>, optional) – 设置为True以在程序包模式下构建（对于要作为pip程序包安装的模块）（默认值：<code>False</code>）。</li>
<li><strong>relative_to</strong> (<em>str</em>, optional) –构建文件的路径。<code>package</code>为<code>True</code>时需要。最好使用<code>__file__</code>作为参数。</li>
<li><strong>kwargs</strong> – 传递给ffi以声明扩展的附加参数。有关详细信息，请参阅<a href="https://docs.python.org/3/distutils/apiref.html#distutils.core.Extension" target="_blank" rel="noopener">Extension API reference</a>。</li>
</ul>
<p><a href="https://blog.csdn.net/manong_wxd/article/details/78720182" target="_blank" rel="noopener">参考示例</a></p>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Mask-R-CNN</title>
    <url>/2021/08/15/Mask-R-CNN/</url>
    <content><![CDATA[<h2 id="Mask-RCNN论文学习笔记"><a href="#Mask-RCNN论文学习笔记" class="headerlink" title="Mask-RCNN论文学习笔记"></a>Mask-RCNN论文学习笔记</h2><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p><img src="/2021/08/15/Mask-R-CNN/Mask-RCNN-0.png" alt="Mask-R-CNN"></p>
<p>Mask R-CNN是一个概念上简单、灵活和通用的对象实例分割框架。该框架有效地检测图像中的对象，同时为每个实例生成高质量的分割掩码。其通过添加一个分支来与现有的边界框识别分支并行预测对象掩码，从而扩展了 Faster R-CNN。</p>
<p> Mask R-CNN，通过添加用于预测每个感兴趣区域 (RoI) 上的分割掩码的分支来扩展 Faster R-CNN，与用于分类和边界框回归的现有分支并行（图 1） . 掩码分支是应用于每个 RoI 的小 FCN，以像素到像素的方式预测分割掩码。</p>
<p>Faster R-CNN 并不是为网络输入和输出之间的像素到像素对齐而设计的。这在<code>RoIPool</code>如何为特征提取执行粗略的空间量化中最为明显。为了修复错位，我们提出了一个简单的、无量化的层，称为<code>RoIAlign</code>，它忠实地保留了精确的空间位置。尽管看似很小的变化，<code>RoIAlign</code>却产生了巨大的影响：它将掩码准确度提高了 10% 到 50%。其次，作者发现将<strong>掩码和类别预测解耦</strong>至关重要：他们独立地为每个类别预测一个二元掩码，类别之间没有竞争，并依靠网络的 RoI 分类分支来预测类别。</p>
<h4 id="二、Mask-R-CNN"><a href="#二、Mask-R-CNN" class="headerlink" title="二、Mask R-CNN"></a>二、Mask R-CNN</h4><p>在训练期间，作者将每个采样的 RoI 上的多任务损失定义为 L = L<sub>cls</sub> + L<sub>box</sub> + L<sub>mask</sub>。 分类损失 L<sub>cls</sub>和边界框损失 L<sub>box与 <code>Faster R-CNN</code> 中定义的相同。 掩码分支对每个 RoI 都有一个 Km<sup>2</sup> 维的输出，它编码 K 个分辨率为 m ×m 的二进制掩码，K为类别数。同时，为每像素应用了 sigmoid，并将 L<sub>mask</sub>定义为平均二元交叉熵损失。对于与真实类别 k 相关联的 RoI，L<sub>mask</sub>仅在第 k 个掩码上定义（其他掩码输出对损失没有贡献）。 </sub></p>
<p>其次，作者对 L<sub>mask</sub>的定义允许网络为每个类生成掩码，而无需类之间的竞争； 依靠专用的分类分支来预测用于选择输出掩码的类标签。 这将掩码和类别预测解耦。并得出这种方式是获得良好实例分割结果的关键。</p>
<p><code>Mask R-CNN</code> 的关键要素，包括像素到像素对齐，这是 Fast/Faster R-CNN 的主要缺失部分。 mask分支使用 <code>FCN</code>从每个 RoI 预测 m ×m 掩码，这种像素到像素的行为要求RoI特征（它们本身是小特征图）能够很好地对齐(因为<code>RoI Pooling</code>，将feature map分成7&times;7的时候，如果不能整除，那么余数将被下取整，但是下取整的部分对应回原图可能有几十个像素的偏差，这对分割任务极为不利)，以忠实地保留明确的每像素空间对应关系。 这促使了<code>RoIAlign</code>层的开发，它在掩码预测中起着关键作用。 </p>
<h4 id="三、ROIAlign"><a href="#三、ROIAlign" class="headerlink" title="三、ROIAlign"></a>三、ROIAlign</h4><p><code>RoIPool</code>是从每个 RoI 中提取小特征图（例如，7×7）的标准操作。 <code>RoIPool</code> 首先将一个浮点数的 RoI 量化为特征图的离散粒度，然后将这个量化的 RoI 细分为自己量化的空间 bin，最后聚合每个 bin 覆盖的特征值（通常通过最大池化）。 例如，通过计算 [x/16] 在<strong>连续坐标</strong> x 上执行量化，其中 16 是特征图步幅，[·] 是舍入； 同样，在划分为 bin 时执行量化（例如，7×7）。 这些量化会在 RoI 和提取的特征之间<strong>引入错位</strong>。 虽然这可能不会影响分类，这对小平移具有鲁棒性，但它对预测像素准确的掩码有很大的负面影响。 </p>
<p>为了解决这个问题，作者提出了一个<code>RoIAlign</code>层，它去除了<code>RoIPool</code>的粗糙量化，正确地将提取的<strong>特征</strong>与<strong>输入</strong>对齐。在这里作者提出了一个简单的方案，即避免对 RoI 边界或 bin 进行任何量化（用使用 x/16 代替 [x/16]）。 并且二使用双线性插值来计算每个 <code>RoI bin</code> 中四个定期采样位置的输入特征的精确值，并聚合结果（使用最大值或平均值），详情参见图 3。 注意到，只要不执行量化，结果对确切的采样位置或采样的点数并不敏感。 </p>
<p><img src="/2021/08/15/Mask-R-CNN/Mask-RCNN-1.png" alt="Mask-R-CNN"></p>
<p>虚线网格表示特征图，实线表示 RoI（在本例中为 2×2 个 bin），点表示每个 bin 中的 4 个采样点。 <code>RoIAlign</code> 从特征图上的附近网格点通过<strong>双线性插值计算每个采样点的值</strong>。 不对 RoI、其 bin 或采样点中涉及的任何坐标执行量化。 </p>
<h4 id="四、网络的HEAD"><a href="#四、网络的HEAD" class="headerlink" title="四、网络的HEAD"></a>四、网络的HEAD</h4><p><img src="/2021/08/15/Mask-R-CNN/Mask-RCNN-2.png" alt="Mask-R-CNN"></p>
<p> 上图左/右面板分别显示了 <code>ResNet C4</code> 和 <code>FPN</code> 主干的头部，其中添加了掩码分支。</p>
<h4 id="五、Training"><a href="#五、Training" class="headerlink" title="五、Training"></a>五、Training</h4><p>就像在 <code>Fast R-CNN</code> 中一样，如果 RoI 具有至少 0.5 的真实值框的 IoU，则它被认为是正的，否则被认为是负的。 掩码损失 L<sub>mask</sub>仅在正 RoI 上定义。 掩码目标是 RoI 与其关联的真实掩码之间的<strong>交集</strong>。 </p>
<p><a href="https://arxiv.org/pdf/1703.06870.pdf" target="_blank" rel="noopener">论文链接</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/73138740#:~:text=ROI%20Pooling%20%E4%B8%8E%20ROI%20Align%20ROI%20Pooling%20%E6%98%AF%E5%9C%A8Faster,Align%E6%98%AF%E5%9C%A8Mask%20RCNN%E4%B8%AD%E6%8F%90%E5%87%BA%E6%9D%A5%E7%9A%84%E7%94%A8%E4%BA%8E%E6%94%B9%E8%BF%9BROI%20Pooling%E7%9A%84%E7%BC%BA%E9%99%B7%E3%80%82%20%E5%81%87%E8%AE%BE%E5%8E%9F%E5%9B%BE%E5%B0%BA%E5%AF%B8%E5%A4%A7%E5%B0%8F%E4%B8%BA256%C3%97256%EF%BC%8C%E9%A2%84%E6%B5%8BROI%E7%9A%84%E5%9D%90%E6%A0%87%E4%B8%BA%20%286.4%2C%2012.8%2C%20153.6%2C%20172.8%29%2C%E7%89%B9%E5%BE%81%E5%9B%BE%E2%80%A6" target="_blank" rel="noopener">ROI Align</a></p>
<p><a href="https://www.aiuai.cn/aifarm1404.html" target="_blank" rel="noopener">待参考链接</a></p>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>R-FCN</title>
    <url>/2021/08/15/R-FCN/</url>
    <content><![CDATA[<h2 id="R-FCN-论文学习"><a href="#R-FCN-论文学习" class="headerlink" title="R-FCN:论文学习"></a>R-FCN:论文学习</h2><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>R-FCN，基于区域的全卷积网络框架，用于目标检测。该网络由共享的、完全卷积的架构组成。<a href="https://papers.nips.cc/paper/2016/file/577ef1154f3240ad5b9b413aa7346a1e-Paper.pdf" target="_blank" rel="noopener">论文链接</a></p>
<h4 id="二、为什么要提出该网络？"><a href="#二、为什么要提出该网络？" class="headerlink" title="二、为什么要提出该网络？"></a>二、为什么要提出该网络？</h4><p>因为，像Faster RCNN类的目标检测算法，在第一阶段得到RoIs和对应的scores后，会从原图和feature map上mapping每一个RoI，并做RoI Pooling，最后用两个全连接层去对每个类别分类和边界框回归(也就是资料中说的<strong>RoI-wise subnetwork</strong>)。作者认为这种使用全连接层的做法丢掉了对于目标位置信息的敏感性，会降低检测精度，并且对检测速度也有影响。所以，作者希望通过<strong>全卷积的方式</strong>去<strong>共享</strong>整个图像的<strong>计算</strong>，并且加强对<strong>位置的敏感性</strong>。</p>
<h4 id="三、如何修正已有网络的缺陷？"><a href="#三、如何修正已有网络的缺陷？" class="headerlink" title="三、如何修正已有网络的缺陷？"></a>三、如何修正已有网络的缺陷？</h4><p><strong>起源：</strong>在开创性的分类网络中如AlexNet, VGG中在卷积层后加一层最大池化层，然后后接几层全连接层。</p>
<p><strong>进展：</strong>最近最先进的分类网络中，已经开始设计全卷积网络，如ResNets-101、GoogLeNets。</p>
<p><strong>引入检测网络存在的问题：</strong>实验得出直接使用全卷积网络后，检测进度相当低，与网络卓越的分类精度不匹配。</p>
<p><strong>已有的修正方法：</strong>ResNet论文中，将Faster R-CNN检测器的RoI池化层被不自然地插入到两组卷积层之间，创建了一个更深的RoI-wise子网络。尽管提高了精度，但是降低了计算速度(由于per-ROI不共享)。</p>
<p><strong>对ResNet中不自然的设计如何解释？</strong></p>
<p>作者们认为，将RoI Pooling插入到两组卷积层之间是为了照顾物体检测时对平移变化的响应。但这种操作打破了图像分类的平移不变性(图像内目标的移动对分类结果应该是无差别的)。</p>
<p>同时，根据全卷积网络在ImageNet分类的领先结果表明，尽可能具有平移不变性在深度全卷积架构更可取(即，不论物体位置如何变化都能分类正确)。但目标检测任务需要在一定程度上具有平移可变的定位表示。例如：候选框内对象的平移应获得有意义的响应。</p>
<p><strong>那么如何在分类任务的平移不变性和检测任务中的平移可变性之间做出权衡呢？</strong></p>
<p>在ResNet中，假设越深的分类网络对于平移的敏感性越低(个人感觉有两个原因，第一是感受野变大，窗口大了看的东西多了，在哪里对分类任务无所谓；第二是越深的网络拟合的特征越细，辨识性越高)。所以较深的卷积层后可以损失分类对平移不变性的关注度，而提升检测任务对定位的敏感度。因此，ResNet论文在检测管道中，在RoI层后多了一组卷积层。当跨不同区域评估是，post-RoI卷积层不在具有平移不变性(这个可能与边界回归smootL1损失函数有关系，就是多个mapping后的RoI区域有共有部分是在统计边界回归是会累计误差，<strong>待确认</strong>)。</p>
<p><strong>那么R-FCN中是怎么做的呢？</strong></p>
<p>作者为了将目标检测中对位置的敏感性加入FCN中，设计了一组专门的卷积层作为FCN输出来构建一组位置敏感的分数图(score map)。这些分数图中的每一个都对相对空间位置信息进行编码。如：在对象的左侧。在FCN之后，附加了一个位置敏感的RoI池化层，让它从这些分数图中引导信息，后面没有权重(卷积/fc)层。该架构是端到端学习的。所有可学习层都是卷积层，并在整个图像上共享，但对目标检测所需的空间信息进行编码。</p>
<p><img src="/2021/08/15/R-FCN/R-FCN-0.png" alt="R-FCN"></p>
<p>R-FCN还是采用了两阶段的目标检测策略，先用RPN提取候选区域，并且RPN和R-FCN之间共享特征。系统的概览如下图所示(文本的图都来自于R-FCN<a href="https://papers.nips.cc/paper/2016/file/577ef1154f3240ad5b9b413aa7346a1e-Paper.pdf" target="_blank" rel="noopener">论文</a>)：</p>
<p><img src="/2021/08/15/R-FCN/F-RCN-1.png" alt="R-FCN"></p>
<p>对于RPN给出的RoIs，R-FCN架构旨在将RoI分类为目标类别和背景。在R-FCN中，所有可学习的权重层都是卷积层，并在整个图像上计算。最后一个卷积层为每个类别生成一组k<sup>2</sup>位置敏感分数图，因此具有k<sup>2</sup>(C+1)个输出通道，其中包含C个目标类别+一个背景类。k<sup>2</sup>得分图库对应于描述相对位置的k&times;k的空间网格。例如，当k&times;k=3&times;3时，9个分数图对目标的类别{左上、中上、右上、…、右下}的情况进行编码。</p>
<p>上面的讲法有点晕，其实，R-FCN的核心思想就是<strong>Position-sensitive score maps</strong>和<strong>Position-sensitive RoI pooling</strong>。那么简单来说<strong>Position-sensitive score maps</strong>就是要对RoI中的某些子区域定位的同时，学习子区域中的内容。比如将RoI划分成3&times;3=9个子区域，用左上、中上、右上、左中、中、右中、右左、右中、右下9个区域表示，每个区域可以看作目标的不同部位。那么假设C+1个类别，每个类别都会在9个子区域上去学习，这样就会生成9&times;(C+1)个channel，如图1所示，9个score maps，每个中有C+1个类。<strong>那么如何取定位每个子区域呢</strong>？这就需要用到<strong>Position-sensitive RoI pooling</strong>了，比如9个子区域中第i个子区域对应的是第i个score map，而第i个score map同样也有3&times;3=9个区域，那么RoI中第i个子区域对应的就是第i个score map中的第i个子区域(每个类有一个子区域，C+1各类有C+1个子区域)，对每个子区域取平均池化得到C+1个value，那么RoI中k&times;k个子区域就有k&times;k&times;(C+1)个value。</p>
<h4 id="四、具体的Position-sensitive-score-maps-amp-Position-sensitive-RoI-pooling如何做的？"><a href="#四、具体的Position-sensitive-score-maps-amp-Position-sensitive-RoI-pooling如何做的？" class="headerlink" title="四、具体的Position-sensitive score maps &amp; Position-sensitive RoI pooling如何做的？"></a>四、具体的Position-sensitive score maps &amp; Position-sensitive RoI pooling如何做的？</h4><p>R-FCN在共享卷积层的最后再接上一层卷积层，也就是位置敏感得分图(Position-sensitive score maps)，它其实是一层卷积层，他的height和width和共享卷积层的一样，但是它的channel=k<sup>2</sup>(C+1)。</p>
<p>为了将位置信息显式地编码到每个 RoI 中，将每个 RoI 矩形通过规则网格划分为 k ×k 个 bin。 对于大小为 w×h 的 RoI 矩形， 一个bin的尺寸大致为w/k&times;h/k。R-FCN构造最后一个卷积层来为每个类别生成 k<sup>2</sup> 得分图，也就对应到了k&times;k个区域。在第 (i,j) 个 bin (0 ≤i,j ≤k −1) 内，定义了一个<strong>位置敏感的 RoI 池化操作</strong>，该操作仅在第 (i,j) 个得分图上进行池化(Position-sensitive RoI pooling)： </p>
<script type="math/tex; mode=display">
r_c(i,j|\Theta)=\sum_{(x,y)\in bin(i,j)}z_{i,j,c}(x+x_0,y+y_0|\Theta)/n\\
r_c(i,j)是第 (i,j) 个 bin 中第 c 个类别的池化响应，z_{i,j,c} 是 k^2(C + 1) 个得分图中的一个得分图 \\
(x0,y0) 表示 RoI 的左上角，n 是 bin 中的像素数， Θ 表示网络的所有可学习参数 \\
第i个bin的跨度为\lfloor i\frac{w}{k} \rfloor\le x\le \lfloor (i+1)\frac{w}{k} \rfloor,\lfloor j\frac{h}{k} \rfloor\le y\le \lfloor (j+1)\frac{h}{k} \rfloor</script><p><img src="/2021/08/15/R-FCN/R-FCN-2.png" alt="R-FCN"></p>
<p>对于每个类别，它都有k<sup>2</sup>个score maps，那么按照上述的池化方式，可以RoI针对该类别可以得到k<sup>2</sup>个值，那么一共有C+1个类别，那么一个RoI就得到 k<sup>2</sup>(C+1)个值。那么对于每个类别，该类别的 k<sup>2</sup> 个值都表示该RoI属于该类别的响应值，那么将这 k<sup>2</sup>个数相加求平均就得到该类别的score(论文中的术语是对k<sup>2</sup>进行vote，averaging the score)，那么一共有C+1个scores，那么将这C+1个数使用简单的softmax函数就可以得到属于各个类别的概率了。</p>
<script type="math/tex; mode=display">
r_c(\Theta)=\sum_{i,j}r_c(i,j|\Theta),S_c(\Theta)=e^{r_c(\Theta)}/\sum^{C}_{c'=0}e^{r_c(\Theta)}</script><p>上述概率用于评估训练期间的交叉熵损失和推理期间的 RoI 排名。 </p>
<p><img src="/2021/08/15/R-FCN/R-FCN-4.png" alt="R-FCN"></p>
<h4 id="五、如何回归边框？"><a href="#五、如何回归边框？" class="headerlink" title="五、如何回归边框？"></a>五、如何回归边框？</h4><p>按照“position-sensitive score map”+“Position-sensitive RoI pooling”思路，其会让每一个RoI得到 C+1 个数作为每个类别的score，那么现在每个RoI还需要 4 个数作为”回归的偏移量”，也就是“坐标和长宽”的偏移量，所以仿照分类设计的思想，还需要一个类似于position-sensitive  score map的用于回归的score  map。那么现在就这样设计：在ResNet的共享卷积层的最后一层上，接上一个与position-sensitive score  map并行的（sibling）score maps，该score maps用于regression，而该regression score map的维度应当是4k<sup>2</sup>，那么在经过Position-sensitive RoI pooling操作后还是4k<sup>2</sup>维的向量，通过平均投票将其聚合为一个4维向量(k<sup>2</sup>个t<sub>x</sub>,t<sub>y</sub>,t<sub>w</sub>,t<sub>h</sub>，每个t<sub>*</sub>求和/k<sup>2</sup>，*表示x,y,w,h)。每一个RoI就会得到4个数作为该RoI的坐标和长宽的偏移量(这里执行了与类无关的边界框回归)。</p>
<h4 id="六、网络的训练"><a href="#六、网络的训练" class="headerlink" title="六、网络的训练"></a>六、网络的训练</h4><p>在每个 RoI 上定义的损失函数是交叉熵损失和框回归损失的总和：</p>
<script type="math/tex; mode=display">
L(s,t_{x,y,w,h})=L_{cls}(S_{c^*})+\lambda[c^*\gt0]L_{reg}(t,t^*)\\
c^*是RoI的ground-truth标签，L_{cls}(S_{c^*})=-log(S_{c^*})是分类的cross-entropy \,\,loss\\
L_{reg}是边界回归损失，t^*表示ground \,\,truth \,\,box,[c^*\gt1]是指示函数条件满足为1，否则为0\\
平衡参数\lambda设置为1，定义正样本为RoI与GT的IoU\ge0.5</script><p>在训练的时候不会对所有的RoI进行处理，而是评估所有N个RoI的损失。然后按损失对所有正负RoI进行排序，并选择具有最高损失的B=128个RoIs。</p>
<p><a href="https://zhuanlan.zhihu.com/p/30867916" target="_blank" rel="noopener">参考链接</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/24780433" target="_blank" rel="noopener">扩展链接</a></p>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Faster-R-CNN</title>
    <url>/2021/08/15/Faster-R-CNN/</url>
    <content><![CDATA[<h2 id="Faster-RCNN"><a href="#Faster-RCNN" class="headerlink" title="Faster RCNN"></a>Faster RCNN</h2><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>在测试阶段，使用选择性搜索获取区域提议成为了算法的性能瓶颈。其次，卷积等处理在GPU上运行，而选择性搜索在CPU上运行，导致了运行时比较并不公平 。</p>
<p>一种可以想到的解决策略是将selective search通过GPU实现一遍，但是这种实现方式忽略了接下来的检测网络可以与区域建议方法共享计算的问题。因此Faster RCNN从提高区域建议的速度出发提出了region proposal network 用以通过GPU实现快速的区域建议。</p>
<p>作者观察到，基于区域的检测器（如 Fast RCNN）使用的卷积特征图也可用于生成区域提议。 在这些卷积特征之上，我们通过添加一些额外的卷积层来构建 RPN，这些卷积层同时回归常规网格上每个位置的区域边界和目标分数。 因此，RPN 是一种全卷积网络 (FCN) ，可以专门针对生成检测建议的任务进行端到端的训练。 Faster RCNN的整体结构如下：</p>
<h4 id="二、Faster-RCNN"><a href="#二、Faster-RCNN" class="headerlink" title="二、Faster RCNN"></a>二、Faster RCNN</h4><p>Faster R-CNN，由两个模块组成。 第一个模块是提取区域的深度全卷积网络，第二个模块是使用建议区域的 Fast R-CNN 检测器。 </p>
<p><img src="/2021/08/15/Faster-R-CNN/Faster-RCNN.png" alt="Faster-R-CNN"></p>
<ul>
<li><p>输入图片</p>
</li>
<li><p>backbone: 卷积特征提取，共享基础卷积层。例如VGG16，或Resnet101，去除其中的全连接层，只留下卷基层，输出下采样后的特征图。</p>
</li>
<li><p>RPN产生proposals</p>
<p>利用最后卷积层的feature map外接几个卷积层构成全卷积网络，通过softmax判断anchors属于positive或者negative，再利用bounding box regression修正anchors获得精确的proposals。</p>
</li>
<li><p>Fast RCNN分类proposals: 利用卷积提取到的特征+RPN提取出的region proposals</p>
<ul>
<li>Roi Pooling：该层收集输入的feature maps和proposals，综合这些信息后提取proposal feature maps，送入后续全连接层判定目标类别。</li>
<li>Classification：利用proposal feature maps计算proposal的类别，同时再次bounding box regression获得检测框最终的精确位置。</li>
</ul>
</li>
</ul>
<h4 id="三、Region-Proposal-Networks"><a href="#三、Region-Proposal-Networks" class="headerlink" title="三、Region Proposal Networks"></a>三、Region Proposal Networks</h4><p>区域提议网络 (RPN) 将图像（任意大小）作为输入并输出一组矩形对象提议，每个提议都有一个目标得分。 整个RPN过程使用全卷积网络进行建模，由于为了与Fast RCNN目标检测网络进行共享计算，所以RPN和Fast RCNN共享一组公共卷积层。</p>
<p><strong>如何产生区域提议？</strong></p>
<ul>
<li>在最后的共享卷积层输出的卷积feature map上滑动一个小网络n*n</li>
<li>将n*n 空间窗口作为输入映射到一个低维特征(ZF为256维，VGG为512维，后面接ReLU)</li>
<li>低维特征被输入到两个子全连接层：一个边界框回归层（reg）和一个边界框分类层（cls）</li>
</ul>
<p><img src="/2021/08/15/Faster-R-CNN/Faster-RCNN-1.png" alt="Faster-R-CNN"></p>
<p><img src="/2021/08/15/Faster-R-CNN/Faster-RCNN-2.png" alt="Faster-R-CNN"></p>
<p>从上图中可以看到，n为3的卷积核对最后一层feature map做卷积后生成1*256 / 1*512维的特征，经过Relu后，使用两个1*1的卷积层生成两个子网络，分别用于分类anchor获得正类或负类。另一个子网络用于回归anchor的bounding box，已获得较精准的proposal。最后的Proposal层负责综合position anchors和对应的bounding box regression偏移量获取proposals。此时已完成了目标定位的功能。</p>
<h5 id="3-1-Anchors"><a href="#3-1-Anchors" class="headerlink" title="3.1 Anchors"></a>3.1 Anchors</h5><p>在每个滑动窗口位置，同时预测多个区域提议，其中每个位置的最大可能提议数表示为 k。 因此，reg 层有 4k 个输出编码用于表示k个框的坐标，cls 层输出 2k 个分数，用于估计区域提议是目标或背景的概率 。</p>
<p> 锚点位于相关滑动窗口的中心，并与缩放尺度和纵横比相关联。 默认情况下，我们使用 3 个缩放尺度和 3 个纵横比，在每个滑动位置产生 k = 9 个锚点。 对于大小为 W × H的卷积特征图，总共有 WHk 个锚点。 </p>
<p><strong>Translation-Invariant Anchors</strong></p>
<p>由于采用RPN去获取anchors，所以保证了待定位物体的平移不变性。同时，因为anchors是以滑动窗口的位置(针对最后一层feature map)去产生固定尺度和纵横比的anchor，所以减少了模型的大小。稳重例举了MultiBox中的例子，其中MultiBox需要(4+1)*800维全连接输出层。而基于anchors的方法，因为k=9，每个anchor有4+2个输出，所以总共(4+2)&times;9维的卷积输出。</p>
<p><strong>Multi-Scale Anchors as Regression References</strong></p>
<p>由于目标检测的目标尺度可能相差很大，因此我们需要尽可能产生不同尺寸的region proposals，常见的有两种方法，加上本文的一共三种方法：</p>
<ul>
<li>图像金字塔：通过将图像放缩到不同的尺寸，然后提取特征去做或先对于图像提取卷积特征，然后将卷积特征放缩到不同的尺寸。</li>
<li>滤波器金字塔：在特征图上使用多个尺度（和/或纵横比）的滑动窗口。 例如：DPM中使用不同的过滤器尺寸分别训练不同纵横比的模型(5&times;7 and 7&times;5)。</li>
<li>anchor金字塔：多个尺度和纵横比的锚框对边界框进行分类和回归。 它只依赖单一尺度的图像和特征图，并使用单一尺寸的过滤器（特征图上的滑动窗口）。</li>
</ul>
<p><img src="/2021/08/15/Faster-R-CNN/Faster-RCNN-3.png" alt="Faster-R-CNN"></p>
<h5 id="3-2-Loss-Function"><a href="#3-2-Loss-Function" class="headerlink" title="3.2 Loss Function"></a>3.2 Loss Function</h5><p>RPN包含两个网络分支，分类层以及回归层。分类层给出一个二分类label，也就是这个region是否包含目标，回归层产生目标的位置。其中与任意ground-truth box的IOU大于0.7即认为是包含目标的或anchor与真实的box重叠的IoU最大(论文中说如果只考虑IoU&gt;0.7有些情况找不到正样例)。如果anchor与所有真值框的 IoU 比率低于 0.3，为anchor分配负标签。 既不是正面也不是负面的锚点对训练目标没有贡献。 (这里相当于给anchor生成label，为了与之后的预测值计算损失)</p>
<p><strong>RPN还是采用多任务损失：</strong></p>
<script type="math/tex; mode=display">
L(\{p_i\},\{t_i\})=\frac{1}{N_{cls}}\sum_{i}L_{cls}(p_i,p^*_i)+\lambda\frac{1}{N_{reg}}\sum_ip^*_iL_{reg}(t_i,t^*_i)\\
i是mini-batch中anchor的索引，p_i是anchor_i预测的目标概率，p^*_i是groud\quad truth\\
t_i是预测边界框的坐标(也就是anchor放大16倍后在原图中对应的坐标)，t^*_i是groud \quad truth\\
p^*_iL_{reg}指出回归损失仅仅对正的anchors有用，即p^*_i=1\\
N_{cls}是正则化项，等于mini-batch的大小，N_{reg}也是正则化项，等于anchor的数量</script><p>L<sub>cls</sub>用的是log loss用于区分目标或背景。L<sub>reg</sub>用的是smooth L<sub>1</sub>损失。</p>
<p><strong>边界回归使用下面四个参数：</strong></p>
<script type="math/tex; mode=display">
t_x=(x-x_a)/w_a,t_y=(y-y_a)/h_a\\
t_w=\log(w/w_a),t_h=\log(h/h_a)\\
t^*_x=(x^*-x_a)/w_a,t^*_y=(y^*-y_a)/h_a\\
t^*_w=\log(w^*/w_a),t^*_h=\log(h^*/h_a)\\
其中，x，y,w,h分别代表box的中心坐标和它的宽、高\\
x对应的是预测框，x_a对应的是anchor框，x^*对应的是真实框\\
从回归框的损失函数看出，以anchor框为参照物(t_i^a)，让t_x，t_y,t_h,t_w接近t_i^*</script><p>下面摘录<a href="https://zhuanlan.zhihu.com/p/31426458" target="_blank" rel="noopener">知乎白裳</a>给出的bounding box regression原理介绍</p>
<p><img src="/2021/08/15/Faster-R-CNN/Faster-RCNN-6.png" alt="Faster-R-CNN"></p>
<p>上图来自<a href="https://www.zhihu.com/people/george-zhang-84" target="_blank" rel="noopener">白裳</a>，图中绿色框为飞机的Ground Truth(GT)，红色为提取的positive  anchors，即便红色的框被分类器识别为飞机，但是由于红色的框定位不准，这张图相当于没有正确的检测出飞机。所以我们希望采用一种方法对红色的框进行微调，使得positive anchors和GT更加接近。</p>
<p>对于窗口一般使用四维向量(x,y,w,h)表示，分别表示窗口的中心点坐标和宽高。对于上图，红色的框A代表原始的positive Anchors，绿色的框G代表目标的GT，我们的目标是寻找一种关系，使得<strong>输入原始的anchor A</strong>经过<strong>映射</strong>得到一个跟<strong>真实窗口G更接近的回归窗口G’</strong>，即：</p>
<p><img src="/2021/08/15/Faster-R-CNN/Faster-RCNN-4.png" alt="Faster-R-CNN"></p>
<ul>
<li><p>给定anchor A=(A<sub>x</sub>，A<sub>y</sub>，A<sub>w</sub>，A<sub>h</sub>)和GT=[G<sub>x</sub>，G<sub>y</sub>，G<sub>w</sub>，G<sub>h</sub>]</p>
</li>
<li><p>寻找一种变换F，使得：F(A<sub>x</sub>，A<sub>y</sub>，A<sub>w</sub>，A<sub>h</sub>)=(G’<sub>x</sub>，G’<sub>y</sub>，G’<sub>w</sub>，G’<sub>h</sub>)，其中</p>
<p>(G’<sub>x</sub>，G’<sub>y</sub>，G’<sub>w</sub>，G’<sub>h</sub>)&approx;(G<sub>x</sub>，G<sub>y</sub>，G<sub>w</sub>，G<sub>h</sub>)</p>
</li>
</ul>
<p><strong>那么如何变换呢？</strong></p>
<script type="math/tex; mode=display">
先平移：G'_x=A_w\cdot d_x(A)+A_x;G'_y=A_h\cdot d_y(A)+A_y\\
再缩放：G'_w=A_w\cdot exp(d_x(A));G'_y=A_h\cdot exp(d_y(A))</script><p>注意：当输入的Proposal和Groud Truth相差较小时(RCNN设置的是IoU&gt;0.6)，可以认为这种变幻是一种线性变幻，那么可以用线性回归来建模对窗口进行微调。否则就变成了复杂的非线性问题(可以查看G-CNN:an iterative Grid Based Object Detector来定位)</p>
<p><strong>那么如何使用线性回归获得d<sub>x</sub>(A),d<sub>y</sub>(A),d<sub>w</sub>(A),d<sub>h</sub>(A)?</strong></p>
<p>线性回归就是给定输入的特征向量X，学习一组参数W，使得经过线性回归后的值跟真实值Y非常接近。即：Y=WX</p>
<p>对于上述的问题，输入为：</p>
<ol>
<li>cnn feature map, 定义为&Phi;</li>
<li>anchors和groud Truth，用于计算gt与anchor的变换量(t<em><sub>x</sub>,t\</em><sub>y</sub>,t*<sub>w</sub>,t*<sub>h</sub>)作为监督信号</li>
</ol>
<p>输出为：d<sub>x</sub>(A),d<sub>y</sub>(A),d<sub>w</sub>(A),d<sub>h</sub>(A)</p>
<p><strong>目标函数：</strong></p>
<script type="math/tex; mode=display">
d_*(A)=W^T_*\cdot \phi(A),\phi(A)是对应anchor的feature\,\,map组成的特征向量,W_*是需要学习的参数\\
d_*(A)是得到的预测值，*表示x,y,w,h,说明每一个变换对应一个上述的目标函数\\
为了让预测值d_x(A)与真实值t_x差距最小，设计L1损失函数：Loss=\sum^{N}_{i}|t^i_*-W^T_*\cdot \phi(A^i)|\\
函数优化的目标为:\hat{W_x}=argmin_{W*}\sum^{n}_{i}|t^i_x-W^T_*\cdot\phi(A^i)|+\lambda||W_x||</script><h5 id="3-3-Proposal-Layer"><a href="#3-3-Proposal-Layer" class="headerlink" title="3.3 Proposal Layer"></a>3.3 Proposal Layer</h5><p>Proposal Layer负责综合所有d<sub>x</sub>(A),d<sub>y</sub>(A),d<sub>w</sub>(A),d<sub>h</sub>(A)变换量和positive anchors，计算出精准的proposal，送入后续RoI Pooling Layer。</p>
<p>输入：1.分类器结果；2、边界回归d<sub>x</sub>(A),d<sub>y</sub>(A),d<sub>w</sub>(A),d<sub>h</sub>(A)；3、im_info；4、feat_stride=16</p>
<p>im_info=[M,N,scale_factor]保存了Faster RCNN传入reshape到固定M&times;N时缩放的所有信息</p>
<p>处理顺序：</p>
<ol>
<li>生成anchors，利用d<sub>x</sub>(A),d<sub>y</sub>(A),d<sub>w</sub>(A),d<sub>h</sub>(A)对所有的anchors做bbox regression回归（这里的anchors生成和训练时完全一致)</li>
<li>按照输入的positive softmax scores由大到小排序anchors，提取前pre_nms_topN(e.g. 6000)个anchors，即提取修正位置后的positive anchors</li>
<li>限定超出图像边界的positive anchors为图像边界，防止后续roi pooling时proposal超出图像边界</li>
<li>剔除尺寸非常小的positive anchors</li>
<li>对剩余的positive anchors进行NMS（nonmaximum suppression）</li>
</ol>
<h5 id="3-4-训练RPNs"><a href="#3-4-训练RPNs" class="headerlink" title="3.4 训练RPNs"></a>3.4 训练RPNs</h5><p>首先，读取RBG提供的预训练好的model（本文使用VGG），开始迭代训练。如stage1_rpn_train.pt网络结构</p>
<p><img src="/2021/08/15/Faster-R-CNN/0.jpg" alt="Faster-R-CNN"></p>
<p>与检测网络类似的是，依然使用Conv Layers提取feature maps。整个网络使用的Loss如下：</p>
<script type="math/tex; mode=display">
L(\{p_i\},\{t_i\})=\frac{1}{N_{cls}}\sum_{i}L_{cls}(p_i,p^*_i)+\lambda\frac{1}{N_{reg}}\sum_ip^*_iL_{reg}(t_i,t^*_i)\\
i是anchor的索引，p_i表示positive\,\,softmax\,\,probability就是anchors中有的不会被用到，有的是negative,有的是positive。\\
p^*_i代表对应的GT \,\,predict概率即当第i个anchor与GT间IoU\gt0.7时，认为该anchor为positive,p^*_i=1；反之IoU\lt0.3时，认为该anchor是negative,p^*_i=0;\\
那些0.3\lt IoU\lt0.7的anchor不参与训练。t代表predict\,\,bounding\,\,box,t^*_i代表对应的positive\,\,anchor对应的GT\,\,box。可以看到，整个Loss分为2个部分：\\
cls-loss，即rpn_cls_loss层计算的softmax loss，用于分类anchors为positive与negative的网络训练;\\
reg-loss，即rpn_loss_bbox层计算的soomth L1 loss，用于bounding box regression网络训练。该loss中乘了p^*_i，相当于只关心positive\,\,anchors的回归\\
由于在实际过程中，N_{cls}和N_{reg}差距过大，用参数λ平衡二者（如N_{cls}=256，N_{reg}=2400时,设置\lambda=\frac{N_{reg}}{N_{cls}}\approx10）</script><h5 id="3-5-收集Proposals"><a href="#3-5-收集Proposals" class="headerlink" title="3.5 收集Proposals"></a>3.5 收集Proposals</h5><p><img src="/2021/08/15/Faster-R-CNN/1.jpg" alt="Faster-R-CNN"></p>
<p>利用之前的RPN网络，获取proposal rois，同时获取positive softmax probability，然后将获取的信息保存在python pickle文件中。</p>
<h4 id="四、训练Faster-RCNN网络"><a href="#四、训练Faster-RCNN网络" class="headerlink" title="四、训练Faster RCNN网络"></a>四、训练Faster RCNN网络</h4><ol>
<li>在已经训练好的model上，训练RPN网络，对应stage1_rpn_train.pt</li>
<li>利用步骤1中训练好的RPN网络，收集proposals，对应rpn_test.pt</li>
<li>第一次训练Fast RCNN网络，对应stage1_fast_rcnn_train.pt</li>
<li>第二训练RPN网络，对应stage2_rpn_train.pt</li>
<li>再次利用步骤4中训练好的RPN网络，收集proposals，对应rpn_test.pt</li>
<li>第二次训练Fast RCNN网络，对应stage2_fast_rcnn_train.pt</li>
</ol>
<p>可以看到训练过程类似于一种“迭代”的过程，不过只循环了2次。至于只循环了2次的原因是应为作者提到：”A similar alternating  training can be run for more iterations, but we have observed negligible improvements”，即循环更多次没有提升了。</p>
<p><img src="/2021/08/15/Faster-R-CNN/2.jpg" alt="Faster-R-CNN"></p>
<p>读取之前保存的pickle文件，获取proposals与positive probability。从data层输入网络，然后：</p>
<ol>
<li>将提取的proposals作为rois传入网络</li>
<li>计算bbox_inside_weights+bbox_outside_weights，作用与RPN一样，传入soomth_L1_loss layer</li>
</ol>
<p>​    <a href="https://zhuanlan.zhihu.com/p/31426458" target="_blank" rel="noopener">推荐阅读知乎-白裳</a></p>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Fast-R-CNN</title>
    <url>/2021/08/15/Fast-R-CNN/</url>
    <content><![CDATA[<h2 id="Fast-R-CNN学习笔记"><a href="#Fast-R-CNN学习笔记" class="headerlink" title="Fast R-CNN学习笔记"></a>Fast R-CNN学习笔记</h2><p><strong>目标检测主要需要解决两个问题：1、必须处理大量候选框；2、必须对候选框进行细化以实现精确定位。</strong></p>
<h4 id="一、R-CNN和SPPnet的问题"><a href="#一、R-CNN和SPPnet的问题" class="headerlink" title="一、R-CNN和SPPnet的问题"></a>一、R-CNN和SPPnet的问题</h4><p>1、R-CNN有如下明显的缺陷：</p>
<ul>
<li>训练一个多阶段的pipeline</li>
<li>训练在空间和时间上都是昂贵的。</li>
<li>物体检测很慢 </li>
</ul>
<p>2、SPPnet有如下缺陷：</p>
<ul>
<li>训练一个多阶段的pipeline<ul>
<li>特征提取</li>
<li>使用log loss微调一个网络</li>
<li>训练SVMs</li>
<li>拟合回归边界框</li>
</ul>
</li>
<li>论文中提出的fine-tune很难更新spatial pyramid pooling层之前的卷据层，对于更深的网络不适用</li>
</ul>
<h4 id="二、Fast-RCNN的架构和训练"><a href="#二、Fast-RCNN的架构和训练" class="headerlink" title="二、Fast RCNN的架构和训练"></a>二、Fast RCNN的架构和训练</h4><ol>
<li>输入为一整个图像和一组候选框</li>
<li>网络首先使用卷积和最大池化层处理整个图像，生成一组特征图</li>
<li>将每个候选框(region of interest)映射到特征图中，使用特征图中的RoI做RoI pooling，生成一个固定尺寸的特征向量(每个RoI对应一个特征向量)</li>
<li>每个特征向量后面接一系列的全连接层</li>
<li>全连接层后分两个子分支输出层：一个分支用softmax概率估计K+1个目标的类别，K个目标加一个背景类；另一个分支对于K个目标中的每个输出4个实数，每组 4 个值编码 K 个类别之一的精细边界框位置 。</li>
</ol>
<p><img src="/2021/08/15/Fast-R-CNN/FastRCNN-1.png" alt="Fast-R-CNN"></p>
<h4 id="2-1-The-RoI-pooling-layer"><a href="#2-1-The-RoI-pooling-layer" class="headerlink" title="2.1 The RoI pooling layer"></a>2.1 The RoI pooling layer</h4><p>RoI 池化层使用最大池化将任何有效感兴趣区域内的特征转换为具有固定空间范围 H × W（例如，7 × 7）的小特征图，其中 H 和 W 是层超参数，它们是 独立于任何特定的RoI。论文中指出每个感兴趣区域被定义为一个四元组(r,c,h,w)，指出长方形窗口的左上角坐标，宽和高。</p>
<ul>
<li>划分特征图中hxw的RoI窗口为HxW个子窗口网格，共有h/h x w/W个子窗口</li>
<li>每个子窗口运用最大池化，相当于吧h x w尺寸的图像缩放为H x W</li>
<li>每个RoI根据网络有多个channel，对每个channel分别进行网格的划分和最大池化</li>
</ul>
<h4 id="2-2-Initializing-from-pre-trained-networks"><a href="#2-2-Initializing-from-pre-trained-networks" class="headerlink" title="2.2  Initializing from pre-trained networks"></a>2.2  Initializing from pre-trained networks</h4><ul>
<li>使用ImageNet预训练的网络初始化Fast R-CNN网络</li>
<li>最后一层池化层用RoI池化层代替，并根据第一层全连接层的输入，设置H和W的值以便于池化操作</li>
<li>网络的最后的全连接层和softmax用两个兄弟层代替，分别用于分类和回归</li>
<li>网络的输入修改为两个：一个为图像的列表，一个为每个图像对应的RoIs列表 </li>
</ul>
<h4 id="2-3-Fine-tuning-for-detection"><a href="#2-3-Fine-tuning-for-detection" class="headerlink" title="2.3  Fine-tuning for detection"></a>2.3  Fine-tuning for detection</h4><p>用反向传播训练所有网络权重是 Fast R-CNN 的一个重要能力。 首先，让我们阐明为什么 SPPnet 无法更新空间金字塔池化层以下的权重。 </p>
<p>根本原因是当每个训练样本（即 RoI）来自不同的图像时，通过 SPP 层的反向传播效率非常低，这正是 R-CNN 和 SPPnet 网络的训练方式。 </p>
<p>作者在这里提出了更有效的训练方法，在Fast R-CNN训练时，采用分层mini-batch的随机梯度下降法。首先，选取N张图像，然后从N张图像中每张选取R/N个RoIs。<strong>来自同一图像的 RoI 在前向和后向传递中共享计算和内存。 使 N 小会减少小批量计算。</strong> 例如：N=2，R=128。选取两张图像每张图像选取64个RoIs的效率要比选取128张不同的图像在训练时更快。(作者实验得出同一张图像的RoI并不影响训练的收敛速度，反而效果更好)</p>
<p>除了分层采样之外，Fast R-CNN 还使用了带有微调阶段的简化训练过程，该阶段<strong>联合优化</strong>了 softmax 分类器和边界框回归器，而不是在三个单独的阶段训练 softmax 分类器、SVM 和回归器。</p>
<h5 id="Multi-task-loss"><a href="#Multi-task-loss" class="headerlink" title="Multi-task loss"></a>Multi-task loss</h5><p>Fast R-CNN有两个兄弟输出层。</p>
<ul>
<li>一个针对每个RoI输出K+1个类别离散的概率分布。p=(p<sub>0</sub>,…,p<sub>K</sub>)。像往常一样，p由全连接层的 K +1 个输出上的 softmax 计算得到。</li>
<li>第二个兄弟层为K个目标类中的每个输出边界框回归偏移量</li>
</ul>
<script type="math/tex; mode=display">
t^k=(t^k_x,t^k_y,t^k_w,t^k_h)，索引为k(其中 t_k 指定相对于对象提议的尺度不变平移和对数空间高度/宽度偏移。 )</script><p>每个训练 RoI 都标有真实类别 u 和真实边界框回归目标 v。在每个标记的 RoI 上使用多任务损失 L 来联合训练分类和边界框回归： </p>
<script type="math/tex; mode=display">
L(p,u,t^u,v)=L_{cls}(p,u)+\lambda[\mu\ge1]L_{loc}(t^u,v)\\
L_{cls}(p,u)=-logp_u是真实类u的log损失；\\
L_{loc}被定义为回归目标u类上真实边界框的一个元组，v=(v_x,v_y,v_w,v_h),t^u=(t^k_x,t^k_y,t^k_w,t^k_h)是对类u预测的元组\\
[u\ge1]是Iverson\quad bracket\quad indicator\quad function,当u\ge 时，为1；否则为0\\</script><p>按照惯例，所有被预测的背景类标记为 u = 0。对于背景 RoI，没有真实边界框的概念，因此忽略 L<sub>loc</sub>。对于边界回归使用如下损失：</p>
<script type="math/tex; mode=display">
L_{loc}(t^u,v)=\sum_{i\in{x,y,w,h}}smooth_{L1}(t^u_i-v_i),其中\\
smooth_{L1}(x)=\begin{cases}
0.5\cdot x^2\quad \quad if |x|\lt1\\
|x|-0.5\quad otherwise.
\end{cases}</script><p>论文中指出smooth<sub>L1</sub>一个稳健的 L1 损失，对异常值的敏感度低于 R-CNN 和 SPPnet 中使用的 L2 损失。 当回归目标无界时，使用 L2 损失进行训练可能需要仔细调整学习率，以防止梯度爆炸。 smooth<sub>L1</sub>消除了这种敏感性。 </p>
<p>方程中的超参数λ控制两个任务损失之间的平衡。由于作者将真实回归目标 v<sub>i</sub> 归一化为具有零均值和单位方差。 所有实验都使用 λ = 1。</p>
<h5 id="Mini-batch-sampling"><a href="#Mini-batch-sampling" class="headerlink" title="Mini-batch sampling"></a>Mini-batch sampling</h5><p>在微调期间，每个 SGD mini-batch 由 N = 2 个图像构成，随机均匀选择（按照惯例，实际上迭代数据集的排列）。 我们使用大小为 R = 128 的小批量，从每个图像中采样 64 个 RoI。与论文Rich feature hierarchies for accurate object detection and semantic segmentation中一样，我们从与真实边界框重叠IoU&ge; 0.5 的对象提议中获取 25% 的 RoI。 这些 RoI 包括标有前景对象类的示例，即 u ≥ 1。其余的 RoI 是从目标建议与真实边界框IoU在区间[0.1,0.5)的最大值中采样，与SPPNet一致。 这些是背景示例，并用 u = 0 标记。 0.1 的较低阈值似乎充当了启发式的困难示例挖掘(ject detection with discriminatively trained part based models.)。 在训练期间，图像以 0.5 的概率水平翻转。 没有使用其他数据增强。 <strong>来自相同图像的RoI在向前和向后传播中共享计算和内存。</strong></p>
<h5 id="Back-propagation-through-RoI-pooling-layers"><a href="#Back-propagation-through-RoI-pooling-layers" class="headerlink" title="Back-propagation through RoI pooling layers"></a>Back-propagation through RoI pooling layers</h5><p>为清楚起见，作者假设每个小批量（N = 1）只有一张图像，但对 N &gt; 1 的扩展很简单，因为前向传递独立处理所有图像。 设 x<sub>i</sub> ∈ R 是输入到 RoI 池化层的第 i 个激活输入(这里有点晕，网上查了很多解释，应该是整个feature map中的输入层节点)，让 y<sub>rj</sub> 是来自第 r 个 RoI 的第 j 个输出(也就是候选区域中的第j个输出层节点)。 RoI 池化层计算使用下面的式子获取RoI Pooling层的输出：</p>
<script type="math/tex; mode=display">
y_{rj}=x_{i*(r,j)},其中，i*(r,j)=argmax_{i'\in R(r,j)}x_{i'}</script><p>R(r, j) 是输出单元 y<sub>rj</sub> 最大池化所对应的输入子窗口中的索引集(指示那个候选区域的那个最大值点被选中作为输出)。 单个 x<sub>i</sub> 可以分配给几个不同的输出 y<sub>rj</sub>(就是多个候选区域有重叠的时候，x<sub>i</sub> 为重叠的像素点集) 。 </p>
<p>首先看看，普通的max pooling层如何求导？</p>
<script type="math/tex; mode=display">
设x_i为输入层节点，y_i为输出层节点，那么损失函数L对输入层节点x_i的梯度为：\\
\frac{\partial L}{\partial x_i}=\begin{cases}
0,\quad \quad \delta(i,j)=false\\
\frac{\partial L}{\partial y},\quad \delta(i,j)=true
\end{cases}\\
判决函数\delta(i,j)表示输入i节点是否被输出j节点选为最大值输出\\
不选中有两种可能\delta(i,j)=false;x_i不在y_i范围内，或者x_i不是最大值\\
选中\delta(i,j)=true;由链式规则可知损失函数L相对 x_i的梯度等于损失函数L相对 y_i的梯度\times y_i对x_i的梯度(y_i对x_i的梯度恒等于1)</script><p><img src="/2021/08/15/Fast-R-CNN/fast-rcnn.png" alt="Fast-R-CNN"></p>
<p>对于RoI max pooling层，设 x<sub>i</sub>为输入层的节点， y<sub>rj</sub> 为第r个候选区域的第j个输出节点，一个输入节点可能和多个输出节点相关连，如下图所示，输入节点7和两个候选区域输出节点相关连；</p>
<p><img src="/2021/08/15/Fast-R-CNN/ROI-Pooling1.png" alt="Fast-R-CNN"></p>
<p>对于输出节点<strong>7</strong>的反向传播如下图所示：</p>
<p><img src="/2021/08/15/Fast-R-CNN/ROI-Pooling2.png" alt="Fast-R-CNN"></p>
<p>对于同一个feature map中不同的候选区域，节点7都存在梯度。所以反向传播中损失函数L对输入节点x<sub>i</sub>的梯度为损失函数L对各个<strong>有可能的</strong>候选区域r输出y<sub>rj</sub>[x<sub>i</sub>中候选区域r的第j个输出节点被选为最大值 ]梯度的累加。</p>
<p>RoI 池化层的向后函数通过计算损失函数关于每个输入变量 xi 及通过下式argmax所选择的值偏导数： </p>
<script type="math/tex; mode=display">
\frac{\partial L}{\partial x_i}=\sum_{r}\sum_{j},[i=i*(r,j)]指示函数\frac{\partial L}{\partial y_{rj}},[i=i*(r,j)]上文提到的指示函数</script><p>判决函数  [i=i∗(r,j)] 表示  <strong>i</strong> 节点是否被候选区域 <strong>r</strong> 的第 <strong>j</strong> 个输出节点选为最大值输出，若是，则由链式规则可知损失函数L相对  xi 的梯度等于(损失函数 L 相对 yri 的梯度)&times;( yrj 对 xi 的梯度),其中， yrj 对 xi 的梯度恒等于1。</p>
<p><a href="https://blog.csdn.net/Wonder233/article/details/53671018" target="_blank" rel="noopener">参考链接</a></p>
<h5 id="SGD-hyper-parameters"><a href="#SGD-hyper-parameters" class="headerlink" title="SGD hyper-parameters"></a>SGD hyper-parameters</h5><ul>
<li>除了修改增加的层，原有的层参数已经通过预训练方式初始化；</li>
<li>用于分类的全连接层以均值为0、标准差为0.01的高斯分布初始化，用于回归的全连接层以均值为0、标准差为0.001的高斯分布初始化，偏置都初始化为0；</li>
<li>针对PASCAL VOC 2007和2012训练集，前30k次迭代全局学习率为0.001，每层权重学习率为1倍，偏置学习率为2倍(这里就是说明权重和偏置设置的学习率分别为0.001和0.002，至于为什么，网上说是偏置的学习率设为2倍能够使网络收敛)，后10k次迭代全局学习率更新为0.0001；</li>
<li>动量设置为0.9，权重衰减设置为0.0005。</li>
</ul>
<h5 id="Scale-invariance"><a href="#Scale-invariance" class="headerlink" title="Scale invariance"></a>Scale invariance</h5><p>作者探索了两种实现尺度不变目标检测的方法：</p>
<ul>
<li><p>通过brute-force(单一尺度)</p>
<p>在单一尺度中，每个图像在训练和测试期间都以预定义的像素大小进行处理。 期望网络能够直接从训练数据中学习尺度不变性。 </p>
</li>
<li><p>通过image pyramids(多尺度)</p>
<p>1、多尺度在<strong>训练阶段</strong>期间，随机从图像中采样金字塔尺寸的一些图像进行训练[缩放图片的scale得到，得到多尺度图片，相当于扩充数据集]，通过一个图像金字塔向网络提供一个近似的尺度不变。训练阶段每次采样一个图像就随机采样一个金字塔尺度。</p>
<p>2、在<strong>测试阶段</strong>图像金字塔用来对每个object proposal近似尺度归一化</p>
</li>
</ul>
<h5 id="Fast-R-CNN-detection"><a href="#Fast-R-CNN-detection" class="headerlink" title="Fast R-CNN detection"></a>Fast R-CNN detection</h5><p> 一旦Fast R-CNN网络被微调，检测相当于运行正向传播（假设对象建议框object proposal是预先计算的）。网络将图像（或图像金字塔，编码为图像列表）和待给得分的 R 对象建议框（object proposal）列表作为输入。</p>
<p>在测试阶段，R 大约为 2K个，但作者会考虑它更大（≈ 45k）的情况。当使用图像金字塔的时候，每个RoI被指定尺度使得接近 224*224。对于每个测试 RoI r，前向传递输出一个类后验概率分布 p 和一组相对于 r 的预测边界框bbox偏移量（K 个类中的每一个都有自己的细化边界框预测）。</p>
<script type="math/tex; mode=display">
然后使用估计概率:Pr(class=k|r)\triangleq p_k给 r 赋予关于 k 个对象类的检测置信度</script><p>最后给每个类都实施一个非极大值抑制。</p>
<h5 id="Truncated-SVD-for-faster-detection-截断SVD以加快检测速度"><a href="#Truncated-SVD-for-faster-detection-截断SVD以加快检测速度" class="headerlink" title="Truncated SVD for faster detection(截断SVD以加快检测速度)"></a>Truncated SVD for faster detection(截断SVD以加快检测速度)</h5><p>对于全图像分类，与卷积层相比，计算全连接层所花费的时间很小。 相反，为了检测，要处理的 RoI 数量很大，前向传递时间的近一半用于计算全连接层（见图 2）。 通过使用截断的 SVD 压缩它们，可以轻松地加速大型完全连接层。 </p>
<p><img src="/2021/08/15/Fast-R-CNN/SVD.png" alt="Fast-R-CNN"></p>
<p>上图来源于Fast R-CNN论文<a href="https://blog.csdn.net/Wonder233/article/details/53671018" target="_blank" rel="noopener">论文链接</a></p>
<p>具体的实现方式：</p>
<ol>
<li><p>物体分类和bbox回归都是通过全连接层实现的，假设全连接层输入数据为X，输出数据为Y，全连接层权值矩阵为W，尺寸为 u × v ，那么该层全连接计算为:Y=W &times; X</p>
</li>
<li><p>若将W进行SVD分解（奇异值分解），并用前t个特征值近似代替，即:</p>
<script type="math/tex; mode=display">
W\approx U\Sigma_tV^T</script></li>
</ol>
<p>U是 u × t 的左奇异矩阵， Σ<sub>t</sub>是 t × t 的对角矩阵 ，V是 v × t 的右奇异矩阵。 截断SVD将参数量由原来的 u × v 减少到 t × (u + v) ，当 t 远小于 min(u,v) 的时候降低了很大的计算量。</p>
<p>在实现时，相当于把一个全连接层拆分为两个全连接层，第一个全连接层使用权值矩阵&Sigma;<sub>t</sub>V<sup>T</sup>（不含偏置），第二个全连接层使用矩阵U（含偏置)；当RoI的数量大时，这种简单的压缩方法有很好的加速。 </p>
<p><a href="https://blog.csdn.net/Wonder233/article/details/53671018" target="_blank" rel="noopener">部分内容：参考博客</a></p>
<h5 id="Which-layers-to-fine-tune-那些层需要被微调"><a href="#Which-layers-to-fine-tune-那些层需要被微调" class="headerlink" title="Which layers to fine-tune?(那些层需要被微调)"></a>Which layers to fine-tune?(那些层需要被微调)</h5><p>作者实验得出，仅仅向SPPNet一样，微调全连接层的话，mAP的减少了很多。证明通过 RoI 池化层进行训练对于非常深的网络很重要。 </p>
<p><strong>那么所有的卷积层都应被为微调吗？</strong></p>
<p>实验得出：</p>
<ul>
<li>在较小的网络（S 和 M）中，作者发现 conv1 是通用的且与任务无关（ ImageNet clas-<br>sification with deep convolutional neural networks.）。 允许 conv1 学习与否对 mAP 没有有意义的影响。 </li>
<li>与从 conv3 1 学习相比，从 conv2 1 更新使训练速度降低了 1.3 倍（12.5 对 9.5 小时）；     </li>
<li>从 conv1 1 更新超过 GPU 内存。 从 conv2 1 开始学习时，mAP 的差异仅为 +0.3 分（表 5，最后一列）。 </li>
</ul>
<p>所以论文推荐所有 Fast R-CNN 结果均使用 VGG16 微调层 conv3 1 及以上。</p>
<h5 id="Scale-invariance-to-brute-force-or-finesse"><a href="#Scale-invariance-to-brute-force-or-finesse" class="headerlink" title="Scale invariance: to brute force or finesse?"></a>Scale invariance: to brute force or finesse?</h5><p>实验发现：深度卷积网络擅长直接学习尺度不变性。 多尺度方法仅提供少量的 mAP 增加，但计算时间成本很高 。</p>
<h5 id="Are-more-proposals-always-better"><a href="#Are-more-proposals-always-better" class="headerlink" title="Are more proposals always better?"></a>Are more proposals always better?</h5><p>广义上，有两种类型的对象检测器</p>
<ul>
<li>那些使用稀疏对象提议集（例如，选择性搜索）<ul>
<li>是cascade的一种类型：其中提议机制首先拒绝大量候选，让分类器留下一个小的集合进行评估</li>
</ul>
</li>
<li>使用密集集和（例如，DPM）的对象检测器</li>
</ul>
<p><a href="https://www.jianshu.com/p/fbbb21e1e390" target="_blank" rel="noopener">部分参考链接</a></p>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Connected-Component-Analysis-Labeling</title>
    <url>/2021/08/15/Connected-Component-Analysis-Labeling/</url>
    <content><![CDATA[<h2 id="图像处理学习笔记"><a href="#图像处理学习笔记" class="headerlink" title="图像处理学习笔记"></a>图像处理学习笔记</h2><h4 id="一、连通域提取"><a href="#一、连通域提取" class="headerlink" title="一、连通域提取"></a>一、连通域提取</h4><p><img src="/2021/08/15/Connected-Component-Analysis-Labeling/connect.png" alt="Connect-Extract"></p>
<p>如上图所示，需要将连通域提取出来。用不同的数字标记。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> XDIM 10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> YDIM 10</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">#深度优先搜索</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> arr[XDIM][YDIM], <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;visited, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> label)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    visited[row][col] = label;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> xLeft = col<span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> xRight = col+<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> yTop = row<span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> yBottom = row+<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(xLeft&gt;<span class="number">0</span> &amp;&amp; arr[row][xLeft]==<span class="number">1</span>  &amp;&amp; visited[row][xLeft]==<span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dfs(arr, visited, row, xLeft, label);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(xRight&lt;XDIM &amp;&amp; arr[row][xRight]==<span class="number">1</span> &amp;&amp; visited[row][xRight]==<span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dfs(arr, visited, row, xRight, label);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(yTop&gt;<span class="number">0</span> &amp;&amp; arr[yTop][col]==<span class="number">1</span> &amp;&amp; visited[yTop][col]==<span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dfs(arr, visited, yTop, col, label);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(yBottom&lt;YDIM &amp;&amp; arr[yBottom][col]==<span class="number">1</span> &amp;&amp; visited[yBottom][col]==<span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dfs(arr, visited, yBottom, col, label);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; &amp;outVec)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;outVec.<span class="built_in">size</span>(); ++ i)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;outVec[<span class="number">0</span>].<span class="built_in">size</span>(); ++j)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; outVec[i][j] &lt;&lt; <span class="string">" "</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"\n"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> type=<span class="number">1</span>; <span class="comment">//type=1表示4领域，type=2表示8领域</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[XDIM][YDIM]=&#123;<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                           <span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                       	   <span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                       	   <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                           <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                           <span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                           <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                           <span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                           <span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                           <span class="number">1</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">0</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> rows = XDIM;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> cols = YDIM;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//std::vector&lt;int*&gt; input;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//for(int i=0; i&lt;rows; ++i)&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//    input.push_back(array[i]);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//打标记的输出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">out</span><span class="params">(rows,<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(cols,<span class="number">0</span>))</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> label=<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r=<span class="number">0</span>; r&lt;rows; ++r)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> c=<span class="number">0</span>; c&lt;cols; ++c)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(<span class="built_in">array</span>[r][c]!=<span class="number">0</span> &amp;&amp; out[r][c]==<span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                dfs(<span class="built_in">array</span>, out, r, c, label);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                label++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">print</span>(out);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//编译</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">g++ ./test.cpp -o test</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">./test</span></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="/2021/08/15/Connected-Component-Analysis-Labeling/connect-component.png" alt="Connect-Component"></p>
<h4 id="二、连通性分析法"><a href="#二、连通性分析法" class="headerlink" title="二、连通性分析法"></a>二、连通性分析法</h4><p>一个连通区域是由具有相同像素值的相邻像素组成像素集合，指将图像中的各个连通区域找出并标记。连通区域分析是一种在CVPR和图像分析处理的众多应用领域中较为常用和基本的方法。例如：OCR识别中字符分割提取（车牌识别、文本识别、字幕识别等）、视觉跟踪中的运动前景目标分割与提取（行人入侵检测、遗留物体检测、基于视觉的车辆检测与跟踪等）、医学图像处理（感兴趣目标区域提取）等等。也就是说，在需要将前景目标提取出来以便后续进行处理的应用场景中都能够用到连通区域分析方法，通常连通区域分析处理的对象是一张二值化后的图像。<a href="https://blog.csdn.net/icvpr/article/details/10259577" target="_blank" rel="noopener">参考文档</a></p>
<h5 id="1、Two-pass-相当于广度搜索"><a href="#1、Two-pass-相当于广度搜索" class="headerlink" title="1、Two-pass(相当于广度搜索)"></a>1、Two-pass(相当于广度搜索)</h5><p>两遍扫描法，指的就是通过扫描两遍图像，就可以将图像中存在的所有连通区域找出并标记。第一遍扫描时赋予每个像素位置一个label，扫描过程中同一个连通区域内的像素集合中可能会被赋予一个或多个不同label，因此需要将这些属于同一个连通区域但具有不同值的label合并，也就是记录它们之间的相等关系；第二遍扫描就是将具有相等关系的equal_labels所标记的像素归为一个连通区域并赋予一个相同的label（通常这个label是equal_labels中的最小值）。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">icvprCcaByTwoPass</span><span class="params">(<span class="keyword">const</span> cv::Mat&amp; _binImg, cv::Mat&amp; _lableImg)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// connected component analysis (4-component)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// use two-pass algorithm</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 1. first pass: label each foreground pixel with a label</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 2. second pass: visit each labeled pixel and merge neighbor labels</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// foreground pixel: _binImg(x,y) = 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// background pixel: _binImg(x,y) = 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> (_binImg.empty() || _binImg.type() != CV_8UC1)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 1. first pass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	_lableImg.<span class="built_in">release</span>() ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	_binImg.convertTo(_lableImg, CV_32SC1) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> label = <span class="number">1</span> ;  <span class="comment">// start by 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; labelSet ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	labelSet.push_back(<span class="number">0</span>) ;   <span class="comment">// background: 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	labelSet.push_back(<span class="number">1</span>) ;   <span class="comment">// foreground: 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> rows = _binImg.rows - <span class="number">1</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> cols = _binImg.cols - <span class="number">1</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">int</span>* data_preRow = _lableImg.ptr&lt;<span class="keyword">int</span>&gt;(i<span class="number">-1</span>) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">int</span>* data_curRow = _lableImg.ptr&lt;<span class="keyword">int</span>&gt;(i) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cols; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> (data_curRow[j] == <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; neighborLabels ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				neighborLabels.reserve(<span class="number">2</span>) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">int</span> leftPixel = data_curRow[j<span class="number">-1</span>] ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">int</span> upPixel = data_preRow[j] ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">if</span> ( leftPixel &gt; <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					neighborLabels.push_back(leftPixel) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">if</span> (upPixel &gt; <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					neighborLabels.push_back(upPixel) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">if</span> (neighborLabels.empty())</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					labelSet.push_back(++label) ;  <span class="comment">// assign to a new label</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">					data_curRow[j] = label ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					labelSet[label] = label ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="built_in">std</span>::sort(neighborLabels.<span class="built_in">begin</span>(), neighborLabels.<span class="built_in">end</span>()) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">int</span> smallestLabel = neighborLabels[<span class="number">0</span>] ;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">					data_curRow[j] = smallestLabel ;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="comment">// save equivalence</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">for</span> (<span class="keyword">size_t</span> k = <span class="number">1</span>; k &lt; neighborLabels.<span class="built_in">size</span>(); k++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">					&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="keyword">int</span> tempLabel = neighborLabels[k] ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="keyword">int</span>&amp; oldSmallestLabel = labelSet[tempLabel] ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="keyword">if</span> (oldSmallestLabel &gt; smallestLabel)</span></pre></td></tr><tr><td class="code"><pre><span class="line">						&#123;							</span></pre></td></tr><tr><td class="code"><pre><span class="line">							labelSet[oldSmallestLabel] = smallestLabel ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">							oldSmallestLabel = smallestLabel ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">						&#125;						</span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="keyword">else</span> <span class="keyword">if</span> (oldSmallestLabel &lt; smallestLabel)</span></pre></td></tr><tr><td class="code"><pre><span class="line">						&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">							labelSet[smallestLabel] = oldSmallestLabel ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">						&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&#125;				</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// update equivalent labels</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// assigned with the smallest label in each equivalent label set</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">2</span>; i &lt; labelSet.<span class="built_in">size</span>(); i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">int</span> curLabel = labelSet[i] ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">int</span> preLabel = labelSet[curLabel] ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">while</span> (preLabel != curLabel)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			curLabel = preLabel ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			preLabel = labelSet[preLabel] ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		labelSet[i] = curLabel ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 2. second pass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">int</span>* data = _lableImg.ptr&lt;<span class="keyword">int</span>&gt;(i) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; cols; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">int</span>&amp; pixelLabel = data[j] ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			pixelLabel = labelSet[pixelLabel] ;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> max_size = <span class="number">1000</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> parent[max_size] = &#123; <span class="number">0</span> &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 找到label x的根节点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> parent[])</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    assert(x &lt; max_size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> i = x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="number">0</span> != parent[i])</span></pre></td></tr><tr><td class="code"><pre><span class="line">        i = parent[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// 将label x 和 label y合并到同一个连通域</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y, <span class="keyword">int</span> parent[])</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    assert(x &lt; max_size &amp;&amp; y &lt; max_size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> i = x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> j = y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="number">0</span> != parent[i])</span></pre></td></tr><tr><td class="code"><pre><span class="line">        i = parent[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">while</span> (<span class="number">0</span> != parent[j])</span></pre></td></tr><tr><td class="code"><pre><span class="line">        j = parent[j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (i != j)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        parent[i] = j;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">twoPassConnectComponent</span><span class="params">(cv::Mat &amp;binaryImg)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> imgW = binaryImg.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> imgH = binaryImg.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> channel = binaryImg.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> type = binaryImg.type();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// first pass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> label = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    cv::Mat dst = cv::Mat::zeros(cv::Size(imgW, imgH), CV_32SC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; imgH; y++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; imgW; x++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (binaryImg.at&lt;uchar&gt;(y, x) != <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> left = (x - <span class="number">1</span> &lt; <span class="number">0</span>) ? <span class="number">0</span> : dst.at&lt;<span class="keyword">int</span>&gt;(y, x - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">int</span> up = (y - <span class="number">1</span> &lt; <span class="number">0</span>) ? <span class="number">0</span> : dst.at&lt;<span class="keyword">int</span>&gt;(y - <span class="number">1</span>, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 <span class="keyword">if</span> (left != <span class="number">0</span> || up != <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                     <span class="keyword">if</span> (left != <span class="number">0</span> &amp;&amp; up != <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                     &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                         dst.at&lt;<span class="keyword">int</span>&gt;(y, x) = <span class="built_in">min</span>(left, up);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                         <span class="keyword">if</span> (left &lt;= up)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                             Union(up, left, parent);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                         <span class="keyword">else</span> <span class="keyword">if</span> (up&lt;left)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                             Union(left, up, parent);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                     <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                         dst.at&lt;<span class="keyword">int</span>&gt;(y, x) = <span class="built_in">max</span>(left, up);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 <span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                 &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                     dst.at&lt;<span class="keyword">int</span>&gt;(y, x) = ++label;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">             &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="comment">//second pass </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; imgH; y++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; imgW; x++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">         &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">             <span class="keyword">if</span> (binaryImg.at&lt;uchar&gt;(y, x) != <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                 dst.at&lt;<span class="keyword">int</span>&gt;(y, x) = Find(dst.at&lt;<span class="keyword">int</span>&gt;(y, x), parent);</span></pre></td></tr><tr><td class="code"><pre><span class="line">         &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">     <span class="keyword">return</span> dst;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/icvpr/article/details/10259577" target="_blank" rel="noopener">第一个代码一不容易看懂: 来源</a></p>
<p><a href="https://www.cnblogs.com/riddick/p/8280883.html" target="_blank" rel="noopener">第二个代码教委清晰: 来源</a></p>
<p><a href="http://www.cse.msu.edu/~stockman/Book/2002/Chapters/ch3.pdf" target="_blank" rel="noopener">可参考的书籍</a></p>
<h5 id="2、Seed-Filling-相当于深度搜索"><a href="#2、Seed-Filling-相当于深度搜索" class="headerlink" title="2、Seed-Filling(相当于深度搜索)"></a>2、Seed-Filling(相当于深度搜索)</h5><p>种子填充方法来源于计算机图形学，常用于对某个图形进行填充。思路：选取一个前景像素点作为种子，然后根据连通区域的两个基本条件（像素值相同、位置相邻）将与种子相邻的前景像素合并到同一个像素集合中，最后得到的该像素集合则为一个连通区域。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/imgproc/imgproc.hpp&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui/highgui.hpp&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">icvprCcaBySeedFill</span><span class="params">(<span class="keyword">const</span> cv::Mat&amp; _binImg, cv::Mat&amp; _lableImg)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// connected component analysis (4-component)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// use seed filling algorithm</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 1. begin with a foreground pixel and push its foreground neighbors into a stack;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// 2. pop the top pixel on the stack and label it with the same label until the stack is empty</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// foreground pixel: _binImg(x,y) = 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">// background pixel: _binImg(x,y) = 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> (_binImg.empty() || _binImg.type() != CV_8UC1)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">	_lableImg.<span class="built_in">release</span>() ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	_binImg.convertTo(_lableImg, CV_32SC1) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> label = <span class="number">1</span> ;  <span class="comment">// start by 2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> rows = _binImg.rows - <span class="number">1</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> cols = _binImg.cols - <span class="number">1</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; rows<span class="number">-1</span>; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">int</span>* data= _lableImg.ptr&lt;<span class="keyword">int</span>&gt;(i) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; cols<span class="number">-1</span>; j++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">if</span> (data[j] == <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="built_in">std</span>::<span class="built_in">stack</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; neighborPixels ;   </span></pre></td></tr><tr><td class="code"><pre><span class="line">				neighborPixels.push(<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(i,j)) ;     <span class="comment">// pixel position: &lt;i,j&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				++label ;  <span class="comment">// begin with a new label</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">while</span> (!neighborPixels.empty())</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="comment">// get the top pixel on the stack and label it with the same label</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; curPixel = neighborPixels.top() ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">int</span> curX = curPixel.first ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">int</span> curY = curPixel.second ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					_lableImg.at&lt;<span class="keyword">int</span>&gt;(curX, curY) = label ;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="comment">// pop the top pixel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">					neighborPixels.pop() ;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="comment">// push the 4-neighbors (foreground pixels)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">if</span> (_lableImg.at&lt;<span class="keyword">int</span>&gt;(curX, curY<span class="number">-1</span>) == <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">					&#123;<span class="comment">// left pixel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">						neighborPixels.push(<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(curX, curY<span class="number">-1</span>)) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">if</span> (_lableImg.at&lt;<span class="keyword">int</span>&gt;(curX, curY+<span class="number">1</span>) == <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">					&#123;<span class="comment">// right pixel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">						neighborPixels.push(<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(curX, curY+<span class="number">1</span>)) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">if</span> (_lableImg.at&lt;<span class="keyword">int</span>&gt;(curX<span class="number">-1</span>, curY) == <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">					&#123;<span class="comment">// up pixel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">						neighborPixels.push(<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(curX<span class="number">-1</span>, curY)) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">if</span> (_lableImg.at&lt;<span class="keyword">int</span>&gt;(curX+<span class="number">1</span>, curY) == <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">					&#123;<span class="comment">// down pixel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">						neighborPixels.push(<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;(curX+<span class="number">1</span>, curY)) ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&#125;		</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/icvpr/article/details/10259577" target="_blank" rel="noopener">第一个代码一不容易看懂</a></p>
]]></content>
      <categories>
        <category>Image Processing</category>
      </categories>
      <tags>
        <tag>Image Processing</tag>
      </tags>
  </entry>
  <entry>
    <title>Support-Vector-Machine</title>
    <url>/2021/08/15/Support-Vector-Machine/</url>
    <content><![CDATA[<h2 id="第六章-支持向量机（西瓜书学习-笔记）"><a href="#第六章-支持向量机（西瓜书学习-笔记）" class="headerlink" title="第六章 支持向量机（西瓜书学习-笔记）"></a>第六章 支持向量机（西瓜书学习-笔记）</h2><p>假设输入空间与特征空间为两个不同的空间。输入空间为欧式空间或离散集合，特征空间为欧式空间或希尔伯特空间。线性可分支持向量机、线性支持向量机假设这两个空间的元素一一对应，并将输入空间中的输入映射为特征空间中的特征向量。<strong>非线性支持向量机</strong>利用一个<strong>从输入空间</strong>到<strong>特征空间</strong>的<strong>非线性映射</strong>将<strong>输入映射为特征向量</strong>。<strong>所以，输入都由输入空间转换到特征空间，支持向量机的学习是在特征空间进行的。</strong>[参考：统计学习方法-李航]</p>
<h4 id="6-1-间隔与支持向量"><a href="#6-1-间隔与支持向量" class="headerlink" title="6.1 间隔与支持向量"></a>6.1 间隔与支持向量</h4><p>给定训练样本集D={(x<sub>1</sub>, y<sub>1</sub>)，(x<sub>2</sub>, y<sub>2</sub>),…, (x<sub>m</sub>, y<sub>m</sub>)}，y<sub>i</sub>&in;{-1,+1}，分类学习最基本的想法就是基于训练集D在样本空间中找到一个划分超平面，将不同类别的样本分开。但能将训练样本分开的划分超平面可能有很多。如下图所示，<strong>那么如何找到最合适的超平面呢？</strong></p>
<p><img src="/2021/08/15/Support-Vector-Machine/SVM.png" alt="ML"></p>
<p>上图中，中间那根粗线这个划分超平面所产生的分类结果是最鲁邦的，对未见示例的泛化能力最高。</p>
<p>在样本空间中，划分超平面可通过如下线性方程来描述：w<sup>T</sup>x+b=0，其中w=(w<sub>1</sub>;w<sub>2</sub>;…;w<sub>d</sub>)为法向量，决定了超平面的方向；b为位移项，决定了超平面与原点之间的距离。</p>
<p>由于超平面可由法向量w和位移b确定，记为(w,b)。则样本空间中任意点x到超平面(w,b)的距离可写为：</p>
<script type="math/tex; mode=display">
r=\frac{|w^Tx+b|}{||w||}\\
\begin{align}&在n维空间中，设任意点坐标为:x=[x^{(1)},x^{(2)},...,x^{(n)}]\in R^n,超平面参数为w=[w^{(1)}，w^{(2)},...,w^{(n)}]\in R^n,b\in R\\
&则超平面方程可表示为w^Tx+b=0。超平面的法向量满足：超平面中任意向量都与该法向量垂直\\
&设超平面上的两个点x_1,x_2,分别满足：w^Tx_1+b=0;w^Tx_2+b=0,两式相减，得：\\
&w^T(x_1-x_2)=0,记\vec v=(x_1-x_2),由于x_1,x_2是任意两点，所以\vec v表示超平面上的任意向量\\
&\because w^T\cdot\vec v=\vec 0,\therefore w是w^Tx+b=0的法向量\\
&记超平面外一点x_0,其在超平面w^Tx+b=0上的投影点为x'_0,满足w^Tx'_0+b=0\\
&则有向量\vec u=(x_0-x'_0)与平面w^Tx+b=0的法向量w互相平行，则两者的数量级为：\\&w^T(x_0-x'_0)=w\cdot (x_0-x'_0)=|w|*|x_0-x'_0|*\cos(0\,or\,\pi)=\pm|w|*d，d=|x_0-x'_0|即为待求点到超平面间的距离\\
&又w^T(x_0-x'_0)=w^Tx_0-w^Tx'_0=w^Tx_0-(-b)=w^Tx_0+b,\because d \ge0,\therefore d=\frac{|w^Tx_0+b|}{|w|}\\
&这里上式中的 ∣ w ∣ w 的模长，模长作为绝对值概念的推广,在欧式空间中，模长常常称为L2范数\\&（也称为Euclidean范数或者Frobenius范数）：
||w||_F=\sqrt{(w^{1})^2+(w^{2})^2+...+(w^{n})^2}
\end{align}</script><p>通过|wx+b|近似表示点x距离超平面的远近(因为还要除以模)，而wx+b的符号与类标记y的符号是否一致来表示分类是否正确。那么可用y(wx+b)来表示分类的正确性与确定度。这就是函数间隔：</p>
<script type="math/tex; mode=display">
\hat\gamma_i=y_i(w\cdot x_i+b)</script><p>但由于函数间隔中，如果成比例的改变w和b，那么即便x<sub>i</sub>距离平面的距离没有变化，函数间隔也将随着w和b而改变。所以需要对分离超平面的法向量w增加约束，如令|w|=1。从而引出了几何间隔：</p>
<script type="math/tex; mode=display">
\gamma_i=y_i\Big(\frac{w}{||w||}\cdot x_i+\frac{b}{||w||}\Big),||w||为w的L_2范数</script><p><strong>支持向量机学习</strong>的<strong>基本思想</strong>是求解能够正确划分训练数据集并且几何间隔最大的分离超平面。那么如何寻找几何间隔最大的分离超平面呢？即为求解下面的约束最优化问题：</p>
<script type="math/tex; mode=display">
\max_{w,b}\quad\gamma\\
s.t.\quad y_i\Big(\frac{w}{||w||}\cdot x_i+\frac{b}{||w||}\Big)\ge\gamma,i=1,2,...,N\\
约束条件表示超平面(w,b)关于每个训练样本点的几何间隔至少为\gamma,转化为函数间隔：\\
\max_{w,b}\quad\frac{\hat \gamma}{||w||}\\
s.t.\quad y_i(w\cdot x_i+b)\ge\hat \gamma,i=1,2,...,N\\
因为函数间隔\hat \gamma 的取值并不影响优化问题的解(同时放大w和b对解没有影响)。\\
令\hat \gamma=1,则上式的最优化问题变成：最大化\frac{1}{||w||}和\frac{1}{2}||w||^2,于是得到下式最优化问题：\\
\min_{w,b}\quad \frac{1}{2}||w||^2\\
s.t.\quad y_i(w\cdot x_i+b)-1\ge0,i=1,2,...,N</script><p>在线性可分的情况下，训练数据集的样本点中与分离超平面距离最近的样本点的实例称为<strong>支持向量</strong>。两个异类支持向量到超平面的距离称为<strong>间隔</strong>：</p>
<script type="math/tex; mode=display">
\gamma=\frac{2}{||w||}</script><p><img src="/2021/08/15/Support-Vector-Machine/SVM-0.png" alt="SVM"></p>
<h4 id="6-2-对偶问题"><a href="#6-2-对偶问题" class="headerlink" title="6.2 对偶问题"></a>6.2 对偶问题</h4><p>对于上式凸二次规划问题，可以利用拉格朗日乘子的对偶性进行求解。先求出对偶问题的解a<sup>*</sup>，在求原始问题的解w<sub>*</sub>和b。对于拉格朗日乘子&alpha;<sub>i</sub>&ge;0，则拉格朗日函数可写为：</p>
<script type="math/tex; mode=display">
L(w,b,\alpha)=\frac{1}{2}||w||^2+\sum^{m}_{i=1}\alpha_i(1-y_i(w^Tx_i+b)),m为样本数</script><p>根据拉格朗日对偶性，原始问题的对偶问题是极大极小问题：</p>
<script type="math/tex; mode=display">
\max_{a}\min_{w,b} L(w,b,\alpha)</script><p>所以先求L(w,b,&alpha;)对w,b的极小，再求&alpha;的极大。</p>
<script type="math/tex; mode=display">
(1)\quad求\min_{w,b}L(w,b,\alpha),分别对w,b求偏导并令其等于0\\
\bigtriangledown_wL(w,b,\alpha)=w-\sum^{m}_{i=1}\alpha_iy_ix_i=0, w=\sum^{m}_{i=1}\alpha_iy_ix_i\\
\bigtriangledown_bL(w,b,\alpha)=\sum^{m}_{i=1}\alpha_iy_i=0,将w和\sum^{m}_{im=1}\alpha_iy_i=0带入L(w,b,\alpha)\\
\begin{align}
L(w,b,\alpha)=&\frac{1}{2}\sum^{m}_{i=1}\sum^{m}_{j=1}\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)-\sum^{m}_{i=1}\alpha_iy_i\Big(\big(\sum^{m}_{j=1}\alpha_jy_jx_j\big)\cdot x_i+b\Big)+\sum^{m}_{i=1}\alpha_i\\
=&-\frac{1}{2}\sum^{m}_{i=1}\sum^{m}_{j=1}\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)+\sum^{m}_{i=1}\alpha_i\\
\end{align}\\
上式中，\sum^{m}_{i=1}\alpha_iy_ib=0,所以，\min_{w,b}L(w,b,\alpha)=-\frac{1}{2}\sum^{m}_{i=1}\sum^{m}_{j=1}\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)+\sum^{m}_{i=1}\alpha_i\\
(2)\quad 求\min_{w,b}L(w,b,\alpha)对\alpha的极大，即是对偶问题\\
\max_{\alpha}-\frac{1}{2}\sum^{m}_{i=1}\sum^{m}_{j=1}\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)+\sum^{m}_{i=1}\alpha_i\\
s.t.\quad \sum^{m}_{i=1}\alpha_iy_i=0\\
\alpha_i\gt0,i=1,2,...,m\\
等价于：\min_{\alpha}\frac{1}{2}\sum^{m}_{i=1}\sum^{m}_{j=1}\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)-\sum^{m}_{i=1}\alpha_i\\
s.t.\quad \sum^{m}_{i=1}\alpha_iy_i=0\\
\alpha_i\gt0,i=1,2,...,m\\
对于线性可分训练数据集，假设对偶最优化问题对\alpha^*=(\alpha^*_u1r,\alpha^*_2,...,\alpha^*_m),那么如何求原始最优化问题的解w^*,b^*</script><p>因为原始最优化问题，满足KKT条件，所以：</p>
<script type="math/tex; mode=display">
\begin{align}
&\bigtriangledown_wL(w^*,b^*,\alpha^*)=w^*-\sum^{m}_{i=1}\alpha^*_iy_ix_i=0\\
&\bigtriangledown_bL(w^*,b^*,\alpha^*)=-\sum^{m}_{i=1}\alpha^*_iy_i=0\\
&\alpha^*_i(y_i(w^*\cdot x_i+b^*)-1)=0,i=1,2,...,m\\
&y_i(w^*\cdot x_i+b^*)-1=0,i=1,2,...,m\\
&a^*_i\ge0,i=1,2,...,m\\
&可得：w^*=\sum_{i}\alpha^*_iy_ix_i\\
&由于其中至少有一个\alpha^*_j\gt0,否则，利用反证法得，w^*=0，矛盾\\
&所以对于\alpha^*_j\gt0得j,y_i(w^*\cdot x_j+b^*)-1=0,将w^*代入:\\
&y_jb^*=1-y^*\sum^{m}_{i=1}\alpha^*_iy_i(x_i\cdot x_j),两边同乘y_j,因为y\in\{1,-1\},y^2_j=1\\
&所以，b^*=y_j-\sum^{m}_{i=1}\alpha^*_iy_i(x_i\cdot x_j)
\end{align}</script><p><strong>那么如何求出&alpha;<sup>*</sup>的值呢？</strong></p>
<p>可以利用SMO (Sequential Minimal Optimization)算法。SMO的基本思路是先固定&alpha;<sub>i</sub>之外的所有参数，然后求&alpha;<sub>i</sub>上的极值。由于存在约束sum&alpha;<sub>i</sub>y<sub>i</sub>=0 i=1,…,m，所以如果固定&alpha;<sub>i</sub>之外的变量，则&alpha;<sub>i</sub>可由其他变量导出。</p>
<p>SMO不断执行一下步骤，直至收敛：</p>
<ul>
<li>选取一对需要更新的变量&alpha;<sub>i</sub>,&alpha;<sub>j</sub>;</li>
<li>固定&alpha;<sub>i</sub>和&alpha;<sub>j</sub>以外的参数，求解下式，获得更新后的&alpha;<sub>i</sub>和&alpha;<sub>j</sub>:</li>
</ul>
<script type="math/tex; mode=display">
\min_{\alpha}\frac{1}{2}\sum^{m}_{i=1}\sum^{m}_{j=1}\alpha_i\alpha_jy_iy_j(x_i\cdot x_j)-\sum^{m}_{i=1}\alpha_i</script><h4 id="6-3-核函数"><a href="#6-3-核函数" class="headerlink" title="6.3 核函数"></a>6.3 核函数</h4><p>之前假设训练样本线性可分，但实现任务中，原始样本空间内也许并不存在一个能正确划分两类样本的超平面。例如：异或问 题。</p>
<p>解决办法是：可将样本从原始空间映射到一个更高维的特征空间，使样本在这个特征空间内线性可分。幸运的是，如果原始空间是有限维，那么一定存在一个高维特征空间使样本可分。</p>
<p><img src="/2021/08/15/Support-Vector-Machine/SVM-1.png" alt="SVM"></p>
<p>令&Phi;(x)表示将x映射后的特征向量，则在特征空间中划分超平面所对应的模型可表示为：</p>
<script type="math/tex; mode=display">
f(x)=w^T\phi(x)+b,w和b是模型参数，有；\\
\min_{w,b}\frac{1}{2}||w||^2\\
s.t.\quad y_i(w^T\phi(x_i)+b)\ge1,i=1,2,...,m\\
对偶问题为：\max_{\alpha}\sum^{m}_{i=1}\alpha_i-\frac{1}{2}\sum^{m}_{i=1}\sum^{m}_{i=1}\alpha_i\alpha_jy_iy_j\phi(x_i)^T\phi(x_j)\\
s.t.\quad\sum^{m}_{i=1}\alpha_iy_i=0,\alpha_i\ge1,i=1,2,...,m\\
\phi(x_i)^T\phi(x_j)是样本x_i与x_j映射到特征空间之后的内积。当特征空间维度过高时，求解很困难。\\
所以设想一个函数：k(x_i,x_j)=\langle\phi(x_i),\phi(x_j)\rangle=\phi(x_i)^T\phi(x_j)\\
x_i与x_j在特征空间的内积等于它们在原始样本空间中通过函数k(\cdot,\cdot)计算的结果</script><p><strong>那么核函数一定存在吗？什么样的函数能做核函数？</strong></p>
<script type="math/tex; mode=display">
令\chi为输入空间，k(\cdot,\cdot)是定义在\chi\times\chi上的对称函数，\\则k是核函数当且仅当对于任意数据D=\{x_1,x_2,...,x_m\},核矩阵K总是半正定的：\\
\left[
\begin{matrix}
k(x_1,x_1) \cdots & k(x_1,x_k) & \cdots & k(x_1,x_m)\\
\vdots & \vdots & \ddots & \vdots\\
k(x_i,x_1) & k(x_i,x_j) & \cdots & k(x_i,x_m)\\
\vdots & \vdots & \ddots & \vdots\\
k(x_m,x_1) & k(x_m,x_j) & \cdots & k(x_m,x_m)
\end{matrix}
\right]
\tag{5}</script><p><img src="/2021/08/15/Support-Vector-Machine/SVM-2.png" alt="SVM"></p>
<p>此外，还可以通过函数组合得到。</p>
<h4 id="6-4-软间隔与正则化"><a href="#6-4-软间隔与正则化" class="headerlink" title="6.4 软间隔与正则化"></a>6.4 软间隔与正则化</h4><p>由于在现实任务中，往往很难确定合适的核函数使得训练样本在特征空间中线性可分。即便，使用的核函数使训练样本在特征空间线性可分，但是不确定是不是由于过拟合造成的。缓解该问题的一个办法是允许支持向量在一些样本上出错，即引入软间隔：</p>
<p><img src="/2021/08/15/Support-Vector-Machine/SVM-3.png" alt="SVM"></p>
<p>软间隔则是允许某些样本不满足约束：</p>
<script type="math/tex; mode=display">
y_i(w^Tx_i+b)\ge1</script><p>但是，在最大间隔的同时，不满足约束的样本应尽可能少，于是优化目标写为：</p>
<script type="math/tex; mode=display">
\min_{w,b}\frac{1}{2}||w||^2+C\sum^{m}_{i=1}l_{0/1}(y_i(w^Tx_i+b)-1 )</script><p>其中C&gt;0是一个常数，l<sub>0/1</sub>是0/1损失函数。</p>
<script type="math/tex; mode=display">
l_{0/1}(z)=
\begin{cases}
1,\quad z\lt 0;\\
0, \quad otherwise
\end{cases}
\tag{1}</script><p>由于，l<sub>0/1</sub>非凸、非连续、数学性质不好。于是，通常用其他一些函数来代替l<sub>0/1</sub>称为替代损失。如下给出三种常用的替代损失函数：</p>
<script type="math/tex; mode=display">
hinge损失：l_{hinge}(z)=max(0,1-z)\\
指数损失(exponential\,\,loss):l_{exp}(z)=exp(-z)\\
对率损失(logistic\,\,loss):l_{log}(z)=log(1+exp(-z))</script><p>若采用hinge损失，则优化目标为：</p>
<script type="math/tex; mode=display">
\min_{w,b}\frac{1}{2}||w||^2+C\sum^{m}_{i=1}max(0,1-y_i(w^Tx_i+b))</script><p>引入松弛变量&xi;<sub>i</sub>&ge;0，则上式重写为：</p>
<script type="math/tex; mode=display">
\min_{w,b,\xi_i}\frac{1}{2}||w||^2+C\sum^{m}_{i=1}\xi_i\\
s.t.\quad y_i(w^Tx_i+b)\ge1-\xi_i\\
\xi_i\ge0,i=1,2,...,m</script><p>上面中每个样本都有一个对应的松弛变量，用以表征样本不满足约束的程度。但仍然是一个二次规划问题，通过拉格朗日乘子法可得如下的拉格朗日函数：</p>
<script type="math/tex; mode=display">
L(w,b,\xi,\mu)=\frac{1}{2}||w||^2+C\sum^{m}_{i=1}\xi_i+\sum^{m}_{i=1}\alpha_i(1-\xi_i-y_i(w^Tx_i+b))-\sum^{m}_{i=1}\mu_i\xi_i,其中\alpha_i\ge0,\mu_i\ge0</script><p><img src="/2021/08/15/Support-Vector-Machine/SVM-4.png" alt="SVM"></p>
<p>上面的0/1损失函数可以换成别的替代损失函数，但它们具有一个共性：优化目标中的第一项用来描述划分超平面的间隔大小，另一项用来表述训练集上的误差，可写为更一般的形式：</p>
<script type="math/tex; mode=display">
\min_{f}\Omega(f)+C\sum^{m}_{i=1}l(f(x_i),y_i),\Omega(f)为结构风险，\sum^{m}_{i=1}l(f(x_i),y_i)称为经验风险，C对二者进行折中</script>]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine-Learning-Desision-Tree</title>
    <url>/2021/08/15/Machine-Learning-Desision-Tree/</url>
    <content><![CDATA[<h2 id="第四章-决策树（西瓜书学习-笔记）"><a href="#第四章-决策树（西瓜书学习-笔记）" class="headerlink" title="第四章 决策树（西瓜书学习-笔记）"></a>第四章 决策树（西瓜书学习-笔记）</h2><h4 id="一、基本流程"><a href="#一、基本流程" class="headerlink" title="一、基本流程"></a>一、基本流程</h4><p>决策树学习的目的是为了产生一颗泛化能力强的决策树。一般，一颗决策树包含一个根结点、若干个内部结点和若干个叶结点；叶结点对应于决策结果，其他每个结点则对应于一个属性测试；每个结点包含的样本集合根据属性测试的结果被划分到子结点中；根结点包含样本全集。从根结点到每个叶节点的路径对应了一个判定测试序列。</p>
<p><img src="/2021/08/15/Machine-Learning-Desision-Tree/DesisionTree_0.png" alt="ML"></p>
<h4 id="二、划分选择"><a href="#二、划分选择" class="headerlink" title="二、划分选择"></a>二、划分选择</h4><p>一般而言，随着划分过程的不断进行，希望决策树的分支结点所包含的样本尽可能属于同一类，即结点的”纯度”越来越高。</p>
<h5 id="2-1-信息增益"><a href="#2-1-信息增益" class="headerlink" title="2.1 信息增益"></a>2.1 信息增益</h5><p>“信息熵”是度量样本集合纯度最常用的一种指标。假设当前样本集合D中第k类样本所占的比例为p<sub>k</sub>(k=1,2,…,|y|),则D的信息熵定义为：</p>
<script type="math/tex; mode=display">
Ent(D)=-\sum^{|y|}_{k=1}p_k\log_2p_k,Ent(D)的值越小，D的纯度越高</script><p>假定离散属性a有V个可能的取值{a<sup>1</sup>,a<sup>2</sup>,…,a<sup>V</sup>}，若使用a来对样本集D进行划分，则会产生V个分支结点，其中第v个分支结点包含了D中所有在属性a上取值为a<sup>v</sup>的样本，记为D<sup>v</sup>。划分步骤如下：</p>
<ol>
<li>计算出D<sup>v</sup>的信息熵</li>
<li>不同分支结点包含不同的样本数，给分支结点赋予权重|D<sup>v</sup>|/D</li>
<li>计算属性a对样本集D进行划分所获得的”信息增益”</li>
</ol>
<script type="math/tex; mode=display">
Gain(D,a)=Ent(D)-\sum^{V}_{v=1}\frac{|D^v|}{|D|}Ent(D^v)</script><p>一般，信息增益越大，则意味着使用属性a来进行划分所获得的“纯度提升”越大。所以上面选择属性时使用下式选择最佳属性(ID3)：</p>
<script type="math/tex; mode=display">
a_*=arg\,\max_{a\in A}Gain(D,a)</script><p><img src="/2021/08/15/Machine-Learning-Desision-Tree/Desision-Tree-2.png" alt="ML"></p>
<p><strong>如何选择最优划分属性？</strong></p>
<p>上图中共包含17个样本，因为是二分类，所以|y|=2。</p>
<ol>
<li>根结点包含D中所有的样例，计算根结点的信息熵：</li>
</ol>
<script type="math/tex; mode=display">
Ent(D)=-\sum^{2}_{k=1}p_k\log_2p_k=-(\frac{8}{17}\log_2\frac{8}{17}+\frac{9}{17}\log_2\frac{9}{17})=0.998,其中，正例占p_1=\frac{8}{17},反例占p_2=\frac{9}{17}</script><ol>
<li><p>计算当前属性集合{色泽，根蒂，敲声，纹理，脐部，触感}中每个属性的信息增益。以属性”色泽”为例。色泽有三个取值：{青绿色，乌黑，浅白}，使用这三个取值对D进行划分，得到3个子集，分别记为：D<sup>1</sup>(色泽=青绿),D<sup>2</sup>(色泽=乌黑)，D<sup>3</sup>(色泽=浅白)。</p>
<p>D<sub>1</sub>包含6个样例，正例占比p<sub>1</sub>=4/6，反例占比p<sub>2</sub>=2/6。D<sub>3</sub>包含5个样例，正例占比p<sub>1</sub>=1/5，反例占比p<sub>2</sub>=4/5。</p>
</li>
</ol>
<script type="math/tex; mode=display">
Ent(D^1)=-(\frac{3}{6}\log_2\frac{3}{6}+\frac{3}{6}\log_2\frac{3}{6})=1.000,\\
Ent(D^2)=-(\frac{4}{6}\log_2\frac{4}{6}+\frac{2}{6}\log_2\frac{2}{6})=0.918,\\
Ent(D^3)=-(\frac{1}{5}\log_2\frac{1}{5}+\frac{4}{5}\log_2\frac{4}{5})=0.772,\\</script><ol>
<li>计算”色泽”的信息增益为：</li>
</ol>
<script type="math/tex; mode=display">
Gain(D,色泽)=Ent(D)-\sum^{3}_{v=1}\frac{|D^v|}{|D|}Ent(D^v)=0.998-(\frac{6}{17}\times1.000+\frac{6}{17}\times0.918+\frac{5}{17}\times0.772)=0.109</script><ol>
<li>类似的，计算出其他属性的信息增益：</li>
</ol>
<script type="math/tex; mode=display">
Gain(D,根蒂)=0.143，Gain(D,敲声)=0.141，Gain(D,纹理)=0.381，Gain(D,脐部)=0.289，Gain(D,触感)=0.006，</script><ol>
<li>选取信息增益最大的属性，上例中为”纹理”</li>
</ol>
<p><img src="/2021/08/15/Machine-Learning-Desision-Tree/Desision-Tree-3.png" alt="ML"></p>
<ol>
<li>根据选取的最大增益的属性划分数据集，如上图纹理=清晰有9个样例。可用属性集合为{色泽，根蒂，敲声，脐部，触感}</li>
<li>基于清晰划分的新集合的D<sub>1</sub>计算各属性的信息增益：</li>
</ol>
<script type="math/tex; mode=display">
Gain(D^1,色泽)=0.043，Gain(D^1,根蒂)=0.458，Gain(D^1,敲声)=0.331，Gain(D^1,脐部)=0.458，Gain(D^1,触感)=0.458，</script><p>若有多个属性均取得了最大的信息增益，可任选其中之一作为划分属性</p>
<ol>
<li>对每个结点进行上述操作</li>
</ol>
<h5 id="2-2-增益率"><a href="#2-2-增益率" class="headerlink" title="2.2 增益率"></a>2.2 增益率</h5><p>由于信息增益准则对可取值数目较多的属性有所偏好(属性可选的值的数量，如色泽、纹理等)，为了减少这种偏好带来的不利影响，著名的C4.5决策树算法不直接使用信息增益，而是使用”增益率”来选择最优划分属性。增益率定义为：</p>
<script type="math/tex; mode=display">
Gain_ratio(D,a)=\frac{Gain(D,a)}{IV(a)},其中，IV(A)=-\sum^{V}_{v=1}\frac{|D|^v}{|D|}\log_2\frac{|D^v|}{|D|},称为属性a的固有值。</script><p>上式中属性a的可能取值数目越多，比如，纹理中清晰的样例越多，则IV(a)的值通常会越大。</p>
<p>注意：增益率准则对可取值数目较少的属性有所偏好，因此，C4.5算法并不是直接选择增益率UI大的候选划分属性，而是使用一个启发式：先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择信息增益最高的。</p>
<h4 id="2-3-基尼指数"><a href="#2-3-基尼指数" class="headerlink" title="2.3 基尼指数"></a>2.3 基尼指数</h4><p>CART决策树使用”基尼指数”(Gini index)来选择划分属性。数据集D的纯度可用基尼值来度量：</p>
<script type="math/tex; mode=display">
Gini(D)=\sum^{|y|}_{k=1}\sum_{k'\ne k}p_kp_k'=1-\sum^{|y|}_{k=1}p_k^2</script><p>直观来说，Gini(D)反映了从数据集D中随机抽取两个样本，其类别标记不一致的概率。因此，Gini(D)越小，则数据集D的纯度越高。</p>
<script type="math/tex; mode=display">
属性a的基尼指数定义为：Gini_index(D,a)=\sum^{V}_{v=1}\frac{|D^v|}{|D|}Gini(D^v)</script><p>所以，最优划分属性选取基尼指数最小的属性：</p>
<script type="math/tex; mode=display">
a_*=arg\,\max_{a\in A}Gini_index(D,a)</script><h4 id="三、剪枝处理"><a href="#三、剪枝处理" class="headerlink" title="三、剪枝处理"></a>三、剪枝处理</h4><p>剪枝(pruning)是决策树学习算法对付“过拟合”的主要手段。在决策树学习中，为了尽可能正确分类训练样本，结点划分过程将不断重复，有时造成决策树分支过多，从而可能因训练样本学得“太好”了，以致于把训练集自身的一些特点当作所有数据都具有的一般性质而导致过拟合。所以，可通过主动去掉一些分支来降低过拟合的分险。</p>
<p>决策树剪枝的基本策略有“预剪枝”(prepruning)和“后剪枝”(post-pruning)。</p>
<ul>
<li>预剪枝：在决策树生成过程中，对每个结点在划分前先进行评估。若当前结点的划分不能带来决策树泛化性能提升，则停止划分并将当前结点标记为叶结点。</li>
<li>后剪枝：先从训练集生成一颗完整的决策树，然后自底向上地对非叶结点进行考察，若将该结点对应的子树替换为叶结点能带来决策树泛化性能提升，则将该子树替换为叶结点。</li>
</ul>
<p>预剪枝优点：使决策树的很多分支没有展开，不仅减低了过拟合的风险，而且显著减少了决策树的训练时间开销和测试时间开销。</p>
<p>预剪枝确定：基于贪心本质禁止这些分支展开，给预剪枝决策树带来了欠拟合的风险。</p>
<p>后剪枝优点：欠拟合风险小，泛化性能往往优于预剪枝决策树。</p>
<p>后剪枝缺点：在生成完全决策树之后进行的，并且要自底向上进行考察，因此训练时间开销要大得多。</p>
<h4 id="四、连续和缺失值"><a href="#四、连续和缺失值" class="headerlink" title="四、连续和缺失值"></a>四、连续和缺失值</h4><h5 id="4-1-连续值处理"><a href="#4-1-连续值处理" class="headerlink" title="4,1 连续值处理"></a>4,1 连续值处理</h5><p>对于要处理的连续属性，需要使用连续属性离散化技术。最简单的策略是采用二分法对连续属性进行处理。 </p>
<p>给定样本集D和连续属性a，假定a在D上出现了n个不同的取值：</p>
<ol>
<li>将这些值从小到大排序，记为{a<sup>1</sup>, a<sup>2</sup>，a<sup>3</sup>，… ，a<sup>n</sup>}</li>
<li>基于划分点t可将D分为子集D<sup>-</sup><sub>t</sub>和D<sup>+</sup><sub>t</sub>，分别表示在属性a上取值不大于t的样本，和取值大于t的样本</li>
<li>在区间[a<sup>i</sup>，a<sup>i+1</sup>)中取任意值所产生的划分结果相同，所以对连续属性a，可以考察包含n-1个元素的候选划分点集合</li>
</ol>
<script type="math/tex; mode=display">
T_a=\{\frac{a^i+a^{i+1}}{2}|1\le i\le n-1\}</script><ol>
<li>把区域[a<sup>i</sup>，a<sup>i+1</sup>)的中心点作为候选划分点。然后可像离散属性值一样来考察这些划分点</li>
</ol>
<script type="math/tex; mode=display">
Gain(D,a)=\max_{t\in T_a}\,Gain(D,a,t)=\max_{t\in T_a}\,Ent(D)-\sum_{\lambda\in\{-,+\}}\frac{|D^{\lambda}_t|}{|D|}Ent(D^{\lambda}_t)\\
Gain(D,a,t)是样本集D基于划分点t二分后的信息增益，可选择使Gain(D,a,t)最大化的划分点</script><p>与离散值不同，当前结点划分属性为连续属性，该属性还可作为其后代结点的划分属性。</p>
<h5 id="4-2-缺失值处理"><a href="#4-2-缺失值处理" class="headerlink" title="4.2 缺失值处理"></a>4.2 缺失值处理</h5><p>任务中会遇到一些不完整的样本，即样本的某些属性值缺失。如果简单地放弃不完整样本，仅使用无缺失的样本进行学习，显然造成了数据信息的浪费。对于缺失值需要处理两个问题：</p>
<ol>
<li>如何在属性值缺失的情况下进行划分属性选择</li>
<li>给定划分属性，若样本在该属性上的值缺失，该如何对样本进行划分</li>
</ol>
<script type="math/tex; mode=display">
给定训练集D和属性a，令\tilde{D}表示D中在属性a上没有缺失值的样本子集。假定属性a有V个可取值\{a^1,a^2,...,a^V\}\\
令\tilde{D}^v表示\tilde{D}中在属性a上取值为a^v的样本子集，\tilde{D}_k表示\tilde{D}中属于第k类(k=1,2,...,|y|)的样本子集\\
则,\tilde{D}=\bigcup^{|y|}_{k=1}\tilde{D}_k,\tilde{D}=\bigcup^{|V|}_{v=1}\tilde{D}^v,假定给每一个样本x赋予一个权重w_x，并定义如下：\\
\rho=\frac{\sum_{x\in\tilde{D}}w_x}{\sum_{x\in D}w_x},\tilde{p}_k=\frac{\sum_{x\in\tilde{D}_k}w_x}{\sum_{x\in \tilde{D}}w_x}\,(1\le k\le|y|),\tilde{r}_v=\frac{\sum_{x\in\tilde{D}^v}w_x}{\sum_{x\in \tilde{D}}w_x}\,(1\le v\le|V|)\\
对属性a，\rho表示无缺失样本所占的比例，\tilde{p}_k表示无缺失样本中第k类所占的比例，\\\tilde{r}_v则表示无缺失样本中在属性a上取值为a^v的样本所占的比例，显然，\sum^{|y|}_{k=1}\tilde{p}_k=1,\sum^{V}_{v=1}\tilde{r}_v=1\\
则，信息增益可推广为：Gain(D,a)=\rho\times Gain(\tilde{D},a)=\rho\times (Ent(\tilde{D})-\sum^{V}_{k-1}\tilde{r}_vEnt(\tilde{D}^v))\\
其中，Ent(\tilde{D})=-\sum^{|y|}_{k=1}\tilde{p}_k\log_2\tilde{p}_k</script><p>对于属性a，如果划分属性已知，则将x划入对应的子结点，保持样本权值为w<sub>x</sub>，对于划分属性缺失的情况，则将x同时划入所有子结点，且样本权值在对应的子结点中调整为tilde r<sub>v</sub> &times; w<sub>x</sub>；直观地看，就是让同一个样本的概率划入到不同的子结点中去。</p>
<h4 id="五、多变量决策树"><a href="#五、多变量决策树" class="headerlink" title="五、多变量决策树"></a>五、多变量决策树</h4><p>决策树形成的分类边界有一个明显的特点：轴平行，即它的分类边界由若干个与坐标轴平行的分段组成。在学习任务的真实分类边界比较复杂时，必须使用很多划分才能获得较好的近似。</p>
<p>多变量决策树，是为了实现斜划分，对非叶结点不再是仅对某个属性，而是对属性的线性组合进行测试。</p>
<script type="math/tex; mode=display">
每个非叶结点是一个\sum^d_{i=1}w_ia_i=t的线性分类器，其中w_i和t可在该结点所含的样本集合属性集上学得</script><p>与单变量决策树不同，多变量决策树的学习过程中，不是为每个非叶结点寻找一个最优划分属性，而是试图建立一个合适的线性分类器。</p>
<p><img src="/2021/08/15/Machine-Learning-Desision-Tree/Desision-Tree-4.png" alt="ML"></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Linear-Model</title>
    <url>/2021/08/15/Linear-Model/</url>
    <content><![CDATA[<h2 id="第三章-线性模型（西瓜书学习-笔记）"><a href="#第三章-线性模型（西瓜书学习-笔记）" class="headerlink" title="第三章 线性模型（西瓜书学习-笔记）"></a>第三章 线性模型（西瓜书学习-笔记）</h2><h4 id="一、基本形式"><a href="#一、基本形式" class="headerlink" title="一、基本形式"></a>一、基本形式</h4><p>线性模型(linear model)试图学得一个通过属性的线性组合来进行预测的函数，即：</p>
<script type="math/tex; mode=display">
下面是由d个属性x=(x_1;x_2;...;x_d)，其中x_i是在第i个属性上的取值
\\f(x)=w_1x_1+w_2x_2+...+w_dx_d+b,一般写成f(x)=w^Tx+b\\
其中w=(w_1;w_2;...;w_d),w和b学得之后，模型就得以确定\\
权重w直观表达了各属性在预测中的重要性</script><p>许多功能更为强大的非线性模型(nonlinear model)可在线性模型的基础上，通过引入层级结构或高维映射得到。<strong>疑问：如何引入？</strong></p>
<h4 id="二、线性回归"><a href="#二、线性回归" class="headerlink" title="二、线性回归"></a>二、线性回归</h4><script type="math/tex; mode=display">
给定数据集D=\{(x1,y1),(x_2,y_2),...,(x_m,y_m)\},其中x_i=(x_{i1};x_{i2};...;x_{id}),y_i\in R\\
线性回归(linear regression)试图学得一个线性模型以尽可能准确地预测实值输出标记。\\
对于只有一个输入属性的简单场景，线性回归试图学得：f(x_i)=wx_i+b,使得f(x_i)\approx y_i\\
如何确定w和b呢？关键在于使预测值和真实值差别最小，使用性能度量方法\\
回归中常用均方误差：(w*,b*)=arg\,\min_{(w,b)}\sum^{m}_{i=1}(f(x_i)-y_i)^2=arg\,\min_{(w,b)}\sum^{m}_{i=1}(y_i-wx_i-b)^2</script><p><strong>基于均方误差最小化来进行模型求解的方法称为”最小二乘法”</strong>。在线性回归中，最小二乘法就是试图找到一条直线，使所有样本到直线上的欧式距离之和最小。</p>
<script type="math/tex; mode=display">
求解w和b使E_{(w,b)}=\Sigma^{m}_{i=1}(y_i-wx_i-b)^2最小化的过程，称为线性回归模型的最小二乘参数估计(parameter estimation)\\
将E_{(w,b)}分别对w和b求导，得到：\frac{\partial E(w,b)}{\partial w}=2(w\sum^{m}_{i=1}x_i^2-\sum^{m}_{i=1}(y_i-b)x_i),\frac{\partial E_{(w,b)}}{\partial b}=2(mb-\sum^{m}_{i=1}(y_i-wx_i))\\
令上面的\frac{\partial E(w,b)}{\partial w}=0，\frac{\partial E_{(w,b)}}{\partial b}=0，可以求得w和b最优解得闭式。</script><p>对于更一般的情形，即样本由d个属性描述。此时，试图学得</p>
<script type="math/tex; mode=display">
f(x_i)=w^Tx_i+b,使得f(x_i)\approx y_i,这称为多元线性回归</script><p>类似的，也可以利用最小二乘来对w和b进行估计。为了简便，把w和b吸收入向量形式：</p>
<script type="math/tex; mode=display">
\hat w=(w;b)\\
数据集D表示一个m\times(d+1)维大小的矩阵X\\
X=\begin{pmatrix}
x_{11}&x_{12}&\cdots&x_{1d}&1\\
x_{21}&x_{22}&\cdots&x_{2d}&1\\
\vdots&\vdots&\vdots&\ddots&\vdots
\\x_{m1}&x_{m2}&\cdots&x_{md}&1\\
\end{pmatrix}
=
\begin{pmatrix}x_1^T&1\\
x_2^T&1\\
\vdots&\vdots\\
x_m^T&1
\end{pmatrix}\\
把标记写成向量形式y=(y_1;y_2;...;y_m)\\
类似有 \hat w^*=arg\,\min_{\hat w}(y-X\hat w)^T(y-X\hat w)\\
令E_{\hat w}=(y-X\hat w)^T(y-X\hat w),对\hat w求导得：\\
\frac{\partial E_{\hat w}}{\partial\hat w}=2X^T(X\hat w-y)，令该式等于0,可得\hat w最优闭式解\\
由于涉及到矩阵求逆，当X^TX是满秩矩阵或正定矩阵是，可得\hat w^*=(X^TX)^{-1}X^Ty\\
对于不是满秩矩阵，那么会得到多个\hat w,选择哪个作为输出，由学习算法的归纳偏好决定，通常引入正则化项</script><p>更一般的，考虑单调可微函数g(.)，令</p>
<script type="math/tex; mode=display">
y=g^{-1}(w^Tx+b),得到的模型称为广义线性模型，g(\cdot)称为联系函数</script><h4 id="三、对数几率回归"><a href="#三、对数几率回归" class="headerlink" title="三、对数几率回归"></a>三、对数几率回归</h4><p><strong>线性模型如何进行分类任务？</strong>找一个单调可微函数将分类任务的真实标记y与线性回归模型的预测值联系起来。</p>
<script type="math/tex; mode=display">
对于二分类任务，输出标记y\in \{0,1\},需将线性回归模型产生的实值预测值z=w^Tx+b，转换为0/1。\\
最理想的是单位阶跃函数\quad 
y=\begin{cases}
0, & \text{z < 0}  \\
0.5, & \text{z = 0} \\
1, & \text{z > 0}
\end{cases}</script><p><img src="/2021/08/15/Linear-Model/ML-1.png" alt="ML"></p>
<p>因为单位阶跃函数不连续，所以希望找到一个在一定程度上近似单位阶跃函数的”替代函数”，并希望它单调可微。而对数几率函数(logistic function)就是常用的一个替代函数：</p>
<script type="math/tex; mode=display">
y=\frac{1}{1+e^{-z}}</script><p><strong>为什么看上去已经做了非线性变换，仍然称为线性模型呢？</strong></p>
<script type="math/tex; mode=display">
z=w^Tx+b,带入上式，y=\frac{1}{1+e^{-(w^Tx+b)}}\\
\frac{y}{1-y}=e^{w^Tx+b},则\ln\frac{y}{1-y}=w^Tx+b\\
上式只是对预测值做了相应的对数变换，而模型仍然是线性模型\\
若者y视为样本x的可能性，则1-y视为反例的可能性，两者比值称为几率，取对数得对数几率(log odds,简称logit)\\
y=\frac{1}{1+e^{-(w^Tx+b)}}实际在用线性回归模型的预测结果去逼近真实标记的对数几率。\\
对应模型为对数几率回归，实际为分类任务</script><p>如何求取上式中的<strong>w</strong>和<strong>b</strong>?</p>
<script type="math/tex; mode=display">
将y视为类的后验概率估计p(y=1|x),则\ln\frac{p(y=1|x)}{p(y=0|x)}=w^Tx+b\\
其中，p(y=1|x)=\frac{e^{w^Tx+b}}{1+e^{w^Tx+b}},p(y=0|x)=\frac{1}{1+e^{w^Tx+b}}\\
后验概率：事情已经发生了，导致事件发生的原因有很多，判断结果的发生是由哪个原因引起的概率\\
p(y=1|x)=\frac{p(x(y=1))}{p(x)}=\frac{p(y=1)p(x|y=1)}{p(x)}</script><p>对于上式，可以通过极大似然法来估计未知参数<strong>w</strong>和<strong>b</strong>。</p>
<h4 id="四、线性判别分析"><a href="#四、线性判别分析" class="headerlink" title="四、线性判别分析"></a>四、线性判别分析</h4><p>线性判别分析(Linear Discriminant Analysis,简称LDA),是一种经典的线性学习方法。</p>
<p>LDA的思想非常朴素：给定训练样例集，设法将样例投影到一条直线上，使得同类样例的投影点尽可能接近、异类样例的投影点尽可能远离。对新样本进行分类时，将其投影到同样的这条直线上，再根据投影点的位置来确定样本的类别。</p>
<p><img src="/2021/08/15/Linear-Model/ML-2.png" alt="ML"></p>
<script type="math/tex; mode=display">
给定数据集D=\{(x_i,y_i)\}^m_{i=1},y_i\in \{0,1\}。\\令X_i、\mu_i、\Sigma_i分别表示第i\in \{0,1\}类实例的集合、均值向量、协方差矩阵。\\
若将所有样本投影到直线上，则两类的协方差分别为w^T\Sigma_0w和w^T\Sigma_1w</script><p>想要让同类样例的投影点尽可能接近，可以让同类样例投影点的协方差尽可能小，即w<sup>T</sup>&Sigma;<sub>0</sub>w+w<sup>T</sup>&Sigma;<sub>1</sub>w尽可能小；而欲使异类样例的投影点尽可能远离，可以让类中心之间的距离尽可能大，即||w<sup>T</sup>&Sigma;<sub>0</sub>w-w<sup>T</sup>&Sigma;<sub>1</sub>w||尽可能大。同时考虑两者，则可得到最大化的目标：</p>
<script type="math/tex; mode=display">
\begin{align}J=&\frac{\|w^T\mu_0-w^T\mu_1\|^2_2}{w^T\Sigma_0w+w^T\Sigma_1w}\\
=&\frac{\|(w^T\mu_0-w^T\mu_1)^T\|^2_2}{w^T(\Sigma_0+\Sigma_1)w}\\
=&\frac{\|(\mu_0-\mu_1)^Tw\|^2_2}{w^T(\Sigma_0+\Sigma_1)w}\\
=&\frac{[(\mu_0-\mu_1)^Tw]^T(\mu_0-\mu_1)^Tw}{w^T(\Sigma_0+\Sigma_1)w} \\
=&\frac{w^T(\mu_0-\mu_1)(\mu_0-\mu_1)^Tw}{w^T(\Sigma_0+\Sigma_1)w}
\end{align}</script><script type="math/tex; mode=display">
定义类内散度矩阵:S_w=\Sigma_0+\Sigma_1=\sum_{x\in X_0}(x-\mu_0)(x-\mu_0)^T+\sum_{x\in X_1}(x-\mu_1)(x-\mu_1)^T\\
类间散度矩阵:S_b=(\mu_0-\mu_1)(\mu_0-\mu_1)^T\\
则上式J可以重写为：J=\frac{w^TS_bw}{w^TS_ww}</script><h4 id="五、多分类学习"><a href="#五、多分类学习" class="headerlink" title="五、多分类学习"></a>五、多分类学习</h4><p>这里利用二分类学习器来解决多分类问题。考虑N个类别C<sub>1</sub>，C<sub>2</sub>，…，C<sub>N</sub>，多分类学习的基本思路是”拆解法”，即将多分类任务拆为若干个二分类任务求解。具体做法如下：</p>
<ul>
<li>先对问题进行拆分，然后为拆出的每个二分类任务训练一个分类器；<strong>如何拆分？</strong></li>
<li>在测试时，对这些分类器的结果进行集成以获得最终的多分类结果。<strong>如何集成？</strong></li>
</ul>
<p>给定数据集D={(x<sub>1</sub>,y<sub>1</sub>)，(x<sub>2</sub>,y<sub>2</sub>),…, (x<sub>m</sub>,y<sub>m</sub>)},y<sub>i</sub>&in;{C<sub>1</sub>,C<sub>2</sub>,…,C<sub>N</sub>}</p>
<p>5.1 拆分：一对一(One vs. One)</p>
<p>​    将N个类别两两配对，从而产生N(N-1)/2个二分类任务。如为区分C<sub>i</sub>和C<sub>j</sub>&gt;训练一个分类器，该分类器把D中的C<sub>i</sub>类样例作为正例C<sub>j</sub>样例作为反例。</p>
<p>​    在测试阶段，新样本将同时提交给所有分类器，于是能够获得N(N-1)/2个分类结果，最终结果可通过投票产生。即将预测得最多的类别作为最终的分类结果。</p>
<p>5.2 拆分：一对其余(One vs. Rest)</p>
<p>​    每次将一个类的样例作为正例，所有其他类的样例作为反例来训练N个分类器。</p>
<p>​    测试时，如果只有一个分类器预测为正类，则对应的类标记作为最终分类结果。若有多个分类器预测为正类，则通常考虑各分类器的预测置性度，选择置信度最大的类别标记作为分类结果。</p>
<p>5.3 拆分：多对多(Many vs. Many)</p>
<p>每次将若干个类作为正类，若干个其他类作为反类。其中，对于正反类的构造必须有特殊的设计，不能随意选取。一种最常用的是MvM技术：”纠错输出码”(ECOC)。主要分为两步：编码和解码。</p>
<h4 id="六、类别不平衡问题"><a href="#六、类别不平衡问题" class="headerlink" title="六、类别不平衡问题"></a>六、类别不平衡问题</h4><p>类别不平衡问题(class-imbalance)是指分类任务中不同类别的训练样例数目差别很大的情况。</p>
<p>解决类别不平衡现有的三类做法：</p>
<ol>
<li>直接对训练集里的反类样例进行”欠采样”(undersampling),即去除一些反例使得正、反例数目接近，然后再进行学习。不能随机丢弃反例，可能丢失一些重要信息。代表算法EasyEnsemble，采用集成学习机制，将反例分成若干个集合供不同学习器使用。</li>
<li>对训练集里的正类样例进行”过采样”(oversampling),即增加一些正例使得正、反例数目接近，然后再进行学习。过采样不能简单重复初始的正样本，这会招致严重过拟合。过采样的代表算法是SMOTE算法，通过对正例插值产生额外的正样本。</li>
<li>直接基于原始训练集进行学习，但在用训练好的分类器进行预测时，需要进行“阈值移动”</li>
</ol>
<script type="math/tex; mode=display">
一般的分类器以0.5作为阈值，来判别样本是正例还是反例\\
因此，y\gt\frac{1}{2}\Rightarrow 2y\gt 1\Rightarrow y\gt 1-y\Rightarrow \frac{y}{1-y}\gt 1\\
当训练集中，正反例数目不同时，令m^+表示正例数目，m^-表示反例数据，观测几率是\frac{m^+}{m^-}\\
如果假设训练集是真实样本总体的无偏采样，那么观测几率就代表了真实几率\\
当分类器的预测几率高于观测几率就应判断为正例，即\frac{y}{1-y}\gt\frac{m^+}{m^-},则预测为正例\\
相应的对预测值再做缩放，可以得到类似于y'\gt ?\Rightarrow\frac{y'}{1-y'}=\frac{y}{1-y}\times\frac{m^-}{m^+}\gt1</script>]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Model-Evaluation-And-Selection</title>
    <url>/2021/08/15/Model-Evaluation-And-Selection/</url>
    <content><![CDATA[<h2 id="第二章-模型评估与选择（西瓜书学习-笔记）"><a href="#第二章-模型评估与选择（西瓜书学习-笔记）" class="headerlink" title="第二章 模型评估与选择（西瓜书学习-笔记）"></a>第二章 模型评估与选择（西瓜书学习-笔记）</h2><p><strong>为什么需要模型评估与选择？</strong></p>
<p>1、学习器的实际预测输出与样本的真实输出之间的差异称为”误差”；</p>
<p>2、学习器在训练数据集上的误差称为”训练误差”，或”经验误差”；</p>
<p>3、在新样本上的误差称为”泛化误差”，学习的最终目的是得到泛化误差小的学习器，而非训练误差小的学习器。因为训练误差小可能已经过拟合了，导致不能用。</p>
<p>4、但实际中，并不知道新样本，所以只能从训练样本中尽可能学出适用于所有潜在样本的“普遍规律“，努力使经验误差最小化的同时，寻找泛化误差最小的模型。</p>
<p><strong>那么过拟合能够完全避免吗？</strong></p>
<p>在书中说无法彻底避免，只能缓解。讲到机器学习是NP难问题，而学习算法必须在多项式时间内运行完。因为P&ne;NP,所以过拟合不可避免。</p>
<h4 id="一、评估方法"><a href="#一、评估方法" class="headerlink" title="一、评估方法"></a>一、评估方法</h4><p><strong>用什么方法评估学习器的泛化误差？</strong></p>
<p>需要一个”测试集”来测试学习器对新样本的判别能力，以测试误差作为泛化误差的近似。假设测试样本与训练样本独立同分布。但要求尽量测试集与训练集互斥。</p>
<p><strong>对于包含m个样例的数据集D，如何分数据？</strong></p>
<p>1.1 留出法(hold-out): 直接将数据集D划分为两个互斥的集合，其中一个作为训练集S，另一个作为测试集T。D=S&cup;T, S&cap;T=&varnothing;。在S上训练处模型后，用T来评估其测试误差。</p>
<p>注意：一、训练/测试集的划分要尽可能保持数据分布的一致性，避免因数据划分过程引入额外的偏差而对最终结果产生影响。比如，D包含500个正样本，500个负样本。S分到了70%的样本，其中要保持正负样本的比例，即正样本350例，负样本350例。T分到了30%的样本，其中正样本150例，负样本150例。</p>
<p>二、样本的数量给定后，对于数据集D的分割也有不同的方式，比如：把D中样本排序，是取前面的350个，还是中间的350个，还是最后的350个样例作为训练集的正/负样本。一般需要采用若干次随机划分，重复进行试验评估后取平均值作为留出法的评估结果。</p>
<p>为了评估整体数据集D的性能，常见做法是将大约2/3~4/5的样本用于训练，剩余样本用于测试。</p>
<p>1.2 交叉验证法：先将数据集D划分为k个大小相似的互斥子集，即D=D<sub>1</sub>&cup;D<sub>2</sub>&cup;…&cup;D<sub>k</sub>，D<sub>i</sub>&cap;D<sub>j</sub>=&varnothing;（i&ne;j）,每个自己D<sub>i</sub>都尽可能保持数据分布的一致性。然后，每次用k-1个子集的并集作为训练集，余下的那个子集作为测试集；这样就可获得k组训练/测试集。从而可进行k次训练和测试，最终返回的是k个测试结果的均值。又称”k折交叉验证”，其中k的取值很大程度上，决定了评估结果的稳定性和保真性(fidelity)。k最常用的取值是10.</p>
<p><img src="/2021/08/15/Model-Evaluation-And-Selection/ImageProcessing100Wen-master/hexo/source/_post/ML-0.png" alt="Machine-Learn"></p>
<p>交叉验证法同样存在将数据集D划分为k个子集同样存在多种划分方式。</p>
<p>1.3 自助法</p>
<p>以自助采样为基础。给定包含m个样本的数据集D，对它进行采样产生数据集D’：每次随机从D中挑选一个样本，将其拷贝放入D’，然后又放回的重复执行m次，得到包含m个样本的数据集D‘。</p>
<h4 id="二、性能度量"><a href="#二、性能度量" class="headerlink" title="二、性能度量"></a>二、性能度量</h4><p>为了评估模型的泛化性能，不仅需要有效可行的实验估计方法，如留出法、K折交叉验证法等。还需要有衡量模型泛化能力的评价标准，即性能度量。在做模型评估的时候，对于什么样的模型是好的，不仅取决于算法和数据，还决定于任务需求。</p>
<h5 id="2-1-均方误差"><a href="#2-1-均方误差" class="headerlink" title="2.1 均方误差"></a>2.1 均方误差</h5><p>1.1 针对离散的数据</p>
<script type="math/tex; mode=display">
E(f;D) = \frac{1}{m}(f(x_i)-y_i)^2</script><p>1.2 针对连续的数据</p>
<script type="math/tex; mode=display">
E(f;D) = \int_{x\sim D} (f(x)-y)^2p(x){\rm d}x</script><h5 id="2-2-查全率、查准率与F1"><a href="#2-2-查全率、查准率与F1" class="headerlink" title="2.2 查全率、查准率与F1"></a>2.2 查全率、查准率与F1</h5><p>对于二分类问题，可将样例根据真实类别与学习器预测类别的组合划分为真正例(TP)，假正例(FP)，真反例(TN)和假反例(FN)，用混淆矩阵表示如下：</p>
<p><img src="/2021/08/15/Model-Evaluation-And-Selection/ImageProcessing100Wen-master/hexo/source/_post/ConfusionMatrix.png" alt="ML"></p>
<script type="math/tex; mode=display">
查准率P： P=\frac{TP}{TP+FP}\\
查全率R： R=\frac{TP}{TP+FN}</script><h5 id="2-3-P-R曲线"><a href="#2-3-P-R曲线" class="headerlink" title="2.3 P-R曲线"></a>2.3 P-R曲线</h5><p>如何画PR曲线，找一组样本，根据学习器的预测结果对样例进行排序，排在前面的是学习器认为”最可能”是正例的样本，排在最后的则是学习器认为”最不可能”是正例的样本。按此顺序逐个把样本作为正例进行预测，每次可以计算出当前的查全率、查准率。以查准率为纵轴、查全率为横轴作图。<br>举例：比如有20个样本，10个正例，10个反例。将20个样例用学习器预测一遍，得到20个预测结果，对20个样例根据预测结果排序。排好序后从预测值最大的开始，第一次取第一个为预测的正样本，其余为预测的负样本，计算查全率和查准率。第二次取前两个为预测的正样本，其余为预测的负样本，计算查全率和查准率。依次进行，直到取全部20个样本都作为预测的正样本，负样本为零。得到20组查全率和查准率的预测值，就可以作图了。<br><img src="/2021/08/15/Model-Evaluation-And-Selection/1.png" alt="ML"></p>
<p><strong>如何比较不同学习器的优劣？</strong></p>
<p>看P-R曲线，如上图如果A完全将C包住则A的性能优于学习器C的性能。如果有交叉，则一般可用P-R曲线下面的面积作为评判标准。但是面积不好求，所以有人提出要综合考虑了查全率和查准率的性能度量。这就出现了F1度量：</p>
<script type="math/tex; mode=display">
F1=\frac{2\times P\times R}{P+R}=\frac{2\times TP}{样例总是+TP-TN}</script><p>在一些应用中，对查准率和查全率的重视程度有所不同，此时，可以使用F1、F<sub>&beta;</sub>作为查准率/查全率不同偏好的度量值。</p>
<script type="math/tex; mode=display">
F_\beta=\frac{(1+\beta^2)\times P\times R}{\beta^2\times P+R}   \quad \beta =1是即为F1,\beta>1时对查全率有更大的影响，\beta<1时，对查准率有更大的影响。</script><p>在实际应用中，往往需要进行多次训练/测试，每次都会得到一个混淆矩阵；或对于多分类任务，每两两类别的组合都对应一个混淆矩阵。<strong>那么如何在n个二分类混淆矩阵上综合考察查准率和查全率呢？</strong></p>
<ol>
<li>直接现在各混淆矩阵上分别计算处查准率和查全率，记为(P<sub>1</sub>,R<sub>1</sub>),(P<sub>2</sub>,R<sub>2</sub>),…,(P<sub>n</sub>,R<sub>n</sub>)。在计算平均值，得到宏查准率(macro-P)，宏查全率(macro-R)和宏F1(macro-F1)</li>
<li>可先将各混淆矩阵的对应元素进行平均，得到TP,FP,TN,FN的平均值TP’,FP’,TN’,FN’,在基于这些平均值计算出微查准率(micro-P)，微查全率(micro-R)和微F1(micro-F1)</li>
</ol>
<h5 id="2-4、ROC曲线"><a href="#2-4、ROC曲线" class="headerlink" title="2.4、ROC曲线"></a>2.4、ROC曲线</h5><p>ROC全称：（Receiver Operating Characteristic(受试者工作特征)）</p>
<p>学习器为测试样本产生一个实值或概率预测，然后将预测值于一个分类阈值进行比较。若大于阈值则分为正类，否则为反类。实际上，根据这个实值或概率预测结果，可以将测试样本进行排序，”最可能”是正例的排在最前面，”最不可能”是正例排在最后面。这样分类相当于在这个排序中以某个截断点将样本分为两部分，前一部分为正例，后一部分为反例。<br>在不同的应用任务中，可根据任务需求来采用不同的截断点；如重视”查准率”，则可选择排序中靠前的位置进行截断；若重视”查全率”，则可选择靠后的位置进行截断。而ROC曲线就是根据不同截断画出的判断泛化性能的有利工具。<br>ROC曲线和PR曲线的计算过程是一样的，但使用的指标不一样，ROC曲线<strong>纵轴</strong>使用”真正例率(TPR)”,<strong>横轴</strong>使用”假正例率(FPR)”</p>
<script type="math/tex; mode=display">
TPR=\frac{TP}{TP+FN}, FPR=\frac{FP}{TN+FP}</script><p><strong>如何比较多个学习器的优劣：</strong>1、查看ROC曲线时候能完全包住另一个，2、看ROC曲线下面的面积AUC(Area Under ROC Curve)</p>
<h5 id="2-5、代价敏感错误率与代价曲线"><a href="#2-5、代价敏感错误率与代价曲线" class="headerlink" title="2.5、代价敏感错误率与代价曲线"></a>2.5、代价敏感错误率与代价曲线</h5><p>由于不同类型的错误所造成的后果不同，所以机器学习器如果出现了错误的预测，那么也应该会造成不同的代价。为了权衡不同类型错误所造成的不同损失，可以使用”非均等代价”。</p>
<script type="math/tex; mode=display">
代价敏感错误率：E(f;D;cost)=\frac{1}{m}(\sum_{x_i\in D^+}I(f(x_i)\ne y_i)\times cost_{01}+\sum_{x_i\in D^-}I(f(x_i)\ne y_i\times cost_{10}))</script><p>在非均等代价下，ROC曲线不能直接反映出学习器的期望总体代价，而”代价曲线图”可以达到这个目的。(P2.3.4节)</p>
<h4 id="三、比较检验"><a href="#三、比较检验" class="headerlink" title="三、比较检验"></a>三、比较检验</h4><p>如何正确的比较性能度量得到的值？是比大小吗？<br>由于机器学习中性能比较比实际复杂的多，由于多种因素的作用，所以需要使用<strong>统计假设检验</strong>。</p>
<p>3.1 假设检验</p>
<p>3.2 交叉验证t检验</p>
<h4 id="四、偏差和方差"><a href="#四、偏差和方差" class="headerlink" title="四、偏差和方差"></a>四、偏差和方差</h4><p>“偏差-方差分解”是解释学习算法泛化性能的一种重要工具。</p>
<p>假设测试样本为x，令yD为x在数据集中的标记，y为x的真实标记，f(x;D)为训练集D上学得模型f在x上的预测输出。以回归任务为例，学习算法的期望预测为：</p>
<script type="math/tex; mode=display">
\overline f(x)=E_D[f(x;D)]\\使用相同样本的不同训练集产生的方差为：
var(x)=E_D[(f(x;D)-\overline f(x))^2]\\
噪声为：\epsilon^2=E_D[(y_D-y)^2]\\
期望输出与真实标记的差别称为偏差，即：bias^2(x)=(\overline f(x)-y)^2</script><p>假定噪声期望为零，即E<sub>D</sub>[y<sub>D</sub>-y]=0。通过简单的多项式展开合并，可对算法的期望泛化误差进行分解：</p>
<script type="math/tex; mode=display">
\begin{align}
E(f;D)=&E_D[(f(x;D)-y_D)^2]\\
=&E_D[(f(x;D)-\overline f(x)+\overline f(x)-y_D)^2]\quad 减一个，加一个\overline f(x)\\
=&E_D[(f(x;D)-\overline f(x))^2+(\overline f(x)-y_D)^2+2(f(x;D)-\overline f(x))(\overline f(x)-y_D)]\because E[X+Y]=E[X]+E[Y]\\
=&E_D[(f(x;D)-\overline f(x))^2]+E_D[(\overline f(x)-y_D)^2]+E_D[2(f(x;D)-\overline f(x))(\overline f(x)-y_D)]\\
\because &E_D[2(f(x;D)-\overline f(x))(\overline f(x)-y_D)]=E_D[2(f(x;D)-\overline f(x))\cdot\overline f(x)]-E_D[2(f(x;D)-\overline f(x))\cdot y_D]\\
展开第一项&E_D[2(f(x;D)-\overline f(x))\cdot\overline f(x)]=E_D[2f(x;D)\cdot\overline f(x)-2\overline f(x)\cdot \overline f(x)] \\
\because& \overline f(x)是常数，E[AX+B]=AE[X]+B\\
\therefore &E_D[2(f(x;D)-\overline f(x))\cdot\overline f(x)]=2\overline f(x)\cdot E_D[f(x;D)]-2\overline f(x)\cdot \overline f(x)\\
\because& E_D[f(x;D)]=\overline f(x),\therefore E_D[2(f(x;D)-\overline f(x))\cdot\overline f(x)]=0\\
展开第二项&E_D[2(f(x;D)-\overline f(x))\cdot y_D]=2E_D[f(x;D)\cdot y_D]-2\overline f(x)\cdot E_D[y_D]\\
由于噪声和&f无关，所以f(x;D)和y_D是两个相互独立的随机变量，根据期望性质E[XY]=E[X]E[Y](X,Y独立)\\
E_D[2(f&(x;D)-\overline f(x))\cdot y_D]=2E_D[f(x;D)\cdot y_D]-2\overline f(x)\cdot E_D[y_D]=2E_D[f(x;D)]\cdot E_D[y_D]-2\overline f(x)E_D[y_D]\\
\because& E_D[f(x;D)]=\overline f(x),\therefore E_D[2(f(x;D)-\overline f(x))\cdot y_D]=0\\
\end{align}</script><script type="math/tex; mode=display">
\begin{align}
\therefore E_D[(f(x;D)-y_D)^2]=&E_D[(f(x;D)-\overline f(x))^2]+E_D[(\overline f(x)-y_D)^2]\\
=&E_D[(f(x;D)-\overline f(x))^2]+E_D[(\overline f(x)-y+y+y_D)^2]\\
=&E_D[(f(x;D)-\overline f(x))^2]+E_D[(\overline f(x)-y)^2]+E_D[(y-y_D)^2]+2E_D[(\overline f(x)-y)(y-y_D)]\\
\because& \overline f(x)和y都为常量，\therefore E_D[(\overline f(x)-y)^2]=(\overline f(x)-y)^2\\
同理&2E_D[(\overline f(x)-y)(y-y_D)]=2(\overline f(x)-y)\cdot E_D[(y-y_D)]\\
又假&设噪声期望为0,E_D[(y-y_D)]=0,\therefore 2E_D[(\overline f(x)-y)(y-y_D)]=0\\
因此&，E_D[(f(x;D)-y_D)^2]=E_D[(f(x;D)-\overline f(x))^2]+E_D[(\overline f(x)-y)^2]+E_D[(y-y_D)^2]\\
于是&，E[f;D]=bias^2(x)+var(x)+\epsilon^2
\end{align}</script><p>由上式可得：泛化误差可分解为偏差、方差与噪声之和。</p>
<p>偏差：度量了学习算法的期望预测与真实结果的偏离程度，即刻画了学习算法本身的拟合能力。</p>
<p>方差：度量了同样大小的训练集的变动所导致的学习性能的变化，即刻画了数据扰动所造成的影响。</p>
<p>噪声：表达了在当前任务上任何学习算法所能达到的期望泛化误差的下界，即刻画了学习问题本身的难度。</p>
<p>由于泛化误差可分解为偏差、方差与噪声之和，所以泛化性能由学习算法的能力、数据的充分性以及学习任务本身的难度所共同决定。</p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>SPPNet</title>
    <url>/2021/07/25/SPPNet/</url>
    <content><![CDATA[<h2 id="SPPNet学习笔记"><a href="#SPPNet学习笔记" class="headerlink" title="SPPNet学习笔记"></a>SPPNet学习笔记</h2><p><strong>Spatial Pyramid Pooling in Deep ConvolutionalNetworks for Visual Recognition</strong><a href="https://arxiv.org/pdf/1406.4729.pdf" target="_blank" rel="noopener">论文链接</a></p>
<h4 id="一、为了解决什么问题"><a href="#一、为了解决什么问题" class="headerlink" title="一、为了解决什么问题"></a>一、为了解决什么问题</h4><p>在CNNs的训练和测试中<strong>存在一个技术问题</strong>：流行的CNNs需要<strong>固定输入图像的尺寸</strong>（例如224×224），这限制了输入图像的纵横比和尺度。当应用于任意尺寸的图像时， 当前方法主要是通过<strong>裁剪</strong>或通过<strong>变形</strong>将输入图像拟合到固定大小。<strong>但是</strong>裁剪区域可能<strong>不包含整个对象</strong>，而扭曲的内容可能会导致不必要的<strong>几何失真</strong>。由于内容丢失或失真，识别<strong>精度可能会受到影响</strong>。不可能采用多尺度或者是大量的数据增强去训练模型。</p>
<p><strong>分析为什么需要固定尺寸的输入？</strong></p>
<p> 一个CNN主要由两部分组成：卷积层和后面的全连接层。 卷积层以滑动窗口方式运行，并输出表示激活空间排列的特征图。事实上，卷积层不需要固定的图像大小，可以生成任意大小的特征图。 另一方面，全连接层需要根据其定义具有固定大小/长度的输入。 因此，固定大小的约束仅来自存在于网络更深阶段的全连接层。 </p>
<p><strong>如何解决全连接层需要固定输入的问题？</strong></p>
<p>在最后的卷积层和全连接层之间加入SPP层(<code>spatial pyramid pooling layer</code>)。具体做法在下图中是，在conv5层得到的特征图是256个feature maps，每层的特征图都做一次spatial pyramid pooling。先把每个特征图分割成多个不同尺寸的网格，比如网格分别为4x4、2x2、1x1,然后每个网格做max  pooling，这样256层特征图就形成了16x256，4x256，1x256维特征，他们连起来就形成了一个固定长度的特征向量，将这个向量输入到后面的全连接层。</p>
<p><img src="/2021/07/25/SPPNet/sppnet.png" alt="SPPNet"></p>
<p><img src="/2021/07/25/SPPNet/sppnet-1.png" alt="SPPNet"></p>
<p><strong>获得的好处：</strong></p>
<p>1) SPP 能够生成固定长度的输出，而不管输入大小，而滑动窗口池化用于以前的深度网络 [3] 不能； </p>
<p>2）SPP使用多级空间bins，而滑动窗口池化只使用单一窗口大小。多级池化已被证明对对象变形具有鲁棒性(SPM中证明)； </p>
<p>3) 由于输入尺度的灵活性，SPP 可以池化以可变尺度提取的特征。通过实验，我们表明所有这些因素都提高了深度网络的识别精度。 </p>
<h4 id="二、多尺度训练方法"><a href="#二、多尺度训练方法" class="headerlink" title="二、多尺度训练方法"></a>二、多尺度训练方法</h4><p>当<strong>输入图像</strong>处于<strong>不同尺度</strong>时，<strong>网络（具有相同过滤器尺寸）将提取不同尺度的特征</strong>。 尺度在传统方法中起着重要作用，例如，SIFT 向量通常在多个尺度上提取 [29]、[27]（由补丁和高斯滤波器的大小决定）。 我们将证明尺度对于深度网络的准确性也很重要。 </p>
<p>从理论上讲，无论输入图像大小如何，都可以使用标准的反向传播来训练上述网络结构。 但在实践中，GPU 实现（例如 cuda-convnet和 Caffe）最好在固定输入图像上运行。 接下来我们描述我们的训练解决方案，它利用这些 GPU 实现，同时仍然保留空间金字塔池化行为。 </p>
<p><strong>首先考虑固定尺度的训练</strong></p>
<p>和之前的工作一样，我们首先考虑一个网络，它采用从图像中裁剪出来的固定尺寸输入（224×224）。裁剪是为了数据增强。对于给定尺寸的图像，我们可以预先计算空间金字塔池化所需的 bin 大小。考虑 conv5 之后的特征图，其大小为 a×a（例如，13×13）。 假如金字塔中的一层有n×n个bins，我们将此金字塔层的池化过程实现为滑动窗口池化，滑动窗的大小为win=&lceil;a/n&rceil;，步长stride=&lfloor;a/n&rfloor;，对应金字塔中的L个层级，用同样的方式实现。最后将L个输出concatenate到一起输入全连接层。</p>
<p><strong>多尺度的训练</strong></p>
<p>为了解决<strong>训练中不同图像尺寸</strong>的问题，我们考虑了一组<strong>预定义的尺寸</strong>。我们考虑两种尺寸：180×180 和 224×224。<strong>我们没有裁剪较小的 180×180 区域，而是将上述 224×224 区域调整为180×180</strong>(这句话的意思是输入的图像其实都是224x224，但是为了考虑多尺度训练，将部分图像的尺寸由224x224缩放到180x180)。因此，两个尺度的区域仅在分辨率上不同，而在<strong>内容/布局</strong>(等比例缩放)上没有区别。为了让网络接受180×180 的输入，我们实现了另一个固定大小的输入为180×180的网络。在这种情况下，conv5之后的特征图，其大小为 a×a=10×10(<strong>注意</strong>，这里用的是<strong>同一个网络结构</strong>，存在一种情况：如果网络较深或图像尺寸比例太大，不同尺度的图像输入后，半中间可能卷积的尺寸就为0了)。然后我们还是用滑动窗的大小为win=&lceil;a/n&rceil;，步长stride=&lfloor;a/n&rfloor;来实现每个金字塔池化级别。这个 180 网络的空间金字塔池化层的输出具有与 224 网络相同的固定长度(<strong>为什么呢？</strong>因为这里不管最后一层卷积输出的特征图是13x13还是10x10都需要根据n的值将feature map分成固定大小的块做pooling，比如4x4，2x2，1x1这些值是固定的，feature map的数量也是固定的<strong>(卷积核数固定)</strong>，如：256)。因此，这个180x180的网络在每一层具有与224网络完全相同的参数。换句话说，在训练期间，我们通过两个<strong>共享参数的固定大小网络</strong>实现了<strong>不同输入大小</strong>的 SPP-net。 </p>
<p>为了减少从一个网络（例如，224）切换到另一个（例如，180）的开销，我们在一个网络上训练每个完整时期(每一个epoch)，然后在下一个完整时期切换到另一个网络（<strong>保留所有权重</strong>）。 这是迭代的。 在实验中，我们发现这种多尺寸训练的收敛率与上述单尺寸训练相似。 </p>
<p><strong>请注意，上述单一/多尺寸解决方案仅用于训练。 在测试阶段，可以直接将 SPP-net训练出的模型应用于任何尺寸的图像。</strong> </p>
<h4 id="三、SPPNet用于目标检测"><a href="#三、SPPNet用于目标检测" class="headerlink" title="三、SPPNet用于目标检测"></a>三、SPPNet用于目标检测</h4><p>我们的 SPP-net 也可用于目标检测。我们只从整个图像中提取一次特征图（可能在多个尺度上）。 然后我们在<strong>特征图的每个候选窗口上</strong>应用<strong>空间金字塔池化</strong>来池化<strong>这个窗口</strong>的<strong>固定长度</strong>表示。 因为耗时的卷积只应用一次，我们的方法可以快几个数量级。 </p>
<p>我们的方法从特征图的区域中提取窗口特征，而 R-CNN 直接从图像区域中提取。 在以前的工作中，可变形零件模型 (DPM)从 HOG特征图中的窗口中提取特征，而选择性搜索 (SS) 方法 从编码的 SIFT 特征图中的窗口中提取特征。 Overfeat检测方法也从深度卷积特征图的窗口中提取，但需要预先定义窗口大小。 相反，我们的方法可以从深度卷积特征图中的任意窗口中提取特征。对卷积层可视化发现：输入图片的某个位置的特征反应在特征图上也是在相同位置。基于这一事实，对某个ROI区域的特征提取只需要在特征图上的相应位置提取就可以了。</p>
<p><img src="/2021/07/25/SPPNet/sppnet2.png" alt="SPPNet"></p>
<p>我们使用<strong>选择性搜索(select search)</strong>的“快速”模式为每个图像生成大约 2,000 个候选窗口。然后我们调整图像的大小，使得 min(w,h) = s，并从<strong>整个图像中提取特征图</strong>。我们暂时使用ZF-5的SPP-net模型（单尺寸训练）。 在每个<strong>候选窗口</strong>中，我们使用 4 级空间金字塔（1×1、2×2、3×3、6×6、总共 50 个 bin）来<strong>汇集</strong>特征。 这将为每个窗口生成一个 12,800-d (256×50) 的表示。 这些表示被<strong>提供给网络的全连接层</strong>。 然后<strong>针对这些特征为每个类别训练一个二元线性 SVM 分类器</strong>。 </p>
<p>我们对 SVM 训练的实施如下。 我们使用<strong>真实窗口来生成正样本</strong>。 <strong>负样本</strong>是那些与<strong>正窗口重叠最多 30%</strong>（由交集与联合（IoU）比率衡量）的那些样本。如果任何<strong>负样本</strong>与<strong>另一个负样本</strong>重叠<strong>超过 70%，则将其移除</strong>。 我们应用标准的<strong>hard negative mining</strong>来训练 SVM。 这一步迭代一次。 为所有 20 个类别训练 SVM 只需不到 1 小时。 在测试中，分类器用于对候选窗口进行评分。 然后我们在评分窗口上使用<strong>非最大抑制</strong>（阈值为 30%）。 </p>
<p>一张任意尺寸的图片，在最后的卷积层conv5可以得到特征图。根据Region proposal步骤可以得到很多候选区域，这个候选区域可以在特征图上找到相同位置对应的窗口，然后使用SPP，每个窗口都可以得到一个固定长度的输出。将这个输出输入到全连接层里面。这样，图片只需要经过一次CNN，候选区域特征直接从整张图片特征图上提取。在训练这个特征提取网络的时候，使用分类任务得到的网络，固定前面的卷积层，只微调后面的全连接层。</p>
<p>在检测的后面模块，仍然和R-CNN一样，使用SVM和边框回归。SVM的特征输入是FC层，边框回归特征使用SPP层。</p>
<p><strong>Mapping  a  Window  to  Feature  Maps(映射图像域中的窗口到特征图上)</strong></p>
<p>在图像域中给出了一个窗口，我们用它来裁剪经过多次子采样的卷积特征图（例如，conv5）。 所以我们需要在特征图上对齐窗口。 </p>
<p>在我们的实现中，我们将<strong>窗口的角点</strong>投影到特征图中的一个像素上，这样<strong>图像域中的这个角点最接近该特征图像素的感受野中心</strong>。 由于所有卷积层和池化层的填充，使得映射变得很复杂。 为了简化实现，在部署期间，我们为过滤器大小为 p 的层填充了&lfloor;p/2&rfloor;个pixels。 因此，对于以 (x’,y’) 为中心的响应(特征图)，其在图像域中的有效感受野以 (x,y) =(Sx’,Sy’) 为中心，其中 S是<strong>所有先前步幅的乘积</strong>。 在我们的模型中，对于 conv5 上的 ZF-5，S= 16，对于 conv5/7 上的 Overfeat-5/7，S= 12。 给定图像域中的一个窗口，我们将左（上）边界投影为：x′=&lfloor;x/S&rfloor;+1 和右（下）边界 x′=&lfloor;x/S&rfloor;−1。 如果填充不是&lfloor;p/2&rfloor;，我们需要给x添加一个适当的偏移量。 </p>
]]></content>
      <categories>
        <category>Deep Learning</category>
      </categories>
      <tags>
        <tag>Deep Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Image-Process-Image-Compression</title>
    <url>/2021/07/25/Image-Process-Image-Compression/</url>
    <content><![CDATA[<h2 id="图像处理学习"><a href="#图像处理学习" class="headerlink" title="图像处理学习"></a>图像处理学习</h2><h3 id="图像压缩笔记"><a href="#图像压缩笔记" class="headerlink" title="图像压缩笔记"></a>图像压缩笔记</h3><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>图像压缩是一种减少描绘一副图像所需数据量的技术和科学。<strong>那么为什么需要进行图像压缩呢？</strong></p>
<p>考虑使用720x480x24比特像素阵列来描绘2小时的标准清晰度(SD)电视电影所需的数据量，(24bit 是为了存储颜色信息)。由于数字电影(视频)是一个视频帧序列，其中每一帧都是一副全彩色静止图像。因为视频播放必须以近于30帧/秒的速率连续地显示，所以必须以：</p>
<script type="math/tex; mode=display">
30\frac{帧}{秒}\times (720\times 480)\frac{像素}{帧}\times3\frac{字节}{像素}=31104000\quad(字节/秒)</script><p>的速率访问SD数字视频数据。则2小时的视频流由：</p>
<script type="math/tex; mode=display">
31104000\frac{字节}{秒}\times(60^2)\frac{秒}{小时}\times2小时\approx2.24\times10^{11}字节</script><p>接近224GB(千兆字节)的数据组成。而一般的存储设备如DVD容量大致为8.5GB，则224GB的数据需要27张DVD来存储。如果想要将224GB的数据放到一张DVD存储盘上，则每一帧必须以平均26.3的系数压缩。对于高清晰度的电视，如1920x1080x24 比特/图像，则需要更高的压缩率。 </p>
<h4 id="二、数据冗余的类型"><a href="#二、数据冗余的类型" class="headerlink" title="二、数据冗余的类型"></a>二、数据冗余的类型</h4><ul>
<li><p>编码冗余</p>
<p>可以使用变长编码的形式(码字乘以每个灰度级的概率分布)，加大压缩率。</p>
</li>
<li><p>空间和时间冗余</p>
<p>需要寻找图像中的一种变换称为映射，分为可逆映射和不可逆映射。</p>
</li>
<li><p>不相关的信息</p>
<p>被人视觉忽略或者与应用无关的信息，但是可能会导致定量的损失，称为量化。 </p>
</li>
</ul>
<h4 id="三、图像信息的度量"><a href="#三、图像信息的度量" class="headerlink" title="三、图像信息的度量"></a>三、图像信息的度量</h4><p>利用信息论给出一个如何不丢失信息压缩的相关数学模型。假设信息的产生可用一个概率过程建模，通过用每个信源输出的平均信息(信源的熵)来表示一副图像中的信息实际上需要的最少的比特数。可在数字图像处理第三版p329处查阅</p>
<p><strong>保真度准则</strong></p>
<ul>
<li>客观保真度：使用均方误差和信噪比度量。</li>
<li>主管保真度：根据人的主观评估来衡量图像的质量，适应绝对等级尺度等进行衡量。</li>
</ul>
<p><strong>图像压缩模型</strong></p>
<p>图像压缩系统由两个不同的功能部分组成：一个编码器和一个解码器。 </p>
<p><img src="/2021/07/25/Image-Process-Image-Compression/1.png" alt="Image-Compression"></p>
<p><strong>一些基本的压缩方法</strong> </p>
<ul>
<li><p>霍夫曼编码</p>
</li>
<li><p>Golomb编码</p>
</li>
<li><p>算术编码</p>
</li>
<li><p>LZW编码</p>
</li>
<li><p>行程编码 </p>
</li>
<li><p>基于符号的编码</p>
</li>
<li><p>比特平面编码</p>
</li>
<li><p>块变换编码：把图像分成大小相等且不重叠的小块，并用二维变换单独处理这些块。二维变换可以用一种可逆线性变换(如傅里叶变换)把每个块或子图像映射为变换系数集合，然后对这些变换系数进行量化(以一种预定义的方式有选择性地消除或更粗略地量化那些携带最少信息的系数)和编码(一般为变长编码)。</p>
<p><img src="/2021/07/25/Image-Process-Image-Compression/2.png" alt="Block-Compression"></p>
</li>
</ul>
<p><strong>块变换编码中变换的选择：</strong>取决于可容忍的重建误差的大小和可用的计算资源。压缩是在对变换系数的量化期间实现的。正变换核核反变换核决定了所计算的变换的类型核总体计算的复杂性，以及所采用块变换编码系统的重建误差。(具体看p362)</p>
<p><strong>变换类型：</strong></p>
<ul>
<li><p>Walsh-Hadamard(WHT)变换</p>
<p>首先,介绍一下<strong>格雷码</strong>，在一组数的编码中，若任意两个相邻的代码只有一位二进制不同，则称这种编码为格雷码(Gray Code)，另外由于最大数与最小数之间也仅一位不同，即“首尾相连”，因此又称循环码或反射码。</p>
<p><strong>那么为什么要使用格雷码？</strong></p>
<p>格雷码是一种具有反射特性与循环特性的单步自补码，其循环和单步特性消除了随机数时出现重大错误的可能，其反射和自补特性使得对其进行求反操作也非常方便，所以，格雷码属于一种可靠性编码，是一种错误最小化的编码方式。</p>
<p>虽然自然二进制码可以直接有数/模转换器转换成模型信号，但是某些情况，例如从十进制的3(011)转换为4(100)时，二进制码的每一位都要变，能使数字电路产生很大的尖峰电流脉冲。而格雷码则没有这一缺点，它在相邻位间转换时，只有一位产生变化。大大地减少了由一个状态到下一个状态时逻辑的混乱。</p>
<p><strong>二进制到格雷码的转换：</strong></p>
<script type="math/tex; mode=display">
n=(n_{p-1},n_{p-2},......n_k......n_2,n_1,n_0) \\
g=(g_{p-1},g_{p-2},......g_k......g_2,h_1,h_0) \\
\begin{cases}
g_{p-1}=n_{p-1}\\
g_{p-2}=n_{p-1}\bigoplus n_{p-2} \quad (\bigoplus,与或符号，对应位相同为0，不同为1)\\
......\\
g_k=n_{k+1}\bigoplus n_k\\......\\
g_1=n_2\bigoplus n_1 \\
g_0=n_1\bigoplus n_0
\end{cases}</script><p>| 十进制 | 二进制(自然排序) | 二进制(二进制) | 格雷码 |<br>| ——— | ———————— | ——————— | ——— |<br>| 0      | 000              | 000            | 000    |<br>| 1      | 001              | 100            | 001    |<br>| 2      | 010              | 010            | 011    |<br>| 3      | 011              | 110            | 010    |<br>| 4      | 100              | 001            | 110    |<br>| 5      | 101              | 101            | 111    |<br>| 6      | 110              | 011            | 101    |<br>| 7      | 111              | 111            | 100    |</p>
<p><strong>格雷码到二进制的转换：</strong></p>
<script type="math/tex; mode=display">
\begin{cases}
n_{p-1}=g_{p-1} \\
n_{p-2}=g_{p-1}\bigoplus g_{p-2} \\
n_{p-3}= g_{p-1}\bigoplus g_{p-2} \bigoplus  g_{p-3}\\
......\\
n_k=g_{k-1}\bigoplus g_{p-2}\bigoplus g_{p-3}......\bigoplus g_k\\ 
......\\
n_0=g_{p-1}\bigoplus g_{p-2}\bigoplus g_{p-3}\bigoplus g_0
\end{cases}</script><p><strong>拉德梅克函数（Rademacher）</strong></p>
<p>定义：</p>
<script type="math/tex; mode=display">
R(n,t)=sgn(\sin2^n\pi t) \quad (周期函数)\\
sgn(x)=\begin{cases}
1& \text{x>0}\\
-1& \text{x<0}
\end{cases}</script><p><img src="/2021/07/25/Image-Process-Image-Compression/4.png" alt="Gray Code"></p>
<p><img src="/2021/07/25/Image-Process-Image-Compression/5.png" alt="Gray Code"></p>
<p><strong>沃尔什函数</strong></p>
<p>有三种不同的函数定义，但都可由拉德梅克函数构成。</p>
<p><img src="/2021/07/25/Image-Process-Image-Compression/6.png" alt="Gray Code"></p>
</li>
</ul>
<p>  <strong>下面的P=2，其实应该是2<sup>3</sup>=8，用三位二进制编码表示(000~111)</strong></p>
<p>  <img src="/2021/07/25/Image-Process-Image-Compression/7.png" alt="Gray Code"></p>
<p>  <img src="/2021/07/25/Image-Process-Image-Compression/8.png" alt="Gray Code"></p>
<p>  <img src="/2021/07/25/Image-Process-Image-Compression/9.png" alt="Gray Code"></p>
<p>  <img src="/2021/07/25/Image-Process-Image-Compression/10.png" alt="Gray Code"></p>
<p>  <img src="/2021/07/25/Image-Process-Image-Compression/11.png" alt="Gray Code"></p>
<p>  <img src="/2021/07/25/Image-Process-Image-Compression/12.png" alt="Gray Code"></p>
<p>  <a href="https://wenku.baidu.com/view/52a0e787f61fb7360b4c65df.html" target="_blank" rel="noopener">上面参考链接</a></p>
<ul>
<li><p>离散余弦变换(DCT)</p>
<p>离散余弦变换(DCT for Discrete Cosine Transform)是与傅里叶变换相关的一种<a href="https://baike.baidu.com/item/变换/7680134" target="_blank" rel="noopener">变换</a>，它类似于<a href="https://baike.baidu.com/item/离散傅里叶变换/6379901" target="_blank" rel="noopener">离散傅里叶变换</a>(DFT for Discrete Fourier Transform),但是只使用实数。离散傅里叶变换需要进行复数运算，尽管有FFT可以提高运算速度，但在图像编码、特别是在实时处理中非常不便。离散傅里叶变换在实际的图像通信系统中很少使用，但它具有理论的指导意义。根据离散傅里叶变换的性质，实偶函数的傅里叶变换只含实的余弦项，因此构造了一种实数域的变换——离散余弦变换(DCT)。</p>
<p>离散余弦变换，尤其是它的第二种类型，经常被信号处理和<a href="https://baike.baidu.com/item/图像处理" target="_blank" rel="noopener">图像处理</a>使用，用于对信号和图像(包括静止图像和运动图像)进行<a href="https://baike.baidu.com/item/有损数据压缩" target="_blank" rel="noopener">有损数据压缩</a>。这是由于离散余弦变换具有很强的”能量集中”特性:大多数的自然信号(包括声音和图像)的能量都集中在离散余弦变换后的低频部分，而且当信号具有接近<strong><a href="https://baike.baidu.com/item/马尔科夫过程" target="_blank" rel="noopener">马尔科夫过程</a></strong>(Markov processes)的统计特性时，离散余弦变换的去相关性接近于K-L变换(Karhunen-Loève 变换—它具有最优的去相关性)的性能。DCT变换实际上就是限定了输入信号的DFT变换。</p>
<p><a href="https://zhuanlan.zhihu.com/p/85299446" target="_blank" rel="noopener">DCT详解-知乎</a> 该文中提到了为了DCT的详细介绍，包括了为了构造通用偶函数而将源信号源于原点做对称处理，周期变成2N，在包含原点的情况下，扩展的函数关于-1/2d对称，所以需要将其向右移动1/2个单位。更详细的介绍<a href="https://zhuanlan.zhihu.com/p/114626779" target="_blank" rel="noopener">DCT</a></p>
</li>
<li><p>离散傅里叶变换(DFT)</p>
</li>
<li><p>Karhunen-Loeve变换(KLT)</p>
</li>
</ul>
<p><strong>子图像尺寸的选择</strong></p>
<p>为了使相邻子图像之间的相关性降低到可接受的程度，其中n为2的整数次幂 。通常子图像的尺寸为8x8或16x16。</p>
<p><strong>JPEG</strong>：使用最普遍且广泛的连续色调静止帧压缩标准使JPEG标准。定义了三种不同的编码系统：</p>
<ul>
<li>一种有损的基本编码系统，以DCT为基础</li>
<li>一种扩展的编码系统</li>
<li>一种面向可逆压缩的无损独立编码系统</li>
</ul>
<p><strong>JPEG压缩</strong></p>
<p><strong>二维离散余弦变换</strong></p>
<script type="math/tex; mode=display">
F(u,v)=\frac{2}{T}C(u)\cdot C(v)\sum^{T-1}_{y=0}\sum^{T-1}_{x=0}I(x,y)\cdot\cos(\frac{(2x+1)u\pi}{2T})\cdot\cos(\frac{(2y+1)v\pi}{2T}),0\le u,v\le T \\
C(u)=\begin{cases}
\frac{1}{\sqrt{2}} & u=0 \\
1 & u \neq0
\end{cases}</script><p><strong>二维离散余弦逆变换</strong></p>
<script type="math/tex; mode=display">
f(x,y)=\frac{2}{T}\sum^{K-1}_{u=0}\sum^{K-1}_{v=0}C(u)C(v)F(u,v)\cdot\cos(\frac{(2x+1)u\pi}{2T})\cdot\cos(\frac{(2y+1)v\pi}{2T}),1\le K\le T \\
C(u)=\begin{cases}
\frac{1}{\sqrt{2}} & u=0 \\
1 & u \neq0
\end{cases}</script><p>在这里, K是决定图像复原时分辨率高低的参数。 K=T时，DCT的系数全被保留，因此IDCT时分辨率最大。 K=1或K=2时，图像复原时的信息量（DCT系数）减少，分辨率降低。如果适当地设定设定K值，可以减小文件大小。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DCT hyoer-parameter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">T = <span class="number">8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">K = <span class="number">8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">channel = <span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># DCT weight</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">w</span><span class="params">(x, y, u, v)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cu = <span class="number">1.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cv = <span class="number">1.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> u == <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cu /= np.sqrt(<span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> v == <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cv /= np.sqrt(<span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    theta = np.pi / (<span class="number">2</span> * T)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (( <span class="number">2</span> * cu * cv / T) * np.cos((<span class="number">2</span>*x+<span class="number">1</span>)*u*theta) * np.cos((<span class="number">2</span>*y+<span class="number">1</span>)*v*theta))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># DCT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dct</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    H, W, _ = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    F = np.zeros((H, W, channel), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> range(channel):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> yi <span class="keyword">in</span> range(<span class="number">0</span>, H, T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> xi <span class="keyword">in</span> range(<span class="number">0</span>, W, T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> range(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">for</span> u <span class="keyword">in</span> range(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">for</span> y <span class="keyword">in</span> range(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="keyword">for</span> x <span class="keyword">in</span> range(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                F[v+yi, u+xi, c] += img[y+yi, x+xi, c] * w(x,y,u,v)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> F</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># IDCT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">idct</span><span class="params">(F)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    H, W, _ = F.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = np.zeros((H, W, channel), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> range(channel):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> yi <span class="keyword">in</span> range(<span class="number">0</span>, H, T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> xi <span class="keyword">in</span> range(<span class="number">0</span>, W, T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> y <span class="keyword">in</span> range(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">for</span> x <span class="keyword">in</span> range(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">for</span> v <span class="keyword">in</span> range(K):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="keyword">for</span> u <span class="keyword">in</span> range(K):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                out[y+yi, x+xi, c] += F[v+yi, u+xi, c] * w(x,y,u,v)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = np.clip(out, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = np.round(out).astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">height</span> = <span class="number">128</span>, <span class="built_in">width</span> = <span class="number">128</span>, channel = <span class="number">3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// DCT hyper-parameter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> T = <span class="number">8</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> K = <span class="number">8</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// DCT coefficient</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dct_str</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> coef[<span class="built_in">height</span>][<span class="built_in">width</span>][channel];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Discrete Cosine transformation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">dct_str <span class="title">dct</span><span class="params">(cv::Mat img, dct_str dct_s)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> I;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> Cu, Cv;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ys = <span class="number">0</span>; ys &lt; <span class="built_in">height</span>; ys += T)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> xs = <span class="number">0</span>; xs &lt; <span class="built_in">width</span>; xs += T)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; T; v ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; T; u ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            F = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (u == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Cu = <span class="number">1.</span> / <span class="built_in">sqrt</span>(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Cu = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (v == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Cv = <span class="number">1.</span> / <span class="built_in">sqrt</span>(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Cv = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; T; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; T; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                I = (<span class="keyword">double</span>)img.at&lt;cv::Vec3b&gt;(ys + y, xs + x)[c];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                F += <span class="number">2.</span> / T * Cu * Cv * I * <span class="built_in">cos</span>((<span class="number">2.</span> * x + <span class="number">1</span>) * u * M_PI / <span class="number">2.</span> / T) * <span class="built_in">cos</span>((<span class="number">2.</span> * y + <span class="number">1</span>) * v * M_PI / <span class="number">2.</span> / T);</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            dct_s.coef[ys + v][xs + u][c] = F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> dct_s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Inverse Discrete Cosine transformation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">idct</span><span class="params">(cv::Mat out, dct_str dct_s)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> f;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> Cu, Cv;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> ys = <span class="number">0</span>; ys &lt; <span class="built_in">height</span>; ys += T)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> xs = <span class="number">0</span>; xs &lt; <span class="built_in">width</span>; xs += T)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; T; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; T; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            f = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; K; v++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; K; u++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (u == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Cu = <span class="number">1.</span> / <span class="built_in">sqrt</span>(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Cu = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (v == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Cv = <span class="number">1.</span> / <span class="built_in">sqrt</span>(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> &#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Cv = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">                f += <span class="number">2.</span> / T * Cu * Cv * dct_s.coef[ys + v][xs + u][c] * <span class="built_in">cos</span>((<span class="number">2.</span> * x + <span class="number">1</span>) * u * M_PI / <span class="number">2.</span> / T) * <span class="built_in">cos</span>((<span class="number">2.</span> * y + <span class="number">1</span>) * v * M_PI / <span class="number">2.</span> / T);</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            f = fmin(fmax(f, <span class="number">0</span>), <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            out.at&lt;cv::Vec3b&gt;(ys + y, xs + x)[c] = (uchar)f;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><strong>峰值信噪比(Peak signal-to-noise ratiio)</strong>: PSNR</p>
<p>用来衡量两幅图片的差异的。一幅图片A，经过一般操作之后得到图片B，一般是与A同样大小。PSBR的单位是db（分贝）。峰值信噪比越大，表示画质损失越小 。</p>
<p>峰值信噪比通过下式定义。MAX表示图像点颜色的最大数值。如果取值范围是[0,255]的话，那么MAX的值就为255。MSE表示均方误差（Mean Squared Error），用来表示两个图像各个像素点之间差值平方和的平均数</p>
<script type="math/tex; mode=display">
PSNR=10\cdot\log_{10}\frac{MAX_I^2}{MSE}=20\cdot\log_{10}\frac{MAX_I}{MSE}，峰值信噪比定义\\
MSE=\frac{1}{mn}\sum^{m-1}_{i=0}\sum^{m-1}_{j=0}[I(i,j)-K(i,j)]^2</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DCT hyoer-parameter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">T = <span class="number">8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">K = <span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">channel = <span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># DCT weight</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">w</span><span class="params">(x, y, u, v)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cu = <span class="number">1.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cv = <span class="number">1.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> u == <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cu /= np.sqrt(<span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> v == <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cv /= np.sqrt(<span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    theta = np.pi / (<span class="number">2</span> * T)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (( <span class="number">2</span> * cu * cv / T) * np.cos((<span class="number">2</span>*x+<span class="number">1</span>)*u*theta) * np.cos((<span class="number">2</span>*y+<span class="number">1</span>)*v*theta))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># DCT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dct</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    H, W, _ = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    F = np.zeros((H, W, channel), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> range(channel):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> yi <span class="keyword">in</span> range(<span class="number">0</span>, H, T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> xi <span class="keyword">in</span> range(<span class="number">0</span>, W, T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> range(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">for</span> u <span class="keyword">in</span> range(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">for</span> y <span class="keyword">in</span> range(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="keyword">for</span> x <span class="keyword">in</span> range(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                F[v+yi, u+xi, c] += img[y+yi, x+xi, c] * w(x,y,u,v)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> F</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># IDCT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">idct</span><span class="params">(F)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    H, W, _ = F.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = np.zeros((H, W, channel), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> range(channel):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> yi <span class="keyword">in</span> range(<span class="number">0</span>, H, T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> xi <span class="keyword">in</span> range(<span class="number">0</span>, W, T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> y <span class="keyword">in</span> range(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">for</span> x <span class="keyword">in</span> range(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">for</span> v <span class="keyword">in</span> range(K):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="keyword">for</span> u <span class="keyword">in</span> range(K):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                out[y+yi, x+xi, c] += F[v+yi, u+xi, c] * w(x,y,u,v)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = np.clip(out, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = np.round(out).astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># MSE</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MSE</span><span class="params">(img1, img2)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    H, W, _ = img1.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mse = np.sum((img1 - img2) ** <span class="number">2</span>) / (H * W * channel)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> mse</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># PSNR</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PSNR</span><span class="params">(mse, vmax=<span class="number">255</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">10</span> * np.log10(vmax * vmax / mse)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># bitrate</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BITRATE</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1.</span> * T * K * K / T / T</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">height</span> = <span class="number">128</span>, <span class="built_in">width</span> = <span class="number">128</span>, channel = <span class="number">3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// DCT hyper-parameter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> T = <span class="number">8</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> K = <span class="number">4</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// DCT coefficient</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dct_str</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> coef[<span class="built_in">height</span>][<span class="built_in">width</span>][channel];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Discrete Cosine transformation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">dct_str <span class="title">dct</span><span class="params">(cv::Mat img, dct_str dct_s)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> I;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> Cu, Cv;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> ys = <span class="number">0</span>; ys &lt; <span class="built_in">height</span>; ys += T)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> xs = <span class="number">0</span>; xs &lt; <span class="built_in">width</span>; xs += T)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; T; v ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; T; u ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            F = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (u == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Cu = <span class="number">1.</span> / <span class="built_in">sqrt</span>(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Cu = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (v == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Cv = <span class="number">1.</span> / <span class="built_in">sqrt</span>(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Cv = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; T; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; T; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                I = (<span class="keyword">double</span>)img.at&lt;cv::Vec3b&gt;(ys + y, xs + x)[c];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                F += <span class="number">2.</span> / T * Cu * Cv * I * <span class="built_in">cos</span>((<span class="number">2.</span> * x + <span class="number">1</span>) * u * M_PI / <span class="number">2.</span> / T) * <span class="built_in">cos</span>((<span class="number">2.</span> * y + <span class="number">1</span>) * v * M_PI / <span class="number">2.</span> / T);</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            dct_s.coef[ys + v][xs + u][c] = F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> dct_s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Inverse Discrete Cosine transformation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">idct</span><span class="params">(cv::Mat out, dct_str dct_s)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> f;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> Cu, Cv;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ys = <span class="number">0</span>; ys &lt; <span class="built_in">height</span>; ys += T)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> xs = <span class="number">0</span>; xs &lt; <span class="built_in">width</span>; xs += T)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; T; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; T; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            f = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; K; v++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; K; u++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (u == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Cu = <span class="number">1.</span> / <span class="built_in">sqrt</span>(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Cu = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (v == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Cv = <span class="number">1.</span> / <span class="built_in">sqrt</span>(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> &#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Cv = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">                f += <span class="number">2.</span> / T * Cu * Cv * dct_s.coef[ys + v][xs + u][c] * <span class="built_in">cos</span>((<span class="number">2.</span> * x + <span class="number">1</span>) * u * M_PI / <span class="number">2.</span> / T) * <span class="built_in">cos</span>((<span class="number">2.</span> * y + <span class="number">1</span>) * v * M_PI / <span class="number">2.</span> / T);</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            f = fmin(fmax(f, <span class="number">0</span>), <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            out.at&lt;cv::Vec3b&gt;(ys + y, xs + x)[c] = (uchar)f;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Compute MSE</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">MSE</span><span class="params">(cv::Mat img1, cv::Mat img2)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> mse = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mse += <span class="built_in">pow</span>(((<span class="keyword">double</span>)img1.at&lt;cv::Vec3b&gt;(y, x)[c] - (<span class="keyword">double</span>)img2.at&lt;cv::Vec3b&gt;(y, x)[c]), <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  mse /= (<span class="built_in">height</span> * <span class="built_in">width</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> mse;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Compute PSNR</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">PSNR</span><span class="params">(<span class="keyword">double</span> mse, <span class="keyword">double</span> v_max)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="number">10</span> * <span class="built_in">log10</span>(v_max * v_max / mse);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Compute bitrate</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">BITRATE</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> T * K * K / T * T;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><strong>JPEG离散余弦变换+量化</strong></p>
<p>数字图像处理第三版370中有JPEG的有损基本压缩过程：本身按三个顺序步骤执行</p>
<ul>
<li>DCT计算</li>
<li>量化</li>
<li>变长编码</li>
</ul>
<p>图像首先被细分为8x8的像素块，对这些像素块按从左到右，从上到下的方式进行处理。当遇到每个8x8的块或子图像时，其64个像素通过减去2<sup>k-1</sup>进行灰度级移动，其中2<sup>k</sup>是灰度级的最大数。然后计算该块的二维离散余弦变换，根据下式对其进行量化：</p>
<script type="math/tex; mode=display">
\hat{T}(u,v)=round(\frac{T(u,v)}{Z(u,v)}),T为二维离散余弦变换后的值，Z为标准化阵列</script><p>在量化后，使用Z型模式对其重新排列。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#标准化阵列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Q = np.array(((<span class="number">16</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">40</span>, <span class="number">51</span>, <span class="number">61</span>), (<span class="number">12</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">58</span>, <span class="number">60</span>, <span class="number">55</span>), (<span class="number">14</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">40</span>, <span class="number">57</span>, <span class="number">69</span>, <span class="number">56</span>), (<span class="number">14</span>, <span class="number">17</span>, <span class="number">22</span>, <span class="number">29</span>, <span class="number">51</span>, <span class="number">87</span>, <span class="number">80</span>, <span class="number">62</span>), (<span class="number">18</span>, <span class="number">22</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">68</span>, <span class="number">109</span>, <span class="number">103</span>, <span class="number">77</span>), (<span class="number">24</span>, <span class="number">35</span>, <span class="number">55</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">104</span>, <span class="number">113</span>, <span class="number">92</span>), (<span class="number">49</span>, <span class="number">64</span>, <span class="number">78</span>, <span class="number">87</span>, <span class="number">103</span>, <span class="number">121</span>, <span class="number">120</span>, <span class="number">101</span>), (<span class="number">72</span>, <span class="number">92</span>, <span class="number">95</span>, <span class="number">98</span>, <span class="number">112</span>, <span class="number">100</span>, <span class="number">103</span>, <span class="number">99</span>)), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># DCT hyoer-parameter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">T = <span class="number">8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">K = <span class="number">4</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">channel = <span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># DCT weight</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DCT_w</span><span class="params">(x, y, u, v)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cu = <span class="number">1.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cv = <span class="number">1.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> u == <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cu /= np.sqrt(<span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> v == <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cv /= np.sqrt(<span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    theta = np.pi / (<span class="number">2</span> * T)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (( <span class="number">2</span> * cu * cv / T) * np.cos((<span class="number">2</span>*x+<span class="number">1</span>)*u*theta) * np.cos((<span class="number">2</span>*y+<span class="number">1</span>)*v*theta))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># DCT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dct</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    H, W, _ = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    F = np.zeros((H, W, channel), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> range(channel):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> yi <span class="keyword">in</span> range(<span class="number">0</span>, H, T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> xi <span class="keyword">in</span> range(<span class="number">0</span>, W, T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> range(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">for</span> u <span class="keyword">in</span> range(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">for</span> y <span class="keyword">in</span> range(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="keyword">for</span> x <span class="keyword">in</span> range(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                F[v+yi, u+xi, c] += img[y+yi, x+xi, c] * DCT_w(x,y,u,v)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> F</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># IDCT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">idct</span><span class="params">(F)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    H, W, _ = F.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = np.zeros((H, W, channel), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> range(channel):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> yi <span class="keyword">in</span> range(<span class="number">0</span>, H, T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> xi <span class="keyword">in</span> range(<span class="number">0</span>, W, T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> y <span class="keyword">in</span> range(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">for</span> x <span class="keyword">in</span> range(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">for</span> v <span class="keyword">in</span> range(K):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="keyword">for</span> u <span class="keyword">in</span> range(K):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                out[y+yi, x+xi, c] += F[v+yi, u+xi, c] * DCT_w(x,y,u,v)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = np.clip(out, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = np.round(out).astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Quantization</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quantization</span><span class="params">(F)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    H, W, _ = F.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Q = np.array(((<span class="number">16</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">40</span>, <span class="number">51</span>, <span class="number">61</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                (<span class="number">12</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">58</span>, <span class="number">60</span>, <span class="number">55</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                (<span class="number">14</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">40</span>, <span class="number">57</span>, <span class="number">69</span>, <span class="number">56</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                (<span class="number">14</span>, <span class="number">17</span>, <span class="number">22</span>, <span class="number">29</span>, <span class="number">51</span>, <span class="number">87</span>, <span class="number">80</span>, <span class="number">62</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                (<span class="number">18</span>, <span class="number">22</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">68</span>, <span class="number">109</span>, <span class="number">103</span>, <span class="number">77</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                (<span class="number">24</span>, <span class="number">35</span>, <span class="number">55</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">104</span>, <span class="number">113</span>, <span class="number">92</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                (<span class="number">49</span>, <span class="number">64</span>, <span class="number">78</span>, <span class="number">87</span>, <span class="number">103</span>, <span class="number">121</span>, <span class="number">120</span>, <span class="number">101</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                (<span class="number">72</span>, <span class="number">92</span>, <span class="number">95</span>, <span class="number">98</span>, <span class="number">112</span>, <span class="number">100</span>, <span class="number">103</span>, <span class="number">99</span>)), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> ys <span class="keyword">in</span> range(<span class="number">0</span>, H, T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> xs <span class="keyword">in</span> range(<span class="number">0</span>, W, T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(channel):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                F[ys: ys + T, xs: xs + T, c] =  np.round(F[ys: ys + T, xs: xs + T, c] / Q) * Q</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> F</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># MSE</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MSE</span><span class="params">(img1, img2)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    H, W, _ = img1.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mse = np.sum((img1 - img2) ** <span class="number">2</span>) / (H * W * channel)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> mse</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># PSNR</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PSNR</span><span class="params">(mse, vmax=<span class="number">255</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">10</span> * np.log10(vmax * vmax / mse)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># bitrate</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BITRATE</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1.</span> * T * K * K / T / T</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">height</span> = <span class="number">128</span>, <span class="built_in">width</span> = <span class="number">128</span>, channel = <span class="number">3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// DCT hyper-parameter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> T = <span class="number">8</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> K = <span class="number">4</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// DCT coefficient</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dct_str</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> coef[<span class="built_in">height</span>][<span class="built_in">width</span>][channel];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Discrete Cosine transformation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">dct_str <span class="title">dct</span><span class="params">(cv::Mat img, dct_str dct_s)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> I;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> Cu, Cv;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> ys = <span class="number">0</span>; ys &lt; <span class="built_in">height</span>; ys += T)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> xs = <span class="number">0</span>; xs &lt; <span class="built_in">width</span>; xs += T)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; T; v ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; T; u ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            F = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (u == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Cu = <span class="number">1.</span> / <span class="built_in">sqrt</span>(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Cu = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (v == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Cv = <span class="number">1.</span> / <span class="built_in">sqrt</span>(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Cv = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; T; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; T; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                I = (<span class="keyword">double</span>)img.at&lt;cv::Vec3b&gt;(ys + y, xs + x)[c];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                F += <span class="number">2.</span> / T * Cu * Cv * I * <span class="built_in">cos</span>((<span class="number">2.</span> * x + <span class="number">1</span>) * u * M_PI / <span class="number">2.</span> / T) * <span class="built_in">cos</span>((<span class="number">2.</span> * y + <span class="number">1</span>) * v * M_PI / <span class="number">2.</span> / T);</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            dct_s.coef[ys + v][xs + u][c] = F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> dct_s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Inverse Discrete Cosine transformation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">idct</span><span class="params">(cv::Mat out, dct_str dct_s)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> f;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> Cu, Cv;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> ys = <span class="number">0</span>; ys &lt; <span class="built_in">height</span>; ys += T)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> xs = <span class="number">0</span>; xs &lt; <span class="built_in">width</span>; xs += T)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; T; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; T; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            f = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; K; v++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; K; u++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (u == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Cu = <span class="number">1.</span> / <span class="built_in">sqrt</span>(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Cu = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (v == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Cv = <span class="number">1.</span> / <span class="built_in">sqrt</span>(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> &#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Cv = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">                f += <span class="number">2.</span> / T * Cu * Cv * dct_s.coef[ys + v][xs + u][c] * <span class="built_in">cos</span>((<span class="number">2.</span> * x + <span class="number">1</span>) * u * M_PI / <span class="number">2.</span> / T) * <span class="built_in">cos</span>((<span class="number">2.</span> * y + <span class="number">1</span>) * v * M_PI / <span class="number">2.</span> / T);</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            f = fmin(fmax(f, <span class="number">0</span>), <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            out.at&lt;cv::Vec3b&gt;(ys + y, xs + x)[c] = (uchar)f;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Quantization</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">dct_str <span class="title">quantization</span><span class="params">(dct_str dct_s)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> Q[T][T] = &#123;&#123;<span class="number">16</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">40</span>, <span class="number">51</span>, <span class="number">61</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#123;<span class="number">12</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">58</span>, <span class="number">60</span>, <span class="number">55</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#123;<span class="number">12</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">58</span>, <span class="number">60</span>, <span class="number">55</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#123;<span class="number">14</span>, <span class="number">17</span>, <span class="number">22</span>, <span class="number">29</span>, <span class="number">51</span>, <span class="number">87</span>, <span class="number">80</span>, <span class="number">62</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#123;<span class="number">18</span>, <span class="number">22</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">68</span>, <span class="number">109</span>, <span class="number">103</span>, <span class="number">77</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#123;<span class="number">24</span>, <span class="number">35</span>, <span class="number">55</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">104</span>, <span class="number">113</span>, <span class="number">92</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#123;<span class="number">49</span>, <span class="number">64</span>, <span class="number">78</span>, <span class="number">87</span>, <span class="number">103</span>, <span class="number">121</span>, <span class="number">120</span>, <span class="number">101</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#123;<span class="number">72</span>, <span class="number">92</span>, <span class="number">95</span>, <span class="number">98</span>, <span class="number">112</span>, <span class="number">100</span>, <span class="number">103</span>, <span class="number">99</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ys = <span class="number">0</span>; ys &lt; <span class="built_in">height</span>; ys += T)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> xs = <span class="number">0</span>; xs &lt; <span class="built_in">width</span>; xs += T)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; T; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; T; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            dct_s.coef[ys + y][xs + x][c] = round(dct_s.coef[ys + y][xs + x][c] / Q[y][x]) * Q[y][x];</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> dct_s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Compute MSE</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">MSE</span><span class="params">(cv::Mat img1, cv::Mat img2)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> mse = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mse += <span class="built_in">pow</span>(((<span class="keyword">double</span>)img1.at&lt;cv::Vec3b&gt;(y, x)[c] - (<span class="keyword">double</span>)img2.at&lt;cv::Vec3b&gt;(y, x)[c]), <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  mse /= (<span class="built_in">height</span> * <span class="built_in">width</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> mse;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Compute PSNR</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">PSNR</span><span class="params">(<span class="keyword">double</span> mse, <span class="keyword">double</span> v_max)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="number">10</span> * <span class="built_in">log10</span>(v_max * v_max / mse);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Compute bitrate</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">BITRATE</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> T * K * K / T * T;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><strong>YCbCr色彩空间</strong></p>
<p>YCbCr色彩空间是用于将图像由表示亮度的 Y、表示蓝色色度Cb以及表示红色色度Cr表示的方法。这用于 JPEG 转换。它在电视系统中比较常用，比如早期的黑白电视机使用彩色电视信号线，就可以单独使用亮度值；这种功能RGB颜色空间就做不到，因为我们不能仅仅使用RGB中某个通道作为亮度信号来使用。</p>
<p>使用下式从 RGB 转换到 YCbCr：</p>
<script type="math/tex; mode=display">
\begin{align}Y=&0.299\cdot R+0.587\cdot G+0.114\cdot B\\
Cb=&-0.1687\cdot R-0.3313\cdot G+0.5\cdot B+128\\
Cr=&0.5\cdot R-0.4187\cdot G-0.0813\cdot B+128\end{align}</script><p>使用下式从 YCbCr转换到 RGB：</p>
<script type="math/tex; mode=display">
\begin{align}R=&Y+(Cr-128)\cdot 1.402\\
G=&Y-(Cb-128)\cdot 0.3441 - (Cr-128)\cdot 0.7139\\
B=&Y+(Cb-128)\cdot1.7718\end{align}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">channel = <span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># BGR -&gt; Y Cb Cr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BGR2YCbCr</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  H, W, _ = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ycbcr = np.zeros([H, W, <span class="number">3</span>], dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ycbcr[..., <span class="number">0</span>] = <span class="number">0.2990</span> * img[..., <span class="number">2</span>] + <span class="number">0.5870</span> * img[..., <span class="number">1</span>] + <span class="number">0.1140</span> * img[..., <span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ycbcr[..., <span class="number">1</span>] = <span class="number">-0.1687</span> * img[..., <span class="number">2</span>] - <span class="number">0.3313</span> * img[..., <span class="number">1</span>] + <span class="number">0.5</span> * img[..., <span class="number">0</span>] + <span class="number">128.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ycbcr[..., <span class="number">2</span>] = <span class="number">0.5</span> * img[..., <span class="number">2</span>] - <span class="number">0.4187</span> * img[..., <span class="number">1</span>] - <span class="number">0.0813</span> * img[..., <span class="number">0</span>] + <span class="number">128.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> ycbcr</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Y Cb Cr -&gt; BGR</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">YCbCr2BGR</span><span class="params">(ycbcr)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  H, W, _ = ycbcr.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  out = np.zeros([H, W, channel], dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  out[..., <span class="number">2</span>] = ycbcr[..., <span class="number">0</span>] + (ycbcr[..., <span class="number">2</span>] - <span class="number">128.</span>) * <span class="number">1.4020</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  out[..., <span class="number">1</span>] = ycbcr[..., <span class="number">0</span>] - (ycbcr[..., <span class="number">1</span>] - <span class="number">128.</span>) * <span class="number">0.3441</span> - (ycbcr[..., <span class="number">2</span>] - <span class="number">128.</span>) * <span class="number">0.7139</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  out[..., <span class="number">0</span>] = ycbcr[..., <span class="number">0</span>] + (ycbcr[..., <span class="number">1</span>] - <span class="number">128.</span>) * <span class="number">1.7718</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  out = np.clip(out, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// BGR -&gt; Y Cb Cr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">BGR2YCbCr</span><span class="params">(cv::Mat img, cv::Mat out)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//cv::Mat out = cv::Mat::zeros(height, width, CV_32F);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">height</span>; j ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">width</span>; i ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// Y</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">0</span>] = (<span class="keyword">int</span>)((<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(j,i)[<span class="number">0</span>] * <span class="number">0.114</span> + \</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(j,i)[<span class="number">1</span>] * <span class="number">0.5870</span> + \</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(j,i)[<span class="number">2</span>] * <span class="number">0.299</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// Cb</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">1</span>] = (<span class="keyword">int</span>)((<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(j,i)[<span class="number">0</span>] * <span class="number">0.5</span> + \</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(j,i)[<span class="number">1</span>] * (<span class="number">-0.3323</span>) + \</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(j,i)[<span class="number">2</span>] * (<span class="number">-0.1687</span>) + <span class="number">128</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// Cr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">2</span>] = (<span class="keyword">int</span>)((<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(j,i)[<span class="number">0</span>] * (<span class="number">-0.0813</span>) + \</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(j,i)[<span class="number">1</span>] * (<span class="number">-0.4187</span>) + \</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(j,i)[<span class="number">2</span>] * <span class="number">0.5</span> + <span class="number">128</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Y Cb Cr -&gt; BGR</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">YCbCr2BGR</span><span class="params">(cv::Mat ycbcr, cv::Mat out)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = out.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = out.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">height</span>; j ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">width</span>; i ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// R</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">2</span>] = (uchar)(ycbcr.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">0</span>] + (ycbcr.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">2</span>] - <span class="number">128</span>) * <span class="number">1.4102</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// G</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">1</span>] = (uchar)(ycbcr.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">0</span>] - (ycbcr.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">1</span>] - <span class="number">128</span>) * <span class="number">0.3441</span> - (ycbcr.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">2</span>] - <span class="number">128</span>) * <span class="number">0.7139</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// B</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">0</span>] = (uchar)(ycbcr.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">0</span>] + (ycbcr.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">1</span>] - <span class="number">128</span>) * <span class="number">1.7718</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">process</span><span class="params">(cv::Mat ycbcr)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = ycbcr.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = ycbcr.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      ycbcr.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">0</span>] *= <span class="number">0.7</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> ycbcr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><strong>YCbCr+离散余弦变换+量化</strong></p>
<ol>
<li>将图像从RGB色彩空间变换到YCbCr色彩空间；</li>
<li>对YCbCr做DCT；</li>
<li>DCT之后做量化；</li>
<li>量化之后应用IDCT； </li>
<li>IDCT之后从YCbCr色彩空间变换到RGB色彩空间。</li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># DCT hyoer-parameter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">T = <span class="number">8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">K = <span class="number">8</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">channel = <span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># BGR -&gt; Y Cb Cr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BGR2YCbCr</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  H, W, _ = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ycbcr = np.zeros([H, W, <span class="number">3</span>], dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ycbcr[..., <span class="number">0</span>] = <span class="number">0.2990</span> * img[..., <span class="number">2</span>] + <span class="number">0.5870</span> * img[..., <span class="number">1</span>] + <span class="number">0.1140</span> * img[..., <span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ycbcr[..., <span class="number">1</span>] = <span class="number">-0.1687</span> * img[..., <span class="number">2</span>] - <span class="number">0.3313</span> * img[..., <span class="number">1</span>] + <span class="number">0.5</span> * img[..., <span class="number">0</span>] + <span class="number">128.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ycbcr[..., <span class="number">2</span>] = <span class="number">0.5</span> * img[..., <span class="number">2</span>] - <span class="number">0.4187</span> * img[..., <span class="number">1</span>] - <span class="number">0.0813</span> * img[..., <span class="number">0</span>] + <span class="number">128.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> ycbcr</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Y Cb Cr -&gt; BGR</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">YCbCr2BGR</span><span class="params">(ycbcr)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  H, W, _ = ycbcr.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  out = np.zeros([H, W, channel], dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  out[..., <span class="number">2</span>] = ycbcr[..., <span class="number">0</span>] + (ycbcr[..., <span class="number">2</span>] - <span class="number">128.</span>) * <span class="number">1.4020</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  out[..., <span class="number">1</span>] = ycbcr[..., <span class="number">0</span>] - (ycbcr[..., <span class="number">1</span>] - <span class="number">128.</span>) * <span class="number">0.3441</span> - (ycbcr[..., <span class="number">2</span>] - <span class="number">128.</span>) * <span class="number">0.7139</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  out[..., <span class="number">0</span>] = ycbcr[..., <span class="number">0</span>] + (ycbcr[..., <span class="number">1</span>] - <span class="number">128.</span>) * <span class="number">1.7718</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  out = np.clip(out, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">  out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># DCT weight</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">DCT_w</span><span class="params">(x, y, u, v)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cu = <span class="number">1.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cv = <span class="number">1.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> u == <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cu /= np.sqrt(<span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> v == <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        cv /= np.sqrt(<span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    theta = np.pi / (<span class="number">2</span> * T)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (( <span class="number">2</span> * cu * cv / T) * np.cos((<span class="number">2</span>*x+<span class="number">1</span>)*u*theta) * np.cos((<span class="number">2</span>*y+<span class="number">1</span>)*v*theta))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># DCT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dct</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    H, W, _ = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    F = np.zeros((H, W, channel), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> range(channel):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> yi <span class="keyword">in</span> range(<span class="number">0</span>, H, T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> xi <span class="keyword">in</span> range(<span class="number">0</span>, W, T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> v <span class="keyword">in</span> range(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">for</span> u <span class="keyword">in</span> range(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">for</span> y <span class="keyword">in</span> range(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="keyword">for</span> x <span class="keyword">in</span> range(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                F[v+yi, u+xi, c] += img[y+yi, x+xi, c] * DCT_w(x,y,u,v)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> F</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># IDCT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">idct</span><span class="params">(F)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    H, W, _ = F.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = np.zeros((H, W, channel), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> range(channel):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> yi <span class="keyword">in</span> range(<span class="number">0</span>, H, T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> xi <span class="keyword">in</span> range(<span class="number">0</span>, W, T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span> y <span class="keyword">in</span> range(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">for</span> x <span class="keyword">in</span> range(T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                        <span class="keyword">for</span> v <span class="keyword">in</span> range(K):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                            <span class="keyword">for</span> u <span class="keyword">in</span> range(K):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                out[y+yi, x+xi, c] += F[v+yi, u+xi, c] * DCT_w(x,y,u,v)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = np.clip(out, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = np.round(out).astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Quantization</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">quantization</span><span class="params">(F)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    H, W, _ = F.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Q = np.array(((<span class="number">16</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">40</span>, <span class="number">51</span>, <span class="number">61</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                (<span class="number">12</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">58</span>, <span class="number">60</span>, <span class="number">55</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                (<span class="number">14</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">40</span>, <span class="number">57</span>, <span class="number">69</span>, <span class="number">56</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                (<span class="number">14</span>, <span class="number">17</span>, <span class="number">22</span>, <span class="number">29</span>, <span class="number">51</span>, <span class="number">87</span>, <span class="number">80</span>, <span class="number">62</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                (<span class="number">18</span>, <span class="number">22</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">68</span>, <span class="number">109</span>, <span class="number">103</span>, <span class="number">77</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                (<span class="number">24</span>, <span class="number">35</span>, <span class="number">55</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">104</span>, <span class="number">113</span>, <span class="number">92</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                (<span class="number">49</span>, <span class="number">64</span>, <span class="number">78</span>, <span class="number">87</span>, <span class="number">103</span>, <span class="number">121</span>, <span class="number">120</span>, <span class="number">101</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">                (<span class="number">72</span>, <span class="number">92</span>, <span class="number">95</span>, <span class="number">98</span>, <span class="number">112</span>, <span class="number">100</span>, <span class="number">103</span>, <span class="number">99</span>)), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> ys <span class="keyword">in</span> range(<span class="number">0</span>, H, T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> xs <span class="keyword">in</span> range(<span class="number">0</span>, W, T):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(channel):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                F[ys: ys + T, xs: xs + T, c] =  np.round(F[ys: ys + T, xs: xs + T, c] / Q) * Q</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> F</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># JPEG without Hufman coding</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">JPEG</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># BGR -&gt; Y Cb Cr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ycbcr = BGR2YCbCr(img)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># DCT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    F = dct(ycbcr)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># quantization</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    F = quantization(F)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># IDCT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ycbcr = idct(F)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># Y Cb Cr -&gt; BGR</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = YCbCr2BGR(ycbcr)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># MSE</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">MSE</span><span class="params">(img1, img2)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    H, W, _ = img1.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mse = np.sum((img1 - img2) ** <span class="number">2</span>) / (H * W * channel)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> mse</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># PSNR</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">PSNR</span><span class="params">(mse, vmax=<span class="number">255</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">10</span> * np.log10(vmax * vmax / mse)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># bitrate</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BITRATE</span><span class="params">()</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">1.</span> * T * K * K / T / T</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Read image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imori.jpg"</span>).astype(np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># JPEG</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">out = JPEG(img)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># MSE</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">mse = MSE(img, out)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># PSNR</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">psnr = PSNR(mse)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># bitrate</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">bitrate = BITRATE()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">"MSE:"</span>, mse)</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">"PSNR:"</span>, psnr)</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">"bitrate:"</span>, bitrate)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Save result</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"result"</span>, out)</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">"out.jpg"</span>, out)</span></pre></td></tr></table></figure>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#Q1 和 Q2 根据 JPEG 规范由以下等式定义：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">Q1 = np.array(((<span class="number">16</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">40</span>, <span class="number">51</span>, <span class="number">61</span>), (<span class="number">12</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">58</span>, <span class="number">60</span>, <span class="number">55</span>), (<span class="number">14</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">40</span>, <span class="number">57</span>, <span class="number">69</span>, <span class="number">56</span>), (<span class="number">14</span>, <span class="number">17</span>, <span class="number">22</span>, <span class="number">29</span>, <span class="number">51</span>, <span class="number">87</span>, <span class="number">80</span>, <span class="number">62</span>), (<span class="number">18</span>, <span class="number">22</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">68</span>, <span class="number">109</span>, <span class="number">103</span>, <span class="number">77</span>), (<span class="number">24</span>, <span class="number">35</span>, <span class="number">55</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">104</span>, <span class="number">113</span>, <span class="number">92</span>), (<span class="number">49</span>, <span class="number">64</span>, <span class="number">78</span>, <span class="number">87</span>, <span class="number">103</span>, <span class="number">121</span>, <span class="number">120</span>, <span class="number">101</span>), (<span class="number">72</span>, <span class="number">92</span>, <span class="number">95</span>, <span class="number">98</span>, <span class="number">112</span>, <span class="number">100</span>, <span class="number">103</span>, <span class="number">99</span>)), dtype=np.float32) </span></pre></td></tr><tr><td class="code"><pre><span class="line">Q2 = np.array(((<span class="number">17</span>, <span class="number">18</span>, <span class="number">24</span>, <span class="number">47</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>), (<span class="number">18</span>, <span class="number">21</span>, <span class="number">26</span>, <span class="number">66</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>), (<span class="number">24</span>, <span class="number">26</span>, <span class="number">56</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>), (<span class="number">47</span>, <span class="number">66</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>), (<span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>), (<span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>), (<span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>), (<span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>)), dtype=np.float32)</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core.hpp&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;complex&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">height</span> = <span class="number">128</span>, <span class="built_in">width</span> = <span class="number">128</span>, channel = <span class="number">3</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// DCT hyper-parameter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> T = <span class="number">8</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> K = <span class="number">8</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// DCT coefficient</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dct_str</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> coef[<span class="built_in">height</span>][<span class="built_in">width</span>][channel];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Discrete Cosine transformation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">dct_str <span class="title">dct</span><span class="params">(cv::Mat img, dct_str dct_s)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> I;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> Cu, Cv;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ys = <span class="number">0</span>; ys &lt; <span class="built_in">height</span>; ys += T)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> xs = <span class="number">0</span>; xs &lt; <span class="built_in">width</span>; xs += T)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; T; v ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; T; u ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            F = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (u == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Cu = <span class="number">1.</span> / <span class="built_in">sqrt</span>(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Cu = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (v == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Cv = <span class="number">1.</span> / <span class="built_in">sqrt</span>(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              Cv = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; T; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; T; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                I = (<span class="keyword">double</span>)img.at&lt;cv::Vec3b&gt;(ys + y, xs + x)[c];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                F += <span class="number">2.</span> / T * Cu * Cv * I * <span class="built_in">cos</span>((<span class="number">2.</span> * x + <span class="number">1</span>) * u * M_PI / <span class="number">2.</span> / T) * <span class="built_in">cos</span>((<span class="number">2.</span> * y + <span class="number">1</span>) * v * M_PI / <span class="number">2.</span> / T);</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            dct_s.coef[ys + v][xs + u][c] = F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> dct_s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Inverse Discrete Cosine transformation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">idct</span><span class="params">(cv::Mat out, dct_str dct_s)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> f;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> Cu, Cv;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ys = <span class="number">0</span>; ys &lt; <span class="built_in">height</span>; ys += T)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> xs = <span class="number">0</span>; xs &lt; <span class="built_in">width</span>; xs += T)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; T; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; T; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            f = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt; K; v++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="keyword">for</span> (<span class="keyword">int</span> u = <span class="number">0</span>; u &lt; K; u++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (u == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Cu = <span class="number">1.</span> / <span class="built_in">sqrt</span>(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Cu = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">if</span> (v == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Cv = <span class="number">1.</span> / <span class="built_in">sqrt</span>(<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125; <span class="keyword">else</span> &#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">                  Cv = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">                f += <span class="number">2.</span> / T * Cu * Cv * dct_s.coef[ys + v][xs + u][c] * <span class="built_in">cos</span>((<span class="number">2.</span> * x + <span class="number">1</span>) * u * M_PI / <span class="number">2.</span> / T) * <span class="built_in">cos</span>((<span class="number">2.</span> * y + <span class="number">1</span>) * v * M_PI / <span class="number">2.</span> / T);</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            f = fmin(fmax(f, <span class="number">0</span>), <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            out.at&lt;cv::Vec3b&gt;(ys + y, xs + x)[c] = (uchar)f;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Quantization</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">dct_str <span class="title">quantization</span><span class="params">(dct_str dct_s)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// Q table for Y</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> Q1[T][T] = &#123;&#123;<span class="number">16</span>, <span class="number">11</span>, <span class="number">10</span>, <span class="number">16</span>, <span class="number">24</span>, <span class="number">40</span>, <span class="number">51</span>, <span class="number">61</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#123;<span class="number">12</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">58</span>, <span class="number">60</span>, <span class="number">55</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#123;<span class="number">12</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">19</span>, <span class="number">26</span>, <span class="number">58</span>, <span class="number">60</span>, <span class="number">55</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#123;<span class="number">14</span>, <span class="number">17</span>, <span class="number">22</span>, <span class="number">29</span>, <span class="number">51</span>, <span class="number">87</span>, <span class="number">80</span>, <span class="number">62</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#123;<span class="number">18</span>, <span class="number">22</span>, <span class="number">37</span>, <span class="number">56</span>, <span class="number">68</span>, <span class="number">109</span>, <span class="number">103</span>, <span class="number">77</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#123;<span class="number">24</span>, <span class="number">35</span>, <span class="number">55</span>, <span class="number">64</span>, <span class="number">81</span>, <span class="number">104</span>, <span class="number">113</span>, <span class="number">92</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#123;<span class="number">49</span>, <span class="number">64</span>, <span class="number">78</span>, <span class="number">87</span>, <span class="number">103</span>, <span class="number">121</span>, <span class="number">120</span>, <span class="number">101</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#123;<span class="number">72</span>, <span class="number">92</span>, <span class="number">95</span>, <span class="number">98</span>, <span class="number">112</span>, <span class="number">100</span>, <span class="number">103</span>, <span class="number">99</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// Q table for Cb Cr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> Q2[T][T] = &#123;&#123;<span class="number">17</span>, <span class="number">18</span>, <span class="number">24</span>, <span class="number">47</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#123;<span class="number">18</span>, <span class="number">21</span>, <span class="number">26</span>, <span class="number">66</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#123;<span class="number">24</span>, <span class="number">26</span>, <span class="number">56</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#123;<span class="number">47</span>, <span class="number">66</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#123;<span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#123;<span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#123;<span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &#123;<span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>, <span class="number">99</span>&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> ys = <span class="number">0</span>; ys &lt; <span class="built_in">height</span>; ys += T)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> xs = <span class="number">0</span>; xs &lt; <span class="built_in">width</span>; xs += T)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; T; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; T; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          dct_s.coef[ys + y][xs + x][<span class="number">0</span>] = round(dct_s.coef[ys + y][xs + x][<span class="number">0</span>] / Q1[y][x]) * Q1[y][x];</span></pre></td></tr><tr><td class="code"><pre><span class="line">          dct_s.coef[ys + y][xs + x][<span class="number">1</span>] = round(dct_s.coef[ys + y][xs + x][<span class="number">1</span>] / Q2[y][x]) * Q2[y][x];</span></pre></td></tr><tr><td class="code"><pre><span class="line">          dct_s.coef[ys + y][xs + x][<span class="number">2</span>] = round(dct_s.coef[ys + y][xs + x][<span class="number">2</span>] / Q2[y][x]) * Q2[y][x];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> dct_s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// BGR -&gt; Y Cb Cr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">BGR2YCbCr</span><span class="params">(cv::Mat img, cv::Mat out)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//cv::Mat out = cv::Mat::zeros(height, width, CV_32F);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">height</span>; j ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">width</span>; i ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// Y</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">0</span>] = (<span class="keyword">int</span>)((<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(j,i)[<span class="number">0</span>] * <span class="number">0.114</span> + \</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(j,i)[<span class="number">1</span>] * <span class="number">0.5870</span> + \</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(j,i)[<span class="number">2</span>] * <span class="number">0.299</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// Cb</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">1</span>] = (<span class="keyword">int</span>)((<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(j,i)[<span class="number">0</span>] * <span class="number">0.5</span> + \</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(j,i)[<span class="number">1</span>] * (<span class="number">-0.3323</span>) + \</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(j,i)[<span class="number">2</span>] * (<span class="number">-0.1687</span>) + <span class="number">128</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// Cr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">2</span>] = (<span class="keyword">int</span>)((<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(j,i)[<span class="number">0</span>] * (<span class="number">-0.0813</span>) + \</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(j,i)[<span class="number">1</span>] * (<span class="number">-0.4187</span>) + \</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(j,i)[<span class="number">2</span>] * <span class="number">0.5</span> + <span class="number">128</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Y Cb Cr -&gt; BGR</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">YCbCr2BGR</span><span class="params">(cv::Mat ycbcr, cv::Mat out)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = out.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = out.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">height</span>; j ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">width</span>; i ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// R</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      val = ycbcr.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">0</span>] + (ycbcr.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">2</span>] - <span class="number">128</span>) * <span class="number">1.4102</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      val = fmin(<span class="number">255</span>, fmax(<span class="number">0</span>, val));</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">2</span>] = (uchar)val;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// G</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      val = ycbcr.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">0</span>] - (ycbcr.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">1</span>] - <span class="number">128</span>) * <span class="number">0.3441</span> - (ycbcr.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">2</span>] - <span class="number">128</span>) * <span class="number">0.7139</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      val = fmin(<span class="number">255</span>, fmax(<span class="number">0</span>, val));</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">1</span>] = (uchar)val;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// B</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      val = ycbcr.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">0</span>] + (ycbcr.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">1</span>] - <span class="number">128</span>) * <span class="number">1.7718</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      val = fmin(<span class="number">255</span>, fmax(<span class="number">0</span>, val));</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;cv::Vec3b&gt;(j, i)[<span class="number">0</span>] = (uchar)val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Compute MSE</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">MSE</span><span class="params">(cv::Mat img1, cv::Mat img2)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> mse = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mse += <span class="built_in">pow</span>(((<span class="keyword">double</span>)img1.at&lt;cv::Vec3b&gt;(y, x)[c] - (<span class="keyword">double</span>)img2.at&lt;cv::Vec3b&gt;(y, x)[c]), <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  mse /= (<span class="built_in">height</span> * <span class="built_in">width</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> mse;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Compute PSNR</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">PSNR</span><span class="params">(<span class="keyword">double</span> mse, <span class="keyword">double</span> v_max)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="number">10</span> * <span class="built_in">log10</span>(v_max * v_max / mse);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Compute bitrate</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">BITRATE</span><span class="params">()</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> T * K * K / T * T;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Main</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> mse;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> psnr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> bitrate;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// read original image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat img = cv::imread(<span class="string">"imori.jpg"</span>, cv::IMREAD_COLOR);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// DCT coefficient</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  dct_str dct_s;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// output image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat ycbcr = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_32FC3);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC3);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// BGR -&gt; Y Cb Cr</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ycbcr = BGR2YCbCr(img, ycbcr);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// DCT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  dct_s = dct(ycbcr, dct_s);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// Quantization</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  dct_s = quantization(dct_s);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// IDCT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  ycbcr = idct(ycbcr, dct_s);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// Y Cb Cr -&gt; BGR</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  out = YCbCr2BGR(ycbcr, out);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// MSE, PSNR</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  mse = MSE(img, out);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  psnr = PSNR(mse, <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  bitrate = BITRATE();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"MSE: "</span> &lt;&lt; mse &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"PSNR: "</span> &lt;&lt; psnr &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"bitrate: "</span> &lt;&lt; bitrate &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::imwrite(<span class="string">"out.jpg"</span>, out);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//cv::imshow("answer", out);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//cv::waitKey(0);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::destroyAllWindows();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Image Processing</category>
      </categories>
      <tags>
        <tag>Image Processing</tag>
      </tags>
  </entry>
  <entry>
    <title>TensorRT</title>
    <url>/2021/07/25/TensorRT/</url>
    <content><![CDATA[<h2 id="TensorRT"><a href="#TensorRT" class="headerlink" title="TensorRT"></a>TensorRT</h2><p><strong>下面是根据何成杰 NVIDIA高级软件架构师的分享出的PPT进行了一些笔记摘录</strong></p>
<h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>用于高性能深度学习推理的 SDK ，在生产环境中优化和部署神经网络，功能如下：</p>
<ul>
<li>使用编译器和运行时，最大化延迟关键应用的吞吐量 </li>
<li>使用 INT8 和 FP16 优化部署，响应迅速且内存高效的应用程序 </li>
<li>优化每个网络，包括 CNN、RNN 和 Transformer </li>
<li>通过 ONNX 支持、原生 TensorRT 集成加速每个框架</li>
<li>在具有容器化推理服务器的节点上运行多个模型 </li>
</ul>
<p><img src="/2021/07/25/TensorRT/tensorRT1.png" alt="TensorRT"></p>
<h4 id="二、TensorRT优化"><a href="#二、TensorRT优化" class="headerlink" title="二、TensorRT优化"></a>二、TensorRT优化</h4><ul>
<li><p>层和张量融合</p>
<ul>
<li>垂直融合</li>
<li>水平融合</li>
<li>层消除</li>
<li>层合并</li>
</ul>
<p>左边为未优化的网络，右边为使用TensorRT优化的网络</p>
<p><img src="/2021/07/25/TensorRT/tensorRT2.png" alt="TensorRT"></p>
</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>Network</th>
<th>Layers before</th>
<th>Layers after</th>
</tr>
</thead>
<tbody>
<tr>
<td>VGG19</td>
<td>43</td>
<td>27</td>
</tr>
<tr>
<td>Inception V3</td>
<td>309</td>
<td>113</td>
</tr>
<tr>
<td>ResNet-152</td>
<td>670</td>
<td>159</td>
</tr>
</tbody>
</table>
</div>
<p><strong>Supported Layer Fusions</strong></p>
<ol>
<li>Convolution and ReLUActivation</li>
<li>FullyConnectedand ReLUActivation</li>
<li>Scale and Activation</li>
<li>Convolution And ElementWiseSum</li>
<li>Shuffle and Reduce</li>
<li>Shuffle and Shuffle</li>
<li>Scale(add 0, multiply by 1)</li>
<li>Convolution and Scale</li>
<li>Reduce</li>
</ol>
<ul>
<li><p>重量和激活精密校准 </p>
</li>
<li><p>内核自动调优 </p>
<p><strong>Multiple factors:</strong></p>
<ul>
<li>Target platform</li>
<li>Batch size</li>
<li>Input dimensions</li>
<li>Filter dimensions</li>
<li>Tensor layout</li>
</ul>
<p><strong>Choice:</strong></p>
<ul>
<li>Implementation of specific algorithm</li>
<li>Kernels</li>
<li>Tensor Layouts</li>
</ul>
</li>
<li><p>动态张量内存 </p>
</li>
</ul>
<p>优化是完全自动的 ，使用单个函数调用执行 </p>
<h4 id="三、FP16，INT8-Precision-calibration"><a href="#三、FP16，INT8-Precision-calibration" class="headerlink" title="三、FP16，INT8 Precision calibration"></a>三、FP16，INT8 Precision calibration</h4><p><strong>利用降低精度功能：</strong> </p>
<ul>
<li>FP16 (Tesla V100): 125 TflopsFP16 vs 15.7 TflopsFP32</li>
<li>INT8 (T4, 70W): 130 INT8 TOPS vs 8.1 TflopsFP32</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>精度</th>
<th>动态范围</th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>FP32</strong></td>
<td>-3.4x10<SUP>38</SUP> ~ +3.4x10<SUP>38</SUP></td>
<td>训练的精度</td>
</tr>
<tr>
<td><strong>FP16</strong></td>
<td>-65504 ~ +65504</td>
<td>无需校正</td>
</tr>
<tr>
<td><strong>INT8</strong></td>
<td>-128 ~ +128</td>
<td>需要校正</td>
</tr>
</tbody>
</table>
</div>
<p><strong>INT8推理的精度校准：</strong> </p>
<ul>
<li>在校准数据集上最大限度地减少 FP32 和 INT8 推理之间的信息丢失 </li>
<li>完全自动化</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th></th>
<th><strong>FP32 Top 1</strong></th>
<th><strong>INT8 Top 1</strong></th>
<th><strong>Difference</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Googlenet</strong></td>
<td><strong>68.87%</strong></td>
<td><strong>68.49%</strong></td>
<td><strong>0.38%</strong></td>
</tr>
<tr>
<td><strong>VGG</strong></td>
<td><strong>68.56%</strong></td>
<td><strong>68.45%</strong></td>
<td><strong>0.11%</strong></td>
</tr>
<tr>
<td><strong>Resnet-50</strong></td>
<td><strong>73.11%</strong></td>
<td><strong>72.54%</strong></td>
<td><strong>0.57%</strong></td>
</tr>
<tr>
<td><strong>Resnet-152</strong></td>
<td><strong>75.18%</strong></td>
<td><strong>74.56%</strong></td>
<td><strong>0.61%</strong></td>
</tr>
</tbody>
</table>
</div>
<h4 id="四、TensorRT工作流"><a href="#四、TensorRT工作流" class="headerlink" title="四、TensorRT工作流"></a>四、TensorRT工作流</h4><p>1、工作流1 使用优化的训练模型直接进行推理 </p>
<p><img src="/2021/07/25/TensorRT/tensorRT3.png" alt="TensorRT"></p>
<p>2、工作流2 </p>
<ol>
<li><p>优化训练模型</p>
<p><img src="/2021/07/25/TensorRT/tensorRT4.png" alt="TensorRT"></p>
</li>
<li><p>使用运行时部署优化计划 </p>
<p><img src="/2021/07/25/TensorRT/tensorRT5.png" alt="TensorRT"></p>
</li>
</ol>
<p>44 / 5000</p>
<p><strong>使用网络定义 API 来定义网络</strong> </p>
<h4 id="五、序列化"><a href="#五、序列化" class="headerlink" title="五、序列化"></a>五、序列化</h4><p>序列化和反序列化是可选的，用于存储和以后使用。 序列化引擎不能跨平台或 TensorRT 版本移植。 </p>
<h4 id="六、量化处理"><a href="#六、量化处理" class="headerlink" title="六、量化处理"></a>六、量化处理</h4><p>量化意识训练 ：提高了 INT8 推理的准确性 </p>
<ul>
<li>与训练后量化 (PTQ) 相比，准确度更高 </li>
<li>以最小的精度损失量化最先进的模型 </li>
<li>基于 PyTorch中的OSS量化工具包，支持 QAT、PTQ 和导出到 ONNX </li>
<li>TensorRT 在不影响性能的情况下优化 Q/DQ 图进行推理 </li>
</ul>
<h4 id="七、稀疏支持"><a href="#七、稀疏支持" class="headerlink" title="七、稀疏支持"></a>七、稀疏支持</h4><p>通过稀疏性以低延迟最大化吞吐量 </p>
<ul>
<li>具有 2:4 细粒度结构稀疏性的新优化可提高性能，将权重减少一半 </li>
<li>ASP (Automatic SParsity) 提供易于使用的工作流程来诱导稀疏性，同时保持原始密集网络的准确性 </li>
<li>TensorRT 使用稀疏内核加速推理 </li>
</ul>
<h4 id="八、TRANSFORMER-OPTIMIZATIONS"><a href="#八、TRANSFORMER-OPTIMIZATIONS" class="headerlink" title="八、TRANSFORMER OPTIMIZATIONS"></a>八、TRANSFORMER OPTIMIZATIONS</h4><p>基于 Transformer 的网络的高性能融合内核生成 ，在生产环境中部署高度优化的基于 Transformers 的应用程序 。</p>
<ul>
<li>编译器融合多个操作，减少内核数量和执行时间 </li>
<li>消除网络中的转置操作，全局地加速 GEMMs</li>
<li>TensorRT 为 Transformer 构建块生成高度优化的内核，例如 MultiheadAttention </li>
</ul>
<h4 id="九、全新的全连接层优化"><a href="#九、全新的全连接层优化" class="headerlink" title="九、全新的全连接层优化"></a>九、全新的全连接层优化</h4><p>加速基于 MLP 的网络 </p>
<ul>
<li>用 1x1 卷积替换全连接层，提高计算速度 </li>
<li>FullConnectedLayers 中的新优化可提高 MLP、BERT 等网络的性能 </li>
<li>在 INT8 模式下使用 Tensor Core 提高性能。 </li>
</ul>
<h4 id="十、循环神经网络的优化"><a href="#十、循环神经网络的优化" class="headerlink" title="十、循环神经网络的优化"></a>十、循环神经网络的优化</h4><p>在生产环境中部署高度优化的对话式 AI 应用程序 </p>
<ul>
<li>用于定义在 RNN 中找到的循环的新 API </li>
<li>编译器融合 pointwise ops，生成优化的内核，并跨时间步融合 ops </li>
<li>在 300 毫秒内运行 ASR、NLU 和 TTS，这是实时应用程序的要求，10 倍性能与 CPU </li>
<li>支持的模型：BERT、MT-DNN、RoBERTa、Tacotron2、WaveRNN、DeepASR、GNMT、LSTM Peephole、LSTM Autoencoder </li>
</ul>
<p><strong>可变输入尺寸支持</strong>，<strong>可变批量支持</strong> ，<strong>使用 MLP 进行神经协同过滤</strong> </p>
<p>最大化接收可变大小输入的应用程序的推理性能 </p>
<p><img src="/2021/07/25/TensorRT/tensorRT6.png" alt="TensorRT"></p>
<h2 id="Triton"><a href="#Triton" class="headerlink" title="Triton"></a>Triton</h2><p>一种模式的推理服务，带有一个/多个 GPU 卡（通常在一个容器中作为服务）。可以与K8S集群—多卡多节点推理服务（容器化服务编排工具集）作比较。</p>
<h4 id="一、TRITON-基本功能"><a href="#一、TRITON-基本功能" class="headerlink" title="一、TRITON 基本功能"></a>一、TRITON 基本功能</h4><ul>
<li>支持多种模型框架（TensorFlow、PyTorch、TensorRT、ONNX RT 和自定义后端）</li>
<li>CPU, GPU, Multi-GPU support</li>
<li>并发模型执行（CPU 级优化）</li>
<li>服务器 HTTP/REST、gRPC APIS </li>
<li>通过延迟和健康指标与编排系统和自动缩放器集成</li>
<li>模型管理、加载/卸载、模型更新 </li>
<li>开源，在 GitHub 和 NGCas docker 容器上每月发布一次 </li>
</ul>
<p><strong>架构图</strong></p>
<p><img src="/2021/07/25/TensorRT/tensorRT7.png" alt="TensorRT"></p>
<h4 id="二、TRITON-的主要设计理念"><a href="#二、TRITON-的主要设计理念" class="headerlink" title="二、TRITON 的主要设计理念"></a>二、TRITON 的主要设计理念</h4><p><strong>想象一下基于推理生命周期：</strong> </p>
<ul>
<li>支持多种模型框架 -&gt; 这受制于框架，应由框架解耦 -&gt; Backends </li>
<li>常用功能 <ul>
<li>常用后台管理 </li>
<li>模型管理——加载/卸载、模型更新、查询模型状态等</li>
<li>并发模型执行——实例管理  </li>
<li>请求队列分发和调度 </li>
<li>推理生命周期管理 <ul>
<li>推理请求的管理</li>
<li>推理响应的管理</li>
</ul>
</li>
</ul>
</li>
<li>GRPC相关<ul>
<li>GRPC服务器</li>
</ul>
</li>
</ul>
<p><strong>想象一下基于客户场景的抽象（注意：主要是模型类型相关）：</strong> </p>
<p>大致可以分为三类 ：</p>
<ul>
<li>简单的独立模型 </li>
<li>与模型管道集成 </li>
<li>有状态模型 </li>
</ul>
<ol>
<li>Stateless<ul>
<li>CV</li>
<li>默认调度器，动态批处理 </li>
</ul>
</li>
<li>Stateful（预测结果取决于之前的序列）<ul>
<li>NLP</li>
<li>序列批次 </li>
</ul>
</li>
<li>Ensemble<ul>
<li>模型管道 </li>
<li>每个模型都可以有自己的调度程序 </li>
</ul>
</li>
</ol>
<h4 id="三、模型组合"><a href="#三、模型组合" class="headerlink" title="三、模型组合"></a>三、模型组合</h4><ul>
<li>一个或多个模型的流水线以及这些模型之间输入和输出张量的连接 </li>
<li>用于数据预处理→推理→数据后处理等多模型的模型拼接或数据流转</li>
<li>收集每个步骤中的输出张量，根据规范将它们作为其他步骤的输入张量提供 </li>
<li>Ensemble 模型会继承所涉及模型的特性，因此请求头中的元数据必须符合 ensemble 内的模型 </li>
</ul>
<p><img src="/2021/07/25/TensorRT/tensorRT8.png" alt="TensorRT"></p>
<h4 id="四、框架后端和客户后端"><a href="#四、框架后端和客户后端" class="headerlink" title="四、框架后端和客户后端"></a>四、框架后端和客户后端</h4><ul>
<li>大多数基于框架的后端在Triton Github是独立的存储库</li>
<li>通常，客户只需要实现一个客户后端 <ul>
<li>模型可以具有非 ML 模型部分（BERT：标记器、特征提取器）。 Triton 后端 API 允许将这些类型的扩展集成到 Triton 中。 </li>
<li>API 还允许用户在 Triton 中集成他们自己的执行引擎实现作为自定义后端。 </li>
<li>好处： <ul>
<li>使用向后兼容的 C API 将代码实现为共享库 </li>
<li>利用完整的 Triton 功能集（与现有框架相同）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="五、Triton辅助功能"><a href="#五、Triton辅助功能" class="headerlink" title="五、Triton辅助功能"></a>五、Triton辅助功能</h4><h5 id="1、模型分析"><a href="#1、模型分析" class="headerlink" title="1、模型分析"></a>1、模型分析</h5><ul>
<li>模型分析器是一套工具，可根据特定的性能要求，提供有关如何在 Triton 中最佳优化单个或多个模型的分析和指导 </li>
<li>在选择正确的模型配置时，它可以帮助用户在吞吐量、延迟和 GPU 内存占用方面做出权衡决定 </li>
<li>提供两种基准测试功能： <ul>
<li>性能分析 - 测量不同客户端负载下的吞吐量 (inf/s) 和延迟 </li>
<li>内存分析 - 测量模型在不同配置下的 GPU 内存占用 </li>
</ul>
</li>
</ul>
<h5 id="2、内存分析"><a href="#2、内存分析" class="headerlink" title="2、内存分析"></a>2、内存分析</h5><ul>
<li>针对各种批量大小和请求并发值测量模型的 GPU 内存占用。 然后可以使用结果来确定最佳模型配置，在满足内存利用率要求的同时最大限度地提高性能 </li>
<li><strong>优化硬件使用：</strong>确定每个 GPU 可以加载的最大模型数量，减少所需的硬件，或权衡吞吐量 </li>
<li><strong>最大化模型吞吐量：</strong>确保放置在每个 GPU 上的模型总和不会超过可用内存和 GPU 利用率的特定阈值。 这最大限度地提高了您的硬件的吞吐量 </li>
<li><strong>提高可靠性：</strong>通过了解您在 GPU 上加载的模型不会超出其能力来消除内存不足错误 </li>
<li><strong>更好的硬件规模：</strong>使用内存要求确定运行模型所需的确切硬件数量 </li>
</ul>
<p><a href="https://docs.nvidia.com/deeplearning/sdk/inference-release-notes/index.htmlhttps://docs.nvidia.com/deeplearning/sdk/triton-inference-serverguide/docs/quickstart.html" target="_blank" rel="noopener">Triton官网学习资料</a></p>
<p><a href="https://github.com/NVIDIA/triton-inference-server" target="_blank" rel="noopener">开源Gitlab存储库</a></p>
]]></content>
      <categories>
        <category>Model Compression and Acceleration</category>
      </categories>
      <tags>
        <tag>Model Compression and Acceleration</tag>
      </tags>
  </entry>
  <entry>
    <title>Open-Neural-Network-Exchange</title>
    <url>/2021/07/25/Open-Neural-Network-Exchange/</url>
    <content><![CDATA[<h2 id="开放神经网络交换-Open-Neural-Network-Exchange"><a href="#开放神经网络交换-Open-Neural-Network-Exchange" class="headerlink" title="开放神经网络交换(Open Neural Network Exchange)"></a>开放神经网络交换(Open Neural Network Exchange)</h2><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><p>ONNX是微软和Facebook提出的用来表示深度学习模型的<strong>开放</strong>格式，其定义了一组和环境、平台均无关的标准格式，来增强各种AI模型的可交互性。</p>
<p>所以针对目前流行的一些训练框架训练的模型，如TensorFlow、Pytorch、MxNet或Paddle等。训练完毕后都可以将这些框架存储的模型统一转换为ONNX这种统一的格式进行存储，从而扩展了模型对于不同平台或环境的移植性。ONNX文件不仅仅存储了神经网络模型的权重，同时也存储了模型的结构信息以及网络中每一层的输入输出和一些其它的辅助信息。ONNX中包括如下三个关键部分：</p>
<ul>
<li>可扩展的计算图模型：定义了通用的计算图中间表示法（Intermediate Representation）。  </li>
<li>内置运算符集内置操作符集：<code>ai.onnx</code>和<code>ai.onnx.ml</code>，<code>ai.onnx</code>是默认的操作符集，主要针对神经网络模型，<code>ai.onnx.ml</code>主要适用于传统非神经网络机器学习模型。 </li>
<li>标准数据类型的定义：包括张量（tensors）、序列（sequences）和映射（maps）。</li>
</ul>
<p>ONNX规范有两个官方变体，主要区别在与支持的类型和默认的操作符集。ONNX神经网络变体只使用张量作为输入和输出；而作为支持传统机器学习模型的<code>ONNX-ML</code>，还可以识别序列和映射，<code>ONNX-ML</code>为支持非神经网络算法扩展了ONNX操作符集。</p>
<h4 id="二、ProtoBuf简述"><a href="#二、ProtoBuf简述" class="headerlink" title="二、ProtoBuf简述"></a>二、ProtoBuf简述</h4><p>ONNX作为一个文件格式，自然需要一定的规则去读取想要的信息或者是写入需要保存的信息。ONNX使用的是<strong>Protobuf</strong>这个序列化数据结构去存储神经网络的权重信息。</p>
<p>Protobuf是一种轻便高效的结构化数据存储格式，可以用于结构化数据串行化，或者说序列化。它很适合做数据存储或数据交换格式。可用于通讯协议、数据存储等领域的语言无关、平台无关、可扩展的序列化结构数据格式。目前提供了 C++、Java、Python 三种语言的 API（摘自官方介绍）。</p>
<p>Protobuf协议是一个以<code>*.proto</code>后缀文件为基础的，这个文件描述了用户自定义的数据结构。</p>
<h4 id="三、ONNX格式分析"><a href="#三、ONNX格式分析" class="headerlink" title="三、ONNX格式分析"></a>三、ONNX格式分析</h4><p>ONNX中最核心的部分就是<code>onnx.proto</code>这个文件了，它定义了ONNX这个数据协议的规则和一些其它信息。地址在<code>https://github.com/onnx/onnx/blob/master/onnx/onnx.proto</code>。其中的一些关键字段为：</p>
<ul>
<li><code>ModelProto</code></li>
<li><code>GraphProto</code></li>
<li><code>NodeProto</code></li>
<li><code>ValueInfoProto</code></li>
<li><code>TensorProto</code></li>
<li><code>AttributeProto</code></li>
</ul>
<p>当我们加载了一个ONNX之后，我们获得的就是一个<code>ModelProto</code>，它包含了一些版本信息，生产者信息和一个<code>GraphProto</code>。在<code>GraphProto</code>里面又包含了四个<code>repeated</code>数组，它们分别是<code>node</code>(<code>NodeProto</code>类型)，<code>input</code>(<code>ValueInfoProto</code>类型)，<code>output</code>(<code>ValueInfoProto</code>类型)和<code>initializer</code>(<code>TensorProto</code>类型)，其中<code>node</code>中存放了模型中所有的计算节点，<code>input</code>存放了模型的输入节点，<code>output</code>存放了模型中所有的输出节点，<code>initializer</code>存放了模型的所有权重参数。</p>
<p>我们知道要完整的表达一个神经网络，不仅仅要知道网络的各个节点信息，还要知道它们的拓扑关系。这个拓扑关系在ONNX中是如何表示的呢？ONNX的每个计算节点都会有<code>input</code>和<code>output</code>两个数组，这两个数组是string类型，通过<code>input</code>和<code>output</code>的指向关系，我们就可以利用上述信息快速构建出一个深度学习模型的拓扑图。这里要注意一下，<code>GraphProto</code>中的<code>input</code>数组不仅包含我们一般理解中的图片输入的那个节点，还包含了模型中所有的权重。例如，<code>Conv</code>层里面的<code>W</code>权重实体是保存在<code>initializer</code>中的，那么相应的会有一个同名的输入在<code>input</code>中，其背后的逻辑应该是把权重也看成模型的输入，并通过<code>initializer</code>中的权重实体来对这个输入做初始化，即一个赋值的过程。</p>
<p>最后，每个计算节点中还包含了一个<code>AttributeProto</code>数组，用来描述该节点的属性，比如<code>Conv</code>节点或者说卷积层的属性包含<code>group</code>，<code>pad</code>，<code>strides</code>等等，每一个计算节点的属性，输入输出信息都详细记录在<code>https://github.com/onnx/onnx/blob/master/docs/Operators.md</code>。</p>
<h4 id="四、PyTorch转换模型到ONNX"><a href="#四、PyTorch转换模型到ONNX" class="headerlink" title="四、PyTorch转换模型到ONNX"></a>四、PyTorch转换模型到ONNX</h4><p>1、到处预训练的AlexNet到一个ONNX文件，名为alexnet.onnx</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">dummy_input = torch.randn(<span class="number">10</span>,<span class="number">3</span>,<span class="number">224</span>,<span class="number">224</span>,device=<span class="string">"cuda"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">model = torchvision.models.alexnet(pretrained=<span class="literal">True</span>).cuda()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">input_names = [ <span class="string">"actual_input_1"</span> ] + [ <span class="string">"learned_%d"</span> % i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">16</span>) ]</span></pre></td></tr><tr><td class="code"><pre><span class="line">output_names = [ <span class="string">"output1"</span> ]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">torch.onnx.export(model, dummy_input, <span class="string">"alexnet.onnx"</span>, verbose=<span class="literal">True</span>, input_names=input_names, output_names=output_names)</span></pre></td></tr></table></figure>
<p>在导出的alexnet.onnx文件中包含了一个二进制的protocol buffer，其中包含了网络结构和模型的参数。设置<code>verbose=True</code>是为了让模型的人眼可读性更好。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment">#验证ONNX库</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#安装onnx</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">conda install -c conda-forge onnx</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#运行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> onnx</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#加载onnx模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">model = onnx.load(<span class="string">"alexnet.onnx"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#检查模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">onnx.checker.check_model(model)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#打印人类可读的图的表示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(onnx.helper.printable_graph(model.graph))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#使用ONNX runtimes运行onnx导出模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> onnxruntime <span class="keyword">as</span> ort</span></pre></td></tr><tr><td class="code"><pre><span class="line">ort_session = ort.InferenceSession(<span class="string">"alexnet.onnx"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">outputs = ort_session.run(</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="literal">None</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;<span class="string">"actual_input_1"</span>: np.random.randn(<span class="number">10</span>,<span class="number">3</span>,<span class="number">224</span>,<span class="number">224</span>).astype(np.float32)&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">)</span></pre></td></tr><tr><td class="code"><pre><span class="line">print(outputs[<span class="number">0</span>])</span></pre></td></tr></table></figure>
<p>在内部，torch.onnx.export() 需要 torch.jit.ScriptModule 而不是 torch.nn.Module。 如果传入的模型还不是 ScriptModule，export() 将使用跟踪对其进行转换。 </p>
<h5 id="1、跟踪-Tracing"><a href="#1、跟踪-Tracing" class="headerlink" title="1、跟踪(Tracing)"></a>1、跟踪(Tracing)</h5><p>如果用一个还不是<code>ScriptModule</code> 的模块调用<code>torch.onnx.export()</code>，它首先执行与<code>torch.jit.trace()</code> 等效的操作。它使用给定的 args 执行一次模型并记录在执行期间发生的所有操作。 这意味着如果您的模型是动态的，例如根据输入数据改变行为，导出的模型将不会捕获这种动态行为(因为PyTorch是动态执行的，下一步的数据需要根据上一步的结果获得，与TensorFlow执行的静态图不同，所以转换PyTorch模型到ONNX的DAG(<strong>有向无环图</strong>)的时候存在较大的差异性)。 同样，跟踪可能仅对<strong>特定输入大小有效</strong>。 我们建议检查导出的模型并确保操作符看起来合理。 <strong>跟踪将展开循环和 if 语句</strong>，导出与跟踪运行完全相同的静态图。 <strong>如果要使用动态控制流导出模型，则需要使用脚本。</strong> 上面展开循环和if语句后，如果输入的数据不同而选择不同的分支，则需要单独处理这种情况。</p>
<h5 id="2、脚本-scripting"><a href="#2、脚本-scripting" class="headerlink" title="2、脚本(scripting)"></a>2、脚本(scripting)</h5><p>通过脚本编译模型可以保留动态控制流，并且对不同大小的输入有效。 要使用脚本： </p>
<ul>
<li>Use <a href="https://pytorch.org/docs/master/generated/torch.jit.script.html#torch.jit.script" target="_blank" rel="noopener"><code>torch.jit.script()</code></a> to produce a <code>ScriptModule</code>.</li>
<li>Call <code>torch.onnx.export()</code> with the <code>ScriptModule</code> as the model, and set the <code>example_outputs</code> arg. This is required so that the types and shapes of the outputs can be captured without executing the model.<a href="https://pytorch.org/docs/master/onnx.html#id5" target="_blank" rel="noopener">参考</a></li>
</ul>
<h5 id="3、一些需要避免的坑"><a href="#3、一些需要避免的坑" class="headerlink" title="3、一些需要避免的坑"></a>3、一些需要避免的坑</h5><ol>
<li><p>避免使用 NumPy 和内置 Python 类型 </p>
<p>PyTorch 模型可以使用 NumPy 或 Python 类型和函数编写，但在跟踪过程中，任何 NumPy 或 Python 类型（而不是 torch.Tensor）的变量都会转换为常量，如果这些值应根据输入而改变，那么该操作将产生错误的结果。 </p>
</li>
<li><p>避免 Tensor.data </p>
<p>使用 Tensor.data 字段会产生不正确的轨迹，因此会产生不正确的 ONNX 图。 改用 torch.Tensor.detach() 。</p>
</li>
</ol>
<h5 id="4、一些限制"><a href="#4、一些限制" class="headerlink" title="4、一些限制"></a>4、一些限制</h5><ul>
<li>仅 torch.Tensors和数字类型（例如 float、int）可以简单地转换为 torch.Tensors 。以及这些类型的元组和列表支持作为模型输入或输出。 在跟踪模式下接受 dict 和 str 输入和输出，但是： <ul>
<li>任何依赖于 dict 或 str 输入值的计算都将替换为在一次跟踪执行期间看到的常量值。 </li>
<li>任何作为 dict 的输出都将被其值的扁平序列无声地替换（键将被删除）。 例如。 {“foo”: 1, “bar”: 2} 变成 (1, 2)。 </li>
</ul>
</li>
<li>由于 ONNX 对嵌套序列的支持有限，脚本模式不支持某些涉及元组和列表的操作。 特别是不支持将元组附加到列表中。 在跟踪模式下，嵌套序列将在跟踪过程中自动展平。 </li>
</ul>
<h5 id="5、运算符实现的差异"><a href="#5、运算符实现的差异" class="headerlink" title="5、运算符实现的差异"></a>5、运算符实现的差异</h5><p>由于操作符实现的差异，在不同的运行时运行导出的模型可能会产生不同的结果，或者与 PyTorch 不同。 通常，这些差异在数值上很小，因此只有当您的应用程序对这些小差异敏感时，才应该考虑这一点。 </p>
<h5 id="6、不受支持的张量索引模式"><a href="#6、不受支持的张量索引模式" class="headerlink" title="6、不受支持的张量索引模式"></a>6、不受支持的张量索引模式</h5><h5 id="7、添加对运算符的支持"><a href="#7、添加对运算符的支持" class="headerlink" title="7、添加对运算符的支持"></a>7、添加对运算符的支持</h5><p>导出包含不受支持的运算符的模型时，您将看到如下错误消息： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RuntimeError: ONNX export failed: Couldn&#39;t export operator foo</span></pre></td></tr></table></figure>
<p>发生这种情况时，您需要更改模型以不使用该运算符，或者添加对运算符的支持。 具体实现根据需要查阅相关内容。</p>
<p>ATen 是 PyTorch 的内置张量库。</p>
<h4 id="五、ONNX-Runtime"><a href="#五、ONNX-Runtime" class="headerlink" title="五、ONNX Runtime"></a>五、ONNX Runtime</h4><p>ONNX Runtime 是一个以性能为中心的 ONNX 模型引擎，它可以跨多个平台和硬件（Windows、Linux 和 Mac 以及 CPU 和 GPU）高效地进行推理。 事实证明，ONNX 运行时可显着提高多个模型的性能。</p>
<p>1、安装 ONNX 和 ONNX Runtime。 </p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">pip install onnx</span></pre></td></tr><tr><td class="code"><pre><span class="line">pip install onnxruntime</span></pre></td></tr></table></figure>
<p>获得 ONNX 和 ONNX Runtime 的二进制版本。 请注意，ONNX 运行时与 Python 版本 3.5<strong>到</strong>3.7 兼容。 </p>
<p>下面给出官网列出的一个超分辨率模型导出的事例：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Some standard imports</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> torch <span class="keyword">import</span> nn</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.utils.model_zoo <span class="keyword">as</span> model_zoo</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.onnx</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Super Resolution model definition in PyTorch</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn <span class="keyword">as</span> nn</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch.nn.init <span class="keyword">as</span> init</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SuperResolutionNet</span><span class="params">(nn.Module)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, upscale_factor, inplace=False)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        super(SuperResolutionNet, self).__init__()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.relu = nn.ReLU(inplace=inplace)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.conv1 = nn.Conv2d(<span class="number">1</span>, <span class="number">64</span>, (<span class="number">5</span>, <span class="number">5</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">2</span>, <span class="number">2</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.conv2 = nn.Conv2d(<span class="number">64</span>, <span class="number">64</span>, (<span class="number">3</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.conv3 = nn.Conv2d(<span class="number">64</span>, <span class="number">32</span>, (<span class="number">3</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.conv4 = nn.Conv2d(<span class="number">32</span>, upscale_factor ** <span class="number">2</span>, (<span class="number">3</span>, <span class="number">3</span>), (<span class="number">1</span>, <span class="number">1</span>), (<span class="number">1</span>, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        self.pixel_shuffle = nn.PixelShuffle(upscale_factor)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        self._initialize_weights()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        x = self.relu(self.conv1(x))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x = self.relu(self.conv2(x))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x = self.relu(self.conv3(x))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x = self.pixel_shuffle(self.conv4(x))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> x</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_initialize_weights</span><span class="params">(self)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        init.orthogonal_(self.conv1.weight, init.calculate_gain(<span class="string">'relu'</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        init.orthogonal_(self.conv2.weight, init.calculate_gain(<span class="string">'relu'</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        init.orthogonal_(self.conv3.weight, init.calculate_gain(<span class="string">'relu'</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">        init.orthogonal_(self.conv4.weight)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Create the super-resolution model by using the above model definition.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">torch_model = SuperResolutionNet(upscale_factor=<span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#在导出模型之前调用 torch_model.eval() 或 torch_model.train(False) 很重要，以将模型转换为推理模式。 这是必需的，因为 dropout 或 batchnorm 等运算符在推理和训练模式下的行为不同。 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Load pretrained model weights</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">model_url = <span class="string">'https://s3.amazonaws.com/pytorch/test_data/export/superres_epoch100-44c6958e.pth'</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">batch_size = <span class="number">1</span>    <span class="comment"># just a random number</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Initialize model with the pretrained weights</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">map_location = <span class="keyword">lambda</span> storage, loc: storage</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> torch.cuda.is_available():</span></pre></td></tr><tr><td class="code"><pre><span class="line">    map_location = <span class="literal">None</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">torch_model.load_state_dict(model_zoo.load_url(model_url, map_location=map_location))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># set the model to inference mode</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">torch_model.eval()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#在 PyTorch 中导出模型是通过跟踪或脚本编写的。 上例将使用通过跟踪导出模型作为示例。 要导出模型，需要调用torch.onnx.export()函数。该操作将执行模型，记录用于计算输出的运算符的跟踪。 因为 export 运行模型，所以需要提供一个输入张量 x。 只要它是正确的类型和大小，其中的值可以是随机的。 请注意，除非指定为动态轴(dynamic_axes )，否则所有输入维度的导出 ONNX 图中的输入大小将是固定的。 在此示例中，我们使用 batch_size=1的输入导出模型，但随后在 torch.onnx.export() 的 dynamic_axes 参数中将第一个维度指定为动态。 因此，导出的模型将接受大小为 [batch_size, 1, 224, 224] 的输入，其中 batch_size 可以是可变的。 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Input to the model</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">x = torch.randn(batch_size, <span class="number">1</span>, <span class="number">224</span>, <span class="number">224</span>, requires_grad=<span class="literal">True</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">torch_out = torch_model(x)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Export the model</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">torch.onnx.export(torch_model,               <span class="comment"># model being run</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                  x,                         <span class="comment"># model input (or a tuple for multiple inputs)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                  <span class="string">"super_resolution.onnx"</span>,   <span class="comment"># where to save the model (can be a file or file-like object)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                  export_params=<span class="literal">True</span>,        <span class="comment"># store the trained parameter weights inside the model file</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                  opset_version=<span class="number">10</span>,          <span class="comment"># the ONNX version to export the model to</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                  do_constant_folding=<span class="literal">True</span>,  <span class="comment"># whether to execute constant folding for optimization</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                  input_names = [<span class="string">'input'</span>],   <span class="comment"># the model's input names</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                  output_names = [<span class="string">'output'</span>], <span class="comment"># the model's output names</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                  dynamic_axes=&#123;<span class="string">'input'</span> : &#123;<span class="number">0</span> : <span class="string">'batch_size'</span>&#125;,    <span class="comment"># variable length axes</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                                <span class="string">'output'</span> : &#123;<span class="number">0</span> : <span class="string">'batch_size'</span>&#125;&#125;)</span></pre></td></tr></table></figure>
<p>但是在使用 ONNX Runtime 验证模型的输出之前，我们将使用 ONNX 的 API 检查 ONNX 模型。 首先，onnx.load(“super_resolution.onnx”) 将加载保存的模型并输出 onnx.ModelProto 结构。 然后，onnx.checker.check_model(onnx_model) 将验证模型的结构并确认模型具有有效的模式。 ONNX 图的有效性通过检查模型的版本、图的结构以及节点及其输入和输出来验证。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> onnx</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">onnx_model = onnx.load(<span class="string">"super_resolution.onnx"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">onnx.checker.check_model(onnx_model)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#为了使用 ONNX Runtime运行模型，我们需要使用所选的配置参数（这里我们使用默认配置）为模型创建推理会话。 创建会话后，我们使用 run() api评估模型。 此调用的输出是一个列表，其中包含 ONNX Runtime 计算出的模型的输出。 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> onnxruntime</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">ort_session = onnxruntime.InferenceSession(<span class="string">"super_resolution.onnx"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">to_numpy</span><span class="params">(tensor)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> tensor.detach().cpu().numpy() <span class="keyword">if</span> tensor.requires_grad <span class="keyword">else</span> tensor.cpu().numpy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># compute ONNX Runtime output prediction</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ort_inputs = &#123;ort_session.get_inputs()[<span class="number">0</span>].name: to_numpy(x)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">ort_outs = ort_session.run(<span class="literal">None</span>, ort_inputs)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># compare ONNX Runtime and PyTorch results</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">np.testing.assert_allclose(to_numpy(torch_out), ort_outs[<span class="number">0</span>], rtol=<span class="number">1e-03</span>, atol=<span class="number">1e-05</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">print(<span class="string">"Exported model has been tested with ONNXRuntime, and the result looks good!"</span>)</span></pre></td></tr></table></figure>
<p><strong>使用 ONNX Runtime 在图像上运行模型</strong> </p>
<p>首先，让我们加载图像，使用标准 PIL python 库对其进行预处理。 请注意，此预处理是处理用于训练/测试神经网络的数据的标准做法。 首先，调整图像大小以适应模型输入的大小 (224x224)。 然后将图像分成 Y、Cb 和 Cr 分量。 这些分量代表灰度图像 (Y)，以及蓝色差 (Cb) 和红色差 (Cr) 色度分量。 Y 分量对人眼更敏感，对将要变换的这个分量感兴趣。 提取 Y 分量后，将其转换为张量，这将是模型的输入。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">img = Image.open(<span class="string">"./_static/img/cat.jpg"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">resize = transforms.Resize([<span class="number">224</span>, <span class="number">224</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">img = resize(img)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">img_ycbcr = img.convert(<span class="string">'YCbCr'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">img_y, img_cb, img_cr = img_ycbcr.split()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">to_tensor = transforms.ToTensor()</span></pre></td></tr><tr><td class="code"><pre><span class="line">img_y = to_tensor(img_y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">img_y.unsqueeze_(<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#运行超分辨率模型在Onnx runtime</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">ort_inputs = &#123;ort_session.get_inputs()[<span class="number">0</span>].name: to_numpy(img_y)&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">ort_outs = ort_session.run(<span class="literal">None</span>, ort_inputs)</span></pre></td></tr><tr><td class="code"><pre><span class="line">img_out_y = ort_outs[<span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#此时，上面是模型输出的一个张量。 现在，将处理模型的输出以从输出张量构造回最终输出图像，并保存图像。 此处的超分辨率模型的 PyTorch 实现采用了后处理步骤。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">img_out_y = Image.fromarray(np.uint8((img_out_y[<span class="number">0</span>] * <span class="number">255.0</span>).clip(<span class="number">0</span>, <span class="number">255</span>)[<span class="number">0</span>]), mode=<span class="string">'L'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># get the output image follow post-processing step from PyTorch implementation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">final_img = Image.merge(</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="string">"YCbCr"</span>, [</span></pre></td></tr><tr><td class="code"><pre><span class="line">        img_out_y,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        img_cb.resize(img_out_y.size, Image.BICUBIC),</span></pre></td></tr><tr><td class="code"><pre><span class="line">        img_cr.resize(img_out_y.size, Image.BICUBIC),</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ]).convert(<span class="string">"RGB"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Save the image, we will compare this with the output image from mobile device</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">final_img.save(<span class="string">"./_static/img/cat_superres_with_ort.jpg"</span>)</span></pre></td></tr></table></figure>
<h4 id="六、ONNX结构分析"><a href="#六、ONNX结构分析" class="headerlink" title="六、ONNX结构分析"></a>六、ONNX结构分析</h4><p>ONNX将每一个网络的每一层或者说是每一个算子当作节点Node，再由这些Node去构建一个Graph，相当于是一个网络。最后将Graph和这个onnx模型的其他信息结合在一起，生成一个model，也就是最终的.onnx的模型。根据原始模型生成架构的不同，转换的过程可能也不相同，如：PyTorch和TensorFlow。</p>
<p>onnx网络查看工具<a href="https://netron.app/" target="_blank" rel="noopener">netron</a></p>
<h4 id="七、ONNX导出函数分析"><a href="#七、ONNX导出函数分析" class="headerlink" title="七、ONNX导出函数分析"></a>七、ONNX导出函数分析</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">torch.onnx.export(model, <span class="comment">#(torch.nn.Module, torch.jit.ScriptModule or torch.jit.ScriptFunction)将被导出的模型</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				  args,  <span class="comment">#tuple or torch.Tensor 元组应包含模型输入，以便 model(*args) 是模型的有效调用。 任何非张量参数都将被硬编码到导出的模型中； 任何张量参数都将成为导出模型的输入，按照它们在元组中出现的顺序。 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				  f,     <span class="comment">#类文件对象或或包含文件名的字符串。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			      export_params=<span class="literal">True</span>, <span class="comment">#如果为 True，将导出所有参数。 如果要导出未经训练的模型，请将其设置为 False。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				  verbose=<span class="literal">False</span>,    <span class="comment">#如果为 True，则打印正在导出到标准输出的模型的描述。 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				  training=&lt;TrainingMode.EVAL: <span class="number">0</span>&gt;, <span class="comment">#TrainingMode.EVAL: 以推理模式导出模型；TrainingMode.PRESERVE: 如果 model.training 为 False，则在推理模式下导出模型，如果 model.training 为 True，则在训练模式下导出模型；TrainingMode.TRAINING:在训练模式下导出模型。 禁用可能干扰训练的优化。 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				  input_names=<span class="literal">None</span>,    <span class="comment">#按顺序分配给图的输入节点的名称。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				  output_names=<span class="literal">None</span>,   <span class="comment">#按顺序分配给图形输出节点的名称。 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				  aten=<span class="literal">False</span>,   <span class="comment">#operator_export_type=OperatorExportTypes.ONNX_ATEN，ATen部分有大量的代码是来声明和定义Tensor运算相关的逻辑的，实现Pytorch中tensor的加速</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				  operator_export_type=<span class="literal">None</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  opset_version=<span class="literal">None</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  _retain_param_name=<span class="literal">True</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  do_constant_folding=<span class="literal">True</span>,<span class="comment">#应用常量折叠优化。 常量折叠将用预先计算的常量节点替换一些具有所有常量输入的操作。 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				  example_outputs=<span class="literal">None</span>,    <span class="comment">#(T or a tuple of T, where T is Tensor or convertible to Tensor, default None)导出 ScriptModule 或 ScriptFunction 时必须提供，否则将被忽略。 用于在不跟踪模型执行的情况下确定输出的类型和形状。 单个对象被视为等同于一个元素的元组。 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				  strip_doc_string=<span class="literal">True</span>,   <span class="comment">#不包括导出模型中的字段 doc_string`。 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				  dynamic_axes=<span class="literal">None</span>,  <span class="comment">#默认情况下，导出的模型会将所有输入和输出张量的形状设置为与 args 中给出的形状（以及需要该 arg 时的 example_outputs）完全匹配。 要将张量轴指定为动态（即仅在运行时已知），请将 dynamic_axes 设置为具有模式的字典。KEY (str): 输入或输出名称。每个名称还必须在 input_names 或 output_names 中提供。VALUE (dict or list): 如果是字典，键是轴索引，值是轴名称。 如果是列表，则每个元素都是一个轴索引。 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				  keep_initializers_as_inputs=<span class="literal">None</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  custom_opsets=<span class="literal">None</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  enable_onnx_checker=<span class="literal">True</span>, <span class="comment">#如果为 True，将运行 onnx 模型检查器以确保导出的模型是有效的 ONNX 模型。 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				  use_external_data_format=<span class="literal">False</span>)  <span class="comment">#如果为 True，则某些模型参数存储在外部数据文件中，而不是存储在 ONNX 模型文件本身中。 由于协议缓冲区的大小限制，无法将大于 2GB 的模型导出到一个文件中。 有关详细信息，请参阅 onnx.proto。 如果为 True，则参数 f 必须是指定模型位置的字符串。 外部数据文件将存储在与 f 相同的目录中。 除非 operator_export_type=OperatorExportTypes.ONNX，否则将忽略此参数。</span></span></pre></td></tr></table></figure>
<p><a href="https://pytorch.org/tutorials/advanced/super_resolution_with_onnxruntime.html" target="_blank" rel="noopener">参考-ONNX-PyTorch</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/86867138" target="_blank" rel="noopener">参考-知乎</a></p>
<p><a href="https://blog.csdn.net/xjm850552586/article/details/114898679" target="_blank" rel="noopener">参考-CSDN</a></p>
]]></content>
      <categories>
        <category>Model Compression and Acceleration</category>
      </categories>
      <tags>
        <tag>Model Compression and Acceleration</tag>
      </tags>
  </entry>
  <entry>
    <title>Gitlab-CI-Automation-Deployment</title>
    <url>/2021/07/25/Gitlab-CI-Automation-Deployment/</url>
    <content><![CDATA[<h2 id="Gitlab-CI自动化部署"><a href="#Gitlab-CI自动化部署" class="headerlink" title="Gitlab CI自动化部署"></a>Gitlab CI自动化部署</h2><p><img src="/2021/07/25/Gitlab-CI-Automation-Deployment/1.jpg" alt="gitlab-ci"></p>
<h4 id="一、概念简述"><a href="#一、概念简述" class="headerlink" title="一、概念简述"></a>一、概念简述</h4><p>GitLab CI/CD 是一个内置在GitLab中的工具，其中集成了Continuous Integration (CI)  <strong>持续集成</strong>、Continuous Delivery (CD)     持续交付、Continuous Deployment (CD)   <strong>持续部署</strong>等功能。可以实现<strong>自动</strong>或<strong>手动</strong>的部署和测试等。</p>
<p><strong>持续集成</strong>的工作原理是将项目根目录下Git管理的代码块推送到Git仓库托管的远程代码分支上，并且每次推送时，都要运行一系列脚本来安装、构建、测试和验证代码的更改。</p>
<p><strong>持续交付(需要人工干预)和部署(自动部署)</strong>相当于更进一步的CI，可以在每次推送到仓库默认分支的同时将应用程序部署到生产环境。</p>
<h4 id="二、优点"><a href="#二、优点" class="headerlink" title="二、优点"></a>二、优点</h4><ul>
<li>可以在开发周期的早期发现bugs和errors，从而确保部署到生产环境的所有代码都符合为应用程序建立的代码标准。能够尽早地发现问题，解决问题，减少项目最终部署的成本。</li>
<li>软件开发的持续方法基于自动执行脚本，以最大程度地减少在开发应用程序时引入错误的机会。从开发新代码到部署新代码，他们几乎不需要人工干预，甚至根本不需要干预。 </li>
</ul>
<h4 id="三、工作过程"><a href="#三、工作过程" class="headerlink" title="三、工作过程"></a>三、工作过程</h4><ol>
<li>gitlab-ci提供了指定ci运行平台的机制，它提供了一个叫<strong>gitlab-runner</strong>的软件，只要在对应的平台(机器或docker)上下载并运行这个命令行软件，并输入从gitlab交互界面获取的token,就可以把当前机器和对应的gitlab-ci流程绑定。</li>
<li>根目录中创建<strong>.gitlab-ci.yml</strong>文件，用于控制CI流程的不同阶段。如：安装、构建、测试和部署的脚本和其他配置信息。</li>
<li>每当你push/merge一次，gitlab-ci都会检查项目的根目录下有没有.gitlab-ci.yml文件。如果有，它会执行你在里面编写的脚本，并完整地走一遍在.gitlab-ci.yml中配置的流程。</li>
</ol>
<h4 id="四、gitlab-ci涉及的抽象概念"><a href="#四、gitlab-ci涉及的抽象概念" class="headerlink" title="四、gitlab-ci涉及的抽象概念"></a>四、gitlab-ci涉及的抽象概念</h4><ol>
<li><h5 id="Pipeling-amp-Job"><a href="#Pipeling-amp-Job" class="headerlink" title="Pipeling &amp; Job"></a>Pipeling &amp; Job</h5><p>Pipeline是Gitlab根据项目的.gitlab-ci.yml文件执行的流程，它由许多个任务节点组成,    而这些Pipeline上的每一个任务节点，都是一个独立的Job。<strong>每个Job都会配置一个stage属性，来表示这个Job所处的阶段。</strong></p>
</li>
<li><h5 id="Runner"><a href="#Runner" class="headerlink" title="Runner"></a><strong>Runner</strong></h5><p>Runner可以理解为：<strong>在特定机器上</strong>根据项目的<strong>.gitlab-ci.yml</strong>文件，对项目执行pipeline的<strong>程序</strong>。Runner可以分为两种： <strong>Specific Runner</strong>(可以自定义，在自己选择的机器上运行runner程序，gitlab给我们提供了一个叫gitlab-runner的命令行软件，只要在对应机器上下载安装这个软件，并且运行gitlab-runner register命令，然后输入从gitlab-ci交互界面获取的token进行注册, 就可以在自己的机器上远程运行pipeline程序了) 和 <strong>Shared Runner</strong>(Gitlab平台提供的免费使用的runner程序，它由Google云平台提供支持，对CI时间有限制)。</p>
</li>
<li><p><strong>Executors</strong></p>
<p>GitLab Runner 实现了许多可用于在不同场景中运行构建的执行器。下表列出了GitLab Runner支持的一些执行器，并且不会在扩展去支持其他的一些执行器。执行器支持用于构建项目的不同平台和方法。 下表显示了每个 executor 的关键事实，这将帮助您决定使用哪个 executor。 </p>
<p><img src="/2021/07/25/Gitlab-CI-Automation-Deployment/table.png" alt="Gitlab-CI-Automation-Deployment"></p>
<p><a href="https://docs.gitlab.com/runner/executors/#selecting-the-executor" target="_blank" rel="noopener">参考链接</a></p>
</li>
<li><p><strong>.gitlab-ci.yml配置的特定关键字</strong></p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>关键字</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>stages</td>
<td>stages定义在YML文件的最外层，它的值是一个数组，用于定义一个pipeline不同的流程节点</td>
</tr>
<tr>
<td>stage</td>
<td>作为Job的子属性，是一个字符串，且是stages数组的一个子项，表示的是当前的pipeline节点</td>
</tr>
<tr>
<td>script</td>
<td>作为Job的子属性，当前pipeline节点运行的shell脚本</td>
</tr>
<tr>
<td>tags</td>
<td>作为Job的子属性，tags是当前Job的标记</td>
</tr>
</tbody>
</table>
</div>
<h4 id="五、实践"><a href="#五、实践" class="headerlink" title="五、实践"></a>五、实践</h4><p><strong>1、在平台上下载并安装Gitlab-runner命令行</strong></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">针对Linux平台</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">下在二进制包</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Linux x86-64</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo curl -L --output /usr/local/bin/gitlab-runner "https://gitlab-runner-downloads.s3.amazonaws.com/latest/binaries/gitlab-runner-linux-amd64"</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">修改用户的下载目录操作权限</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo chmod +x /usr/local/bin/gitlab-runner</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">创建一个Gitlab CI 用户</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo useradd --comment 'GitLab Runner' --create-home gitlab-runner --shell /bin/bash</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">Install</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo gitlab-runner install --user=gitlab-runner --working-directory=/home/gitlab-runner</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">Run as service</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo gitlab-runner start</span></pre></td></tr></table></figure>
<p><a href="https://docs.gitlab.com/runner/install/linux-manually.html" target="_blank" rel="noopener">参考官网的链接</a></p>
<p><strong>3、注册Runner</strong></p>
<p>注册前的需求</p>
<ul>
<li>安装gitlab-runner到部署服务器，而不是GitLab仓库所在的服务器</li>
<li>获取token<ul>
<li>For a <a href="https://docs.gitlab.com/ee/ci/runners/#shared-runners" target="_blank" rel="noopener">shared runner</a>, have an administrator go to the GitLab Admin Area and click <strong>Overview &gt; Runners</strong></li>
<li>For a <a href="https://docs.gitlab.com/ee/ci/runners/README.html#group-runners" target="_blank" rel="noopener">group runner</a>, go to <strong>Settings &gt; CI/CD</strong> and expand the <strong>Runners</strong> section</li>
<li>For a <a href="https://docs.gitlab.com/ee/ci/runners/README.html#specific-runners" target="_blank" rel="noopener">project-specific runner</a>, go to <strong>Settings &gt; CI/CD</strong> and expand the <strong>Runners</strong> section</li>
</ul>
</li>
</ul>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">针对Linux平台</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">1、sudo gitlab-runner register</span></pre></td></tr><tr><td class="code"><pre><span class="line">2、Enter your GitLab instance URL (also known as the gitlab-ci coordinator URL). </span></pre></td></tr><tr><td class="code"><pre><span class="line">3、Enter the token you obtained to register the runner. </span></pre></td></tr><tr><td class="code"><pre><span class="line">4、Enter a description for the runner. You can change this value later in the GitLab user interface. </span></pre></td></tr><tr><td class="code"><pre><span class="line">5、Enter the tags associated with the runner, separated by commas. You can change this value later in the GitLab user interface. </span></pre></td></tr><tr><td class="code"><pre><span class="line">6、Provide the runner executor. For most use cases, enter docker. </span></pre></td></tr><tr><td class="code"><pre><span class="line">7、If you entered docker as your executor, you’ll be asked for the default image to be used for projects that do not define one in .gitlab-ci.yml.</span></pre></td></tr></table></figure>
<p><a href="https://docs.gitlab.com/runner/register/index.html" target="_blank" rel="noopener">参考链接</a></p>
<p><strong>4、激活Runner</strong></p>
<p>注册完了可能还需要激活，如果在CI/CD面板中Runner显示的是黑色的感叹号，那么说明Runner已经注册成功了，但是还需要激活，如果显示绿色的话，说明已经激活，可以跳过本步。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo gitlab-runner verify</span></pre></td></tr></table></figure>
<p><strong>注意：</strong>gitlab-ci每次都会对比部署目录下面的文件夹，如果仓库中的文件夹在本地没有的话，那么每次push/merge的时候会删除部署环境中的文件夹。如果mysql/data在部署路径下， 但是仓库中没有mysql的目录，那么每次push就会删除数据库。简直是<strong>神不知，鬼不觉</strong>的删库跑路。所以为了避免这种情况，需要将mysql的环境在docker-compose中单独指定宿主机的一个目录，然后在映射到docker容器中，然后指定docker容器中mysql的配置文件即可。这里的原因可能有两个，一个是在选择exector的时候，根据前面说的，选择了会情况build环境的executor，另一个可能涉及到<strong>Cache</strong>这个关键字(但对于单Job的执行流程来说，尝试过设置Cache的path，但是没有卵用)。</p>
<p>Cache的出现是为了缓冲一些已经安装好的环境，<strong>以免</strong>每次push/merge的时候都需安装一些依赖的环境，导致整个pipeline的时间过长，降低效率。另一个是<strong>gitlab-ci在运行下一个Job的时候，会默认把前一个Job新增的资源删除干净。</strong></p>
<p><strong>cache的作用就是：</strong></p>
<ul>
<li><strong>在不同pipeline之间重用资源</strong></li>
<li><strong>在同一pipeline的不同Job之间重用资源</strong></li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/184936276" target="_blank" rel="noopener">参考资料</a></p>
]]></content>
      <categories>
        <category>Cloud Compute</category>
      </categories>
      <tags>
        <tag>Cloud Compute</tag>
      </tags>
  </entry>
  <entry>
    <title>Image-Process-Pattern-Recognition</title>
    <url>/2021/07/25/Image-Process-Pattern-Recognition/</url>
    <content><![CDATA[<h2 id="图像处理学习"><a href="#图像处理学习" class="headerlink" title="图像处理学习"></a>图像处理学习</h2><p><strong>模式识别</strong>主要介绍两大领域：<strong>决策理论方法</strong>和<strong>结构方法</strong>。第一类使用<strong>定量描述子</strong>来描述各种模式，就是由量化的值。第二类方法处理的是由<strong>定性描述子</strong>来描述的各种模式。</p>
<p><strong>模式</strong>是<strong>描述子</strong>的组合，也可以说是<strong>特征的组合</strong>。比如一个模式由两个用于描述的特征组成，长度和宽度。模式类是指具有某些共同属性的一族模式。模式类用&omega;<sub>1</sub>,&omega;<sub>2</sub>,…&omega;<sub>W</sub>表示，其中W是模式类数。模式组合的形式可以是向量(用于定量描述)，串和树(用于结构描述)，模式向量的分量便成为每个物理样本的完整描述。</p>
<p>经典的<strong>特征选择</strong>问题，即类的可分程度在很大程度上取决于所用的描述子的选择，也即特征的选择。</p>
<h4 id="一、基于决策理论方法的识别"><a href="#一、基于决策理论方法的识别" class="headerlink" title="一、基于决策理论方法的识别"></a>一、基于决策理论方法的识别</h4><p>以决策(或判别)函数为基础。令x=(x<sub>1</sub>,x<sub>2</sub>,…,x<sub>n</sub>)<sup>T</sup>表示一个n维模式向量。对于W个模式类&omega;<sub>1</sub>,&omega;<sub>2</sub>,…&omega;<sub>W</sub>，决策理论模式识别的基本问题是依据模式向量找出W个决策函数d<sub>1</sub>(x),d<sub>2</sub>(x),…,d<sub>W</sub>(x): 如果模式x属于类&omega;<sub>i</sub>，则</p>
<script type="math/tex; mode=display">
d_i(x)\gt d_j(x) \quad j=1,2,...,W;j\neq i</script><p>就是说将模式x代入W个决策函数中，找出其中使决策函数最大的模式类，作为模式x的模式类，称未知模式x属于第i个模式类。</p>
<p><strong>那么如何确定决策边界？</strong></p>
<script type="math/tex; mode=display">
通常使用单一函数d_{ij}(x)=d_i(x)-d_j=0来识别两类之间的决策边界。\\
对于模式类\omega_i有d_{ij}(x)\gt0,对于模式类\omega_j有d_{ij}(x)\lt0</script><h5 id="1-1-匹配"><a href="#1-1-匹配" class="headerlink" title="1.1 匹配"></a>1.1 匹配</h5><p>基于匹配的识别技术通过一个原型模式向量来表示每个类。根据一种预定义的度量，将一个未知模板赋予最接近的类。</p>
<p><strong>最小距离分类器</strong></p>
<p>假设每个模式类的原型定义为该类模式的平均向量：</p>
<script type="math/tex; mode=display">
m_j=\frac{1}{N_j}\sum^{}_{X\in \omega_j}(x_j)\quad j=1,2,3,...,W,m_j为每个模板类的平均值，N_j为来自\omega_j类模式向量的数量</script><p>使用欧式距离求接近程度，可以表示为如下的距离度量：</p>
<script type="math/tex; mode=display">
D_j(x)=\lVert x-m_j\rVert\quad j=1,2,...,W</script><h5 id="1-2-相关匹配"><a href="#1-2-相关匹配" class="headerlink" title="1.2 相关匹配"></a>1.2 相关匹配</h5><p>可以使用归一化相关系数用于模板匹配，当归一化的w和f中对应的归一化区域相同时，&gamma;(x,y)出现最大值。即最大相关为最好的匹配。当模板与图像区域有最小相似性时，归一化相关系数出现最小值。归一化相关系数的公式如下：</p>
<script type="math/tex; mode=display">
\gamma(x,y)=\frac{\sum_{s}^{}\sum^{}_{t}[w(s,t)-\overline w][f(x+s,y+t-\overline f_{xy})]}{\{\sum^{}_{s}\sum^{}_{t}[w(s,t)-\overline w]^2\sum^{}_{s}\sum^{}_{t}[f(x+s,y+t-\overline f_{xy})]^2\}^\frac{1}{2}}\\\overline w模板均值，\overline f_{xy}是f中与w重合区域均值,\gamma(x,y)\in[-1,1]</script><h5 id="1-3-最佳统计分类器"><a href="#1-3-最佳统计分类器" class="headerlink" title="1.3 最佳统计分类器"></a>1.3 最佳统计分类器</h5><p>主要将概率应用于模式识别中，主要分类器为贝叶斯分类器</p>
<h5 id="1-4-神经网络"><a href="#1-4-神经网络" class="headerlink" title="1.4 神经网络"></a>1.4 神经网络</h5><p>多层感知机</p>
<h4 id="二、结构方法"><a href="#二、结构方法" class="headerlink" title="二、结构方法"></a>二、结构方法</h4><h5 id="2-1-匹配形状数"><a href="#2-1-匹配形状数" class="headerlink" title="2.1 匹配形状数"></a>2.1 匹配形状数</h5><p>两个区域边界(形状)之间的相似度k定义为它们的形状数保持一致的最大阶。两个形状a和b之间的距离定义为它们的相似度的倒数：</p>
<script type="math/tex; mode=display">
D(a,b)=\frac{1}{k}\\
该距离满足：D(a,b)\ge0,D(a,b)=0;if \quad a=b;D(a,c)\le max[D(a,b),D(b,c)]</script><p>如果使用相似度，则k越大，形状越相似。当使用距离度量时，情形正好相反。</p>
<h5 id="2-2-串匹配"><a href="#2-2-串匹配" class="headerlink" title="2.2 串匹配"></a>2.2 串匹配</h5><p>将两个区域编码成串，分别记录两个串之间的匹配数&alpha;,和不匹配的符号数&beta;。则a和b之间的一种简单的相似性度量比率是：</p>
<script type="math/tex; mode=display">
R=\frac{\alpha}{\beta}=\frac{\alpha}{max(|a|,|b|)-\alpha},当且仅当a和b相同时，\beta=0</script><p>对于完美匹配，R为无限大，而当a和b中没有任何符号匹配时，R为0。</p>
]]></content>
      <categories>
        <category>Image Processing</category>
      </categories>
      <tags>
        <tag>Image Processing</tag>
      </tags>
  </entry>
  <entry>
    <title>Image-Process-Edge-Detection</title>
    <url>/2021/07/25/Image-Process-Edge-Detection/</url>
    <content><![CDATA[<h2 id="图像处理学习"><a href="#图像处理学习" class="headerlink" title="图像处理学习"></a>图像处理学习</h2><h4 id="边缘检测"><a href="#边缘检测" class="headerlink" title="边缘检测"></a>边缘检测</h4><p> 对于灰度突变、局部变化可以用微分类来检测，因此，可以使用一阶微分和二阶微分。其中，一阶或二阶微分有如下的一些性质：</p>
<ul>
<li>一阶导数通常在图像中产生较粗的边缘</li>
<li>二阶导数对精细细节，如细线、孤立点和噪声有较强的响应</li>
<li>二阶导数在灰度斜坡和灰度台阶过渡处会产生双边缘响应</li>
<li>二阶导数的符号可用于确定边缘的过渡是从亮到暗还是从暗到亮。(边缘从暗到亮是正二阶导数，反之为负二阶导数)</li>
</ul>
<p>图像中每个像素位置处的一阶导数和二阶导数的可选择方法是使用空间滤波器。</p>
<p><strong>注意：微弱的可见噪声对检测边缘所用的一阶导数核二阶导数有严重的影响。所以使用导数之前图像平滑处理，应重点关注。</strong></p>
<h4 id="一、孤立点检测"><a href="#一、孤立点检测" class="headerlink" title="一、孤立点检测"></a>一、孤立点检测</h4><p>点的检测应用二阶导数，所以可以使用拉普拉斯算子：</p>
<script type="math/tex; mode=display">
\nabla^2f(x,y)=\frac{\partial^2f}{\partial x^2}+\frac{\partial^2f}{\partial y^2} \\
\frac{\partial^2f(x,y)}{\partial x^2}=f(x+1,y)+f(x-1,y)-2f(x,y) \\
\frac{\partial^2f(x,y)}{\partial y^2}=f(x,y+1)+f(x,y-1)-2f(x,y) \\
\nabla^2f(x,y)=f(x+1,y)+f(x-1,y)+f(x,y+1)+f(x,y-1)-4f(x,y)</script><p>使用如下的卷积核对原始图像进行卷积操作：</p>
<script type="math/tex; mode=display">
\begin{matrix} 1 & 1 & 1 \\ 1 & -8 & 1 \\ 1 & 1 & 1 \end{matrix}</script><p>如果在某点处该模板的响应的绝对值超过了一个指定的阈值，那么表明在模板中心位置(x,y)处的点已经被检测到了。</p>
<script type="math/tex; mode=display">
g(x,y)=\begin{cases} 1, & |R(x,y)|\ge T\\ 0, & 其他\end{cases}</script><p>g(x,y)是输出图像，T是一个非负的阈值。</p>
<h4 id="二、边缘检测"><a href="#二、边缘检测" class="headerlink" title="二、边缘检测"></a>二、边缘检测</h4><p>一般的基本步骤：</p>
<ol>
<li>为降噪对图像进行平滑处理。</li>
<li>边缘点的检测，这是一个局部操作，从一副图像中提取所有的点，这些点是边缘点的潜在候选者。</li>
<li>边缘定位，从候选边缘点中选择组成边缘点集合中的真实成员。</li>
</ol>
<h5 id="1、一阶导数用于边缘检测-数字图像处理第三版p455"><a href="#1、一阶导数用于边缘检测-数字图像处理第三版p455" class="headerlink" title="1、一阶导数用于边缘检测(数字图像处理第三版p455)"></a>1、<strong>一阶导数用于边缘检测</strong>(数字图像处理第三版p455)</h5><script type="math/tex; mode=display">
g_x=\frac{\partial f(x,y)}{\partial x}=f(x+1,y)-f(x,y),g_y=\frac{\partial f(x,y)}{\partial y}=f(x,y+1)-f(x,y) \\
上式可以用右边的两个模板做卷积，\begin{matrix} -1 & 0 \\ 0 & -1 \end{matrix} \quad 和 \quad\begin{matrix} 0 & -1 \\ 1 & 0 \end{matrix}</script><p>但是一般使用中心对称的模板计算边缘方向，最小的模板尺寸是3x3，所以对如下的3x3模板可以定义卷积核为：</p>
<script type="math/tex; mode=display">
g_x=\frac{\partial f(x,y)}{\partial x}=(z_7+z_8+z_9)-(z_1+z_2+z_3)\\g_y=\frac{\partial f(x,y)}{\partial y}=(z_3+z_6+z_9)-(z_1+z_4+z_7) \\
\begin{matrix} z_1 & z_2 & z_3 \\ z_4 & z_5 & z_6 \\ z_7 & z_8 & z_9 \end{matrix}\quad\Rightarrow \quad \begin{matrix} -1 & -1 & -1 \\ 0 & 0 & 0 \\ 1 & 1 & 1 \end{matrix} \quad 和 \quad \begin{matrix} -1 & 0 & 1 \\ -1 & 0 & 1 \\ -1 & 0 & 1 \end{matrix}\quad (Prewitt算子)</script><p>另一个变化是中心系数上使用一个权值2（权值为2变为Sobel算子能较好地抑制噪声的特性）：</p>
<script type="math/tex; mode=display">
g_x=\frac{\partial f(x,y)}{\partial x}=(z_7+2z_8+z_9)-(z_1+2z_2+z_3)\\
g_y=\frac{\partial f(x,y)}{\partial y}=(z_3+2z_6+z_9)-(z_1+2z_4+z_7) \\
\begin{matrix} z_1 & z_2 & z_3 \\ z_4 & z_5 & z_6 \\ z_7 & z_8 & z_9 \end{matrix}\quad\Rightarrow \quad \begin{matrix} -1 & -2 & -1 \\ 0 & 0 & 0 \\ 1 & 2 & 1 \end{matrix} \quad 和 \quad \begin{matrix} -1 & 0 & 1 \\ -2 & 0 & 2 \\ -1 & 0 & 1 \end{matrix}\quad (Sobel算子)</script><h5 id="2、二阶导数用于边缘检测"><a href="#2、二阶导数用于边缘检测" class="headerlink" title="2、二阶导数用于边缘检测"></a>2、<strong>二阶导数用于边缘检测</strong></h5><p><strong>Marr-Hildreth边缘检测器</strong></p>
<p>Marr和Hildreth证明：</p>
<ol>
<li>灰度变化与图像尺寸无关，要求检测使用不同尺寸的算子</li>
<li>灰度的突然变化会在一阶导数中引起波峰或波谷，二阶导数中等效地引起零交叉</li>
</ol>
<p>所以边缘检测算子应有两个显著特点：</p>
<ol>
<li>检测微分算子是一个能计算图像中每一点处的一阶导数或二阶导数</li>
<li>能被调整以便在任何期望的尺寸上起作用</li>
</ol>
<p>Marr和Hildreth论证，满足上述条件的算子是滤波器&nabla;<sup>2</sup>G，&nabla;<sup>2</sup>是拉普拉斯算子，G是二维高斯函数</p>
<script type="math/tex; mode=display">
\begin{align}G(x,y)=e^{-\frac{x^2+y^2}{2\sigma^2}},\nabla^2G(x,y)=&\frac{\partial^2G(x,y)}{\partial x^2}+\frac{\partial^2(x,y)}{\partial y^2}=\frac{\partial}{\partial x}[\frac{-x}{\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}]+\frac{\partial}{\partial y}[\frac{-y}{\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}]\\
=&[\frac{x^2}{\sigma^4}-\frac{1}{\sigma^2}]e^{-\frac{x^2+y^2}{2\sigma^2}}+[\frac{y^2}{\sigma^4}-\frac{1}{\sigma^2}]e^{-\frac{x^2+y^2}{2\sigma^2}} \\
=&[\frac{x^2+y^2-2\sigma^2}{\sigma^4}]e^{-\frac{x^2+y^2}{2\sigma^2}}
\end{align}</script><p>上式称为高斯拉普拉斯(LoG)</p>
<p><strong>为什么选择高斯拉普拉斯算子？</strong></p>
<ol>
<li>算子的高斯部分会模糊图像，从而在寸尺上将结构的灰度(包括噪声)降低到远小于&sigma;的程度，并且高斯滤波可以用于空域和频域。</li>
<li>拉普拉斯使用了二阶导数，并具有各向同性的优点，避免了使用多个模板去计算图像中任何点处的最强响应。</li>
</ol>
<p>Marr-Hildreth边缘检测算法由LOG滤波器与一幅输入图像f(x,y)卷积组成，即：</p>
<script type="math/tex; mode=display">
g(x,y)=[\nabla^2G(x,y)]*f(x,y)，由于操作都是线性的，所以\Leftrightarrow g(x,y)=\nabla^2[G(x,y)*f(x,y)]</script><p><strong>Marr-Hildreth步骤：</strong></p>
<ol>
<li><p>用一个对高斯取样得到的nxn的高斯低通滤波器(大小为nxn的LoG离散滤波器，其n值应该是大于等于6&sigma;的最小奇整数，解释在p461)对输入图像滤波</p>
</li>
<li><p>计算由第一步得到的图像的拉普拉斯</p>
<p>拉普拉斯算子可用如下所示的模板：</p>
<script type="math/tex; mode=display">
\begin{matrix} 1 & 1 & 1 \\ 1 & -8 & 1 \\ 1 & 1 & 1 \end{matrix}</script></li>
<li><p>找步骤2所得图像的零交叉(一种方法是用以p为中心的一个3x3领域，判断至少两个相对的领域像素的符号不同左/右、上/下和两个对角)，并将g(x,y)与一个给定的阈值比较。</p>
</li>
</ol>
<p>Marr-Hildreth指出使用DoG(高斯差分近似高斯拉普拉斯是可能的)</p>
<script type="math/tex; mode=display">
DoG(x,y)=\frac{1}{2\pi\sigma_1^2}e^{-\frac{x^2+y^2}{2\sigma_1^2}}-\frac{1}{2\pi\sigma_2^2}e^{-\frac{x^2+y^2}{2\sigma_2^2}},其中，\sigma_1\gt\sigma_2</script><h5 id="3、坎尼检测器-Canny-检测器"><a href="#3、坎尼检测器-Canny-检测器" class="headerlink" title="3、坎尼检测器(Canny)检测器"></a>3、坎尼检测器(Canny)检测器</h5><p>三个基本目标：</p>
<ol>
<li>低错误率。所有边缘都应被找到，并且应该没有伪响应。</li>
<li>边缘点应被很好地定位。已定位边缘必须尽可能接近真实边缘。</li>
<li>单一的边缘点响应。对于真实的边缘点，检测器仅应返回一个点。 </li>
</ol>
<p>对由加性高斯白噪声污染的一维台阶边缘。其最佳台阶边缘检测器的一个较好近似是高斯一阶导数：</p>
<script type="math/tex; mode=display">
\frac{d}{dx}e^{-\frac{x^2}{2\sigma^2}}=\frac{-x}{\sigma^2}e^{-\frac{x^2}{2\sigma^2}}</script><p>为了将一维推广到二维，因为预先法线方向未知，就需要在所有可能的方向上应用一维边缘检测器。</p>
<p>因此，canny边缘检测算法是由下列基本步骤组成的：</p>
<ol>
<li><p>用一个高斯滤波器平滑输入灰度图像g<sub>s</sub>，主要为了降噪，同时也可能增大边缘的宽度</p>
</li>
<li><p>利用prewitt或sobel算子获取平滑后图像的梯度图，计算梯度幅值图和角度图</p>
<script type="math/tex; mode=display">
M(x,y)=\sqrt{g_x^2+g_y^2},\alpha(x,y)=\arctan[\frac{g_y}{g_x}],g_x=\partial f_s/\partial x,g_y=\partial f_s/\partial y</script></li>
<li><p>对梯度幅值图像应用非极大值抑制</p>
<p>本质是指定边缘法线的许多离散方向，通常定义四个边缘方向：水平、垂直、+45&deg;和-45&deg;。由边缘法线的方向(角度图中获得)确定边缘方向。假设令d<sub>1</sub>，d<sub>2</sub>，d<sub>3</sub>，d<sub>4</sub>表示3x3区域的四个基本边缘方向：水平、垂直、+45&deg;和-45&deg;。(为什么？一个中心像素其左右，上下和两个对角线上才有幅度值，为了找出极大值，需要先确定x,y点最接近的梯度方向，当然用线性插值计算参与比较的像素梯度值也可)</p>
<p>对于&alpha;(x,y)中以点(x,y)为中心的3x3区域，非最大抑制方向为：1、寻找最接近&alpha;(x,y)的方向d<sub>k</sub>，2、如果M(x,y)的值至少小于沿d<sub>k</sub>的两个邻居之一，则令g<sub>N</sub>(x,y)=0(抑制)；否则，令g<sub>N</sub>(x,y)=M(x,y)，g<sub>N</sub>是非最大抑制后的图像。g<sub>N</sub>为新创建的一个array</p>
</li>
<li><p>用双阈值(滞后阈值)和连接分析来检测并连接边缘</p>
<p>对g<sub>N</sub>进行阈值处理(二值化)，定义一个高阈值和一个低阈值。梯度强度低于低阈值的像素点被抑制，不作为边缘点；高于高阈值的像素点被定义为强边缘，保留为边缘点；处于高低阈值之间的定义为弱边缘，如果与确定为边缘的像素点邻接(4或8)，则判定为边缘；否则为非边缘。具体步骤看数字图像处理第三版p465。</p>
<ul>
<li>如果x，y梯度幅值⼤于⾼阈值的话，令g<sub>N</sub>=255</li>
<li>如果x，y梯度幅值小于⾼阈值的话，令g<sub>N</sub>=0</li>
<li>如果x，y梯度幅值介于⾼阈值和低阈值之间并且周围8邻域内有⽐⾼阈值⾼的像素点存在，令g<sub>N</sub>=255</li>
</ul>
<p><strong>梯度方向量化</strong></p>
<script type="math/tex; mode=display">
angle =
\begin{cases}
0 & \text{-0.4142<tan<0.4142}  \\
45 & \text{0.4142<tan<2.4142} \\
90 & |tan|\ge2.4142\\
135 & \text{-2.4142<tan<0.4142}
\end{cases}</script></li>
</ol>
   <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Canny</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># Gray scale</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">BGR2GRAY</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		b = img[:, :, <span class="number">0</span>].copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">		g = img[:, :, <span class="number">1</span>].copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">		r = img[:, :, <span class="number">2</span>].copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment"># Gray scale</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		out = <span class="number">0.2126</span> * r + <span class="number">0.7152</span> * g + <span class="number">0.0722</span> * b</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># Gaussian filter for grayscale</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">gaussian_filter</span><span class="params">(img, K_size=<span class="number">3</span>, sigma=<span class="number">1.3</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> len(img.shape) == <span class="number">3</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">			H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line">			gray = <span class="literal">False</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">else</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">			img = np.expand_dims(img, axis=<span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line">			gray = <span class="literal">True</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">## Zero padding</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		pad = K_size // <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		out = np.zeros([H + pad * <span class="number">2</span>, W + pad * <span class="number">2</span>, C], dtype=np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out[pad : pad + H, pad : pad + W] = img.copy().astype(np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">## prepare Kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		K = np.zeros((K_size, K_size), dtype=np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> x <span class="keyword">in</span> range(-pad, -pad + K_size):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> y <span class="keyword">in</span> range(-pad, -pad + K_size):</span></pre></td></tr><tr><td class="code"><pre><span class="line">				K[y + pad, x + pad] = np.exp( - (x ** <span class="number">2</span> + y ** <span class="number">2</span>) / (<span class="number">2</span> * sigma * sigma))</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">#K /= (sigma * np.sqrt(2 * np.pi))</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		K /= (<span class="number">2</span> * np.pi * sigma * sigma)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		K /= K.sum()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		tmp = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment"># filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">for</span> c <span class="keyword">in</span> range(C):</span></pre></td></tr><tr><td class="code"><pre><span class="line">					out[pad + y, pad + x, c] = np.sum(K * tmp[y : y + K_size, x : x + K_size, c])</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		out = np.clip(out, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out = out[pad : pad + H, pad : pad + W]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> gray:</span></pre></td></tr><tr><td class="code"><pre><span class="line">			out = out[..., <span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># sobel filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sobel_filter</span><span class="params">(img, K_size=<span class="number">3</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> len(img.shape) == <span class="number">3</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">			H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">else</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">			H, W = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment"># Zero padding</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		pad = K_size // <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		out = np.zeros((H + pad * <span class="number">2</span>, W + pad * <span class="number">2</span>), dtype=np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out[pad : pad + H, pad : pad + W] = img.copy().astype(np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		tmp = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		out_v = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out_h = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">## Sobel vertical</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		Kv = [[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">1.</span>],[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>], [<span class="number">-1.</span>, <span class="number">-2.</span>, <span class="number">-1.</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">## Sobel horizontal</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		Kh = [[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">-1.</span>],[<span class="number">2.</span>, <span class="number">0.</span>, <span class="number">-2.</span>],[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">-1.</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment"># filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="code"><pre><span class="line">				out_v[pad + y, pad + x] = np.sum(Kv * (tmp[y : y + K_size, x : x + K_size]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">				out_h[pad + y, pad + x] = np.sum(Kh * (tmp[y : y + K_size, x : x + K_size]))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		out_v = np.clip(out_v, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out_h = np.clip(out_h, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		out_v = out_v[pad : pad + H, pad : pad + W]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out_v = out_v.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out_h = out_h[pad : pad + H, pad : pad + W]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out_h = out_h.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> out_v, out_h</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_edge_angle</span><span class="params">(fx, fy)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment"># get edge strength</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		edge = np.sqrt(np.power(fx.astype(np.float32), <span class="number">2</span>) + np.power(fy.astype(np.float32), <span class="number">2</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">		edge = np.clip(edge, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		fx = np.maximum(fx, <span class="number">1e-10</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">#fx[np.abs(fx) &lt;= 1e-5] = 1e-5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment"># get edge angle</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		angle = np.arctan(fy / fx)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> edge, angle</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">angle_quantization</span><span class="params">(angle)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		angle = angle / np.pi * <span class="number">180</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		angle[angle &lt; <span class="number">-22.5</span>] = <span class="number">180</span> + angle[angle &lt; <span class="number">-22.5</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		_angle = np.zeros_like(angle, dtype=np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		_angle[np.where(angle &lt;= <span class="number">22.5</span>)] = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		_angle[np.where((angle &gt; <span class="number">22.5</span>) &amp; (angle &lt;= <span class="number">67.5</span>))] = <span class="number">45</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		_angle[np.where((angle &gt; <span class="number">67.5</span>) &amp; (angle &lt;= <span class="number">112.5</span>))] = <span class="number">90</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		_angle[np.where((angle &gt; <span class="number">112.5</span>) &amp; (angle &lt;= <span class="number">157.5</span>))] = <span class="number">135</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> _angle</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">non_maximum_suppression</span><span class="params">(angle, edge)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		H, W = angle.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line">		_edge = edge.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">		</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">if</span> angle[y, x] == <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">							dx1, dy1, dx2, dy2 = <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">elif</span> angle[y, x] == <span class="number">45</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">							dx1, dy1, dx2, dy2 = <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">elif</span> angle[y, x] == <span class="number">90</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">							dx1, dy1, dx2, dy2 = <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">elif</span> angle[y, x] == <span class="number">135</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">							dx1, dy1, dx2, dy2 = <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">if</span> x == <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">							dx1 = max(dx1, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">							dx2 = max(dx2, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">if</span> x == W<span class="number">-1</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">							dx1 = min(dx1, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">							dx2 = min(dx2, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">if</span> y == <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">							dy1 = max(dy1, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">							dy2 = max(dy2, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">if</span> y == H<span class="number">-1</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">							dy1 = min(dy1, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">							dy2 = min(dy2, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">if</span> max(max(edge[y, x], edge[y + dy1, x + dx1]), edge[y + dy2, x + dx2]) != edge[y, x]:</span></pre></td></tr><tr><td class="code"><pre><span class="line">							_edge[y, x] = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> _edge</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">hysterisis</span><span class="params">(edge, HT=<span class="number">100</span>, LT=<span class="number">30</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		H, W = edge.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment"># Histeresis threshold</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		edge[edge &gt;= HT] = <span class="number">255</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		edge[edge &lt;= LT] = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		_edge = np.zeros((H + <span class="number">2</span>, W + <span class="number">2</span>), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		_edge[<span class="number">1</span> : H + <span class="number">1</span>, <span class="number">1</span> : W + <span class="number">1</span>] = edge</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">## 8 - Nearest neighbor</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		nn = np.array(((<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>), (<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>), (<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>)), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>, H+<span class="number">2</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, W+<span class="number">2</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="keyword">if</span> _edge[y, x] &lt; LT <span class="keyword">or</span> _edge[y, x] &gt; HT:</span></pre></td></tr><tr><td class="code"><pre><span class="line">								<span class="keyword">continue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="keyword">if</span> np.max(_edge[y<span class="number">-1</span>:y+<span class="number">2</span>, x<span class="number">-1</span>:x+<span class="number">2</span>] * nn) &gt;= HT:</span></pre></td></tr><tr><td class="code"><pre><span class="line">								_edge[y, x] = <span class="number">255</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="keyword">else</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">								_edge[y, x] = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		edge = _edge[<span class="number">1</span>:H+<span class="number">1</span>, <span class="number">1</span>:W+<span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">								</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> edge</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># grayscale</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	gray = BGR2GRAY(img)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># gaussian filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	gaussian = gaussian_filter(gray, K_size=<span class="number">5</span>, sigma=<span class="number">1.4</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># sobel filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	fy, fx = sobel_filter(gaussian, K_size=<span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># get edge strength, angle</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	edge, angle = get_edge_angle(fx, fy)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># angle quantization</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	angle = angle_quantization(angle)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># non maximum suppression</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	edge = non_maximum_suppression(angle, edge)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># hysterisis threshold</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = hysterisis(edge, <span class="number">50</span>, <span class="number">20</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Read image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imori.jpg"</span>).astype(np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Canny</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">edge = Canny(img)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">out = edge.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Save result</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">"out.jpg"</span>, out)</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"result"</span>, out)</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// RGB to Gray scale</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">BGR2GRAY</span><span class="params">(cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// BGR -&gt; Gray</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (<span class="keyword">int</span>)((<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">0</span>] * <span class="number">0.0722</span> + \</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">1</span>] * <span class="number">0.7152</span> + \</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">2</span>] * <span class="number">0.2126</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">clip</span><span class="params">(<span class="keyword">float</span> value, <span class="keyword">float</span> <span class="built_in">min</span>, <span class="keyword">float</span> <span class="built_in">max</span>)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> fmin(fmax(value, <span class="number">0</span>), <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// gaussian filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">gaussian_filter</span><span class="params">(cv::Mat img, <span class="keyword">double</span> sigma, <span class="keyword">int</span> kernel_size)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC3);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (channel == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> pad = <span class="built_in">floor</span>(kernel_size / <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> _x = <span class="number">0</span>, _y = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> kernel_sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get gaussian kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">float</span> kernel[kernel_size][kernel_size];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; kernel_size; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; kernel_size; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _y = y - pad;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _x = x - pad; </span></pre></td></tr><tr><td class="code"><pre><span class="line">      kernel[y][x] = <span class="number">1</span> / (<span class="number">2</span> * M_PI * sigma * sigma) * <span class="built_in">exp</span>( - (_x * _x + _y * _y) / (<span class="number">2</span> * sigma * sigma));</span></pre></td></tr><tr><td class="code"><pre><span class="line">      kernel_sum += kernel[y][x];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; kernel_size; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; kernel_size; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      kernel[y][x] /= kernel_sum;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// for BGR</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (channel == <span class="number">3</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> dy = -pad; dy &lt; pad + <span class="number">1</span>; dy++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> dx = -pad; dx &lt; pad + <span class="number">1</span>; dx++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="keyword">if</span> (((x + dx) &gt;= <span class="number">0</span>) &amp;&amp; ((y + dy) &gt;= <span class="number">0</span>) &amp;&amp; ((x + dx) &lt; <span class="built_in">width</span>) &amp;&amp; ((y + dy) &lt; <span class="built_in">height</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                v += (<span class="keyword">double</span>)img.at&lt;cv::Vec3b&gt;(y + dy, x + dx)[c] * kernel[dy + pad][dx + pad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          out.at&lt;cv::Vec3b&gt;(y, x)[c] = (uchar)clip(v, <span class="number">0</span>, <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// for Gray</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dy = -pad; dy &lt; pad + <span class="number">1</span>; dy++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> dx = -pad; dx &lt; pad + <span class="number">1</span>; dx++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (((x + dx) &gt;= <span class="number">0</span>) &amp;&amp; ((y + dy) &gt;= <span class="number">0</span>) &amp;&amp; ((x + dx) &lt; <span class="built_in">width</span>) &amp;&amp; ((y + dy) &lt; <span class="built_in">height</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              v += (<span class="keyword">double</span>)img.at&lt;uchar&gt;(y + dy, x + dx) * kernel[dy + pad][dx + pad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        out.at&lt;uchar&gt;(y, x) = (uchar)clip(v, <span class="number">0</span>, <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Sobel filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">sobel_filter</span><span class="params">(cv::Mat img, <span class="keyword">int</span> kernel_size, <span class="keyword">bool</span> horizontal)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> kernel[kernel_size][kernel_size] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (horizontal)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">-2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> pad = <span class="built_in">floor</span>(kernel_size / <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// filtering  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> dy = -pad; dy &lt; pad + <span class="number">1</span>; dy++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dx = -pad; dx &lt; pad + <span class="number">1</span>; dx++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">if</span> (((y + dy) &gt;= <span class="number">0</span>) &amp;&amp; (( x + dx) &gt;= <span class="number">0</span>) &amp;&amp; ((y + dy) &lt; <span class="built_in">height</span>) &amp;&amp; ((x + dx) &lt; <span class="built_in">width</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v += (<span class="keyword">double</span>)img.at&lt;uchar&gt;(y + dy, x + dx) * kernel[dy + pad][dx + pad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (uchar)clip(v, <span class="number">0</span>, <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// get edge</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">get_edge</span><span class="params">(cv::Mat fx, cv::Mat fy)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = fx.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = fx.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> _fx, _fy;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _fx = (<span class="keyword">double</span>)fx.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _fy = (<span class="keyword">double</span>)fy.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (uchar)clip(<span class="built_in">sqrt</span>(_fx * _fx + _fy * _fy), <span class="number">0</span>, <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// get angle</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">get_angle</span><span class="params">(cv::Mat fx, cv::Mat fy)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = fx.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = fx.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> _fx, _fy;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> angle;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _fx = fmax((<span class="keyword">double</span>)fx.at&lt;uchar&gt;(y, x), <span class="number">0.000001</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _fy = (<span class="keyword">double</span>)fy.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      angle = <span class="built_in">atan2</span>(_fy, _fx);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      angle = angle / M_PI * <span class="number">180</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span>(angle &lt; <span class="number">-22.5</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        angle = <span class="number">180</span> + angle;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (angle &gt;= <span class="number">157.5</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        angle = angle - <span class="number">180</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//std::cout &lt;&lt; angle &lt;&lt; " " ;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// quantization</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (angle &lt;= <span class="number">22.5</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        out.at&lt;uchar&gt;(y, x) = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (angle &lt;= <span class="number">67.5</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        out.at&lt;uchar&gt;(y, x) = <span class="number">45</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (angle &lt;= <span class="number">112.5</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        out.at&lt;uchar&gt;(y, x) = <span class="number">90</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        out.at&lt;uchar&gt;(y, x) = <span class="number">135</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// non maximum suppression</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">non_maximum_suppression</span><span class="params">(cv::Mat angle, cv::Mat edge)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = angle.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = angle.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = angle.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> dx1, dx2, dy1, dy2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> now_angle;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat _edge = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      now_angle = angle.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// angle condition</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (now_angle == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dx1 = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dy1 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dx2 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dy2 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(now_angle == <span class="number">45</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dx1 = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dy1 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dx2 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dy2 = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(now_angle == <span class="number">90</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dx1 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dy1 = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dx2 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dy2 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dx1 = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dy1 = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dx2 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dy2 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (x == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dx1 = fmax(dx1, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dx2 = fmax(dx2, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (x == (<span class="built_in">width</span> - <span class="number">1</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dx1 = fmin(dx1, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dx2 = fmin(dx2, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (y == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dy1 = fmax(dy1, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dy2 = fmax(dy2, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (y == (<span class="built_in">height</span> - <span class="number">1</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dy1 = fmin(dy1, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dy2 = fmin(dy2, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// if pixel is max among adjuscent pixels, pixel is kept</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (fmax(fmax(edge.at&lt;uchar&gt;(y, x), edge.at&lt;uchar&gt;(y + dy1, x + dx1)), edge.at&lt;uchar&gt;(y + dy2, x + dx2)) == edge.at&lt;uchar&gt;(y, x)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _edge.at&lt;uchar&gt;(y, x) = edge.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> _edge;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// histerisis</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">histerisis</span><span class="params">(cv::Mat edge, <span class="keyword">int</span> HT, <span class="keyword">int</span> LT)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = edge.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = edge.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channle = edge.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat _edge = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> now_pixel;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// get pixel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      now_pixel = edge.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// if pixel &gt;= HT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (now_pixel &gt;= HT)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _edge.at&lt;uchar&gt;(y, x) = <span class="number">255</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// if LT &lt; pixel &lt; HT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (now_pixel &gt; LT) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dy = <span class="number">-1</span>; dy &lt; <span class="number">2</span>; dy++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> dx = <span class="number">-1</span>; dx &lt; <span class="number">2</span>; dx++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// if 8 nearest neighbor pixel &gt;= HT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (edge.at&lt;uchar&gt;(fmin(fmax(y + dy, <span class="number">0</span>), <span class="number">255</span>), fmin(fmax(x + dx, <span class="number">0</span>), <span class="number">255</span>)) &gt;= HT)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              _edge.at&lt;uchar&gt;(y, x) = <span class="number">255</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> _edge;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Canny</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">Canny</span><span class="params">(cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// BGR -&gt; Gray</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat gray = BGR2GRAY(img);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// gaussian filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat gaussian = gaussian_filter(gray, <span class="number">1.4</span>, <span class="number">5</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// sobel filter (vertical)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat fy = sobel_filter(gaussian, <span class="number">3</span>, <span class="literal">false</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// sobel filter (horizontal)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat fx = sobel_filter(gaussian, <span class="number">3</span>, <span class="literal">true</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get edge</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat edge = get_edge(fx, fy);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get angle</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat angle = get_angle(fx, fy);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// edge non-maximum suppression</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  edge = non_maximum_suppression(angle, edge);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// histerisis</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  edge = histerisis(edge, <span class="number">50</span>, <span class="number">20</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> edge;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// read image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat img = cv::imread(<span class="string">"imori.jpg"</span>, cv::IMREAD_COLOR);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// Canny</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat edge = Canny(img);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//cv::imwrite("out.jpg", out);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::imshow(<span class="string">"answer(edge)"</span>, edge);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::waitKey(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::destroyAllWindows();</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h5 id="4、直线检测-霍夫变换-Hough-Transform"><a href="#4、直线检测-霍夫变换-Hough-Transform" class="headerlink" title="4、直线检测-霍夫变换(Hough Transform)"></a>4、直线检测-霍夫变换(Hough Transform)</h5><p> 考虑<strong>xy平面</strong>上的一个点(x<sub>i</sub>,y<sub>i</sub>)和斜截式形式为y<sub>i</sub>=ax<sub>i</sub>+b的一条直线。通过点(x<sub>i</sub>,y<sub>i</sub>)的直线有无数条，且对a和b的不同值，他们都满足方程y<sub>i</sub>=ax<sub>i</sub>+b。该式可以写成b=-x<sub>i</sub>a+y<sub>i</sub>，考虑<strong>ab平面(参数空间)</strong>，将得到固定点(x<sub>i</sub>,y<sub>i</sub>)的单一直线方程。<strong>什么意思？</strong>就是说在xy平面中直线L上的点，因为有固定的斜率和截距，所以转到ab参数空间中的时候，xy平面直线L上的任意点，因为有不同的x值和y值，所以在ab参数空间会对应以-x为斜率y为截距的一组直线，这组ab参数空间中的直线相交于一个点(a<sup>‘</sup>，b<sup>’</sup>)。</p>
<p>那么接下来就是要统计在ab平面中交与一点的点在xy平面中的坐标，直接从xy平面向ab平面转换时有个问题，就是当垂直时斜率a没法求tan(90&deg;)趋于无穷。所以需要做一个极坐标的转换：</p>
<script type="math/tex; mode=display">
\frac{x}{\rho}=\cos\theta,\frac{y}{\rho}=\sin\theta;\frac{x\cos\theta}{\rho}=\cos^2\theta,\frac{y\sin\theta}{\rho}=\sin^2\theta,所以，x\cos\theta+y\sin\theta=\rho</script><p>水平直线有&theta;=0&deg;，&rho;等于正的x的截距。类似地，垂直直线有&theta;=90&deg;，&rho;等于正的y截距；或者有&theta;=-90&deg;，&rho;等于负的y的截距。</p>
<p><img src="/2021/07/25/Image-Process-Edge-Detection/1.png" alt="Image-Process-Edge-Detection"></p>
<p><img src="/2021/07/25/Image-Process-Edge-Detection/1.png" alt="Image-Process-Edge-Detection"></p>
<p>霍夫变换可将&rho;&theta;参数空间划分为所谓的累计单元，其中(&rho;<sub>min</sub>,&rho;<sub>max</sub>)和(&theta;<sub>min</sub>,&theta;<sub>max</sub>)是所有期望的参数值范围：-90&deg;&le;&theta;&le;90&deg;和-D&le;&rho;&le;D，其中D是图像中对角之间的最大距离。D的值从&rho;关于x，y坐标的关系可以看出。如果获取坐标(i，j)处的累加值A(i，j)，对应于参数空间坐标(&rho;<sub>i</sub>,&theta;<sub>j</sub>)相关联的累加单元。</p>
<ul>
<li>将所有的累加单元置零</li>
<li>对于xy平面中的每个非背景点(x<sub>k</sub>，y<sub>k</sub>)，令&theta;等于&theta;轴上每个允许的细分值，同时使用方程&rho;=x<sub>k</sub>cos&theta;+y<sub>k</sub>sin&theta;解出对应的&rho;</li>
<li>对&rho;四舍五入，得到沿&theta;轴最接近的一个允许单元值</li>
<li>如果选择一个&theta;<sub>p</sub>得到解&rho;<sub>q</sub>，则令A(p,q)=A(p,q)+1</li>
<li>所有非背景点结束后，A(i,j)中的值P将意味着xy平面中有P个点位于直线xcos&theta;<sub>j</sub>+ysin&theta;<sub>j</sub>=&rho;<sub>i</sub>上。</li>
</ul>
<p>&rho;&theta;平面中的细分数量决定了这些点的共线性的精确度。对于对于霍夫变换用于别的形状的分析看数字图像处理第三版p474。</p>
<p><strong>霍夫变换的方法</strong></p>
<ol>
<li><p>用边缘图像来对边缘像素进行霍夫变换</p>
<p>1.1    求出图像的对角线长r<sub>max</sub>;</p>
<p>1.2    在用检测算法检测到的边缘点(x,y)处，&theta;取遍[0,179]，求取&rho;值</p>
<p>1.3    做一个180 &times; &rho;<sub>max</sub>大小的表，根据1.2式计算的&rho;值对表进行投票</p>
</li>
<li><p>霍夫变换后获取值的直方图并选择最大点</p>
<p>2.1    在上述表中，如果遍历到的像素的投票数⼤于其8近邻的像素值，则它不变</p>
<p>2.2    如果遍历到的像素的投票数⼩于其8近邻的像素值，则设置为0(NMS)</p>
</li>
<li><p>对极大值点的&rho;和&theta;的值进行霍夫逆变换以获得检测到的直线方程</p>
<script type="math/tex; mode=display">
y=-\frac{\cos\theta}{\sin\theta}x+\frac{r}{\sin\theta},x=-\frac{\sin\theta}{\cos\theta}y+\frac{r}{\cos\theta}</script></li>
</ol>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Canny</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># Gray scale</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">BGR2GRAY</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		b = img[:, :, <span class="number">0</span>].copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">		g = img[:, :, <span class="number">1</span>].copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">		r = img[:, :, <span class="number">2</span>].copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment"># Gray scale</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		out = <span class="number">0.2126</span> * r + <span class="number">0.7152</span> * g + <span class="number">0.0722</span> * b</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># Gaussian filter for grayscale</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">gaussian_filter</span><span class="params">(img, K_size=<span class="number">3</span>, sigma=<span class="number">1.3</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> len(img.shape) == <span class="number">3</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">			H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line">			gray = <span class="literal">False</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">else</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">			img = np.expand_dims(img, axis=<span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line">			gray = <span class="literal">True</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">## Zero padding</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		pad = K_size // <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		out = np.zeros([H + pad * <span class="number">2</span>, W + pad * <span class="number">2</span>, C], dtype=np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out[pad : pad + H, pad : pad + W] = img.copy().astype(np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">## prepare Kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		K = np.zeros((K_size, K_size), dtype=np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> x <span class="keyword">in</span> range(-pad, -pad + K_size):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> y <span class="keyword">in</span> range(-pad, -pad + K_size):</span></pre></td></tr><tr><td class="code"><pre><span class="line">				K[y + pad, x + pad] = np.exp( - (x ** <span class="number">2</span> + y ** <span class="number">2</span>) / (<span class="number">2</span> * sigma * sigma))</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">#K /= (sigma * np.sqrt(2 * np.pi))</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		K /= (<span class="number">2</span> * np.pi * sigma * sigma)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		K /= K.sum()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		tmp = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment"># filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">for</span> c <span class="keyword">in</span> range(C):</span></pre></td></tr><tr><td class="code"><pre><span class="line">					out[pad + y, pad + x, c] = np.sum(K * tmp[y : y + K_size, x : x + K_size, c])</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		out = np.clip(out, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out = out[pad : pad + H, pad : pad + W]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> gray:</span></pre></td></tr><tr><td class="code"><pre><span class="line">			out = out[..., <span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># sobel filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">sobel_filter</span><span class="params">(img, K_size=<span class="number">3</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span> len(img.shape) == <span class="number">3</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">			H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">else</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">			H, W = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment"># Zero padding</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		pad = K_size // <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		out = np.zeros((H + pad * <span class="number">2</span>, W + pad * <span class="number">2</span>), dtype=np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out[pad : pad + H, pad : pad + W] = img.copy().astype(np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		tmp = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		out_v = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out_h = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">## Sobel vertical</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		Kv = [[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">1.</span>],[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>], [<span class="number">-1.</span>, <span class="number">-2.</span>, <span class="number">-1.</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">## Sobel horizontal</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		Kh = [[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">-1.</span>],[<span class="number">2.</span>, <span class="number">0.</span>, <span class="number">-2.</span>],[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">-1.</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment"># filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="code"><pre><span class="line">				out_v[pad + y, pad + x] = np.sum(Kv * (tmp[y : y + K_size, x : x + K_size]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">				out_h[pad + y, pad + x] = np.sum(Kh * (tmp[y : y + K_size, x : x + K_size]))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		out_v = np.clip(out_v, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out_h = np.clip(out_h, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		out_v = out_v[pad : pad + H, pad : pad + W]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out_v = out_v.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out_h = out_h[pad : pad + H, pad : pad + W]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out_h = out_h.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> out_v, out_h</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">get_edge_angle</span><span class="params">(fx, fy)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment"># get edge strength</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		edge = np.sqrt(np.power(fx.astype(np.float32), <span class="number">2</span>) + np.power(fy.astype(np.float32), <span class="number">2</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">		edge = np.clip(edge, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		fx = np.maximum(fx, <span class="number">1e-10</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">#fx[np.abs(fx) &lt;= 1e-5] = 1e-5</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment"># get edge angle</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		angle = np.arctan(fy / fx)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> edge, angle</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">angle_quantization</span><span class="params">(angle)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		angle = angle / np.pi * <span class="number">180</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		angle[angle &lt; <span class="number">-22.5</span>] = <span class="number">180</span> + angle[angle &lt; <span class="number">-22.5</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		_angle = np.zeros_like(angle, dtype=np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		_angle[np.where(angle &lt;= <span class="number">22.5</span>)] = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		_angle[np.where((angle &gt; <span class="number">22.5</span>) &amp; (angle &lt;= <span class="number">67.5</span>))] = <span class="number">45</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		_angle[np.where((angle &gt; <span class="number">67.5</span>) &amp; (angle &lt;= <span class="number">112.5</span>))] = <span class="number">90</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		_angle[np.where((angle &gt; <span class="number">112.5</span>) &amp; (angle &lt;= <span class="number">157.5</span>))] = <span class="number">135</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> _angle</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">non_maximum_suppression</span><span class="params">(angle, edge)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		H, W = angle.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line">		_edge = edge.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">		</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">if</span> angle[y, x] == <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">							dx1, dy1, dx2, dy2 = <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">elif</span> angle[y, x] == <span class="number">45</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">							dx1, dy1, dx2, dy2 = <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">elif</span> angle[y, x] == <span class="number">90</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">							dx1, dy1, dx2, dy2 = <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">elif</span> angle[y, x] == <span class="number">135</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">							dx1, dy1, dx2, dy2 = <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">if</span> x == <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">							dx1 = max(dx1, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">							dx2 = max(dx2, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">if</span> x == W<span class="number">-1</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">							dx1 = min(dx1, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">							dx2 = min(dx2, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">if</span> y == <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">							dy1 = max(dy1, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">							dy2 = max(dy2, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">if</span> y == H<span class="number">-1</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">							dy1 = min(dy1, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">							dy2 = min(dy2, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">if</span> max(max(edge[y, x], edge[y + dy1, x + dx1]), edge[y + dy2, x + dx2]) != edge[y, x]:</span></pre></td></tr><tr><td class="code"><pre><span class="line">							_edge[y, x] = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> _edge</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">hysterisis</span><span class="params">(edge, HT=<span class="number">100</span>, LT=<span class="number">30</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		H, W = edge.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment"># Histeresis threshold</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		edge[edge &gt;= HT] = <span class="number">255</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		edge[edge &lt;= LT] = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		_edge = np.zeros((H + <span class="number">2</span>, W + <span class="number">2</span>), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		_edge[<span class="number">1</span> : H + <span class="number">1</span>, <span class="number">1</span> : W + <span class="number">1</span>] = edge</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">## 8 - Nearest neighbor</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		nn = np.array(((<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>), (<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">1.</span>), (<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>)), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>, H+<span class="number">2</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, W+<span class="number">2</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="keyword">if</span> _edge[y, x] &lt; LT <span class="keyword">or</span> _edge[y, x] &gt; HT:</span></pre></td></tr><tr><td class="code"><pre><span class="line">								<span class="keyword">continue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="keyword">if</span> np.max(_edge[y<span class="number">-1</span>:y+<span class="number">2</span>, x<span class="number">-1</span>:x+<span class="number">2</span>] * nn) &gt;= HT:</span></pre></td></tr><tr><td class="code"><pre><span class="line">								_edge[y, x] = <span class="number">255</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="keyword">else</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">								_edge[y, x] = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		edge = _edge[<span class="number">1</span>:H+<span class="number">1</span>, <span class="number">1</span>:W+<span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">								</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> edge</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># grayscale</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	gray = BGR2GRAY(img)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># gaussian filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	gaussian = gaussian_filter(gray, K_size=<span class="number">5</span>, sigma=<span class="number">1.4</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># sobel filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	fy, fx = sobel_filter(gaussian, K_size=<span class="number">3</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># get edge strength, angle</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	edge, angle = get_edge_angle(fx, fy)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># angle quantization</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	angle = angle_quantization(angle)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># non maximum suppression</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	edge = non_maximum_suppression(angle, edge)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># hysterisis threshold</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = hysterisis(edge, <span class="number">100</span>, <span class="number">30</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Hough_Line</span><span class="params">(edge, img)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">## Voting</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">voting</span><span class="params">(edge)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		H, W = edge.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line">		</span></pre></td></tr><tr><td class="code"><pre><span class="line">		drho = <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		dtheta = <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment"># get rho max length</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		rho_max = np.ceil(np.sqrt(H ** <span class="number">2</span> + W ** <span class="number">2</span>)).astype(np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment"># hough table</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		hough = np.zeros((rho_max * <span class="number">2</span>, <span class="number">180</span>), dtype=np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment"># get index of edge</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		ind = np.where(edge == <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">## hough transformation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> y, x <span class="keyword">in</span> zip(ind[<span class="number">0</span>], ind[<span class="number">1</span>]):</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">for</span> theta <span class="keyword">in</span> range(<span class="number">0</span>, <span class="number">180</span>, dtheta):</span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="comment"># get polar coordinat4s</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">						t = np.pi / <span class="number">180</span> * theta</span></pre></td></tr><tr><td class="code"><pre><span class="line">						rho = int(x * np.cos(t) + y * np.sin(t))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="comment"># vote</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">						hough[rho + rho_max, theta] += <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">							</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out = hough.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># non maximum suppression</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">non_maximum_suppression</span><span class="params">(hough)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		rho_max, _ = hough.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment">## non maximum suppression</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(rho_max):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">180</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="comment"># get 8 nearest neighbor</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				x1 = max(x<span class="number">-1</span>, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">				x2 = min(x+<span class="number">2</span>, <span class="number">180</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">				y1 = max(y<span class="number">-1</span>, <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">				y2 = min(y+<span class="number">2</span>, rho_max<span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">if</span> np.max(hough[y1:y2, x1:x2]) == hough[y,x] <span class="keyword">and</span> hough[y, x] != <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">pass</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="comment">#hough[y,x] = 255</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">else</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">					hough[y,x] = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> hough</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">inverse_hough</span><span class="params">(hough, img)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		H, W, _ = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line">		rho_max, _ = hough.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		out = img.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment"># get x, y index of hough table</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		ind_x = np.argsort(hough.ravel())[::<span class="number">-1</span>][:<span class="number">20</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		ind_y = ind_x.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">		thetas = ind_x % <span class="number">180</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		rhos = ind_y // <span class="number">180</span> - rho_max / <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment"># each theta and rho</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> theta, rho <span class="keyword">in</span> zip(thetas, rhos):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment"># theta[radian] -&gt; angle[degree]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			t = np.pi / <span class="number">180.</span> * theta</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="comment"># hough -&gt; (x,y)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">if</span> np.sin(t) != <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">					y = - (np.cos(t) / np.sin(t)) * x + (rho) / np.sin(t)</span></pre></td></tr><tr><td class="code"><pre><span class="line">					y = int(y)</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">if</span> y &gt;= H <span class="keyword">or</span> y &lt; <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="keyword">continue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">					out[y, x] = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">if</span> np.cos(t) != <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">					x = - (np.sin(t) / np.cos(t)) * y + (rho) / np.cos(t)</span></pre></td></tr><tr><td class="code"><pre><span class="line">					x = int(x)</span></pre></td></tr><tr><td class="code"><pre><span class="line">					<span class="keyword">if</span> x &gt;= W <span class="keyword">or</span> x &lt; <span class="number">0</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">						<span class="keyword">continue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">					out[y, x] = [<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">				</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># voting</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	hough = voting(edge)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># non maximum suppression</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	hough = non_maximum_suppression(hough)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># inverse hough</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = inverse_hough(hough, img)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Read image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"thorino.jpg"</span>).astype(np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Canny</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">edge = Canny(img)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Hough</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">out = Hough_Line(edge, img)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Save result</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">"out.jpg"</span>, out)</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"result"</span>, out)</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core.hpp&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// RGB to Gray scale</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">BGR2GRAY</span><span class="params">(cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// BGR -&gt; Gray</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (<span class="keyword">int</span>)((<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">0</span>] * <span class="number">0.0722</span> + \</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">1</span>] * <span class="number">0.7152</span> + \</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">2</span>] * <span class="number">0.2126</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">clip</span><span class="params">(<span class="keyword">float</span> value, <span class="keyword">float</span> <span class="built_in">min</span>, <span class="keyword">float</span> <span class="built_in">max</span>)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> fmin(fmax(value, <span class="number">0</span>), <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// gaussian filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">gaussian_filter</span><span class="params">(cv::Mat img, <span class="keyword">double</span> sigma, <span class="keyword">int</span> kernel_size)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC3);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (channel == <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> pad = <span class="built_in">floor</span>(kernel_size / <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> _x = <span class="number">0</span>, _y = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> kernel_sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get gaussian kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">float</span> kernel[kernel_size][kernel_size];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; kernel_size; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; kernel_size; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _y = y - pad;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _x = x - pad; </span></pre></td></tr><tr><td class="code"><pre><span class="line">      kernel[y][x] = <span class="number">1</span> / (<span class="number">2</span> * M_PI * sigma * sigma) * <span class="built_in">exp</span>( - (_x * _x + _y * _y) / (<span class="number">2</span> * sigma * sigma));</span></pre></td></tr><tr><td class="code"><pre><span class="line">      kernel_sum += kernel[y][x];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; kernel_size; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; kernel_size; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      kernel[y][x] /= kernel_sum;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// for BGR</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (channel == <span class="number">3</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> dy = -pad; dy &lt; pad + <span class="number">1</span>; dy++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> dx = -pad; dx &lt; pad + <span class="number">1</span>; dx++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              <span class="keyword">if</span> (((x + dx) &gt;= <span class="number">0</span>) &amp;&amp; ((y + dy) &gt;= <span class="number">0</span>) &amp;&amp; ((x + dx) &lt; <span class="built_in">width</span>) &amp;&amp; ((y + dy) &lt; <span class="built_in">height</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                v += (<span class="keyword">double</span>)img.at&lt;cv::Vec3b&gt;(y + dy, x + dx)[c] * kernel[dy + pad][dx + pad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          out.at&lt;cv::Vec3b&gt;(y, x)[c] = (uchar)clip(v, <span class="number">0</span>, <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// for Gray</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dy = -pad; dy &lt; pad + <span class="number">1</span>; dy++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> dx = -pad; dx &lt; pad + <span class="number">1</span>; dx++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (((x + dx) &gt;= <span class="number">0</span>) &amp;&amp; ((y + dy) &gt;= <span class="number">0</span>) &amp;&amp; ((x + dx) &lt; <span class="built_in">width</span>) &amp;&amp; ((y + dy) &lt; <span class="built_in">height</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              v += (<span class="keyword">double</span>)img.at&lt;uchar&gt;(y + dy, x + dx) * kernel[dy + pad][dx + pad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        out.at&lt;uchar&gt;(y, x) = (uchar)clip(v, <span class="number">0</span>, <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Sobel filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">sobel_filter</span><span class="params">(cv::Mat img, <span class="keyword">int</span> kernel_size, <span class="keyword">bool</span> horizontal)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> kernel[kernel_size][kernel_size] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (horizontal)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">-2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> pad = <span class="built_in">floor</span>(kernel_size / <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// filtering  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> dy = -pad; dy &lt; pad + <span class="number">1</span>; dy++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dx = -pad; dx &lt; pad + <span class="number">1</span>; dx++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">if</span> (((y + dy) &gt;= <span class="number">0</span>) &amp;&amp; (( x + dx) &gt;= <span class="number">0</span>) &amp;&amp; ((y + dy) &lt; <span class="built_in">height</span>) &amp;&amp; ((x + dx) &lt; <span class="built_in">width</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v += (<span class="keyword">double</span>)img.at&lt;uchar&gt;(y + dy, x + dx) * kernel[dy + pad][dx + pad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (uchar)clip(v, <span class="number">0</span>, <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// get edge</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">get_edge</span><span class="params">(cv::Mat fx, cv::Mat fy)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = fx.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = fx.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> _fx, _fy;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _fx = (<span class="keyword">double</span>)fx.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _fy = (<span class="keyword">double</span>)fy.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (uchar)clip(<span class="built_in">sqrt</span>(_fx * _fx + _fy * _fy), <span class="number">0</span>, <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// get angle</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">get_angle</span><span class="params">(cv::Mat fx, cv::Mat fy)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = fx.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = fx.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> _fx, _fy;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> angle;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _fx = fmax((<span class="keyword">double</span>)fx.at&lt;uchar&gt;(y, x), <span class="number">0.000001</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _fy = (<span class="keyword">double</span>)fy.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      angle = <span class="built_in">atan2</span>(_fy, _fx);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      angle = angle / M_PI * <span class="number">180</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span>(angle &lt; <span class="number">-22.5</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        angle = <span class="number">180</span> + angle;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (angle &gt;= <span class="number">157.5</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        angle = angle - <span class="number">180</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// quantization</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (angle &lt;= <span class="number">22.5</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        out.at&lt;uchar&gt;(y, x) = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (angle &lt;= <span class="number">67.5</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        out.at&lt;uchar&gt;(y, x) = <span class="number">45</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (angle &lt;= <span class="number">112.5</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        out.at&lt;uchar&gt;(y, x) = <span class="number">90</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        out.at&lt;uchar&gt;(y, x) = <span class="number">135</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// non maximum suppression</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">non_maximum_suppression</span><span class="params">(cv::Mat angle, cv::Mat edge)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = angle.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = angle.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = angle.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> dx1, dx2, dy1, dy2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> now_angle;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat _edge = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      now_angle = angle.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// angle condition</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (now_angle == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dx1 = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dy1 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dx2 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dy2 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(now_angle == <span class="number">45</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dx1 = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dy1 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dx2 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dy2 = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(now_angle == <span class="number">90</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dx1 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dy1 = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dx2 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dy2 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dx1 = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dy1 = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dx2 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dy2 = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (x == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dx1 = fmax(dx1, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dx2 = fmax(dx2, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (x == (<span class="built_in">width</span> - <span class="number">1</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dx1 = fmin(dx1, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dx2 = fmin(dx2, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (y == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dy1 = fmax(dy1, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dy2 = fmax(dy2, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (y == (<span class="built_in">height</span> - <span class="number">1</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dy1 = fmin(dy1, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        dy2 = fmin(dy2, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// if pixel is max among adjuscent pixels, pixel is kept</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (fmax(fmax(edge.at&lt;uchar&gt;(y, x), edge.at&lt;uchar&gt;(y + dy1, x + dx1)), edge.at&lt;uchar&gt;(y + dy2, x + dx2)) == edge.at&lt;uchar&gt;(y, x)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _edge.at&lt;uchar&gt;(y, x) = edge.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> _edge;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// histerisis</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">histerisis</span><span class="params">(cv::Mat edge, <span class="keyword">int</span> HT, <span class="keyword">int</span> LT)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = edge.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = edge.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channle = edge.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat _edge = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> now_pixel;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// get pixel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      now_pixel = edge.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// if pixel &gt;= HT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (now_pixel &gt;= HT)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _edge.at&lt;uchar&gt;(y, x) = <span class="number">255</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// if LT &lt; pixel &lt; HT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span> (now_pixel &gt; LT) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dy = <span class="number">-1</span>; dy &lt; <span class="number">2</span>; dy++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> dx = <span class="number">-1</span>; dx &lt; <span class="number">2</span>; dx++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">// if 8 nearest neighbor pixel &gt;= HT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (edge.at&lt;uchar&gt;(fmin(fmax(y + dy, <span class="number">0</span>), <span class="number">255</span>), fmin(fmax(x + dx, <span class="number">0</span>), <span class="number">255</span>)) &gt;= HT)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              _edge.at&lt;uchar&gt;(y, x) = <span class="number">255</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> _edge;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Canny</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">Canny</span><span class="params">(cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// BGR -&gt; Gray</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat gray = BGR2GRAY(img);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// gaussian filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat gaussian = gaussian_filter(gray, <span class="number">1.4</span>, <span class="number">5</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// sobel filter (vertical)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat fy = sobel_filter(gaussian, <span class="number">3</span>, <span class="literal">false</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// sobel filter (horizontal)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat fx = sobel_filter(gaussian, <span class="number">3</span>, <span class="literal">true</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get edge</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat edge = get_edge(fx, fy);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get angle</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat angle = get_angle(fx, fy);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// edge non-maximum suppression</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  edge = non_maximum_suppression(angle, edge);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// histerisis</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  edge = histerisis(edge, <span class="number">100</span>, <span class="number">30</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> edge;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//------</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// hough</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ANGLE_T = <span class="number">180</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> RHO_MAX = <span class="number">320</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// hough table</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">struct_hough_table</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> table[RHO_MAX * <span class="number">2</span>][ANGLE_T];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// hough vote</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">struct_hough_table <span class="title">Hough_vote</span><span class="params">(struct_hough_table hough_table, cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> rho = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> angle = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// if not edge, skip</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (img.at&lt;uchar&gt;(y, x) != <span class="number">255</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// 0 &lt;= angle t &lt; 180</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; ANGLE_T; t++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        angle = M_PI / <span class="number">180</span> * t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        rho = (<span class="keyword">int</span>)(x * <span class="built_in">cos</span>(angle) + y * <span class="built_in">sin</span>(angle));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hough_table.table[rho + RHO_MAX][t] ++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> hough_table;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// hough nms</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">struct_hough_table <span class="title">Hough_NMS</span><span class="params">(struct_hough_table hough_table)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// output hough table</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  struct_hough_table output_hough_table;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// initialize 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> rho = <span class="number">0</span>; rho &lt; RHO_MAX * <span class="number">2</span>; rho++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; ANGLE_T; t++)&#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">      output_hough_table.table[rho][t] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// top N x, y</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> N = <span class="number">30</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> top_N_rho[N], top_N_t[N], top_N_vote[N];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> tmp_rho, <span class="keyword">tmp_t</span>, tmp_vote, tmp_rho2, tmp_t2, tmp_vote2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> rho, t;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; N; n++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    top_N_rho[n] = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    top_N_t[n] = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    top_N_vote[n] = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> rho = <span class="number">0</span>; rho &lt; RHO_MAX * <span class="number">2</span>; rho++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; ANGLE_T; t++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (hough_table.table[rho][t] == <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// compare to left top</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (((t - <span class="number">1</span>) &gt;= <span class="number">0</span>) &amp;&amp; ((rho - <span class="number">1</span>) &gt;= <span class="number">0</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (hough_table.table[rho][t] &lt; hough_table.table[rho - <span class="number">1</span>][t - <span class="number">1</span>])&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// comparet to top</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> ((rho - <span class="number">1</span>) &gt;= <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (hough_table.table[rho][t] &lt; hough_table.table[rho - <span class="number">1</span>][t])&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// compare to left top</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (((t + <span class="number">1</span>) &lt; ANGLE_T) &amp;&amp; ((rho - <span class="number">1</span>) &gt;= <span class="number">0</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (hough_table.table[rho][t] &lt; hough_table.table[rho - <span class="number">1</span>][t + <span class="number">1</span>])&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// compare to left</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> ((t - <span class="number">1</span>) &gt;= <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (hough_table.table[rho][t] &lt; hough_table.table[rho][t - <span class="number">1</span>])&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// compare to right</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> ((t + <span class="number">1</span>) &lt; ANGLE_T)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (hough_table.table[rho][t] &lt; hough_table.table[rho][t + <span class="number">1</span>])&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// compare to left bottom</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (((t - <span class="number">1</span>) &gt;= <span class="number">0</span>) &amp;&amp; ((rho + <span class="number">1</span>) &lt; RHO_MAX * <span class="number">2</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (hough_table.table[rho][t] &lt; hough_table.table[rho + <span class="number">1</span>][t - <span class="number">1</span>])&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// compare to bottom</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> ((rho + <span class="number">1</span>) &lt; RHO_MAX * <span class="number">2</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (hough_table.table[rho][t] &lt; hough_table.table[rho + <span class="number">1</span>][t])&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// compare to right bottom</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (((t + <span class="number">1</span>) &lt; ANGLE_T) &amp;&amp; ((rho + <span class="number">1</span>) &lt; RHO_MAX * <span class="number">2</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (hough_table.table[rho][t] &lt; hough_table.table[rho + <span class="number">1</span>][t + <span class="number">1</span>])&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// Select top N votes</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; N; n++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (top_N_vote[n] &lt;= hough_table.table[rho][t])&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          tmp_vote = top_N_vote[n];</span></pre></td></tr><tr><td class="code"><pre><span class="line">          tmp_rho = top_N_rho[n];</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">tmp_t</span> = top_N_t[n];</span></pre></td></tr><tr><td class="code"><pre><span class="line">          top_N_vote[n] = hough_table.table[rho][t];</span></pre></td></tr><tr><td class="code"><pre><span class="line">          top_N_rho[n] = rho;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          top_N_t[n] = t;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> m = n + <span class="number">1</span>; m &lt; N - <span class="number">1</span>; m++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            tmp_vote2 = top_N_vote[m];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            tmp_rho2 = top_N_rho[m];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            tmp_t2 = top_N_t[m];</span></pre></td></tr><tr><td class="code"><pre><span class="line">            top_N_vote[m] = tmp_vote;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            top_N_rho[m] = tmp_rho;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            top_N_t[m] = <span class="keyword">tmp_t</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            tmp_vote = tmp_vote2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            tmp_rho = tmp_rho2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">tmp_t</span> = tmp_t2;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">          top_N_vote[N - <span class="number">1</span>] = tmp_vote;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          top_N_rho[N - <span class="number">1</span>] = tmp_rho;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          top_N_t[N - <span class="number">1</span>] = <span class="keyword">tmp_t</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get pixel for top N votes</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">0</span>; n &lt; N; n++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span> (top_N_rho[n] == <span class="number">-1</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">break</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    rho = top_N_rho[n];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    t = top_N_t[n];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    output_hough_table.table[rho][t] = hough_table.table[rho][t];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> output_hough_table;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Inverse hough transformation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">Hough_inverse</span><span class="params">(struct_hough_table hough_table, cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> _cos, _sin;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> y, x;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> rho = <span class="number">0</span>; rho &lt; RHO_MAX * <span class="number">2</span>; rho++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; ANGLE_T; t++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// if not vote, skip</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (hough_table.table[rho][t] &lt; <span class="number">1</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      _cos = <span class="built_in">cos</span>(t * M_PI / <span class="number">180</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _sin = <span class="built_in">sin</span>(t * M_PI / <span class="number">180</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> ((_sin == <span class="number">0</span>) || (_cos == <span class="number">0</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        y = (<span class="keyword">int</span>)(- _cos / _sin * x + (rho - RHO_MAX) / _sin);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((y &gt;= <span class="number">0</span>) &amp;&amp; (y &lt; <span class="built_in">height</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          img.at&lt;cv::Vec3b&gt;(y, x) = cv::Vec3b(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        x = (<span class="keyword">int</span>)(- _sin / _cos * y + (rho - RHO_MAX) / _cos);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((x &gt;= <span class="number">0</span>) &amp;&amp; (x &lt; <span class="built_in">width</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          img.at&lt;cv::Vec3b&gt;(y, x) = cv::Vec3b(<span class="number">0</span>, <span class="number">0</span>, <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> img;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// hough line detection</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">Hough_line</span><span class="params">(cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get edge by canny</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat edge = Canny(img);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// hough</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  struct_hough_table hough_table;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// initialize 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> rho = <span class="number">0</span>; rho &lt; RHO_MAX * <span class="number">2</span>; rho++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; ANGLE_T; t++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      hough_table.table[rho][t] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// hough vote</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  hough_table = Hough_vote(hough_table, edge);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// hough NMS</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  hough_table = Hough_NMS(hough_table);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// hough inverse</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = Hough_inverse(hough_table, img);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// read image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat img = cv::imread(<span class="string">"thorino.jpg"</span>, cv::IMREAD_COLOR);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// Hough line detection</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat hough = Hough_line(img);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//cv::imwrite("out.jpg", out);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::imshow(<span class="string">"answer(hough)"</span>, hough);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::waitKey(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::destroyAllWindows();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Image Processing</category>
      </categories>
      <tags>
        <tag>Image Processing</tag>
      </tags>
  </entry>
  <entry>
    <title>Image-Process-Morphology</title>
    <url>/2021/07/25/Image-Process-Morphology/</url>
    <content><![CDATA[<h2 id="图像处理学习"><a href="#图像处理学习" class="headerlink" title="图像处理学习"></a>图像处理学习</h2><p><strong>形态学图像处理</strong></p>
<h4 id="一、膨胀和腐蚀"><a href="#一、膨胀和腐蚀" class="headerlink" title="一、膨胀和腐蚀"></a>一、膨胀和腐蚀</h4><p>A和B是Z<sup>2</sup>(二维整数空间)中的集合，用A&oplus;B表示B对A的<strong>膨胀</strong>，定义为：</p>
<script type="math/tex; mode=display">
A\oplus B=\{z|(\hat B)_z\cap A\neq\varnothing\}，只要结构元\hat B_z与A有交集则并入A,\hat B和A至少有一个元素是重叠的</script><p>在实际进⾏形态学处理的时候，待操作的像素4-近邻与矩阵A相乘，结果⼤于255的话，将中⼼像素设为255。</p>
<p>A和B是Z<sup>2</sup>(二维整数空间)中的集合，用A&ominus;B表示B对A的<strong>腐蚀</strong>，定义为：</p>
<script type="math/tex; mode=display">
A\ominus B=\{z|(B)_z\subseteq A\},B包含在A中的所有的点z的集合，等价于A\ominus B=\{z|(B)_z\cap A^c=\varnothing\},A^c为A的补集</script><p>在实际进⾏形态学处理的时候，待操作的像素4-近邻与矩阵A相乘，结果⼩于 255&times;4的话，将中⼼像素设为0。</p>
<script type="math/tex; mode=display">
A=\left[
\begin{matrix}
0 & 1 & 0\\
1 & 0 & 1 \\
0 & 1 & 0
\end{matrix}
\right]
\tag{3}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Morphology Dalite</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Morphology_Dalite</span><span class="params">(img, Dil_time=<span class="number">1</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	H, W = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	MF = np.array(((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">				(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">				(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)), dtype=np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># each dilate time</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = img.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(Dil_time):</span></pre></td></tr><tr><td class="code"><pre><span class="line">		tmp = np.pad(out, (<span class="number">1</span>, <span class="number">1</span>), <span class="string">'edge'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>, H+<span class="number">1</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, W+<span class="number">1</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">if</span> np.sum(MF * tmp[y<span class="number">-1</span>:y+<span class="number">2</span>, x<span class="number">-1</span>:x+<span class="number">2</span>]) &gt;= <span class="number">255</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">					out[y<span class="number">-1</span>, x<span class="number">-1</span>] = <span class="number">255</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Morphology Erode</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Morphology_Erode</span><span class="params">(img, Erode_time=<span class="number">1</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	H, W = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = img.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	MF = np.array(((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">				(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">				(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)), dtype=np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># each erode</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(Erode_time):</span></pre></td></tr><tr><td class="code"><pre><span class="line">		tmp = np.pad(out, (<span class="number">1</span>, <span class="number">1</span>), <span class="string">'edge'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment"># erode</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>, H+<span class="number">1</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, W+<span class="number">1</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">if</span> np.sum(MF * tmp[y<span class="number">-1</span>:y+<span class="number">2</span>, x<span class="number">-1</span>:x+<span class="number">2</span>]) &lt; <span class="number">255</span>*<span class="number">4</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">					out[y<span class="number">-1</span>, x<span class="number">-1</span>] = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Morphology Erode</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">Morphology_Erode</span><span class="params">(cv::Mat img, <span class="keyword">int</span> Erode_time)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// output image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat tmp_img;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = img.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// for erode time</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Erode_time; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    tmp_img = out.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// each pixel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// check left pixel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((x &gt; <span class="number">0</span>) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y, x - <span class="number">1</span>) == <span class="number">0</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// check up pixel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((y &gt; <span class="number">0</span>) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y - <span class="number">1</span>, x) == <span class="number">0</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// check right pixel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((x &lt; <span class="built_in">width</span> - <span class="number">1</span>) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y, x + <span class="number">1</span>) == <span class="number">0</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// check left pixel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((y &lt; <span class="built_in">height</span> - <span class="number">1</span>) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y + <span class="number">1</span>, x) == <span class="number">0</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Morphology Dilate</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">Morphology_Dilate</span><span class="params">(cv::Mat img, <span class="keyword">int</span> Dilate_time)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// output image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat tmp_img;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = img.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// for erode time</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; Dilate_time; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    tmp_img = out.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// each pixel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// check left pixel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((x &gt; <span class="number">0</span>) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y, x - <span class="number">1</span>) == <span class="number">255</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) = <span class="number">255</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// check up pixel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((y &gt; <span class="number">0</span>) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y - <span class="number">1</span>, x) == <span class="number">255</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) = <span class="number">255</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// check right pixel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((x &lt; <span class="built_in">width</span> - <span class="number">1</span>) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y, x + <span class="number">1</span>) == <span class="number">255</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) = <span class="number">255</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// check left pixel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> ((y &lt; <span class="built_in">height</span> - <span class="number">1</span>) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y + <span class="number">1</span>, x) == <span class="number">255</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) = <span class="number">255</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="二、开操作和闭操作"><a href="#二、开操作和闭操作" class="headerlink" title="二、开操作和闭操作"></a>二、开操作和闭操作</h4><p>结构元B对集合A的<strong>开操作</strong>，表示如下：</p>
<script type="math/tex; mode=display">
A\circ B=(A\ominus B)\oplus B</script><p>B对A的开操作就是B对A的腐蚀，紧接着用B对结果进行膨胀。一般会平滑物体的轮廓、断开较窄的狭颈并消除细的突出物。</p>
<p>结构元B对集合A的<strong>闭操作</strong>，表示如下：</p>
<script type="math/tex; mode=display">
A\bullet B=(A\oplus B) \ominus B</script><p>B对A的闭操作就是B对A的膨胀，紧接着用B对结果进行腐蚀。同样具有平滑轮廓的一部分，但与开操作相反，它通常会弥合较窄的间断和细长的沟壑，消除小的孔洞，填补轮廓线中的断裂。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Morphology Erode</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Morphology_Erode</span><span class="params">(img, Erode_time=<span class="number">1</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	H, W = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = img.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	MF = np.array(((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">				(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">				(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)), dtype=np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># each erode</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(Erode_time):</span></pre></td></tr><tr><td class="code"><pre><span class="line">		tmp = np.pad(out, (<span class="number">1</span>, <span class="number">1</span>), <span class="string">'edge'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="comment"># erode</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>, H+<span class="number">1</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, W+<span class="number">1</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">if</span> np.sum(MF * tmp[y<span class="number">-1</span>:y+<span class="number">2</span>, x<span class="number">-1</span>:x+<span class="number">2</span>]) &lt; <span class="number">255</span>*<span class="number">4</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">					out[y<span class="number">-1</span>, x<span class="number">-1</span>] = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Morphology Dilate</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Morphology_Dilate</span><span class="params">(img, Dil_time=<span class="number">1</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	H, W = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	MF = np.array(((<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">				(<span class="number">1</span>, <span class="number">0</span>, <span class="number">1</span>),</span></pre></td></tr><tr><td class="code"><pre><span class="line">				(<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>)), dtype=np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># each dilate time</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = img.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(Dil_time):</span></pre></td></tr><tr><td class="code"><pre><span class="line">		tmp = np.pad(out, (<span class="number">1</span>, <span class="number">1</span>), <span class="string">'edge'</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(<span class="number">1</span>, H+<span class="number">1</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">1</span>, W+<span class="number">1</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="keyword">if</span> np.sum(MF * tmp[y<span class="number">-1</span>:y+<span class="number">2</span>, x<span class="number">-1</span>:x+<span class="number">2</span>]) &gt;= <span class="number">255</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">					out[y<span class="number">-1</span>, x<span class="number">-1</span>] = <span class="number">255</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Opening morphology</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#开运算，即先进⾏N次腐蚀再进⾏N次膨胀。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Morphology_Opening</span><span class="params">(img, time=<span class="number">1</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = Morphology_Erode(out, Erode_time=time)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = Morphology_Dilate(img, Dilate_time=time)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Morphology Closing</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#闭运算，即先进⾏N次膨胀再进⾏N次腐蚀。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">Morphology_Closing</span><span class="params">(img, time=<span class="number">1</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = Morphology_Dilate(out, Dilate_time=time)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = Morphology_Erode(img, Erode_time=time)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Morphology Erode</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv::Mat Morphology_Erode(cv::Mat img, int Erode_time)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  int height &#x3D; img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  int width &#x3D; img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; output image</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat tmp_img;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out &#x3D; img.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; for erode time</span></pre></td></tr><tr><td class="code"><pre><span class="line">  for (int i &#x3D; 0; i &lt; Erode_time; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    tmp_img &#x3D; out.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; each pixel</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (int y &#x3D; 0; y &lt; height; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      for (int x &#x3D; 0; x &lt; width; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; check left pixel</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if ((x &gt; 0) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y, x - 1) &#x3D;&#x3D; 255))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) &#x3D; 255;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          continue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; check up pixel</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if ((y &gt; 0) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y - 1, x) &#x3D;&#x3D; 255))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) &#x3D; 255;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          continue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; check right pixel</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if ((x &lt; width - 1) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y, x + 1) &#x3D;&#x3D; 255))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) &#x3D; 255;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          continue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; check left pixel</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if ((y &lt; height - 1) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y + 1, x) &#x3D;&#x3D; 255))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) &#x3D; 255;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          continue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  return out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Morphology Dilate</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv::Mat Morphology_Dilate(cv::Mat img, int Dilate_time)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  int height &#x3D; img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  int width &#x3D; img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; output image</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat tmp_img;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out &#x3D; img.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; for erode time</span></pre></td></tr><tr><td class="code"><pre><span class="line">  for (int i &#x3D; 0; i &lt; Dilate_time; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    tmp_img &#x3D; out.clone();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; each pixel</span></pre></td></tr><tr><td class="code"><pre><span class="line">    for (int y &#x3D; 0; y &lt; height; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      for (int x &#x3D; 0; x &lt; width; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; check left pixel</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if ((x &gt; 0) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y, x - 1) &#x3D;&#x3D; 0))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          continue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; check up pixel</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if ((y &gt; 0) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y - 1, x) &#x3D;&#x3D; 0))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          continue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; check right pixel</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if ((x &lt; width - 1) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y, x + 1) &#x3D;&#x3D; 0))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          continue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; check left pixel</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if ((y &lt; height - 1) &amp;&amp; (tmp_img.at&lt;uchar&gt;(y + 1, x) &#x3D;&#x3D; 0))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          out.at&lt;uchar&gt;(y, x) &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          continue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  return out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Morphology opening</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv::Mat Morphology_Opening(cv::Mat img, int open_time)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; Morphology erode</span></pre></td></tr><tr><td class="code"><pre><span class="line">  img &#x3D; Morphology_Erode(img, open_time);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; Morphology dilate</span></pre></td></tr><tr><td class="code"><pre><span class="line">  img &#x3D; Morphology_Dilate(img, open_time);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  return img;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Morphology closing</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv::Mat Morphology_Closing(cv::Mat img, int open_time)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; Morphology dilate</span></pre></td></tr><tr><td class="code"><pre><span class="line">  img &#x3D; Morphology_Dilate(img, open_time);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#x2F;&#x2F; Morphology erode</span></pre></td></tr><tr><td class="code"><pre><span class="line">  img &#x3D; Morphology_Erode(img, open_time);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  return img;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="三、一些基本的形态学算法"><a href="#三、一些基本的形态学算法" class="headerlink" title="三、一些基本的形态学算法"></a>三、一些基本的形态学算法</h4><h5 id="3-1-边界提取"><a href="#3-1-边界提取" class="headerlink" title="3.1 边界提取"></a>3.1 边界提取</h5><p>表示为&beta;(A)的集合A的边界可以通过先用B对A腐蚀，而后执行A和腐蚀的结果之间的集合之差得到。</p>
<script type="math/tex; mode=display">
\beta(A)=A-(A\ominus B)\\
结构元为B=\left[
\begin{matrix}
1 & 1 & 1\\
1 & 0 & 1 \\
1 & 1 & 1
\end{matrix}
\right]
\tag{3}</script><p>上述的结构元不是唯一的，也可以根据实际情况使用5&times;5大小的结构元，将得到不同宽度的边界。</p>
<h5 id="3-2-孔洞填充"><a href="#3-2-孔洞填充" class="headerlink" title="3.2 孔洞填充"></a>3.2 孔洞填充</h5><p>孔洞定义为由前景像素相连接的边界所包围的一个背景区域。假设每个孔洞区域内有一个已知的点，并标记为1，则可以使用如下的迭代方式进行孔洞填充：</p>
<script type="math/tex; mode=display">
X_k=(X_{k-1}\oplus B)\cap A^c,k=1,2,3,\cdots\\
B=\left[
\begin{matrix}
0 & 1 & 0\\
1 & 0 & 1 \\
0 & 1 & 0
\end{matrix}
\right]
\tag{3}，4-连通</script><ul>
<li>设定一个与包含A的阵列大小相同的阵列X<sub>0</sub>，其中孔洞中有一个给定点被设置为1</li>
<li>使用上面的迭代过程对X<sub>0</sub>进行迭代</li>
<li>如果X<sub>k</sub>=X<sub>k-1</sub>，则算法结束</li>
</ul>
<p>每一步中与A<sup>c</sup>的交集操作将结果限制到感兴趣区域内。</p>
<h5 id="3-3-连通分量的提取"><a href="#3-3-连通分量的提取" class="headerlink" title="3.3 连通分量的提取"></a>3.3 连通分量的提取</h5><ul>
<li>令A是一个包含一个或多个连通分量的集合，形成一个阵列X<sub>0</sub>(该阵列的大小与包含A的阵列大小相同)</li>
<li>A中每个连通分量中，取一个已知点置为1(表示前景)，阵列中的其他元素置为0(表示背景)</li>
<li>使用下列的迭代过程进行迭代</li>
<li>如果X<sub>k</sub>=X<sub>k-1</sub>，则算法结束</li>
</ul>
<script type="math/tex; mode=display">
X_k=(X_{k-1}\oplus B)\cap A,k=1,2,3,\cdots\\
B=\left[
\begin{matrix}
1 & 1 & 1\\
1 & 0 & 1 \\
1 & 1 & 1
\end{matrix}
\right]
\tag{3},8-连通</script><p>X<sub>k</sub>中包含输入图像中的所有的连通分量</p>
<h4 id="四、灰度级形态学"><a href="#四、灰度级形态学" class="headerlink" title="四、灰度级形态学"></a>四、灰度级形态学</h4><h5 id="4-1、腐蚀和膨胀"><a href="#4-1、腐蚀和膨胀" class="headerlink" title="4.1、腐蚀和膨胀"></a>4.1、腐蚀和膨胀</h5><p>当b的原点位于(x,y)处时，用一个平坦的结构元b在(x,y)处对图像f的<strong>腐蚀</strong>定义为图像f中与b重合区域的最小值。腐蚀公式如下：</p>
<script type="math/tex; mode=display">
[f\ominus b](x,y)=\mathop {min}_{(s,t)\in b}\{f(x+s,y+t)\}</script><p>在任何位置的腐蚀由从包含在与b重合区域中的f的所有值中选取的最小值决定。</p>
<p>当b的映像b<sup>^</sup>的原点位于(x,y)处时，用一个平坦的结构元b在(x,y)处对图像f的<strong>膨胀</strong>定义为图像f中与b重合区域的最大值。膨胀公式如下：</p>
<script type="math/tex; mode=display">
[f\oplus b](x,y)=\mathop {max}_{(s,t)\in b}\{f(x-s,y-t)\},\hat b=b(-x,-y)</script><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
<th>膨胀</th>
<th style="text-align:center">1</th>
<th style="text-align:center">2</th>
<th style="text-align:center">3</th>
<th style="text-align:center">4</th>
<th style="text-align:center">5</th>
<th style="text-align:center">6</th>
<th style="text-align:center">7</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">209</td>
<td style="text-align:center">125</td>
<td style="text-align:center">191</td>
<td style="text-align:center">9</td>
<td style="text-align:center">168</td>
<td style="text-align:center">246</td>
<td style="text-align:center">158</td>
<td></td>
<td style="text-align:center">232</td>
<td style="text-align:center">232</td>
<td style="text-align:center">205</td>
<td style="text-align:center">191</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
</tr>
<tr>
<td style="text-align:center">232</td>
<td style="text-align:center">205</td>
<td style="text-align:center">101</td>
<td style="text-align:center">113</td>
<td style="text-align:center">42</td>
<td style="text-align:center">141</td>
<td style="text-align:center">122</td>
<td></td>
<td style="text-align:center">232</td>
<td style="text-align:center">232</td>
<td style="text-align:center">205</td>
<td style="text-align:center">191</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
</tr>
<tr>
<td style="text-align:center">33</td>
<td style="text-align:center">37</td>
<td style="text-align:center">168</td>
<td style="text-align:center">98</td>
<td style="text-align:center">31</td>
<td style="text-align:center">36</td>
<td style="text-align:center">91</td>
<td></td>
<td style="text-align:center">234</td>
<td style="text-align:center">234</td>
<td style="text-align:center">205</td>
<td style="text-align:center">196</td>
<td style="text-align:center">196</td>
<td style="text-align:center">213</td>
<td style="text-align:center">213</td>
</tr>
<tr>
<td style="text-align:center">234</td>
<td style="text-align:center">108</td>
<td style="text-align:center">44</td>
<td style="text-align:center">196</td>
<td style="text-align:center">128</td>
<td style="text-align:center">39</td>
<td style="text-align:center">213</td>
<td>=&gt;</td>
<td style="text-align:center">235</td>
<td style="text-align:center">235</td>
<td style="text-align:center">235</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
</tr>
<tr>
<td style="text-align:center">162</td>
<td style="text-align:center">235</td>
<td style="text-align:center">181</td>
<td style="text-align:center">204</td>
<td style="text-align:center">246</td>
<td style="text-align:center">66</td>
<td style="text-align:center">150</td>
<td></td>
<td style="text-align:center">235</td>
<td style="text-align:center">235</td>
<td style="text-align:center">235</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
</tr>
<tr>
<td style="text-align:center">25</td>
<td style="text-align:center">203</td>
<td style="text-align:center">9</td>
<td style="text-align:center">48</td>
<td style="text-align:center">88</td>
<td style="text-align:center">216</td>
<td style="text-align:center">141</td>
<td></td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">235</td>
<td style="text-align:center">235</td>
</tr>
<tr>
<td style="text-align:center">72</td>
<td style="text-align:center">246</td>
<td style="text-align:center">71</td>
<td style="text-align:center">126</td>
<td style="text-align:center">150</td>
<td style="text-align:center">66</td>
<td style="text-align:center">235</td>
<td></td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">246</td>
<td style="text-align:center">150</td>
<td style="text-align:center">216</td>
<td style="text-align:center">235</td>
<td style="text-align:center">235</td>
</tr>
</tbody>
</table>
</div>
<h5 id="4-2-形态学梯度"><a href="#4-2-形态学梯度" class="headerlink" title="4.2 形态学梯度"></a>4.2 形态学梯度</h5><p>膨胀和腐蚀可与图像相减结合起来得到一副图像的形态学梯度，由g定义：</p>
<script type="math/tex; mode=display">
g=(f\oplus b)-(f\ominus b)</script><p>膨胀粗化一幅图像中的区域，腐蚀则细化它们。膨胀和腐蚀的差强调了区域间的边界。</p>
<h5 id="4-3-顶帽变换和底帽变换"><a href="#4-3-顶帽变换和底帽变换" class="headerlink" title="4.3 顶帽变换和底帽变换"></a>4.3 顶帽变换和底帽变换</h5><p>图像相减与开操作和闭操作相结合，会产生所谓的顶帽(Top-hat)变换和底帽(Bottom-hat)变换。</p>
<p>灰度级图像f的顶帽变换定义为f减去其开操作：</p>
<script type="math/tex; mode=display">
T_{hat}(f)=f-(f\circ b)</script><p>灰度级图像f的底帽变换定义为f的闭操作减去f：</p>
<script type="math/tex; mode=display">
B_{hat}(f)=(f\bullet b)-f</script><p>主要应用是，用一个结构元通过开操作或闭操作从一幅图像中删除物体，然后，差操作得到一幅仅保留已删除分量的图像。顶帽变换用于暗背景上的亮物体，底帽变换则相反。                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </p>
]]></content>
      <categories>
        <category>Image Processing</category>
      </categories>
      <tags>
        <tag>Image Processing</tag>
      </tags>
  </entry>
  <entry>
    <title>Image-Process-Three-Fourier-Transform</title>
    <url>/2021/07/25/Image-Process-Three-Fourier-Transform/</url>
    <content><![CDATA[<h2 id="图像处理学习"><a href="#图像处理学习" class="headerlink" title="图像处理学习"></a>图像处理学习</h2><h4 id="第一部分-离散傅里叶变换"><a href="#第一部分-离散傅里叶变换" class="headerlink" title="第一部分 离散傅里叶变换"></a>第一部分 离散傅里叶变换</h4><p>这里先引入单变量的离散傅里叶变换(DFT)。</p>
<script type="math/tex; mode=display">
\begin{align}
&假设原始函数为f(x),经过采样后的函数为\tilde{f}(x),采样函数相应的傅里叶变换为\tilde{F}(\mu)\\
&则利用傅里叶变换可得： \\
&\tilde{F}(\mu)=\int_{-\infty}^{\infty}\tilde{f}(x)e^{-j2\pi\mu t}dt \\
&根据数字图像处理p131的式(4.3-1)\\
&\tilde{f}(t)=f(t)s_{\Delta T}(t)=\sum_{n=-\infty}^{\infty}f(t)\delta(t-n\Delta T),代入得： \\
\tilde{F}(\mu)=&\int_{-\infty}^{\infty}\tilde{f}(t)e^{-j2\pi\mu t}dt=\int_{-\infty}^{\infty}\sum_{n=-\infty}^{\infty}f(t)\delta(t-n\Delta T)e^{-j2\pi\mu t}dt \\
=&\sum_{n=-\infty}^{\infty}\int_{-\infty}^{\infty}f(t)\delta(t-n\Delta T)e^{-j2\pi\mu t}dt=\sum_{\infty}^{\infty}f_ne^{-j2\pi\mu n\Delta T}
\end{align}</script><p>上式得最后一步推导有点不理解，下面给出个人的一个理解：</p>
<script type="math/tex; mode=display">
由于单位冲激函数\delta(t)的定义为：\\
\delta(t)=\begin{cases}
\infty & t=0 \\
0 & t\neq0 
\end{cases},那么
\delta(t-t_0)=\begin{cases}
\infty & t-t_0=0 \\
0 & t-t_0\neq0 
\end{cases} \\
又根据取样特性：\int_{-\infty}^{\infty}f(t)\delta(t-t_0)dt=f(t_0)，这里可以直接把\int_{-\infty}^{\infty}f(t)\delta(t-t_0)dt=f(t_0)看成\int_{-\infty}^{\infty}f(t_0)\delta(t-t_0)dt=f(t_0)\\
因为\int_{-\infty}^{\infty}\delta(t-t_0)d(t-t_0)=1， \int_{-\infty}^{\infty}f(t_0)\delta(t-t_0)dt=f(t_0)=f(t_0)\int_{-\infty}^{\infty}\delta(t-t_0)dt=f(t_0)\\
所以，\sum_{n=-\infty}^{\infty}\int_{-\infty}^{\infty}f(t)\delta(t-n\Delta T)e^{-j2\pi\mu t}dt=\sum_{n=-\infty}^{\infty}\int_{-\infty}^{\infty}f(n\Delta T)\delta(t-n\Delta T)e^{-j2\pi\mu t}dt=\sum_{n=-\infty}^{\infty}f(n\Delta T)\int_{-\infty}^{\infty}\delta(t-n\Delta T)e^{-j2\pi\mu t}dt\\
由于数字图像处理p129中例4.2,F(\mu)=\int_{-\infty}^{\infty}\delta(t-t_0)e^{-j2\pi\mu t}dt=e^{-j2\pi\mu t_0},所以上式等于 \\
\sum_{n=-\infty}^{\infty}\int_{-\infty}^{\infty}f(n\Delta T)\delta(t-n\Delta T)e^{-j2\pi\mu t}dt=\sum_{n=-\infty}^{\infty}f(n\Delta T)e^{-j2\pi\mu n\Delta T} \\
因为数字图像处理p132中式(4.3-2),f_k=\int_{-\infty}^{\infty}f(t)\delta(t-k\Delta T)dt=f(k\Delta T) \\
所以，\sum_{n=-\infty}^{\infty}\int_{-\infty}^{\infty}f(n\Delta T)\delta(t-n\Delta T)e^{-j2\pi\mu t}dt=\sum_{n=-\infty}^{\infty}f_ne^{-j2\pi\mu n\Delta T}</script><p>假设想要在周期&mu;=0到&amp;mu=1/&Delta;T之间得到M个等间距的样本，可以通过在如下频率处取样：</p>
<script type="math/tex; mode=display">
\mu=\frac{m}{M\Delta T},m=0,1,2,\cdots,M-1,代入\tilde{F}(\mu)得，F_m=\sum_{n=0}^{M-1}f_ne^{-j2\pi mn/M},M=0,1,2,\cdots,M-1</script><p>根据上面一维离散傅里叶变换得推导，可以扩展到下面得二维离散傅里叶变换得情况。</p>
<p>二维离散傅立叶变换是傅立叶变换在图像处理上的应用方法。通常傅立叶变换用于分离模拟信号或音频等连续一维信号的频率。但是，数字图像使用[0, 255]范围内的离散值表示，范围内的离散值表示，并且图像使用HxW的二维矩阵表示，所以在这里使用二维离散傅立叶变换。二维离散傅立叶变换使用下式计算，其中 表示输入图像：</p>
<script type="math/tex; mode=display">
G(u,v)=\sum^{M-1}_{x=0}\sum^{N-1}_{y=0}I(x,y)e^{-2\cdot \pi\cdot j\cdot (\frac{ux}{M}+\frac{vy}{N})}</script><p>二维傅里叶逆变换从频率分量G按照下式复原图像：</p>
<script type="math/tex; mode=display">
I(x,y)=\frac{1}{M\cdot N}\sum^{M-1}_{x=0}\sum^{N-1}_{y=0}G(u,v)e^{2\cdot \pi\cdot j\cdot (\frac{ux}{M}+\frac{vy}{N})}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DFT hyper-parameters</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">K, L = <span class="number">128</span>, <span class="number">128</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">channel = <span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># DFT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dft</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	H, W, _ = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># Prepare DFT coefficient</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	G = np.zeros((L, K, channel), dtype=np.complex)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># prepare processed index corresponding to original image positions</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	x = np.tile(np.arange(W), (H, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	y = np.arange(H).repeat(W).reshape(H, <span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># dft</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> c <span class="keyword">in</span> range(channel):</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> l <span class="keyword">in</span> range(L):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> k <span class="keyword">in</span> range(K):</span></pre></td></tr><tr><td class="code"><pre><span class="line">				G[l, k, c] = np.sum(img[..., c] * np.exp(<span class="number">-2j</span> * np.pi * (x * k / K + y * l / L))) / np.sqrt(K * L)</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="comment">#for n in range(N):</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="comment">#    for m in range(M):</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="comment">#        v += gray[n, m] * np.exp(-2j * np.pi * (m * k / M + n * l / N))</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="comment">#G[l, k] = v / np.sqrt(M * N)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> G</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># IDFT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">idft</span><span class="params">(G)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># prepare out image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	H, W, _ = G.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.zeros((H, W, channel), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># prepare processed index corresponding to original image positions</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	x = np.tile(np.arange(W), (H, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	y = np.arange(H).repeat(W).reshape(H, <span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># idft</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> c <span class="keyword">in</span> range(channel):</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> l <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> k <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="code"><pre><span class="line">				out[l, k, c] = np.abs(np.sum(G[..., c] * np.exp(<span class="number">2j</span> * np.pi * (x * k / W + y * l / H)))) / np.sqrt(W * H)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># clipping</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.clip(out, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">height</span> = <span class="number">128</span>, <span class="built_in">width</span> = <span class="number">128</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fourier_str</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; coef[<span class="built_in">height</span>][<span class="built_in">width</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// RGB to Gray scale</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">BGR2GRAY</span><span class="params">(cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// BGR -&gt; Gray</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (<span class="keyword">int</span>)((<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">0</span>] * <span class="number">0.0722</span> + \</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">1</span>] * <span class="number">0.7152</span> + \</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">2</span>] * <span class="number">0.2126</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Discrete Fourier transformation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">fourier_str <span class="title">dft</span><span class="params">(cv::Mat img, fourier_str fourier_s)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> I;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> theta;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; val;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="built_in">height</span>; l ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="built_in">width</span>; k ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      val.real(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      val.imag(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          I = (<span class="keyword">double</span>)img.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          theta = <span class="number">-2</span> * M_PI * ((<span class="keyword">double</span>)k * (<span class="keyword">double</span>)x / (<span class="keyword">double</span>)<span class="built_in">width</span> + (<span class="keyword">double</span>)l * (<span class="keyword">double</span>)y / (<span class="keyword">double</span>)<span class="built_in">height</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          val += <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">cos</span>(theta), <span class="built_in">sin</span>(theta)) * I;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      val /= <span class="built_in">sqrt</span>(<span class="built_in">height</span> * <span class="built_in">width</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      fourier_s.coef[l][k] = val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> fourier_s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Inverse Discrete Fourier transformation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">idft</span><span class="params">(cv::Mat out, fourier_str fourier_s)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> theta;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> g;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; G;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; val;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      val.real(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      val.imag(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="built_in">height</span>; l ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="built_in">width</span>; k ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          G = fourier_s.coef[l][k];</span></pre></td></tr><tr><td class="code"><pre><span class="line">          theta = <span class="number">2</span> * M_PI * ((<span class="keyword">double</span>)k * (<span class="keyword">double</span>)x / (<span class="keyword">double</span>)<span class="built_in">width</span> + (<span class="keyword">double</span>)l * (<span class="keyword">double</span>)y / (<span class="keyword">double</span>)<span class="built_in">height</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          val += <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">cos</span>(theta), <span class="built_in">sin</span>(theta)) * G;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      g = <span class="built_in">std</span>::<span class="built_in">abs</span>(val) / <span class="built_in">sqrt</span>(<span class="built_in">height</span> * <span class="built_in">width</span>);      </span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (uchar)g;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="第二部分-二维傅里叶变换的一些性质"><a href="#第二部分-二维傅里叶变换的一些性质" class="headerlink" title="第二部分 二维傅里叶变换的一些性质"></a>第二部分 二维傅里叶变换的一些性质</h4><h5 id="1、平移"><a href="#1、平移" class="headerlink" title="1、平移"></a>1、平移</h5><script type="math/tex; mode=display">
f(x,y)e^{j2\pi(u_0x/M+v_0y/N)}\Leftrightarrow F(u-u_0,v-v_0),f(x-x_0,y-y_0)\Leftrightarrow F(u,v)e^{-j2\pi(x_0u/M+y_0v/N)}</script><p>上式指出，用指数项乘以f(x,y)将使DFT的原点移到点(u<sub>0</sub>,v<sub>0</sub>)；反之，用负指数乘以F(u,v)将使f(x,y)的原点移到点(x<sub>0</sub>,y<sub>0</sub>)。要证明上式成立，首先需要看清楚指数项所乘的对象，与对应的转换。</p>
<script type="math/tex; mode=display">
\because F(u,v)=\sum^{M-1}_{x=0}\sum^{N-1}_{y=0}f(x,y)e^{-j2\pi(ux/M+vy/N)}</script><script type="math/tex; mode=display">
\therefore \sum^{M-1}_{x=0}\sum^{N-1}_{y=0}f(x,y)e^{-j2\pi(\frac{ux}{M}+\frac{vy}{N})}\times e^{j2\pi(\frac{u_0x}{M}+\frac{v_0y}{N})}=\sum^{M-1}_{x=0}\sum^{N-1}_{y=0}f(x,y)e^{-j2\pi[\frac{(u-u_0)x}{M}+\frac{(v-v_0)y}{N}]}=F(u-u_0,v-v_0)</script><script type="math/tex; mode=display">
同理，\because f(x,y)=\frac{1}{M}\sum^{M-1}_{u=0}\sum^{N-1}_{v=0}F(u,v)e^{j2\pi(ux/M+vy/N}</script><script type="math/tex; mode=display">
\therefore \frac{1}{M}\sum^{M-1}_{u=0}\sum^{N-1}_{v=0}F(u,v)e^{j2\pi(ux/M+vy/N}\times e^{-j2\pi(x_0u/M+y_0v/N)}=\frac{1}{M}\sum^{M-1}_{u=0}\sum^{N-1}_{v=0}F(u,v)e^{j2\pi[(x-x_0)u/M+(v-v_0)y/N)]}=f(x-x_0,y-y_0)</script><p> 除了上面的推导外，从网上看到了另一种推导方式，很漂亮👏。<a href="http://www.kevinnan.org.cn/index.php/archives/637/" target="_blank" rel="noopener">链接</a></p>
<p>简单做一下记录，便于以后回顾：</p>
<script type="math/tex; mode=display">
f(x-x_0,y-y_0)\Leftrightarrow F(u',v') \\
F(u',v')=\int^{\infty}_{-\infty}\int^{\infty}_{-\infty}f(x-x_0,y-y_0)e^{-j2\pi(ux+vy)}dxdy \\
令x-x_0=x',y-y_0=y',则x=x'+x_0,y=y'+y_0;dx=dx',dy=dy' \\
所以，F(u',v')=\int^{\infty}_{-\infty}\int^{\infty}_{-\infty}f(x',y')e^{-j2\pi [u(x'+x_0)+v(y'+y_0)]}dx'dy'=e^{-j2\pi (ux_0+vy_0)}\cdot\int^{\infty}_{-\infty}\int^{\infty}_{-\infty}f(x',y')e^{-j2\pi (ux'+vy')}dx'dy' \\
因此，F(u',v')=F(u,v)\cdot e^{-j2\pi(ux_0+vy_0)}，同理也可以将F(u-u_0,v-v_0)代入求F(u-u_0,v-v_0)\Leftrightarrow f(x',y')*2、旋转</script><h5 id="2、旋转"><a href="#2、旋转" class="headerlink" title="2、旋转"></a>2、旋转</h5><p>若f(x,y)旋转&theta;角，则F(u,v)也往相同的方向旋转相同的角度。</p>
<p>假设直角坐标系中点P(x,y)，绕平面中心旋转&theta;得Q(x’,y’)，用旋转矩阵表示两者得关系：（利用极坐标的表示方法推导下式）</p>
<script type="math/tex; mode=display">
x=r\cos\phi\quad y=r\sin\phi;x'=rcos(\theta+\phi),y=rsin(\theta+\phi)\\
利用三角函数展开，x'=r\cos\theta\cos\phi-r\sin\theta\sin\phi,y'=r\sin\theta\cos\phi+r\cos\theta\sin\phi\\
将x,y代入，即可得，x'=x\cos\theta-y\sin\theta,y'=x\sin\theta+y\cos\theta</script><script type="math/tex; mode=display">
\left[
\begin{matrix}
x\\
y \\
\end{matrix}
\right]
=
\left[
\begin{matrix}
cos\theta & -sin\theta\\
sin\theta & cos\theta \\
\end{matrix}
\right]
\left[
\begin{matrix}
x'\\
y'\\
\end{matrix}
\right]
反向求x',y';
\left[
\begin{matrix}
x'\\
y'\\
\end{matrix}
\right]
=
\left[
\begin{matrix}
cos\theta & sin\theta\\
-sin\theta & cos\theta \\
\end{matrix}
\right]
\left[
\begin{matrix}
x\\
y\\
\end{matrix}
\right]</script><p>上式是利用了旋转矩阵的逆等于旋转矩阵的转置这个性质，即：</p>
<script type="math/tex; mode=display">
假设旋转矩阵为：R=[x^T\quad y^T\quad z^T],其转置矩阵为R^T=\left[
\begin{matrix}
x^T\\
y^T\\
z^T
\end{matrix}
\right]\\
则，R^TR=\left[
\begin{matrix}
xx^T & xy^T & xz^T\\
yx^T & yy^T & yz^T\\
zx^T & zy^T & zz^T
\end{matrix}
\right],由于三角函数的正交特性，只有xx^T=yy^T=zz^T=1,其余为0\\
故R^TR=I=R^{-1}R,即R^R=R^{-1}</script><p>旋转后点f(x’,y’)的傅里叶变换为：</p>
<script type="math/tex; mode=display">
F(u',v')=\int^{\infty}_{-\infty}\int^{\infty}_{-\infty}f(x',y')e^{-j2\pi(ux+vy)}dxdy \\
F(u',v')=\int^{\infty}_{-\infty}\int^{\infty}_{-\infty}e^{-j2\pi[u(cos\theta x'-sin\theta y')+v(sin\theta x'+cos\theta y')]}dx'dy'\\
F(u',v')=\int^{\infty}_{-\infty}\int^{\infty}_{-\infty}e^{-j2\pi[x'(ucos\theta+vsin\theta )+y'(vcos\theta-usin\theta)]}dx'dy'\\
F(u',v')=F(ucos\theta+vsin\theta,-usin\theta+vsin\theta)，由此可得：\\
\left[
\begin{matrix}
u'\\
v'\\
\end{matrix}
\right]
=
\left[
\begin{matrix}
cos\theta & sin\theta\\
-sin\theta & cos\theta \\
\end{matrix}
\right]
\left[
\begin{matrix}
u\\
v\\
\end{matrix}
\right]</script><p>所以，u，v旋转的角度和x，y旋转的角度相同。上面的dx，dy与dx’，dy’的转换使用的是二重积分的变换关系式。<a href="https://zhuanlan.zhihu.com/p/50355468" target="_blank" rel="noopener">参考</a></p>
<h5 id="3、周期性"><a href="#3、周期性" class="headerlink" title="3、周期性"></a>3、周期性</h5><p>如一维情况一样，二维傅里叶变换及其反变换在u方向和v方向是无线周期的，即</p>
<script type="math/tex; mode=display">
F(u,v)=F(u+k_1M,v)=F(u,v+k_2N)=F(u+k1M,v+k_2N)\\
f(x,y)=f(x+k_1M,y)=f(x,y+k_2N)=f(x+k_1M,y+k_2N)</script><p>上式中k<sub>1</sub>,k<sub>2</sub>为整数。</p>
<p>由于在单维离散傅里叶变换表示为：</p>
<script type="math/tex; mode=display">
F_m=\sum^{M-1}_{n=0}f_ne^{-j2\pi mn/M},m=0,1,2,\cdots,M-1\\
当m=\frac{M}{2}时，F_m=\sum^{M-1}_{n=0}f_ne^{-j\pi n}=\sum^{M-1}_{n=0}f_n[\cos(\pi n)-\sin(\pi n)]=\sum^{M-1}_{n=0}f_n\cos(\pi n)</script><p>上式说明，在M/2处，只有半个周期。而采样区间是在[0, M-1]。可见，该区间内是两个周期的各一半，即背靠背的半个周期组成。为了显示和滤波，<strong>在该区间中有一个变换的完整周期会更加方便</strong>。所以需要平移M/2个半周期。根据平移的性质：</p>
<script type="math/tex; mode=display">
f(x)e^{j2\pi(u_0x/M)}\Leftrightarrow F(u-u_0),令u_0=M/2,则指数变为e^{j\pi x}，由于x为整数\\
e^{j\pi x}=\cos(\pi x)=(-1)^x,所以，上式，f(x)(-1)^x=F(u-u_0)</script><p>上式用(-1)<sup>x</sup>乘以f(x)将位于原点的数据F(0)移动到区间[0, M-1]的中心位置。这里做的是<strong>频谱的中心化</strong>，可以扩展到二维离散空间。</p>
<script type="math/tex; mode=display">
f(x,y)(-1)^x\Leftrightarrow F(u-M/2,v-N/2)</script><h4 id="补充部分"><a href="#补充部分" class="headerlink" title="补充部分"></a>补充部分</h4><p>周期冲击串的傅里叶变换</p>
<p>首先，介绍一下冲击串s<sub>&Delta;T</sub>(t)：无限多个分离的周期冲激单元&Delta;T之和</p>
<script type="math/tex; mode=display">
s_{\Delta T}(t)=\sum^{\infty}_{n=-\infty}\delta(t-n\Delta T)</script><p>因为冲击串是一个周期函数，所以可以使用傅里叶级数表示：</p>
<script type="math/tex; mode=display">
s_{\Delta T}(t)=\sum^{\infty}_{n=-\infty}c_ne^{j\frac{2\pi n}{\Delta T}t}</script><p> 其中，</p>
<script type="math/tex; mode=display">
c_n=\frac{1}{\Delta T}\int^{\Delta T/2}_{-\Delta T/2}s_{\Delta T}e^{-j\frac{2\pi n}{\Delta T}t}dt</script><p>由于在区间[-&Delta;T/2，&Delta;T/2]的积分仅包含位于原点的冲激，所以，</p>
<script type="math/tex; mode=display">
c_n=\frac{1}{\Delta T}\int^{\Delta T/2}_{-\Delta T/2}\delta (t)e^{-j\frac{2\pi n}{\Delta T}t}dt=\frac{1}{\Delta T}</script><p>则，</p>
<script type="math/tex; mode=display">
s_{\Delta T}(t)=\frac{1}{\Delta T}\sum^{\infty}_{n=-\infty}e^{j\frac{2\pi n}{\Delta T}t}</script><p>则周期冲激串的傅里叶变换S(&mu;)为：</p>
<script type="math/tex; mode=display">
S(\mu)=\mathscr{F}\{s_{\Delta T(t)}\}=\mathscr{F}\{\frac{1}{\Delta T}\sum^{\infty}_{n=-\infty}e^{j\frac{2\pi n}{\Delta T}t}\}=\frac{1}{\Delta T}\mathscr{F}\{\sum^{\infty}_{n=-\infty}e^{j\frac{2\pi n}{\Delta T}t}\}</script><p> 从上式的最后一项看是对指数函数求和的傅里叶变换，由于求和是线性变换，与傅里叶变换之后求和的结果一致，所以需要求指数函数的傅里叶变换，即：</p>
<script type="math/tex; mode=display">
要求，\mathscr{F}\{e^{j\frac{2\pi n}{\Delta T}t}\}，根据定义\mathscr{F}\{f(t)\}=\int^{\infty}_{-\infty}f(t)e^{-j2\pi\mu t}dt \\
则，\mathscr{F}\{e^{j\frac{2\pi n}{\Delta T}t}\}=\int^{\infty}_{-\infty}e^{j\frac{2\pi n}{\Delta T}t}\cdot e^{-j2\pi\mu t}dt=\int^{\infty}_{-\infty}1\cdot e^{-j2\pi(\mu-\frac{n}{\Delta T})t}dt \\
所以，\mathscr{F}\{e^{j\frac{2\pi n}{\Delta T}t}\}=F(\mu-\frac{n}{\Delta T})=\delta(\mu-\frac{n}{\Delta T}),这里相当于模拟\mu的一个函数</script><h4 id="三、低通滤波器"><a href="#三、低通滤波器" class="headerlink" title="三、低通滤波器"></a>三、低通滤波器</h4><p>低通滤波器在频率中将高频信号滤除，保留更多的低频信号。其中，在傅里叶变换且中心化频率后，中心是平均灰度值，越靠近中心，低频信号越多；越远离，则为高频信号，例如：边界或噪声。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># DFT hyper-parameters</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">K, L = <span class="number">128</span>, <span class="number">128</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">channel = <span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># bgr -&gt; gray</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bgr2gray</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	gray = <span class="number">0.2126</span> * img[..., <span class="number">2</span>] + <span class="number">0.7152</span> * img[..., <span class="number">1</span>] + <span class="number">0.0722</span> * img[..., <span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> gray</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># DFT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dft</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># Prepare DFT coefficient, complex() 函数用于创建一个值为 real + imag * j 的复数 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	G = np.zeros((L, K, channel), dtype=np.complex)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># prepare processed index corresponding to original image positions</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	x = np.tile(np.arange(W), (H, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	y = np.arange(H).repeat(W).reshape(H, <span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># dft</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> c <span class="keyword">in</span> range(channel):</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> l <span class="keyword">in</span> range(L):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> k <span class="keyword">in</span> range(K):</span></pre></td></tr><tr><td class="code"><pre><span class="line">				G[l, k, c] = np.sum(img[..., c] * np.exp(<span class="number">-2j</span> * np.pi * (x * k / K + y * l / L))) / np.sqrt(K * L)</span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="comment">#for n in range(N):</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="comment">#    for m in range(M):</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="comment">#        v += gray[n, m] * np.exp(-2j * np.pi * (m * k / M + n * l / N))</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">				<span class="comment">#G[l, k] = v / np.sqrt(M * N)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> G</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># IDFT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">idft</span><span class="params">(G)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># prepare out image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	H, W, _ = G.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.zeros((H, W, channel), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># prepare processed index corresponding to original image positions</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	x = np.tile(np.arange(W), (H, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	y = np.arange(H).repeat(W).reshape(H, <span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># idft</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> c <span class="keyword">in</span> range(channel):</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> l <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> k <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="code"><pre><span class="line">				out[l, k, c] = np.abs(np.sum(G[..., c] * np.exp(<span class="number">2j</span> * np.pi * (x * k / W + y * l / H)))) / np.sqrt(W * H)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># clipping</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.clip(out, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># LPF</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lpf</span><span class="params">(G, ratio=<span class="number">0.5</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	H, W, _ = G.shape	</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># transfer positions</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	_G = np.zeros_like(G)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	_G[:H//<span class="number">2</span>, :W//<span class="number">2</span>] = G[H//<span class="number">2</span>:, W//<span class="number">2</span>:]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	_G[:H//<span class="number">2</span>, W//<span class="number">2</span>:] = G[H//<span class="number">2</span>:, :W//<span class="number">2</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	_G[H//<span class="number">2</span>:, :W//<span class="number">2</span>] = G[:H//<span class="number">2</span>, W//<span class="number">2</span>:]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	_G[H//<span class="number">2</span>:, W//<span class="number">2</span>:] = G[:H//<span class="number">2</span>, :W//<span class="number">2</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># get distance from center (H / 2, W / 2)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	x = np.tile(np.arange(W), (H, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	y = np.arange(H).repeat(W).reshape(H, <span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># make filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	_x = x - W // <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	_y = y - H // <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	r = np.sqrt(_x ** <span class="number">2</span> + _y ** <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	mask = np.ones((H, W), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	mask[r &gt; (W // <span class="number">2</span> * ratio)] = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	mask = np.repeat(mask, channel).reshape(H, W, channel)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	_G *= mask</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># reverse original positions</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	G[:H//<span class="number">2</span>, :W//<span class="number">2</span>] = _G[H//<span class="number">2</span>:, W//<span class="number">2</span>:]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	G[:H//<span class="number">2</span>, W//<span class="number">2</span>:] = _G[H//<span class="number">2</span>:, :W//<span class="number">2</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	G[H//<span class="number">2</span>:, :W//<span class="number">2</span>] = _G[:H//<span class="number">2</span>, W//<span class="number">2</span>:]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	G[H//<span class="number">2</span>:, W//<span class="number">2</span>:] = _G[:H//<span class="number">2</span>, :W//<span class="number">2</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> G</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Read image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imori.jpg"</span>).astype(np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line">H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Gray scale</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">gray = bgr2gray(img)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># DFT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">G = dft(img)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># LPF</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">G = lpf(G)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># IDFT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">out = idft(G)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Save result</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"result"</span>, out)</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">"out.jpg"</span>, out)</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">height</span> = <span class="number">128</span>, <span class="built_in">width</span> = <span class="number">128</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fourier_str</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; coef[<span class="built_in">height</span>][<span class="built_in">width</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// RGB to Gray scale</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">BGR2GRAY</span><span class="params">(cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// BGR -&gt; Gray</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (<span class="keyword">int</span>)((<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">0</span>] * <span class="number">0.0722</span> + \</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">1</span>] * <span class="number">0.7152</span> + \</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">2</span>] * <span class="number">0.2126</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Discrete Fourier transformation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">fourier_str <span class="title">dft</span><span class="params">(cv::Mat img, fourier_str fourier_s)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> I;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> theta;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; val;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="built_in">height</span>; l ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="built_in">width</span>; k ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      val.real(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      val.imag(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          I = (<span class="keyword">double</span>)img.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="comment">//求欧拉公式中的theta角jxtheta=cos(theta)+jsin(theta)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">          theta = <span class="number">-2</span> * M_PI * ((<span class="keyword">double</span>)k * (<span class="keyword">double</span>)x / (<span class="keyword">double</span>)<span class="built_in">width</span> + (<span class="keyword">double</span>)l * (<span class="keyword">double</span>)y / (<span class="keyword">double</span>)<span class="built_in">height</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          val += <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">cos</span>(theta), <span class="built_in">sin</span>(theta)) * I;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      val /= <span class="built_in">sqrt</span>(<span class="built_in">height</span> * <span class="built_in">width</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      fourier_s.coef[l][k] = val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> fourier_s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Inverse Discrete Fourier transformation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">idft</span><span class="params">(cv::Mat out, fourier_str fourier_s)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> theta;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> g;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; G;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; val;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      val.real(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      val.imag(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="built_in">height</span>; l ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="built_in">width</span>; k ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          G = fourier_s.coef[l][k];</span></pre></td></tr><tr><td class="code"><pre><span class="line">          theta = <span class="number">2</span> * M_PI * ((<span class="keyword">double</span>)k * (<span class="keyword">double</span>)x / (<span class="keyword">double</span>)<span class="built_in">width</span> + (<span class="keyword">double</span>)l * (<span class="keyword">double</span>)y / (<span class="keyword">double</span>)<span class="built_in">height</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          val += <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">cos</span>(theta), <span class="built_in">sin</span>(theta)) * G;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      g = <span class="built_in">std</span>::<span class="built_in">abs</span>(val) / <span class="built_in">sqrt</span>(<span class="built_in">height</span> * <span class="built_in">width</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      g = fmin(fmax(g, <span class="number">0</span>), <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (uchar)g;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Low pass Filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">fourier_str <span class="title">lpf</span><span class="params">(fourier_str fourier_s, <span class="keyword">double</span> pass_r)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> r = <span class="built_in">height</span> / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> filter_d = (<span class="keyword">int</span>)((<span class="keyword">double</span>)r * pass_r);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">height</span> / <span class="number">2</span>; j++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">width</span> / <span class="number">2</span>; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (<span class="built_in">sqrt</span>(i * i + j * j) &gt;= filter_d)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        fourier_s.coef[j][i] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        fourier_s.coef[j][<span class="built_in">width</span> - i] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        fourier_s.coef[<span class="built_in">height</span> - i][i] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        fourier_s.coef[<span class="built_in">height</span> - i][<span class="built_in">width</span> - i] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> fourier_s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="四、高通滤波器"><a href="#四、高通滤波器" class="headerlink" title="四、高通滤波器"></a>四、高通滤波器</h4><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># DFT hyper-parameters</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">K, L = <span class="number">128</span>, <span class="number">128</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">channel = <span class="number">3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># bgr -&gt; gray</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bgr2gray</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	gray = <span class="number">0.2126</span> * img[..., <span class="number">2</span>] + <span class="number">0.7152</span> * img[..., <span class="number">1</span>] + <span class="number">0.0722</span> * img[..., <span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> gray</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># DFT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dft</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># Prepare DFT coefficient</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	G = np.zeros((L, K, channel), dtype=np.complex)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># prepare processed index corresponding to original image positions</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	x = np.tile(np.arange(W), (H, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	y = np.arange(H).repeat(W).reshape(H, <span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># dft</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> c <span class="keyword">in</span> range(channel):</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> l <span class="keyword">in</span> range(L):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> k <span class="keyword">in</span> range(K):</span></pre></td></tr><tr><td class="code"><pre><span class="line">				G[l, k, c] = np.sum(img[..., c] * np.exp(<span class="number">-2j</span> * np.pi * (x * k / K + y * l / L))) / np.sqrt(K * L)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> G</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># IDFT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">idft</span><span class="params">(G)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># prepare out image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	H, W, _ = G.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.zeros((H, W, channel), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># prepare processed index corresponding to original image positions</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	x = np.tile(np.arange(W), (H, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	y = np.arange(H).repeat(W).reshape(H, <span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># idft</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> c <span class="keyword">in</span> range(channel):</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> l <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> k <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="code"><pre><span class="line">				out[l, k, c] = np.abs(np.sum(G[..., c] * np.exp(<span class="number">2j</span> * np.pi * (x * k / W + y * l / H)))) / np.sqrt(W * H)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># clipping</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.clip(out, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># HPF</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hpf</span><span class="params">(G, ratio=<span class="number">0.1</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	H, W, _ = G.shape	</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># transfer positions</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	_G = np.zeros_like(G)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	_G[:H//<span class="number">2</span>, :W//<span class="number">2</span>] = G[H//<span class="number">2</span>:, W//<span class="number">2</span>:]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	_G[:H//<span class="number">2</span>, W//<span class="number">2</span>:] = G[H//<span class="number">2</span>:, :W//<span class="number">2</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	_G[H//<span class="number">2</span>:, :W//<span class="number">2</span>] = G[:H//<span class="number">2</span>, W//<span class="number">2</span>:]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	_G[H//<span class="number">2</span>:, W//<span class="number">2</span>:] = G[:H//<span class="number">2</span>, :W//<span class="number">2</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># get distance from center (H / 2, W / 2)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	x = np.tile(np.arange(W), (H, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	y = np.arange(H).repeat(W).reshape(H, <span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># make filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	_x = x - W // <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	_y = y - H // <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	r = np.sqrt(_x ** <span class="number">2</span> + _y ** <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	mask = np.ones((H, W), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	mask[r &lt; (W // <span class="number">2</span> * ratio)] = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	mask = np.repeat(mask, channel).reshape(H, W, channel)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	_G *= mask</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># reverse original positions</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	G[:H//<span class="number">2</span>, :W//<span class="number">2</span>] = _G[H//<span class="number">2</span>:, W//<span class="number">2</span>:]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	G[:H//<span class="number">2</span>, W//<span class="number">2</span>:] = _G[H//<span class="number">2</span>:, :W//<span class="number">2</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	G[H//<span class="number">2</span>:, :W//<span class="number">2</span>] = _G[:H//<span class="number">2</span>, W//<span class="number">2</span>:]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	G[H//<span class="number">2</span>:, W//<span class="number">2</span>:] = _G[:H//<span class="number">2</span>, :W//<span class="number">2</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> G</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Read image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imori.jpg"</span>).astype(np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line">H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Gray scale</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">gray = bgr2gray(img)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># DFT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">G = dft(img)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># HPF</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">G = hpf(G)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># IDFT</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">out = idft(G)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Save result</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"result"</span>, out)</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">"out.jpg"</span>, out)</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> <span class="built_in">height</span> = <span class="number">128</span>, <span class="built_in">width</span> = <span class="number">128</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fourier_str</span> &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; coef[<span class="built_in">height</span>][<span class="built_in">width</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// RGB to Gray scale</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">BGR2GRAY</span><span class="params">(cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// BGR -&gt; Gray</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (<span class="keyword">int</span>)((<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">0</span>] * <span class="number">0.0722</span> + \</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">1</span>] * <span class="number">0.7152</span> + \</span></pre></td></tr><tr><td class="code"><pre><span class="line">				  (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">2</span>] * <span class="number">0.2126</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Discrete Fourier transformation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">fourier_str <span class="title">dft</span><span class="params">(cv::Mat img, fourier_str fourier_s)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> I;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> theta;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; val;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="built_in">height</span>; l ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="built_in">width</span>; k ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      val.real(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      val.imag(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          I = (<span class="keyword">double</span>)img.at&lt;uchar&gt;(y, x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          theta = <span class="number">-2</span> * M_PI * ((<span class="keyword">double</span>)k * (<span class="keyword">double</span>)x / (<span class="keyword">double</span>)<span class="built_in">width</span> + (<span class="keyword">double</span>)l * (<span class="keyword">double</span>)y / (<span class="keyword">double</span>)<span class="built_in">height</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          val += <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">cos</span>(theta), <span class="built_in">sin</span>(theta)) * I;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      val /= <span class="built_in">sqrt</span>(<span class="built_in">height</span> * <span class="built_in">width</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      fourier_s.coef[l][k] = val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> fourier_s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Inverse Discrete Fourier transformation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">idft</span><span class="params">(cv::Mat out, fourier_str fourier_s)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> theta;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> g;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; G;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt; val;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      val.real(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      val.imag(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> l = <span class="number">0</span>; l &lt; <span class="built_in">height</span>; l ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="built_in">width</span>; k ++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          G = fourier_s.coef[l][k];</span></pre></td></tr><tr><td class="code"><pre><span class="line">          theta = <span class="number">2</span> * M_PI * ((<span class="keyword">double</span>)k * (<span class="keyword">double</span>)x / (<span class="keyword">double</span>)<span class="built_in">width</span> + (<span class="keyword">double</span>)l * (<span class="keyword">double</span>)y / (<span class="keyword">double</span>)<span class="built_in">height</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          val += <span class="built_in">std</span>::<span class="built_in">complex</span>&lt;<span class="keyword">double</span>&gt;(<span class="built_in">cos</span>(theta), <span class="built_in">sin</span>(theta)) * G;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      g = <span class="built_in">std</span>::<span class="built_in">abs</span>(val) / <span class="built_in">sqrt</span>(<span class="built_in">height</span> * <span class="built_in">width</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      g = fmin(fmax(g, <span class="number">0</span>), <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (uchar)g;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Band pass Filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">fourier_str <span class="title">bpf</span><span class="params">(fourier_str fourier_s, <span class="keyword">double</span> pass_lower, <span class="keyword">double</span> pass_upper)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> r = <span class="built_in">height</span> / <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> filter_lower = (<span class="keyword">int</span>)((<span class="keyword">double</span>)r * pass_lower);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> filter_upper = (<span class="keyword">int</span>)((<span class="keyword">double</span>)r * pass_upper);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> ( <span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="built_in">height</span> / <span class="number">2</span>; j++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">width</span> / <span class="number">2</span>; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> ((<span class="built_in">sqrt</span>(i * i + j * j) &lt; filter_lower) || </span></pre></td></tr><tr><td class="code"><pre><span class="line">          (<span class="built_in">sqrt</span>(i * i + j * j) &gt; filter_upper))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        fourier_s.coef[j][i] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        fourier_s.coef[j][<span class="built_in">width</span> - i] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        fourier_s.coef[<span class="built_in">height</span> - i][i] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        fourier_s.coef[<span class="built_in">height</span> - i][<span class="built_in">width</span> - i] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> fourier_s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Image Processing</category>
      </categories>
      <tags>
        <tag>Image Processing</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA-Programmer-Learn-Two</title>
    <url>/2021/07/03/CUDA-Programmer-Learn-two/</url>
    <content><![CDATA[<h2 id="CUDA编程学习笔记"><a href="#CUDA编程学习笔记" class="headerlink" title="CUDA编程学习笔记"></a>CUDA编程学习笔记</h2><p>本笔记主要<a href="https://face2ai.com/program-blog/#GPU%E7%BC%96%E7%A8%8B%EF%BC%88CUDA%EF%BC%89" target="_blank" rel="noopener">参考: 谭升</a>大神的博客进行了部分关键知识的摘录，可能有些地方回去单独查找一些资料进行解释。</p>
<p>GPU中使用CUDA编程的核心部分分为：核函数、内存管理、线程管理和流。</p>
<p>在CUAD编程中特有的功能为：通过组织层次结构在GPU上组织线程的方法；通过组织层次结构在GPU上组织内存的方法。</p>
<p>在实际的CUDA应用开发过程中：需要从三个角度来思考如何解决问题？</p>
<ol>
<li>领域层，根据所要解决的问题的条件，在领域层分析数据和函数</li>
<li>逻辑层，需要考虑线程的层次结构，可以获得良好的可扩展性。</li>
<li>硬件层，通过理解线程如何映射到机器上，能充分帮助我们提高性能。</li>
</ol>
<h4 id="一、内存管理"><a href="#一、内存管理" class="headerlink" title="一、内存管理"></a>一、内存管理</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">标准C函数</th>
<th style="text-align:center">CUDA C函数</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">malloc</td>
<td style="text-align:center">cudaMalloc</td>
<td style="text-align:center">内存分配</td>
</tr>
<tr>
<td style="text-align:center">memcpy</td>
<td style="text-align:center">cudaMemcpy</td>
<td style="text-align:center">内存复制</td>
</tr>
<tr>
<td style="text-align:center">memset</td>
<td style="text-align:center">cudaMemset</td>
<td style="text-align:center">内存设置</td>
</tr>
<tr>
<td style="text-align:center">free</td>
<td style="text-align:center">cudaFree</td>
<td style="text-align:center">释放内存</td>
</tr>
</tbody>
</table>
</div>
<h4 id="二、线程管理"><a href="#二、线程管理" class="headerlink" title="二、线程管理"></a>二、线程管理</h4><p>一个核函数只能有一个grid，一个grid可以有很多个块，每个块可以有很多的线程，这种分层的组织结构使得我们的并行过程更加自如灵活。一个线程块block中的线程可以完成同步和内存共享。<strong>不同块内线程不能相互影响，他们是物理隔离的。</strong></p>
<p>每个线程都执行同样的一段串行代码，那么怎么让这段相同的代码对应不同的数据呢？</p>
<p>依靠下面两个内置结构体确定线程标号：blockIdx（线程块在线程网格内的位置索引），threadIdx（线程在线程块内的位置索引）。这两个内置结构体基于 uint3 定义，包含三个无符号整数的结构，通过三个字段来指定：blockIdx.x，blockIdx.y，blockIdx.z，threadIdx.x，threadIdx.y，threadIdx.z。</p>
<p>blockIdx对应的范围为gridDim，threadIdx对应的范围为blockDim。他们是dim3类型(基于uint3定义的数据结构)的变量，也包含三个字段x,y,z。blockDim.x，blockDim.y，blockDim.z。</p>
<p>通过指定grid和block的维度，我们可以配置：1、内核中线程的数目；2、内核中使用的线程布局。可以使用<strong>dim3类型</strong>的grid维度和block维度配置内核，也可以使用int类型的变量，或者常量直接初始化。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">kernel_name&lt;&lt;&lt;<span class="number">4</span>,<span class="number">8</span>&gt;&gt;&gt;(argument <span class="built_in">list</span>);</span></pre></td></tr></table></figure>
<p>上面这条指令的线程布局是：</p>
<p><img src="/2021/07/03/CUDA-Programmer-Learn-two/1.png" alt="CUDA-Program-Lean-Plus"></p>
<p>核函数是同时复制到多个线程执行的，上文我们说过一个对应问题，多个计算执行在一个数据，肯定是浪费时间，所以为了让多线程按照我们的意愿对应到不同的数据，就要给线程一个唯一的标识，由于设备内存是线性的（基本市面上的内存硬件都是线性形式存储数据的）我们观察上图，可以用threadIdx.x 和blockIdx.x 来组合获得对应的线程的唯一标识。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主机端显示等待设备端执行</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cudaError_t <span class="title">cudaDeviceSynchronize</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//主机端隐式等待设备端执行 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//当核函数启动后的下一条指令就是从设备复制数据回主机端，那么主机端必须要等待设备端计算完成。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cudaError_t <span class="title">cudaMemcpy</span><span class="params">(<span class="keyword">void</span>* dst,<span class="keyword">const</span> <span class="keyword">void</span> * src,</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">  <span class="keyword">size_t</span> count,cudaMemcpyKind kind)</span></span>;</span></pre></td></tr></table></figure>
<p>所有CUDA核函数的启动都是异步的。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//编写核函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">kernel_name</span><span class="params">(argument <span class="built_in">list</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//CUDA小技巧，当我们进行调试的时候可以把核函数配置成单线程的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">kernel_name&lt;&lt;&lt;<span class="number">1</span>,<span class="number">1</span>&gt;&gt;&gt;(argument <span class="built_in">list</span>)</span></pre></td></tr></table></figure>
<p><strong>错误处理</strong>，获得每个函数执行后的返回结果，然后对不成功的信息加以处理，CUDA C 的API每个调用都会返回一个错误代码。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK(call) \</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;\</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">const</span> cudaError_t error=call;\</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span>(error!=cudaSuccess)\</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;\</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">printf</span>(<span class="string">"ERROR: %s:%d,"</span>,__FILE__,__LINE__);\</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">printf</span>(<span class="string">"code:%d,reason:%s\n"</span>,error,cudaGetErrorString(error));\</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="built_in">exit</span>(<span class="number">1</span>);\</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;\</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><strong>用CPU计时</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">cpuSecond</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tp</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  gettimeofday(&amp;tp,<span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span>((<span class="keyword">double</span>)tp.tv_sec+(<span class="keyword">double</span>)tp.tv_usec*<span class="number">1e-6</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><strong>理论极限最大化</strong></p>
<p>得到了实际操作值，我们需要知道的是我们能优化的极限值是多少，也就是机器的理论计算极限，这个极限我们永远也达不到，但是我们必须明确的知道，比如理论极限是2秒，我们已经从10秒优化到2.01秒了，基本就没有必要再继续花大量时间优化速度了，而应该考虑买更多的机器或者更新的设备。各个设备的理论极限可以通过其芯片说明计算得到。具体的计算指标为：</p>
<ul>
<li>单精度峰值浮点数计算次数</li>
<li>内存带宽峰值</li>
<li>指令比</li>
</ul>
<h4 id="三、组织并行线程"><a href="#三、组织并行线程" class="headerlink" title="三、组织并行线程"></a>三、组织并行线程</h4><p>介绍每一个线程是怎么确定唯一的索引，然后建立并行计算，并且不同的线程组织形式是怎样影响性能的？</p>
<p><strong>使用快和线程建立矩阵索引</strong></p>
<p>多线程的优点就是每个线程处理不同的数据计算，那么怎么分配好每个线程处理不同的数据，而不至于多个不同的线程处理同一个数据，或者避免不同的线程没有组织的乱访问内存。</p>
<p><img src="/2021/07/03/CUDA-Programmer-Learn-two/2.png" alt="CUDA-Program-Learn-Plus"></p>
<p>这里(ix,iy)就是整个线程模型中任意一个线程的索引，或者叫做全局地址，局部地址当然就是(threadIdx.x,threadIdx.y)了，当然这个局部地址目前还没有什么用处，他只能索引线程块内的线程，不同线程块中有相同的局部索引值。</p>
<p>前面讲过CUDA每一个线程执行相同的代码，也就是异构计算中说的多线程单指令，如果每个不同的线程执行同样的代码，又处理同一组数据，将会得到多个相同的结果，显然这是没意义的，为了让不同线程处理不同的数据，CUDA常用的做法是让不同的线程对应不同的数据，也就是用线程的全局标号对应不同组的数据。</p>
<p>设备内存或者主机内存都是线性存在的，比如一个二维矩阵 (8×6)，存储在内存中是这样的：</p>
<p><img src="/2021/07/03/CUDA-Programmer-Learn-two/3.png" alt="CUDA-Program-Learn-Plus"></p>
<p>图像块中数据寻址的计算步骤：</p>
<ul>
<li>线程和块索引（来计算线程的全局索引），矩阵中给定点的坐标（ix,iy）</li>
<li>(ix,iy)对应的线性内存的位置</li>
</ul>
<p>线性位置的计算方法是：</p>
<script type="math/tex; mode=display">
idx=ix+iy∗nx</script><h4 id="四、执行模型"><a href="#四、执行模型" class="headerlink" title="四、执行模型"></a>四、执行模型</h4><p>用CUDA的目的其实说白了就是为计算速度快，所以压榨性能，提高效率其实就是CUDA学习的最终目的。什么时候我们沿着硬件设计的思路设计程序，我们就会得到百战百胜。CUDA执行模型揭示了GPU并行架构的抽象视图，了解CUDA的执行模型，可以帮助我们优化指令吞吐量，和内存使用来获得极限速度。</p>
<p><strong>GPU架构概述：</strong>GPU架构是围绕一个流式多处理器（SM）的扩展阵列搭建的。通过复制这种结构来实现GPU的硬件并行。</p>
<p>下面图中展示了流式多处理器中的一些核心组件：CUDA核心、共享内存/一级缓存、寄存器文件、加载/存储单元、特殊功能单元、线程束调度器。</p>
<p><img src="/2021/07/03/CUDA-Programmer-Learn-two/4.png" alt="CUDA-Program-Learn-Plus"></p>
<p>GPU中每个SM都能支持数百个线程并发执行，每个GPU通常有多个SM，当一个核函数的网格被启动的时候，多个block会被同时分配给可用的SM上执行。</p>
<p><strong>注意:</strong> 当一个blcok被分配给一个SM后，他就只能在这个SM上执行了，不可能重新分配到其他SM上了，多个线程块可以被分配到同一个SM上。在SM上同一个块内的多个线程进行线程级别并行，<strong>而同一线程内，指令利用指令级并行将单个线程处理成流水线。</strong></p>
<p><strong>线程束：</strong>CUDA  采用单指令多线程SIMT架构管理执行线程，不同设备有不同的线程束大小，但是到目前为止基本所有设备都是维持在32，也就是说每个SM上有多个block，一个block有多个线程（可以是几百个，但不会超过某个最大值），但是从机器的角度，在某时刻T，SM上只执行一个线程束，也就是32个线程在同时同步执行，线程束中的每个线程执行同一条指令。</p>
<p><strong>SIMD vs SIMT：</strong>单指令多数据的执行属于向量机，比如我们有四个数字要加上四个数字，那么我们可以用这种单指令多数据的指令来一次完成本来要做四次的运算。这种机制的问题就是过于死板，不允许每个分支有不同的操作，所有分支必须同时执行相同的指令，必须执行没有例外。相比之下单指令多线程SIMT就更加灵活了，虽然两者都是将相同指令广播给多个执行单元，但是SIMT的某些线程可以选择不执行，也就是说同一时刻所有线程被分配给相同的指令，SIMD规定所有人必须执行，而SIMT则规定有些人可以根据需要不执行，这样SIMT就保证了线程级别的并行，而SIMD更像是指令级别的并行。</p>
<p>SIMT包括以下SIMD不具有的关键特性：</p>
<ol>
<li>每个线程都有自己的指令地址计数器</li>
<li>每个线程都有自己的寄存器状态</li>
<li>每个线程可以有一个独立的执行路径</li>
</ol>
<p>而上面这三个特性在编程模型可用的方式就是给每个线程一个唯一的标号（blckIdx,threadIdx），并且这三个特性保证了各线程之间的独立。</p>
<p><strong>问题：如何将线程的标号唯一的对应到SM流式多处理器中的block，对应到block后CUDA核和指令寄存器之间的关系如何确定?</strong></p>
<h4 id="五、CUDA编程的组件与逻辑"><a href="#五、CUDA编程的组件与逻辑" class="headerlink" title="五、CUDA编程的组件与逻辑"></a>五、CUDA编程的组件与逻辑</h4><p>下图从逻辑角度和硬件角度描述了CUDA编程模型对应的组件。</p>
<p><img src="/2021/07/03/CUDA-Programmer-Learn-two/5.png" alt="CUDA-Program-Learn-Plus"></p>
<p>SM中共享内存，和寄存器是关键的资源，线程块中线程通过共享内存和寄存器相互通信协调。寄存器和共享内存的分配可以严重影响性能！</p>
<p>每个SM有<strong>两个线程束调度器，和两个指令调度单元</strong>，当一个线程块被指定给一个SM时，线程块内的所有线程被分成线程束，线程束选择其中两个线程束，在用指令调度器存储两个线程束要执行的指令（就像上面例子中分水果的水果一样，我们这里有两个班，两个班的老师各自控制的自己的水果，老师就是指令调度器）像第一张图上的显示一样，每16个CUDA核心为一个组，还有16个加载/存储单元或4个特殊功能单元。当某个线程块被分配到一个SM上的时候，会被分成多个线程束，线程束在SM上交替执行。</p>
<p><strong>开发高性能计算程序关键的两个步骤：1、保证结果正确，和程序健壮性；2、优化速度。</strong></p>
<p><strong>性能分析的主要关注点：</strong></p>
<ol>
<li>应用程序代码的空间或时间复杂度</li>
<li>特殊指令的使用</li>
<li>函数调用的频率和持续时间</li>
</ol>
<p><strong>性能分析工具：</strong></p>
<ul>
<li>nvvp</li>
<li>nvprop</li>
</ul>
<h4 id="六、线程束和线程块"><a href="#六、线程束和线程块" class="headerlink" title="六、线程束和线程块"></a>六、线程束和线程块</h4><p>线程束是SM中基本的执行单元，当一个网格被启动（网格被启动，等价于一个内核被启动，每个内核对应于自己的网格），网格中包含线程块，线程块被分配到某一个SM上以后，将分为多个线程束，每个线程束一般是32个线程（目前的GPU都是32个线程，但不保证未来还是32个）在一个线程束中，所有线程按照单指令多线程SIMT的方式执行，每一步执行相同的指令，但是处理的数据为私有的数据，下图反应的就是逻辑，实际，和硬件的图形化。</p>
<p><img src="/2021/07/03/CUDA-Programmer-Learn-two/6.png" alt="CUDA-Program-Learn-Plus"></p>
<p><strong>线程束的分化：</strong>那么当一个线程束的32个线程执行这段代码的时候，如果其中16个执行if中的代码段，而另外16个执行else中的代码块，同一个线程束中的线程，执行不同的指令。<strong>线程束分化会产生严重的性能下降。条件分支越多，并行性削弱越严重。</strong>（因为分配命令的调度器就一个，所以满足if条件的线程得到if中的指令执行，不满足的部分等待。当满足if条件的线程执行完后，不满足的线程执行else中的指令，其余线程等待）</p>
<p><strong>如何解决线程束的分化？</strong></p>
<p>根本思路是避免同一个线程束内的线程分化，而让我们能控制线程束内线程行为的原因是线程块中线程分配到线程束是有规律的而不是随机的。这就使得我们根据线程编号来设计分支是可以的，补充说明下，当一个线程束中所有的线程都执行if或者，都执行else时，不存在性能下降；只有当线程束内有分歧产生分支的时候，性能才会急剧下降。线程束内被分配的线程是可以被我们控制的，那么我们就把都执行if的线程塞到一个线程束中，或者让一个线程束中的线程都执行if，另外线程都执行else的这种方式可以将效率提高很多。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//低效的if else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">mathKernel1</span><span class="params">(<span class="keyword">float</span> *c)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> tid = blockIdx.x* blockDim.x + threadIdx.x;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">float</span> a = <span class="number">0.0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">float</span> b = <span class="number">0.0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> (tid % <span class="number">2</span> == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		a = <span class="number">100.0f</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		b = <span class="number">200.0f</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	c[tid] = a + b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//高效的if else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">mathKernel2</span><span class="params">(<span class="keyword">float</span> *c)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> tid = blockIdx.x* blockDim.x + threadIdx.x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">float</span> a = <span class="number">0.0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">float</span> b = <span class="number">0.0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> ((tid/warpSize) % <span class="number">2</span> == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		a = <span class="number">100.0f</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">else</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		b = <span class="number">200.0f</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	c[tid] = a + b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//上面warpSize表示线程束中线程的大小,比如总64个线程，分到了两个线程束，一个线程束32个线程。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//那么0-31的线程束都是if内的指令，32-63的线程束都是else指令。</span></span></pre></td></tr></table></figure>
<h4 id="七、资源分配"><a href="#七、资源分配" class="headerlink" title="七、资源分配"></a>七、资源分配</h4><p>每个SM上执行的基本单位是线程束，也就是说，单指令通过指令调度器广播给某线程束的全部线程，这些线程同一时刻执行同一命令。对于线程束来说有激活和未激活两个状态，线程束一旦被激活来到片上，那么他就不会再离开SM直到执行结束。而每个SM上有多少个线程束处于激活状态，取决于以下资源：</p>
<ol>
<li>程序计数器</li>
<li>寄存器</li>
<li>共享内存</li>
</ol>
<p>一个SM上被分配多少个线程块和线程束取决于SM中可用的寄存器和共享内存，以及内核需要的寄存器和共享内存大小。</p>
<p>当寄存器和共享内存分配给了线程块，这个线程块处于活跃状态，所包含的线程束称为活跃线程束。活跃的线程束又分为三类：</p>
<ul>
<li>选定的线程束</li>
<li>阻塞的线程束</li>
<li>符合条件的线程束 //32个CUDA核心可以用于执行；执行所需要的资源全部就位</li>
</ul>
<p>当SM要执行某个线程束的时候，执行的这个线程束叫做选定的线程束，准备要执行的叫符合条件的线程束，如果线程束不符合条件还没准备好就是阻塞的线程束。</p>
<h4 id="八、延迟隐藏"><a href="#八、延迟隐藏" class="headerlink" title="八、延迟隐藏"></a>八、延迟隐藏</h4><p>最大化是要最大化硬件，尤其是计算部分的硬件满跑，都不闲着的情况下利用率是最高的，总有人闲着，利用率就会低很多，即最大化功能单元的利用率。<strong>利用率与常驻线程束直接相关。</strong>硬件中线程束调度器负责调度线程束调度，当每时每刻都有可用的线程束供其调度，这时候可以达到计算资源的完全利用，以此来保证通过其他常驻线程束中发布其他指令的，可以隐藏每个指令的延迟。</p>
<p>对于指令的延迟，通常分为两种：算术指令、内存指令。</p>
<p>算数指令延迟是一个算术操作从开始，到产生结果之间的时间，这个时间段内只有某些计算单元处于工作状态，而其他逻辑计算单元处于空闲。算术延迟 10~20   个时钟周期</p>
<p>内存指令延迟很好理解，当产生内存访问的时候，计算单元要等数据从内存拿到寄存器，这个周期是非常长的。内存延迟 400~800 个时钟周期</p>
<p>所需线程束=延迟×吞吐量</p>
<p>同样，与指令周期隐藏延迟类似，内存隐藏延迟是靠内存读取的并发操作来完成的，需要注意的是，指令隐藏的关键目的是使用全部的计算资源，而内存读取的延迟隐藏是为了使用全部的内存带宽，内存延迟的时候，计算资源正在被别的线程束使用，所以我们不考虑内存读取延迟的时候计算资源在做了什么。</p>
<p>所以，延迟的隐藏取决于活动的线程束的数量，数量越多，隐藏的越好，但是线程束的数量又受到上面的说的资源影响。所以这里就需要寻找最优的执行配置来达到最优的延迟隐藏。</p>
<h4 id="九、同步"><a href="#九、同步" class="headerlink" title="九、同步"></a>九、同步</h4><p>块级别的就是同一个块内的线程会同时停止在某个设定的位置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">__syncthread();</span></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>CUDA Programmer</category>
      </categories>
      <tags>
        <tag>CUDA Programmer</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA-Programmer-Learn-Two</title>
    <url>/2021/07/03/CUDA-Programmer-Learn-Two/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>CUDA-Programmer-Learn-One</title>
    <url>/2021/07/03/CUDA-Programmer-Learn-One/</url>
    <content><![CDATA[<h2 id="CUDA编程学习笔记"><a href="#CUDA编程学习笔记" class="headerlink" title="CUDA编程学习笔记"></a>CUDA编程学习笔记</h2><p>本笔记主要<a href="https://face2ai.com/program-blog/#GPU%E7%BC%96%E7%A8%8B%EF%BC%88CUDA%EF%BC%89" target="_blank" rel="noopener">参考: 谭升</a>大神的博客进行了部分关键知识的摘录，可能有些地方回去单独查找一些资料进行解释。</p>
<h4 id="一、编程模型"><a href="#一、编程模型" class="headerlink" title="一、编程模型"></a>一、编程模型</h4><p>1、 <strong>简单介绍线程层级：</strong>CUDA编程是一个多线程编程，数个线程(Thread)组成一个线程块(Block)，所有线程块组成一个线程网格(Grid)。目前的GPU限制一个<strong>线程块</strong>中，最多可以安排1024个线程。由于<strong>32个相邻的线程会组成一个线程束</strong>(Thread Warp)，而一个线程束中的线程会运行同样的指令。因此一般线程块中线程的数量被安排为32的倍数，选用256是比较合适的。</p>
<p>2、<strong>内核函数：</strong>CUDA每个线程执行的函数。关键字为global，返回值的关键字为void。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//kernal definition</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">vecAdd</span><span class="params">(<span class="keyword">float</span>* A, <span class="keyword">float</span>* B, <span class="keyword">float</span>* C)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> i=threadId.x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    C[i]=A[i]+B[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    vecAdd&lt;&lt;&lt;<span class="number">1</span>, N&gt;&gt;&gt;(A, B, C);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">matAdd</span><span class="params">(<span class="keyword">float</span> A[N][N], <span class="keyword">float</span> B[N][N], <span class="keyword">float</span> C[N][N])</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//blockDim代表当前线程块的尺寸</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> i = blockIdx.x * blockDim.x + threadIdx.x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> j = blockIdx.y * blockDim.y + threadIdx.y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(i &lt; N &amp;&amp; j &lt; N)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        C[j][i] = A[j][i] + B[j][i]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> main()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dim3 threadsPerBlock(<span class="number">16</span>,<span class="number">16</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">dim3 <span class="title">numBlocks</span><span class="params">(N / threadsPerBlock.x, N / threadsPerBlock.y)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    matAdd&lt;&lt;&lt;numBlocks, threadsPerBlock&gt;&gt;&gt;(A, B, C);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><strong>SIMT，相同指令，不同线程</strong></p>
<p>3、<strong>内存层级：</strong>一般主机端内存通过PCI-E总线与设备端内存交换数据。数据交换的速度等于PCI-E总线的速度。</p>
<ol>
<li>寄存器和本地内存绑定到了每个线程，其他线程无法访问。</li>
<li>同一个线程块内的线程，可以访问同一块共享内存。注意，即使两个线程块被调度到了同一个SM上，他们的共享内存也是隔离开的，不能互相访问。</li>
<li>网格中的所有线程都可以自由读写全局内存。</li>
<li>常量内存和纹理内存只能被CPU端修改，GPU内的线程只能读取数据。</li>
</ol>
<p>4、<strong>CPU/GPU混合编程：</strong></p>
<p>CPU和GPU的内存是独立的，如何在两者之间共享数据。</p>
<ul>
<li>主机端(Host，即CPU)执行串行代码，然后调用内核函数，让设备端(Device，即GPU)执行并行代码。如此交错执行。<ul>
<li>一、因此在运行内核函数前，主机端需要调用内存拷贝函数，将数据通过PCI-E总线拷贝到设备端。内核运行结束后，需要CPU再次调用内存拷贝函数，将数据拷回主机端内存。</li>
<li>二、使用统一编址，将设备端的内存和主机端内存编到一起。这样主机就不需要显式的调用函数将数据拷贝到设备端内存了。</li>
</ul>
</li>
<li>除了CPU/GPU交错执行代码的方式外，还可以通过使用事件(event)和流(stream)等方式，让CPU/GPU并行工作，提升整体的效率。</li>
</ul>
<p>5、<strong>计算能力：</strong>指不同的GPU版本，每个版本具有不同的特性，编程也会有所差异。CUDA的版本与计算能力没有关系，只是表示对不同架构的支持。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//CPU、OpenCV、CUDA分别执行图像灰度转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/highgui.hpp"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"opencv2/opencv.hpp"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> cv;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//CPU转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">cpuConvertGray</span><span class="params">(Mat src, <span class="keyword">int</span> <span class="built_in">height</span>, <span class="keyword">int</span> <span class="built_in">width</span>)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Mat outImg = zeros(imgHeight, imgWidth, CV_8UC1, Scalar(<span class="number">0</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;<span class="built_in">height</span>; ++y)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;<span class="built_in">width</span>; ++x)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            outImg.at&lt;uchar&gt;(y,x) = <span class="number">0.2126</span> * (<span class="keyword">float</span>)src.at&lt;Vec3b&gt;(y,x)[<span class="number">2</span>] + \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="number">0.7152</span> * (<span class="keyword">float</span>)src.at&lt;Vec3b&gt;(y,x)[<span class="number">1</span>] + \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="number">0.0722</span> * (<span class="keyword">float</span>)src.at&lt;Vec3b&gt;(y,x)[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> outImg;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//OpenCV转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">Mat <span class="title">openCvtGray</span><span class="params">(Mat src)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Mat out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cvtColor(src, out, COLOR_BGR2GRAY);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//CUDA转换</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">gpuConvertGray</span><span class="params">(uchar3* <span class="keyword">const</span> input, <span class="keyword">unsigned</span> <span class="keyword">char</span>* output, <span class="keyword">int</span> <span class="built_in">height</span>, <span class="keyword">int</span> <span class="built_in">width</span>)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = blockIdx.x * blockDim.x + threadIdx.x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> idy = blockIdx.y * blockDim.y + threadIdy.y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(idx &lt; <span class="built_in">width</span> &amp;&amp; idy &lt; <span class="built_in">height</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        uchar3 rgbImg = input[idy*<span class="built_in">width</span>+idx];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        output[idy*<span class="built_in">width</span>+idx]=<span class="number">0.299f</span> * rgb.x + <span class="number">0.587f</span> * rgb.y + <span class="number">0.114f</span> * rgb.z;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">clock_t</span> start, <span class="built_in">end</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Mat srcImg = imread(imagePath);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> imgHeight = srcImg.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">const</span> <span class="keyword">int</span> imgWidth = srcImg.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    Mat grayImg = zeros(imgHeight, imgWidth, CV_8UC1, Scalar(<span class="number">0</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    start = clock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//在CPU上进行图像灰度转化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    grayImg = cpuConvertGray(srcImg, imgHeight, imgWidth);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">end</span> = clock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"Cpu exec time is %.8f\n"</span>, (<span class="keyword">double</span>)(<span class="built_in">end</span>-start)/CLOCKS_PER_SEC);</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">    Mat outImg = zeros(imgHeight, imgWidth, CV_8UC1, Scalar(<span class="number">0</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    uchar3* input;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* output;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//使用opencv转化</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    start = clock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    grayImg = openCvtGray(srcImg);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">end</span> = clock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"OpenCV exec time is %.8f\n"</span>, (<span class="keyword">double</span>)(<span class="built_in">end</span>-start)/CLOCKS_PER_SEC);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//在GPU上分配内存</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;input, <span class="built_in">height</span>*<span class="built_in">width</span>*<span class="keyword">sizeof</span>(uchar3));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cudaMalloc((<span class="keyword">void</span>**)&amp;output, <span class="built_in">height</span>*<span class="built_in">width</span>*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//将图像数据从host拷贝到gpu上</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cudaMemcpy(input, src.data, <span class="built_in">height</span>*<span class="built_in">width</span>*<span class="keyword">sizeof</span>(uchar3), cudaMemcpyHostToDevice);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">dim3 <span class="title">threadsPerBlock</span><span class="params">(<span class="number">32</span>, <span class="number">32</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">dim3 <span class="title">blocksPerGrid</span><span class="params">((imgWidth+threadsPerBlock.x<span class="number">-1</span>) / threadsPerBlock.x, \</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">                       (imgHeight+threadsPerBlock.y<span class="number">-1</span>) / threadsPerBlock.y)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    start = clock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//启动内核</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    gpuConvertGray&lt;&lt;&lt;blocksPerGrid, threadsPerBlock&gt;&gt;&gt;(input, output, imgHeight, imgWidth);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//执行一个内核是一个异步操作，因此需要同步统计时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    cudaDeviceSynchronize();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">end</span> = clock();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"Cuda exec time is %.8f\n"</span>, (<span class="keyword">double</span>)(<span class="built_in">end</span>-start)/CLOCKS_PER_SEC);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    cudaMemcpy(grayImg.data, output, imgHeight*imgWidth*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>), cudaMemcpyDeviceToHost);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cudaFree(input);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	cudaFree(output);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>6、<strong>NVCC编译器编译CUDA程序</strong></p>
<p>NVCC提供了简单方便的接口，能够很好的同时处理主机端和设备端代码。</p>
<ul>
<li><p>离线编译</p>
<p><em>分离CUDA程序中的主机端代码(host code)和设备端代码(device code)</em>  将设备端代码编译成一种虚拟汇编文件(名为PTX)，再接着编译成二进制代码(名为cubin) ，将主机端代码中含有”&lt;&lt;&lt;&gt;&gt;&gt;”的代码(即内核调用)替换为CUDA运行库中的函数调用代码。之后NVCC会借助其他编译器(如gcc)将主机端代码编译出来，主机端代码和设备端代码被编译好后，nvcc会将两段代码链接起来。</p>
</li>
<li><p>在线编译</p>
<p>PTX是一个虚拟汇编文件。其形式虽然很像汇编，但里面的每一条指令实际上是一个虚拟的指令，与机器码无法对应。需要编译器或设备驱动程序将其翻译成对应平台的汇编/机器码才能运行。</p>
<p>如果在编译过程中，NVCC不将设备端代码编译为cubin文件，即二进制代码，而是停在PTX代码上。设备驱动(device  driver)会负责在运行时，使用PTX代码生成二进制代码。这个过程被称作在线编译(JIT Compilation, Just-In-Time  Compilation)。</p>
<p>在线编译必然会使得程序启动的时间延长，不过设备驱动程序会自动缓存编译出来的二进制代码(也被称作compute cache)。</p>
</li>
</ul>
<p>7、<strong>CUDA C运行库</strong></p>
<p>7.1 初始化：CUDA运行库没有显式的初始化函数，在调用第一个函数时会自动初始化(设备和版本管理函数不行)。初始化时，会产生一个全局可见的设备上下文(device context)。主机端代码调用了<code>cudaDeviceReset()</code>函数，则会销毁掉这个上下文。注意，销毁的上下文是主机端正在操纵的设备。如要更换，需要使用<code>cudaSetDevice()</code>来进行切换。</p>
<p>7.2 设备内存：</p>
<p>CUDA运行库提供了函数以分配/释放设备端的内存(全局内存+常量内存+纹理内存)，以及与主机端内存传输数据。</p>
<ul>
<li><p>线性存储(linear memory)：在GPU上用40位的地址线寻址</p>
<p>线性内存可以用<code>cudaMalloc()</code>分配，用<code>cudaFree()</code>释放，用<code>cudaMemcpy()</code>复制数据，用<code>cudaMemset()</code>赋值。</p>
<p>对于2D或3D数组，可以使用<code>cudaMallocPitch()</code>和<code>cudaMalloc3D()</code>来分配内存。这两个函数会自动padding，以满足内存对齐的要求，提高内存读写效率。</p>
</li>
<li><p>CUDA arrays—与纹理内存有关</p>
</li>
</ul>
<p>在设备内存中定义全局变量，则需要使用使用<code>__constant__</code>或<code>__device__</code>来修饰，并使用<code>cudaMemcpyToSymbol()</code>和<code>cudaMemcpyFromSymbol()</code>来读写。</p>
<p>实际上，当使用<code>__constant__</code>关键字时，是申请了一块常量内存；而使用<code>__device__</code>时，是普通的全局内存。因此<code>__device__</code>申请的内存需要申请，而<code>__constant__</code>不用。不管是全局内存，还是常量内存，需要用带有<code>Symbol</code>的函数拷贝。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">__constant__ <span class="keyword">float</span> constData[<span class="number">256</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> data[<span class="number">256</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaMemcpyToSymbol(&amp;constData, data, <span class="keyword">sizeof</span>(data));</span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaMemcpyFromSymbol(&amp;data, constData, <span class="keyword">sizeof</span>(data));</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">__device__ <span class="keyword">float</span> devData;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> value = <span class="number">3.14f</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaMemcpyToSymbol(devData, &amp;value, <span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">__device__ <span class="keyword">float</span>* devPtr;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">float</span>* ptr;</span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaMalloc(&amp;ptr, <span class="number">256</span>*<span class="keyword">sizeof</span>(<span class="keyword">float</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaMemcpyToSymbol(devPtr, &amp;ptr, <span class="keyword">sizeof</span>(ptr));</span></pre></td></tr></table></figure>
<p>8、<strong>共享内存</strong></p>
<p>不管是全局变量还是局部变量，都需要使用<code>__shared__</code>来修饰。不过需要注意的是，即使定义为全局变量，共享内存依旧只能被同一线程块内的线程可见。但是注意，并不是什么时候都可以使用共享内存来获取加速的。例如内核函数计算出来结果后，如果这个结果只需要传输回主机端，而不需要再次被用到时，直接写回全局内存会比较快。如果先写回共享内存，再写回全局内存，反而会比较缓慢。一般来讲，当需要频繁读写，或是有原子操作时，使用共享内存替代全局内存，会取得比较大的增益。</p>
<p><strong>共享内存只能为线程块内的线程共享。如果需要整个线程网格中线程都能访问，则需要全局内存或常量内存。</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//直方图统计</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">__shared__ <span class="keyword">unsigned</span> <span class="keyword">char</span> hist_shared[<span class="number">256</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">getGrayHistByCudaUsingSharedMem</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span> * <span class="keyword">const</span> grayData,</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">                                               <span class="keyword">unsigned</span> <span class="keyword">int</span> * <span class="keyword">const</span> hist,</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">                                               uint imgheight,</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="params">                                               uint imgwidth)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>9、<strong>锁页内存</strong></p>
<p>锁页内存指的是主机端上不会被换出到虚拟内存(位于硬盘)上的内存。</p>
<p>锁页内存的分配与释放：在CUDA程序中，使用<code>cudaHostAlloc()</code>，可以分配锁页内存，使用<code>cudaFreeHost()</code>来释放锁页内存，或者使用<code>cudaHostRegister()</code>来将<code>malloc()</code>分配的内存指定为锁页内存。</p>
<p>10、<strong>合并写内存(Write-Combining Memory)</strong></p>
<p>11、<strong>异步并行执行</strong></p>
<ul>
<li><p>主机端/设备端并行：</p>
<ul>
<li>内核启动与执行</li>
<li>设备端内部传输数据</li>
<li>使用流或内存映射传输数据</li>
<li>设备端memset函数cudaMemset())</li>
</ul>
</li>
<li><p>内核并行执行</p>
<ul>
<li>计算能力2.x及以上的设备，支持多个内核函数同时执行。</li>
<li>执行多个内核函数，需要主机端不同的线程启动。如果一个线程依次启动多个内核，则这些内核会串行执行。同一线程的内核函数返回时会触发隐式的同步。</li>
<li>多个内核函数必须位于同一个CUDA上下文(CUDA context)上。不同CUDA上下文上的内核不能并行。</li>
</ul>
</li>
<li><p>数据传输和内核执行并行(需要使用锁页内存)</p>
<ul>
<li>一些设备支持数据传输(主机端/设备端、设备端/设备端)和内核执行并行，可通过检查<code>asyncEngineCount</code>来确认。</li>
</ul>
</li>
<li><p>数据传入核传出并行</p>
</li>
<li><p>流(stream)</p>
<p>可以通过<code>cudaStreamCreateWithPriority()</code>来在创建流时指定流的优先级。可以指定的优先级可由<code>cudaDeviceGetStreamPriorityRange()</code>来获得。</p>
<p>运行时，高优先级stream中的线程块不能打断正在执行的低优先级stream的线程块(即不是抢占式的)。但是当低优先级stream的线程块退出SM时，高优先级stream中的线程块会被优先调度进SM。</p>
<ul>
<li>在CUDA中，流(streams)指的是在GPU上一连串执行的命令。</li>
<li>不同的线程，可以向同一个流填入任务。</li>
<li>同一个流内的任务会按顺序执行。</li>
<li>同一设备上不同的流有可能并行，其执行顺序不会有保证。</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//流的创建和销毁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaStream_t stream[<span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cudaStreamCreate(&amp;stream[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cudaStreamDestroy(stream[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//当设备还在执行流中的任务，而用户调用cudaStreamDestroy()函数时，函数会立刻执行(不会阻塞)。之后，当流中的任务完成后，与流相关的资源会自动释放。</span></span></pre></td></tr></table></figure>
<p>12、<strong>显示同步(Explicit Synchronization)</strong></p>
<p><strong>cudaDeviceSynchronize():</strong>  直到<strong>所有线程</strong>向设备端的<strong>所有流</strong>的<strong>所有已送入指令</strong>完成，才会退出阻塞。</p>
<p><strong>cudaStreamSynchronize():</strong> 直到<strong>指定流</strong>的<strong>之前所有已送入指令</strong>完成，才会退出阻塞。</p>
<p><strong>cudaStreamWaitEvent():</strong> 需要stream和event作为输入参数。需要等待该函数等待的事件(Event)发生后，才能执行。</p>
<p>13、<strong>隐式同步(Implicit Synchronization)</strong></p>
<p>一般来讲，不同流内的命令可以并行。但是当任何一个流执行如下的命令时，情况例外，不能并行：</p>
<ul>
<li>锁页内存的分配</li>
<li>设备端内存分配  </li>
<li>设备端内存设置(memset) </li>
<li>设备内部拷贝 </li>
<li>NULL stream内的命令</li>
<li>L1 cache/共享内存空间的重新分配</li>
</ul>
<p>14、<strong>回调函数</strong></p>
<p>可以使用<code>cudaStreamAddCallback()</code>函数，向流中添加callback。该callback会在流中之前所有的任务完成后被调用。如果stream参数设为0，则代表之前的所有stream的任务执行完后就调用该callback。</p>
<p>回调函数和<code>cudaStreamWaitEvent()</code>一样，对于在加在callback之后的指令，必须等待callback<em>执行完成</em>后，才会继续执行。</p>
<p>回调函数中不能直接或间接的执行CUDA函数，否则会因为等待自己完成而造成死锁。</p>
<p>15、<strong>事件(Event)</strong></p>
<p>事件(Event)可以被压入流中以监视流的运行情况，或者用于精确计时。如果向stream 0压入事件，则当压入事件前向所有流压入的任务完成后，事件才被触发。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cudaEvent_t start, <span class="built_in">stop</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaEventCreate(&amp;start);   <span class="comment">//创建</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaEventCreate(&amp;<span class="built_in">stop</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">...</span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaEventDestroy(start);    <span class="comment">//销毁</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaEventDestroy(<span class="built_in">stop</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//计算时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaEventRecord(start, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;<span class="number">2</span>; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cudaMemcpyAsync(inputDev + i * <span class="built_in">size</span>, inputHost + i * <span class="built_in">size</span>, <span class="built_in">size</span>, cudaMemcpyHostToDevice, stream[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    MyKernel&lt;&lt;&lt;<span class="number">100</span>, <span class="number">512</span>, <span class="number">0</span>, stream[i]&gt;&gt;&gt;(outputDev + i * <span class="built_in">size</span>, inputDev + i * <span class="built_in">size</span>, <span class="built_in">size</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cudaMemcpyAsync(outputHost + i * <span class="built_in">size</span>, outputDev + i * <span class="built_in">size</span>, <span class="built_in">size</span>, cudaMemcpyDeviceToHost, stream[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaEventRecord(<span class="built_in">stop</span>, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaEventSynchronize(<span class="built_in">stop</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">float</span> elapsedTime;</span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaEventElapsedTime(&amp;elapsedTime, start, <span class="built_in">stop</span>);</span></pre></td></tr></table></figure>
<p>16、<strong>多设备系统</strong></p>
<ul>
<li>设备枚举</li>
<li>设备选择</li>
<li>流和事件的执行情况<ul>
<li><strong>内核启动</strong>：如果将内核压入不属于当前设备的流中，则内核会启动失败。也就是说，如果要向一个流中压入内核，必须先切换到流所在的设备。</li>
<li><strong>内存拷贝</strong>：如果对一个不属于当前设备的流进行内存拷贝工作，内存拷贝会成功。</li>
<li><strong>cudaEventRecord()</strong>：必须现将设备上下文切换过去，再向流压入事件。</li>
<li><strong>cudaEventElapsedTime()</strong>：计算时间差前，必须先切换设备。</li>
<li><strong>cudaEventSynchronize() and cudaEventQuery()</strong>：即使处于不同的设备，事件同步和事件查询依然有效。</li>
<li><strong>cudaStreamWaitEvent()</strong>：比较特殊，即使函数输入的流和事件不在同一个设备上，也能成功执行。也就是说，可以让流等待另一个设备上(当然当前设备也可以)的事件。这个函数可以用作多个设备间的同步。</li>
</ul>
</li>
<li>内存的访问</li>
<li>(设备间)对等内存访问：计算能力2.0及以上的设备支持设备间对等内存访问，这意味着两个GPU之间的传输和访问可以不经过主机端中转，速度会有提升。</li>
<li>(设备间)对等内存访问：对等设备的地址是统一编址的，可以使用<code>cudaMemcpyPeer()、cudaMemcpyPeerAsync()、cudaMemcpy3DPeer、cudaMemcpy3DPeerAsync()</code>来进行直接拷贝。无需先拷贝会主机端内存，再转到另一块卡上。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设备枚举</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> deviceCount;</span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaGetDeviceCount(&amp;deviceCount);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> device;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(device=<span class="number">0</span>; device&lt;deviceCount; device++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cudaDeviceProp deviceProp;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cudaGetDeviceProperties(&amp;deviceProp, device);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"Device %d has compute capability %d.%d.\n"</span>, device, deviceProp.major, deviceProp.minor);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//设备选择</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//使用cudaSetDevice()选择设备，当不选择时，默认使用设备0。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//注意，所有的内存分配、内核函数启动、流和事件的创建等，都是针对当前选择的设备的。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="built_in">size</span> = <span class="number">1024</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaSetDevice(<span class="number">0</span>);   <span class="comment">// Set device 0 as current</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">float</span>* p0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaMalloc(&amp;p0, <span class="built_in">size</span>);  <span class="comment">// Allocate memory on device 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">MyKernel&lt;&lt;&lt;<span class="number">1000</span>, <span class="number">128</span>&gt;&gt;&gt;(p0);    <span class="comment">// Launch kernel on device 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaSetDevice(<span class="number">1</span>);   <span class="comment">// Set device 1 as current</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">float</span>* p1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaMalloc(&amp;p1, <span class="built_in">size</span>);  <span class="comment">// Allocate memory on device 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">MyKernel&lt;&lt;&lt;<span class="number">1000</span>, <span class="number">128</span>&gt;&gt;&gt;(p1); <span class="comment">// Launch kernel on device 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//设备间，对等内存拷贝</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaSetDevice(<span class="number">0</span>);   <span class="comment">// Set device 0 as current</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">float</span>* p0;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">size_t</span> <span class="built_in">size</span> = <span class="number">1024</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaMalloc(&amp;p0, <span class="built_in">size</span>);  <span class="comment">// Allocate memory on device 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaSetDevice(<span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">float</span>* p1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaMalloc(&amp;p1, <span class="built_in">size</span>);  <span class="comment">// Allocate memory on device 1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaSetDevice(<span class="number">0</span>);       <span class="comment">// Set Device 0 as Current</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">MyKernel&lt;&lt;&lt;<span class="number">1000</span>, <span class="number">128</span>&gt;&gt;&gt;(p0);    <span class="comment">// Launch Kernel on Device 0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaSetDevice(<span class="number">1</span>);               <span class="comment">// Set Device 1 as Current</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cudaMemcpyPeer(p1, <span class="number">1</span>, p0, <span class="number">0</span>, <span class="built_in">size</span>); <span class="comment">// Copy p0 to p1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">MyKernel&lt;&lt;&lt;<span class="number">1000</span>, <span class="number">128</span>&gt;&gt;&gt;(p1);        <span class="comment">// Launch Kernel on Device 1</span></span></pre></td></tr></table></figure>
<p>如果使用的是NULL stream，如果拷贝的双方中的任何一方，在设备拷贝前有任务未完成，则拷贝会被阻塞，直至任务完成。*  只有拷贝结束后，两者的后续任务才能继续执行。</p>
<h4 id="二、性能优化"><a href="#二、性能优化" class="headerlink" title="二、性能优化"></a>二、性能优化</h4><p>性能优化的原则：</p>
<ol>
<li>最大化并行，以提升资源利用率</li>
<li>优化内存排布，以最大化内存吞吐</li>
<li>最大化指令吞吐</li>
</ol>
<p>性能分析工具：CUDA profiler</p>
<p><strong>应用级别并行</strong>： 尽可能让主机端、设备端、PCI-E总线并行工作。对此可以使用异步CUDA函数，以及流(Stream)来实现。</p>
<p>同步操作，以及内存的共享会影响程序的并行性。因此需要仔细设计算法流程，尽量减少同步和内存共享。</p>
<p><strong>设备级别同步：</strong>可以通过流的方式，尽可能的让多个内核并行，提升利用率。</p>
<p><strong>处理器级别并行：</strong>延迟(latency)指的是线程束(从上一个动作开始)到它处于ready状态的时钟数。 例如线程束先提交了一个内存访问请求，然后等了400个时钟周期，内存管理系统才返回数据，线程束可以继续执行。这400个时钟周期称为延迟。</p>
<p>当一个线程束发生延迟时，线程束调度器(warp  scheduler)会将其他处于ready状态的线程束调度到SP上。等到延迟结束后，再将该线程调度回SP继续执行。这样一来，前一个线程束的延迟，就被另一个线程束的执行所隐藏了。 这一过程被称作延迟的隐藏(hidden latency)。  </p>
<p>隐藏延迟是GPU编程的核心概念。由于GPU具有巨大的寄存器空间，线程的切换不存在损耗。因此，通过向GPU上分配足够多的线程，可以让这些线程延迟互相交错，以起到隐藏延迟的作用，提高硬件利用率。</p>
<p><strong>最大化内存吞吐：</strong>主要手段就是少用低带宽的内存。首先要尽可能减少主机端和设备端间的设备传输(PCI-E，特别慢)，其次要尽可能减少全局内存的读写(快于PCI-E，但是相对于片内内存来说，还是挺慢的)；尽可能的使用片内的内存(寄存器、cache、共享内存)。</p>
]]></content>
      <categories>
        <category>CUDA Programmer</category>
      </categories>
      <tags>
        <tag>CUDA Programmer</tag>
      </tags>
  </entry>
  <entry>
    <title>CUDA-Programmer-Learn-Zero</title>
    <url>/2021/07/03/CUDA-Programmer-Learn-Zero/</url>
    <content><![CDATA[<h2 id="CUDA编程学习笔记"><a href="#CUDA编程学习笔记" class="headerlink" title="CUDA编程学习笔记"></a>CUDA编程学习笔记</h2><h4 id="一、CUDA编程模式的基本概念"><a href="#一、CUDA编程模式的基本概念" class="headerlink" title="一、CUDA编程模式的基本概念"></a>一、CUDA编程模式的基本概念</h4><p>CUDA是一种通用的异构并行计算平台和编程模型，你可以利用CUDA平台像在CPU上那样使用GPU来进行计算。</p>
<p>一般的CUDA(.cu)程序的执行步骤为：</p>
<ol>
<li>分配GPU显存</li>
<li>将待处理的数据从HOST内存拷贝到GPU的显存</li>
<li>调用核函数对存储在GPU显存中的数据进行处理</li>
<li>将结果从GPU显存拷贝到HOST内存</li>
<li>释放GPU显存</li>
</ol>
<h4 id="二、CUDA编程模式的两大重点"><a href="#二、CUDA编程模式的两大重点" class="headerlink" title="二、CUDA编程模式的两大重点"></a>二、CUDA编程模式的两大重点</h4><ol>
<li><p>通过层次结构来组织线程</p>
<p>1.1 线程的管理：<strong>线程网格(Grid)、线程块(Block)、线程束(Warp)和线程(Thread)</strong></p>
<p>1.2 一个内核启动所生成的所有线程称为一个网格，同一网格内的所有线程共享同一块全局内存空间。一个网格有多个线程块构成。一个线程块由一组线程构成</p>
<p>1.3 优势：合理的利用资源，优化性能</p>
</li>
<li><p>通过层次结构来组织内存</p>
<p>2.1 GPU的各级缓存和显存是可以通过程序进行控制的。具体有寄存器、共享内存、常量内存和全局内存等</p>
<p>2.2 <strong>寄存器</strong>是GPU上运行速度最快的内存空间，带宽通常为8TB/s,延时为一个时钟周期。<strong>共享内存</strong>是GPU上可受用户控制的一级缓存，带宽通常为1.5TB/s,延迟为1~32个时钟周期。<strong>全局内存</strong>是GPU中最大的，延迟最高且最常被使用的内存。</p>
<p><img src="/2021/07/03/CUDA-Programmer-Learn-Zero/1.jpg" alt="Cuda-memory-struct"></p>
</li>
</ol>
<h5 id="三、矩阵运算"><a href="#三、矩阵运算" class="headerlink" title="三、矩阵运算"></a>三、矩阵运算</h5><p>1、矩阵索引：在一个二维矩阵加法的核函数中，一个线程通常被分配一个数据元素来处理。首先要完成的任务是如何使用块和线程索引从全局内存中访问指定的数据。</p>
<p><strong>如何映射线程的Id到图像矩阵的坐标上？</strong></p>
<p>可以使用如下的公式将线程网格和线程块的索引映射到矩阵坐标上,称为坐标索引。</p>
<script type="math/tex; mode=display">
ix = blockIdx.x * blockDim.x + threadIdx.x \\
iy = blockIdx.y * blockDim.y + threadIdx.y</script><p>可以使用如下公式将矩阵坐标映射到全局内存的索引/存储单元上，称为全局索引(因为数据在内存的存储往往是一维的，需要地址映射)。</p>
<script type="math/tex; mode=display">
idx = iy*nx + ix,\quad nx表示x维度上元素的个数</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">__global__ <span class="keyword">void</span> <span class="title">sumMatUsingGPU</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">char</span>* A, <span class="keyword">unsigned</span> <span class="keyword">char</span>* B, <span class="keyword">unsigned</span> <span class="keyword">char</span>* C, uint <span class="built_in">height</span>, uint <span class="built_in">width</span>)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> ix = blockIdx.x * blockDim.x + threadIdx.x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> iy = blockIdy.y * blockDim.y + threadIdy.y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> idx = iy * <span class="built_in">width</span> + ix;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(ix &lt; <span class="built_in">width</span> &amp;&amp; iy &lt; <span class="built_in">height</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        C[idx] = A[idx] + B[idx];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    uint <span class="built_in">height</span> = <span class="number">5</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    uint <span class="built_in">width</span> = <span class="number">20</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> byteSize = <span class="built_in">height</span> * <span class="built_in">width</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">size_t</span> nBytes = byteSize * <span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">float</span> *h_A, *h_B, *h_C;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    h_A = (<span class="keyword">float</span> *)<span class="built_in">malloc</span>(nBytes);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    h_B = (<span class="keyword">float</span> *)<span class="built_in">malloc</span>(nBytes);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    h_C = (<span class="keyword">float</span> *)<span class="built_in">malloc</span>(nBytes);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>* A, *B, *C;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cudaMalloc(&amp;A, byteSize*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cudaMalloc(&amp;B, byteSize*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cudaMalloc(&amp;C, byteSize*<span class="keyword">sizeof</span>(<span class="keyword">unsigned</span> <span class="keyword">char</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    cudaMemcpy(A, h_A, nBytes, cudaMemcpyHostToDeviec);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cudaMemcpy(B, h_B, nBytes, cudaMemcpyHostToDeviec);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cudaMemcpy(C, h_C, nBytes, cudaMemcpyHostToDeviec);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">dim3 <span class="title">thread</span><span class="params">(<span class="built_in">height</span>/<span class="number">5</span>,<span class="built_in">width</span>/<span class="number">5</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">dim3 <span class="title">block</span><span class="params">(<span class="built_in">height</span>, <span class="built_in">width</span>)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sumMatUsingGPU&lt;&lt;&lt;block, thread&gt;&gt;&gt;(A, B, C, <span class="built_in">height</span>, <span class="built_in">width</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cudaMemcpy(h_c, d_c, nBytes, cudaMemcpyDeviceToHost);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cudaFree(A);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cudaFree(B);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cudaFree(C);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//编译</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">nvcc -arch=sm_20 sumOnGPU.cu -o sumOnGPU</span></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>限定符</th>
<th>执行</th>
<th>调用</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>__global__</code></td>
<td>在设备端执行</td>
<td>可从主机、设备端调用</td>
<td>必须有一个void返回类型</td>
</tr>
<tr>
<td><code>__device__</code></td>
<td>在设备端执行</td>
<td>仅能从设备端调用</td>
<td></td>
</tr>
<tr>
<td><code>__host__</code></td>
<td>在主机端执行</td>
<td>仅能从主机端上调用</td>
<td>可以省略不写</td>
</tr>
</tbody>
</table>
</div>
<h4 id="四、如何提升并行能力"><a href="#四、如何提升并行能力" class="headerlink" title="四、如何提升并行能力"></a>四、如何提升并行能力</h4><ul>
<li>降低延迟，延迟是指操作从开始到结束所需要的时间，一般用微秒计算，延迟越低越好。</li>
<li>提高带宽，带宽是单位时间内处理的数据量，一般用MB/s或者GB/s表示。</li>
<li>提高吞吐量，吞吐量是单位时间内成功处理的运算数量，一般用gflops来表示（十亿次浮点计算），吞吐量和延迟有一定关系，都是反应计算速度的，<strong>一个是时间除以运算次数，得到的是单位次数用的时间–延迟，一个是运算次数除以时间，得到的是单位时间执行次数–吞吐量。</strong></li>
</ul>
<h4 id="五、计算机架构"><a href="#五、计算机架构" class="headerlink" title="五、计算机架构"></a>五、计算机架构</h4><p>划分不同计算机结构的方法有很多，广泛使用的一种被称为佛林分类法Flynn’s Taxonomy，<strong>根据指令和数据进入CPU的方式分类</strong>，分为以下四类：</p>
<ol>
<li>单指令单数据SISD（传统串行计算机，386）</li>
<li>单指令多数据SIMD（并行架构，比如向量机，所有核心指令唯一，但是数据不同，现在CPU基本都有这类的向量指令）</li>
<li>多指令单数据MISD（少见，多个指令围殴一个数据）</li>
<li>多指令多数据MIMD（并行架构，多核心，多指令，异步处理多个数据流，从而实现空间上的并行，MIMD多数情况下包含SIMD，就是MIMD有很多计算核，计算核支持SIMD）</li>
</ol>
<p><strong>根据内存划分</strong>，分为以下两类：</p>
<ol>
<li><p>分布式内存的多节点系统</p>
<p>通常叫做集群，就是一个机房好多机箱，每个机箱都有内存处理器电源等一些列硬件，通过网络互动，这样组成的就是分布式。</p>
</li>
<li><p>共享内存的多处理器系统</p>
<p>单个主板有多个处理器，他们共享相同的主板上的内存，内存寻址空间相同，通过PCIe和内存互动。</p>
<p><strong>多个处理器可以分多片处理器，和单片多核（众核many-core）</strong>，也就是有些主板上挂了好多片处理器，也有的是一个主板上就一个处理器，但是这个处理器里面有几百个核。<strong>GPU就属于众核系统</strong></p>
</li>
</ol>
<ul>
<li>CPU适合执行复杂的逻辑，比如多分支，其核心比较重（复杂）</li>
<li>GPU适合执行简单的逻辑，大量的数据计算，其吞吐量更高，但是核心比较轻（结构简单）</li>
</ul>
<h4 id="六、异构架构"><a href="#六、异构架构" class="headerlink" title="六、异构架构"></a>六、异构架构</h4><p>拥有不同计算机架构体系的硬件相互配合完成高吞吐量工作的系统。例如：CPU我们可以把它看做一个指挥者，主机端，host，而完成大量计算的GPU是我们的计算设备，device。下图来之谭升的知乎</p>
<p><img src="/2021/07/03/CUDA-Programmer-Learn-Zero/2.png" alt="Cuda-memory-struct"></p>
<ul>
<li>左图：一个四核CPU一般有四个ALU，ALU是完成逻辑计算的核心，也是我们平时说四核八核的核，控制单元，缓存也在片上，DRAM是内存，一般不在片上，CPU通过总线访问内存。</li>
<li>右图：GPU，绿色小方块是ALU，我们注意红色框内的部分SM，这一组ALU公用一个Control单元和Cache，<strong>这个部分相当于一个完整的多核CPU</strong>，但是<strong>不同的是ALU多了，control部分变小，可见计算能力提升了，控制能力减弱了，</strong>所以对于控制（逻辑）复杂的程序，一个GPU的SM是没办法和CPU比较的，但是对了逻辑简单，数据量大的任务，GPU更高效。注意，一个GPU有好多个SM，而且越来越多。</li>
</ul>
<p>CPU和GPU之间通过PCIe总线连接，用于传递指令和数据，这部分也是后面要讨论的性能瓶颈之一。</p>
<p>一个异构应用包含两种以上架构，所以分为主机端代码和设备端代码。主机代码在主机端运行，被<strong>编译成主机架构的机器码</strong>，设备端的在设备上执行，<strong>被编译成设备架构的机器码</strong>，所以主机端的机器码和设备端的机器码是隔离的，自己执行自己的，没办法交换执行。</p>
<p>主机端代码主要是<strong>控制设备，完成数据传输等控制类工作</strong>，设备端主要的任务就是<strong>计算</strong>。</p>
<p>NVIDIA目前有多种计算平台，每个平太针对不同的应用场景，比如Tegra用于嵌入式，Geforce是我们平时打游戏用到，Tesla主要用于计算。</p>
<p>衡量GPU计算能力的主要靠下面两种<strong>容量特征</strong>：<strong>CUDA核心数和内存大小</strong>。<strong>计算能力的性能指标</strong>：<strong>峰值计算能力和内存带宽</strong>。下图来之谭升的知乎</p>
<p><img src="/2021/07/03/CUDA-Programmer-Learn-Zero/3.png" alt="Cuda-memory-struct"></p>
<p>CPU和GPU线程的区别：</p>
<ol>
<li>CPU线程是重量级实体，操作系统交替执行线程，线程上下文切换花销很大。</li>
<li>GPU线程是轻量级的，GPU应用一般包含成千上万的线程，多数在排队状态，线程之间切换基本没有开销。</li>
<li>CPU的核被设计用来尽可能减少一个或两个线程运行时间的延迟，而GPU核则是大量线程，最大幅度提高吞吐量。</li>
</ol>
<p>CUDA nvcc编译器会自动分离你代码里面的不同部分，如图中主机代码用C写成，使用本地的C语言编译器编译，设备端代码，也就是核函数，用CUDA C编写，通过nvcc编译，链接阶段，在内核程序调用或者明显的GPU设备操作时，添加运行时库。</p>
<p>可以用到的工具：</p>
<ul>
<li>Nvidia Nsight集成开发环境</li>
<li>CUDA-GDB 命令行调试器</li>
<li>性能分析可视化工具</li>
<li>CUDA-MEMCHECK工具</li>
<li>GPU设备管理工具</li>
</ul>
<p><a href="https://face2ai.com/program-blog/#GPU%E7%BC%96%E7%A8%8B%EF%BC%88CUDA%EF%BC%89" target="_blank" rel="noopener">学习参考资料</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/346910129" target="_blank" rel="noopener">总结性资料</a></p>
]]></content>
      <categories>
        <category>CUDA Programmer</category>
      </categories>
      <tags>
        <tag>CUDA Programmer</tag>
      </tags>
  </entry>
  <entry>
    <title>Principles-Of-Computer-Composition-Zero</title>
    <url>/2021/07/03/Principles-Of-Computer-Composition-Zero/</url>
    <content><![CDATA[<h2 id="计算机组成原理部分知识学习笔记"><a href="#计算机组成原理部分知识学习笔记" class="headerlink" title="计算机组成原理部分知识学习笔记"></a>计算机组成原理部分知识学习笔记</h2><h4 id="一、线程绑定CPU核心的意义"><a href="#一、线程绑定CPU核心的意义" class="headerlink" title="一、线程绑定CPU核心的意义"></a>一、线程绑定CPU核心的意义</h4><p>在多核CPU中合理的调度线程在各个核上运行可以获得更高的性能。在多线程编程中，<strong>每个线程处理的任务优先级是不一样</strong>的，对于<strong>要求实时性比较高</strong>的线程或者是<strong>主线程</strong>，对于这种线程可以<strong>在创建线程时指定其绑定到某个CPU核</strong>上，以后这个核就专门处理该线程。这样可以使得该线程的任务可以得到较快的处理(<strong>因为减少了线程上下文在多核间切换时候的开销)</strong>，特别是和用户直接交互的任务，较短的响应时间可以提升用户的体验感。<br>原文链接：<a href="https://blog.csdn.net/weixin_42031299/article/details/114376419" target="_blank" rel="noopener">https://blog.csdn.net/weixin_42031299/article/details/114376419</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE             <span class="comment">/* See feature_test_macros(7) */</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_setaffinity_np</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">size_t</span> cpusetsize, <span class="keyword">const</span> <span class="keyword">cpu_set_t</span> *cpuset)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pthread_getaffinity_np</span><span class="params">(<span class="keyword">pthread_t</span> thread, <span class="keyword">size_t</span> cpusetssoize, <span class="keyword">cpu_set_t</span> *cpuset)</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//编译和链接的时候需要在Makefile中添加 -pthread动态so库</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">原文链接：https:<span class="comment">//blog.csdn.net/bandaoyu/article/details/113700713</span></span></pre></td></tr></table></figure>
<h4 id="二、进程绑定CPU核心"><a href="#二、进程绑定CPU核心" class="headerlink" title="二、进程绑定CPU核心"></a>二、进程绑定CPU核心</h4><p>在Linux系统中，进程的调度切换是由内核自动完成的，在多核CPU上，进程有可能在不同的CPU核上来回切换执行，这对CPU的缓存不是很有利。</p>
<p><img src="/2021/07/03/Principles-Of-Computer-Composition-Zero/1.png" alt="CPU"></p>
<p>在多核CPU结构中，每个核心有各自的L1、L2缓存，而L3缓存是共用的。如果一个进程在核心间来回切换，各个<strong>核心的缓存命中率</strong>就会受到影响。相反如果进程不管如何调度，都始终可以在一个核心上执行，那么其数据的L1、L2 缓存的命中率可以显著提高。如下为绑定CPU的具体实现：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1、使用 **CPU_**系列函数，必须定义 _GNU_SOURCE 宏，告诉编译器启用这些函数。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//2、首先声明一个 cpu_set_t，然后用 CPU_ZERO()初始化bit数据：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//The cpu_set_t data type is implemented as a bitset. </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">cpu_set_t</span> mask;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//将cpu_set_t结构体清零，Clears set, so that it contains no CPUs. </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">CPU_ZERO(&amp;mask);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//接下来把进程绑定到某几个CPU核心，这要用CPU_SET()来设置cpu_set_t中相应的bit位，比如想让进程只在核心1或核心5上执行：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">CPU_SET(<span class="number">1</span>, &amp;mask); <span class="comment">//Add CPU cpu to set. </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//最后用sched_setaffinity完成实际的绑定：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//sched_setaffinity(pid_t pid, unsigned int cpusetsize, cpu_set_t *mask) </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//该函数设置进程为pid的这个进程,让它运行在mask所设定的CPU上.如果pid的值为0,则表示指定的是当前进程,使当前进程运行在mask所设定的那些CPU上.第二个参数cpusetsize是mask所指定的数的长度.通常设定为sizeof(cpu_set_t).如果当前pid所指定的进程此时没有运行在mask所指定的任意一个CPU上,则该指定的进程会从其它CPU上迁移到mask的指定的一个CPU上运行. </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">cpu_set_t</span>), &amp;mask);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//sched_getaffinity获取绑定关系</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//Remove CPU cpu from set. </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">CPU_CLR()</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//Test to see if CPU cpu is a member of set.  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">CPU_ISSET()</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//Return the number of CPUs in set.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">CPU_COUNT()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//The constant CPU_SETSIZE (currently 1024) specifies a value one greater than the maximum CPU number that can be stored in cpu_set_t. </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">num = sysconf(_SC_NPROCESSORS_CONF);  <span class="comment">//获取核数</span></span></pre></td></tr></table></figure>
<p>举例：假定有一台双核机器，这段程序我们起了20个进程，从0开始每个进程分配一个进程号（注意是这里值我们自己起的进程号，不是进程pid），奇数进程号绑定绑定在 Core 0上执行，偶数号的进程绑定在 Core 1上执行。<br>链接：<a href="https://www.jianshu.com/p/f59d7df06432" target="_blank" rel="noopener">https://www.jianshu.com/p/f59d7df06432</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _GNU_SOURCE</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GNU_SOURCE</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sched.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/time.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 100000</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">(<span class="keyword">int</span> pid, <span class="keyword">int</span> core)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">cpu_set_t</span> mask;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	CPU_ZERO(&amp;mask);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	CPU_SET(core, &amp;mask);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    设置亲和性</span></pre></td></tr><tr><td class="code"><pre><span class="line">	sched_setaffinity(<span class="number">0</span>, <span class="keyword">sizeof</span>(<span class="keyword">cpu_set_t</span>), &amp;mask);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">long</span> <span class="built_in">begin</span>=tv.tv_sec * <span class="number">1000</span> * <span class="number">1000</span> + tv.tv_usec;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> arr[N];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i != N; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        arr[i] = i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">long</span> sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i != N; i++) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sum += arr[i];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    gettimeofday(&amp;tv, <span class="literal">NULL</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">long</span> <span class="built_in">end</span> = tv.tv_sec * <span class="number">1000</span> * <span class="number">1000</span>+ tv.tv_usec;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">printf</span>(<span class="string">"%ld\n"</span>, <span class="built_in">end</span> - <span class="built_in">begin</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//for(int i=0; i&lt;2; i++)&#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//	printf("%d, %d\n",pid,sched_getcpu());</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">int</span> i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;<span class="number">20</span>; ++i)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">pid_t</span> pid = fork(); <span class="comment">//fork函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span>(pid==<span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="built_in">run</span>(i, i%<span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="built_in">exit</span>(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//Makefile编译和链接</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">g++ thread_bind_cpu.cpp -o thread_bind_cpu</span></pre></td></tr></table></figure>
<p>测试的部分结果，得出绑定对应的CPU对计算性能有一定的提升。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>次数</th>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
<th>10</th>
</tr>
</thead>
<tbody>
<tr>
<td>绑CPU核</td>
<td>849/us</td>
<td>838/us</td>
<td>835/us</td>
<td>818/us</td>
<td>834/us</td>
<td>819/us</td>
<td>838/us</td>
<td>819/us</td>
<td>841/us</td>
<td>823/us</td>
</tr>
<tr>
<td>不绑定核</td>
<td>868/us</td>
<td>903/us</td>
<td>943/us</td>
<td>918/us</td>
<td>954/us</td>
<td>981/us</td>
<td>985/us</td>
<td>987/us</td>
<td>1025/us</td>
<td>960/us</td>
</tr>
</tbody>
</table>
</div>
<p><a href="https://linux.die.net/man/3/cpu_set" target="_blank" rel="noopener">cpu_set_t的参考链接</a>  | <a href="https://linux.die.net/man/2/sched_setaffinity" target="_blank" rel="noopener">sched_setaffinity的参考链接</a>  </p>
<p><strong>Linux中的fork()函数</strong></p>
<p><strong>一个进程</strong>，<strong>包括代码、数据和分配给进程的资源</strong>。fork（）函数通过系统调用创建一个与原来进程几乎完全相同的进程，也就是两个进程可以做完全相同的事。一个进程调用fork（）函数后，系统先给新的进程分配资源，例如存储数据和代码的空间。然后把原来的进程的所有值都复制到新的新进程中，只有少数值与原来的进程的值不同。相当于克隆了一个自己。在<strong>fork函数执行完毕后</strong>，<strong>如果创建新进程成功</strong>，<strong>则出现两个进程，一个是子进程，一个是父进程</strong>。<strong>在子进程中，fork函数返回0，在父进程中，fork返回新创建子进程的进程ID</strong>。我们可以通过fork返回的值来判断当前进程是子进程还是父进程。用大神的话说“其实就相当于链表，进程形成了链表，父进程的fpid(p 意味point)指向子进程的进程id, 因为子进程没有子进程，所以其fpid为0。</p>
<p>fork出错可能有两种原因：1、当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。2、系统内存不足，这时errno的值被设置为ENOMEM。</p>
<p>创建新进程成功后，系统中出现两个基本完全相同的进程，这两个进程<strong>执行没有固定的先后顺序</strong>，哪个进程先执行要看系统的进程调度策略。 <strong>每个进程都有一个独特（互不相同）的进程标识符（process ID），可以通过getpid（）函数获得</strong>，还有一个记录父进程pid的变量，可以通过getppid（）函数获得变量的值。</p>
<p><strong>注意：</strong> <strong>fork()不是从#include处开始复制代码的</strong>，这是因为fork是把进程当前的情况拷贝一份，执行fork时，进程已经执行完了int count=0;fork只拷贝下一个要执行的代码到新的进程。</p>
<p><a href="https://www.cnblogs.com/dongguolei/p/8086346.html" target="_blank" rel="noopener">原文链接</a></p>
<h4 id="三、对上面一、二的补充"><a href="#三、对上面一、二的补充" class="headerlink" title="三、对上面一、二的补充"></a>三、对上面一、二的补充</h4><p>1、查看绑定情况</p>
<p>查看进程的绑定核情况：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">taskset -p pid</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; pid xxx<span class="string">'s current affinity mask: 6 //6的二进制表示为110,则表示该pid在cpu1和cpu2上运行，从0开始计数</span></span></span></pre></td></tr></table></figure>
<p>2、程序启动时绑定</p>
<p>3、程序启动后绑定</p>
<p>4、查看cpu的核数</p>
<p>使用<code>cat /proc/cpuinfo</code>查看cpu信息: processor指明第几个cpu处理器，cpu cores指明每个处理器的核数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysconf</span><span class="params">(_SC_NPROCESSORS_CONF)</span></span>;<span class="comment">/* 返回系统可以使用的核数，但是其值会包括系统中禁用的核的数目，因 此该值并不代表当前系统中可用的核数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sysconf</span><span class="params">(_SC_NPROCESSORS_ONLN)</span></span>;<span class="comment">/* 返回值真正的代表了系统当前可用的核数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">/* 以下两个函数与上述类似 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sysinfo.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_nprocs_conf</span> <span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">/* 可用核数 */</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_nprocs</span> <span class="params">(<span class="keyword">void</span>)</span></span>;<span class="comment">/* 真正的反映了当前可用核数 */</span></span></pre></td></tr></table></figure>
<p>原文链接：<a href="https://blog.csdn.net/bandaoyu/article/details/113700713" target="_blank" rel="noopener">https://blog.csdn.net/bandaoyu/article/details/113700713</a></p>
<h4 id="四、简述Opaque-不透明类型"><a href="#四、简述Opaque-不透明类型" class="headerlink" title="四、简述Opaque(不透明类型)"></a>四、简述Opaque(不透明类型)</h4><p>在计算机科学中，<strong>不透明数据类型</strong>(opaque is a data type)是其具体<strong>数据结构未在接口中定义</strong>的数据类型。 这会<strong>强制隐藏信息</strong>，因为<strong>它的值</strong>只能<strong>通过调用有权访问</strong>缺失信息<strong>的子例程</strong>来操作。 类型的<strong>具体表示对其用户是隐藏的</strong>，<strong>可见的实现是不完整的</strong>。 <strong>如果</strong>表示可见的数据类型称为透明，<strong>否则</strong>称为不透明类型。 不透明数据类型经常用于实现抽象数据类型。 </p>
<p>不透明数据类型的<strong>典型示例</strong>包括操作系统向应用软件提供的资源句柄。 例如，线程的 POSIX 标准定义了一个基于许多不透明类型的应用程序编程接口，这些类型代表线程或同步原语，如<strong>互斥锁或条件变量</strong>。</p>
<p><a href="https://en.wikipedia.org/wiki/Opaque_data_type" target="_blank" rel="noopener">参考Wiki</a></p>
<h4 id="五、缓存相关学习笔记"><a href="#五、缓存相关学习笔记" class="headerlink" title="五、缓存相关学习笔记"></a>五、缓存相关学习笔记</h4><p>主要参考来自于<a href="https://www.cnblogs.com/ricks/p/12400900.html" target="_blank" rel="noopener">此</a></p>
<h5 id="1、基础知识："><a href="#1、基础知识：" class="headerlink" title="1、基础知识："></a>1、基础知识：</h5><p>现在的CPU多核技术，都会有几级缓存，老的CPU会有两级内存（L1和L2），新的CPU会有三级内存（L1，L2，L3 ），如下图所示：</p>
<p><img src="/2021/07/03/Principles-Of-Computer-Composition-Zero/2.png" alt="cache-architecture"></p>
<p>其中：</p>
<ul>
<li>L1缓分成两种，一种是指令缓存，一种是数据缓存。L2缓存和L3缓存不分指令和数据。</li>
<li>L1和L2缓存在每一个CPU核中，L3则是所有CPU核心共享的内存。</li>
<li>L1、L2、L3的越离CPU近就越小，速度也越快，越离CPU远，速度也越慢。</li>
</ul>
<p>再往后面就是内存，内存的后面就是硬盘，如下为各级的存取速度：</p>
<ul>
<li>L1 的存取速度：<strong>4 个CPU时钟周期</strong></li>
<li>L2 的存取速度： <strong>11 个CPU时钟周期</strong></li>
<li>L3 的存取速度：<strong>39 个CPU时钟周期</strong></li>
<li>RAM内存的存取速度<strong>：107 个CPU时钟周期</strong></li>
</ul>
<p>数据就从内存向上，先到L3，再到L2，再到L1，最后到寄存器进行CPU计算。为什么会设计成三层？这里有下面几个方面的考虑：</p>
<ul>
<li>一个方面是物理速度，如果要更大的容量就需要更多的晶体管，除了芯片的体积会变大，更重要的是大量的晶体管会导致速度下降，因为访问速度和要访问的晶体管所在的位置成反比，也就是当信号路径变长时，通信速度会变慢。这部分是物理问题。</li>
<li>另外一个问题是，多核技术中，数据的状态需要在多个CPU中进行同步，并且，我们可以看到，cache和RAM的速度差距太大，所以，多级不同尺寸的缓存有利于提高整体的性能。</li>
</ul>
<p>同时会产生两个比较重要的问题：</p>
<ul>
<li>一个是比较简单的缓存的命中率的问题。</li>
<li>另一个是比较复杂的缓存更新的一致性问题。</li>
</ul>
<h5 id="2、缓存命中-计算机组成原理"><a href="#2、缓存命中-计算机组成原理" class="headerlink" title="2、缓存命中(计算机组成原理)"></a>2、缓存命中(计算机组成原理)</h5><p>缓存基本上来说就是把后面的数据加载到离自己近的地方，对于CPU来说，它是不会一个字节一个字节的加载的，因为这非常没有效率，<strong>一般来说都是要一块一块的加载的</strong>，对于这样的一块一块的数据单位，术语叫<strong>“Cache Line”</strong>，一般来说，一个主流的CPU的Cache Line 是 64  Bytes（也有的CPU用32Bytes和128Bytes），64Bytes也就是16个32位的整型，这就是CPU从内存中捞数据上来的最小数据单位。</p>
<p><strong>比如：</strong>Cache Line是最小单位（64Bytes），所以先把Cache分成多个Cache Line，比如：L1有32KB，那么，32KB/64B = 512 个 Cache Line。</p>
<p>一方面，缓存需要把内存里的数据放到放进来，英文叫 <strong>CPU  Associativity</strong>。Cache的数据<strong>放置的策略</strong>决定了内存中的数据块会拷贝到CPU  Cache中的哪个位置上，因为Cache的大小远远小于内存，所以，需要有一种<strong>地址关联</strong>的算法，能够让内存中的数据可以被映射到Cache中来。</p>
<p>基本上来说，会有如下的一些方法：</p>
<ul>
<li>一种方法是，任何一个内存地址的数据可以被缓存在任何一个Cache Line里，这种方法是最灵活的，<strong>但是</strong>，如果我们要知道一个内存是否存在于Cache中，我们就需要进行O(n)复杂度的Cache遍历，这是很没有效率的。<strong>（全相联方式）</strong></li>
<li>另一种方法，为了降低缓存搜索算法，我们需要使用像Hash Table这样的数据结构，最简单的hash table就是做“求模运算”，比如：我们的L1 Cache有512个Cache Line，那么，公式：<code>（内存地址 mod 512）* 64</code> 就可以直接找到所在的Cache地址的偏移了。<strong>但是</strong>，这样的方式需要我们的程序对内存地址的访问要非常地平均，不然<strong>冲突就会非常严重</strong>。<strong>（直接相联方式）</strong></li>
<li>为了避免上述的两种方案的问题，于是就要容忍一定的hash冲突，也就出现了 <strong>N-Way 关联</strong>。也就是把连续的N个Cache Line绑成一组，然后，先把找到相关的组，然后再在这个组内找到相关的Cache Line。这叫 <strong>Set Associativity</strong>。<strong>但是</strong>，但是实现难度和造价要比直接映像方式高。<strong>（组相联映像方式）</strong></li>
</ul>
<p><img src="/2021/07/03/Principles-Of-Computer-Composition-Zero/3.png" alt="cache-associative-fill-both"></p>
<p>N-ways  Set-Associative，这个n=1，就是直接映射；n=cache大小，就是全相关映射。我们从上面知道两者都不好，而n最好取中间某个值。那么n到底该选几呢？这比较复杂，和Cache的速度和大小、内存的速度、主频等等很多都相关，在很多情况下都是个经验值，也是大量pre-silicon实验的结果。</p>
<p>TLB可以看作页表的Cache，<strong>CPU每次转换地址都会查看TLB</strong>，<strong>如果有了就不用去取内存页表了</strong>。<strong>那么TLB和Cache有什么关系呢？</strong>可以说TLB命中是Cache命中的基本条件。TLB不命中，会更新TLB项，这个代价非常大，Cache命中的好处基本都没有了。<strong>在TLB命中的情况下，物理地址才能够被选出，Cache的命中与否才能够达成。</strong>可以看出，只有在TLB命中的前提下，才有可能获得虚拟地址对应的物理地址，知道了物理地址才能得知Cache是否命中。<a href="https://zhuanlan.zhihu.com/p/31859105" target="_blank" rel="noopener">段落参考</a></p>
<p>在知道物理地址的情况下，如何分析Cache是否命中？</p>
<p>如下图：根据物理页地址的24位找到对应Cache中的组，也即Directory。然后根据6bits(2<sup>6</sup>=64)的Set Index查找一路中的Cache Line索引(因为一路中包含多个Cache Line)，6bits(2<sup>6</sup>=64)的Offset Into cache line表示在Cache Line 里的偏移量。</p>
<p><img src="/2021/07/03/Principles-Of-Computer-Composition-Zero/4.png" alt="cache-associative-fill-both"></p>
<p>（图片来自《<a href="https://manybutfinite.com/post/intel-cpu-caches/" target="_blank" rel="noopener">Cache: a place for concealment and safekeeping</a>》）</p>
<p>上面的图说明L1Cache可以映射到36bits的内存地址，一共2<sup>36</sup>=64GB的内存。当CPU要访问一个内存的时候，通过这个内存的前24bits 和中间的6bits可以直接定位相应的Cache Line。这里的64GB是处理器可以寻址 64GB 的物理 RAM。同时由于页面一般为4KB。所以需要寻址的位为 64GB / 4KB =2<sup>24</sup>，因此我们的标签需要 24 位 。</p>
<p>此外，当有数据没有命中缓存的时候，CPU就会以最小为Cache  Line的单元向内存更新数据。当然，CPU并不一定只是更新64Bytes，因为访问主存实在是太慢了，所以，一般都会多更新一些。好的CPU会有一些预测的技术，如果找到一种pattern的话，就会预先加载更多的内存，包括指令也可以预加载。这叫 Prefetching 技术 （参看，Wikipedia 的 <a href="https://en.wikipedia.org/wiki/Cache_prefetching" target="_blank" rel="noopener">Cache Prefetching</a> 和 <a href="http://compas.cs.stonybrook.edu/~nhonarmand/courses/sp16/cse502/slides/13-prefetch.pdf" target="_blank" rel="noopener">纽约州立大学的 Memory Prefetching</a>）。比如，你在for-loop访问一个连续的数组，你的步长是一个固定的数，内存就可以做到prefetching。<a href="https://www.cnblogs.com/ricks/p/12400900.html" target="_blank" rel="noopener">段落参考</a></p>
<h4 id="六、缓存的一致性"><a href="#六、缓存的一致性" class="headerlink" title="六、缓存的一致性"></a>六、缓存的一致性</h4><p>对于主流的CPU来说，缓存的写操作基本上是两种策略：</p>
<ul>
<li>一种是Write Back，写操作只要在cache上，然后再flush到内存上。</li>
<li>一种是Write Through，写操作同时写到cache和内存上。</li>
</ul>
<p>为了提高写的性能，一般来说，主流的CPU（如：Intel Core i7/i9）采用的是Write Back的策略，因为直接写内存实在是太慢了。<strong>现在问题来了</strong>，如果有一个<strong>数据 x 在 CPU 第0核的缓存上被更新了</strong>，那么<strong>其它CPU核上对于这个数据 x 的值也要被更新</strong>，这就是缓存一致性的问题。（当然，对于我们上层的程序我们不用关心CPU多个核的缓存是怎么同步的，这对上层的代码来说都是透明的）。</p>
<p>一般来说，在CPU硬件上的解决方法有两种方法：</p>
<ul>
<li><strong>Directory 协议：</strong>这种方法的典型实现是要设计一个集中式控制器，它是主存储器控制器的一部分。其中有一个目录存储在主存储器中，其中包含有关各种本地缓存内容的全局状态信息。当单个CPU Cache 发出读写请求时，这个集中式控制器会检查并发出必要的命令，以在主存和CPU Cache之间或在CPU  Cache自身之间进行数据同步和传输。</li>
<li><strong>Snoopy 协议：</strong>这种协议更像是一种数据通知的总线型的技术。CPU Cache通过这个协议可以识别其它Cache上的数据状态。如果有数据共享的话，可以通过广播机制将共享数据的状态通知给其它CPU Cache。这个协议要求每个CPU Cache 都可以<strong>窥探</strong>数据事件的通知并做出相应的反应。<a href="https://www.cnblogs.com/ricks/p/12400900.html" target="_blank" rel="noopener">段落参考</a></li>
</ul>
<h4 id="七、程序虚拟地址和实际物理地址的映射"><a href="#七、程序虚拟地址和实际物理地址的映射" class="headerlink" title="七、程序虚拟地址和实际物理地址的映射"></a>七、程序虚拟地址和实际物理地址的映射</h4><p>指令里面的地址是程序空间（虚拟空间）的虚拟地址（程序地址）。所以当 程序真正运行起来的时候，每个虚拟地址必然要对应着一个物理地址（实际存在）。</p>
<p>分页内存管理机制将虚拟内存和物理内存都分成大小一样大的部分，我们称为页，然后按页进行内存分配。一般页的大小有4KB、8KB、16KB。在该管理机制下内存分配单位化而且不需要空闲连续在一起即可使用。<strong>虚拟地址的页号表示和物理地址页号表示是从0开始的</strong>。</p>
<p><strong>内存的两种视角</strong></p>
<ul>
<li>虚拟地址(线性地址)，进程看到的内存地址称为虚拟地址，他们不对应任何物理实体，每个进程有自己的地址空间。</li>
<li>物理地址，内存系统看到的地址称为物理地址，他们用实际的地址去查找和存储内容。</li>
</ul>
<p><strong>为什么？</strong>如果运行多个进程，直接将内容映射到物理地址的话可能会存在访问冲突。所以需要相对地址，进而保护进行。因此，在早期的时候设置了地址空间，利用<strong>动态重定位技术</strong>用两个寄存器分别为<strong>基址寄存器</strong>和<strong>界限寄存器</strong>，将进程的起始地址放到基址寄存器中，进程占据内存的长度存到界限寄存器中，这样就相当于为进程划清了界限。<strong>(要求为内存空间连续)。</strong>但是会遇到什么问题？当进程很多的时候，内存中放不下，那么只能利用<strong>内存的交换技术(swapping)</strong>将一部分<strong>进程</strong>暂时放到磁盘中，但是在交换的过程中会出现大量的<strong>内存空洞</strong>，所以需要将内存中的<strong>进程向低地址移动</strong>，以便留出更大的空间，称为<strong>内存紧缩</strong>。但是会耗费大量的CPU时间。<strong>一个更好的方法</strong>，将进程所需的内存切成一个个小块，比如4KB大小，称为一页，其中只有一部分的页在内存中，当cpu需要方位的地址不在内存中时，可以从磁盘加载对应的部分，同时内存不够时也可以把长期不访问的页面保存到磁盘中，然后删除内存中的部分。这种做法称为虚拟内存。</p>
<p>内存如何管理？查看是否有足够大的内存能够满足进程的要求</p>
<ol>
<li>位图：将内存划分为单位小区域，每个区域由0/1表示状态（空闲/占用）。当一个进程需要加载内存是，需要扫描连续为0的空闲区域，作为进程的内存区域。缺点查找比较耗时。</li>
<li>链表：为了规避位图耗时的问题，每一块连续的区域分别由一个节点表示，节点有4个值，第一个若为P，则表示这块区域是有进程的，H则代表空闲区。第二个值指向对应区域的起始位置，第三个值对应的是区域的长度，第四个值是个指针指向下一个节点。进程加载内存是扫描第一个值，称为首次适配算法。此外，还是有最佳适配算法等。</li>
</ol>
<p>介绍一下整个地址映射的关系：</p>
<p>首先程序对应的是逻辑地址，其中包括代码、数据、堆(从低地址往高地址寻址)、栈(从高地址往低地址寻址)。例如：栈地址需要根据逻辑地址(虚拟地址)selector:offset，根据selector从GDT(Global Descriptor Table)中获取段描述符其中包含Base Address，结合逻辑地址中的offset能够计算出线性地址。最后，根据线性地址(22-31位)，从CR3寄存器中获取到页目录的地址(Base Address)，线性地址中记载了页目录的offset，加上offset得到页表的Base Address，加上线性地址中(12-22位)的offset，得到物理地址中的基地址，加上偏移量(线性地址)中的(0-12位)得到物理地址中的第几页。</p>
<p>程序虚拟空间中的虚拟地址<strong>通过分段机制</strong>得到虚拟地址/线性地址，线性地址<strong>通过分页机制</strong>（需要用到页表(page table)，每次地址转换都要查看内存页表太浪费时间了。现代计算机为了加速这一过程，转译后备缓冲区TLB）得到真实的物理地址。</p>
]]></content>
      <categories>
        <category>Principles-Of-Computer-Composition</category>
      </categories>
      <tags>
        <tag>Principles-Of-Computer-Composition</tag>
      </tags>
  </entry>
  <entry>
    <title>Image-Process-There-Plus</title>
    <url>/2021/06/27/Image-Process-There-Plus/</url>
    <content><![CDATA[<h2 id="图像处理学习"><a href="#图像处理学习" class="headerlink" title="图像处理学习"></a>图像处理学习</h2><h3 id="频率域滤波"><a href="#频率域滤波" class="headerlink" title="频率域滤波"></a>频率域滤波</h3><h4 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h4><h5 id="1、复数"><a href="#1、复数" class="headerlink" title="1、复数"></a>1、复数</h5><p>复数C的定义如下：</p>
<script type="math/tex; mode=display">
C=R=jI, \quad 其中，R和I是实数，j是一个等于-1的平方根的虚数。即j=\sqrt{-1}</script><p>R表示复数的实部，I是复数的虚部。实数是I=0的复数的子集。一个复数C的共轭表示为C<sup>*</sup>, 其定义是：</p>
<script type="math/tex; mode=display">
C^*=R-jI</script><p>复数从几何的角度可以被看做是平面(称为复平面)上的一个点，其横坐标是实轴(R的值)，其纵坐标是虚轴(I的值)。复数R+jI可以看成是复平面直角坐标系统中的点（R，I）。</p>
<p>下图是生成正弦波的图像：</p>
<p><img src="/2021/06/27/Image-Process-There-Plus/1.png" alt="Image-Process-Three-Plus"></p>
<p><img src="/2021/06/27/Image-Process-There-Plus/2.png" alt="Image-Process-Three-Plus"></p>
<p>由上图可知，极坐标下的复数表示为：</p>
<script type="math/tex; mode=display">
C=R+jI=\sqrt{R^2+I^2}\left(\frac{R}{\sqrt{R^2+I^2}}+\frac{I}{\sqrt{R^2+I^2}}j\right)</script><script type="math/tex; mode=display">
\because\frac{R}{\sqrt{R^2+I^2}}=\cos\theta,\frac{I}{\sqrt{R^2+I^2}}=\sin\theta</script><script type="math/tex; mode=display">
\therefore C=|C|(\cos\theta+j\sin\theta), |C|=\sqrt{R^2+I^2}\quad(模长)</script><script type="math/tex; mode=display">
\theta为幅角，\tan\theta=(I/R),\theta=\arctan(I/R),\theta\in[-\pi/2,\pi/2]</script><p>然后由于R和I可正、可负，所以&theta;&in;[-&pi;, &pi;]。</p>
<p><strong>欧拉公式：</strong></p>
<script type="math/tex; mode=display">
e^{i\theta}=\cos\theta+i\sin\theta,\quad(\theta\in R)</script><p><strong>为什么欧拉公式能用上式表示？</strong></p>
<p>在实数域下，有些函数的泰勒公式如下:</p>
<script type="math/tex; mode=display">
e^x=1+x+\frac{1}{2!}x^2+\frac{1}{3!}x^3+...</script><script type="math/tex; mode=display">
\sin x=x-\frac{1}{3!}x^3+\frac{1}{5!}s^5+...</script><script type="math/tex; mode=display">
\cos x=1-\frac{1}{2!}x^2+\frac{1}{4!}x^4+...</script><p>这三个公式分为为省略余项的麦克劳林公式，中麦克劳林公式为泰勒公式的一种特殊形式。</p>
<p>在e<sup>x</sup>的展开式中把x换成&pm;(ix)</p>
<script type="math/tex; mode=display">
(\pm i)^2=-1,(\pm i)^3=\mp i,(\pm i)^4=1......</script><script type="math/tex; mode=display">
e^{\pm ix}=1\pm \frac{ix}{1!}-\frac{x^2}{2!}\mp\frac{ix^3}{3!}+\frac{x^4}{4!}.....=(1-\frac{x^2}{2!}+......)\pm i(x-\frac{x^3}{3!}......)</script><script type="math/tex; mode=display">
\therefore e^{\pm ix}=\cos x \pm i\sin x</script><p>由此：</p>
<script type="math/tex; mode=display">
e^{ix}=\cos x+i\sin x, e^{-ix}=\cos x-i\sin x</script><script type="math/tex; mode=display">
\sin x=\frac{e^{ix}-e^{-ix}}{2i},\cos x=\frac{e^{ix}+e^{-ix}}{2}</script><script type="math/tex; mode=display">
e^{ix}=\cos x+i\sin x,令x=\pi,e^{ix}+1=0</script><p>复函数：变量u的复函数F(u)可表示为F(u)=R(u)+jI(u)，其中R(u)表示实分量函数，I(u)表示虚分量函数。复共轭函数是：</p>
<script type="math/tex; mode=display">
F^*(U) = R(U)-jI(u),幅值是|F(u)|=\sqrt{R(u)^2+I(u)^2},角度是:\theta=\arctan[I(u)/R(u)]</script><h4 id="二、傅里叶级数"><a href="#二、傅里叶级数" class="headerlink" title="二、傅里叶级数"></a>二、傅里叶级数</h4><p>具有周期T的连续变量t的周期函数f(t)可以被描述为乘以适当系数的正弦和余弦和。该和称为傅里叶级数，具有如下形式：</p>
<script type="math/tex; mode=display">
f(t)=\sum^{\infty}_{n=-\infty}c_ne^{j\frac{2\pi n}{T}t},其中，c_n=\frac{1}{T}\int^{T/2}_{-T/2}f(t)e^{-j\frac{2\pi n}{T}t}dt,n=0,\pm1,\pm2...\quad是系数</script><p><strong>由来：</strong>首先，周期函数是客观世界中周期运动的数学表述，如物体挂在弹簧上作简谐振动、单摆振动、无线电电子振荡器的电子振荡等，大多可以表述为如下的三角函数：</p>
<script type="math/tex; mode=display">
f(t)=A\sin(\omega t+\psi)</script><p>这里t表示时间，A表示振幅，&omega;为角频率，&psi;为初相(与考察时设置原点位置有关，可以理解为一个常量)。</p>
<p>世界上许多周期信号并非正弦函数那么简单，如方波、三角波等。为了简化表示，希望用一系列三角函数来表达复杂的周期函数。所以有下式：</p>
<script type="math/tex; mode=display">
f(t)=A_0+\sum^{\infty}_{n=1}A_n\sin(n\omega t+\psi_n)</script><p>傅里叶是想把一个周期函数表示成许多正弦函数的线性叠加，这许许多多的正弦函数有着不同的幅度分量A<sub>n</sub>、有不同的周期或频率n，有不同的初相角&psi;<sub>n</sub>，还有一个常数项A<sub>0</sub>。n从1到无穷，是一个无穷级数。</p>
<p><strong>这里强调一下，傅里叶级数中对不同频率的波有一个要求就是给定一个初始的频率&omega;<sub>0</sub>，之后的角频率必须是&omega;<sub>0</sub>的整数倍，这也是离散傅里叶变换中角频率取值的原则。</strong></p>
<p> 要求f(t)的表达式，需要求各项系数，所以对上式做变换：</p>
<script type="math/tex; mode=display">
A_n\sin(n\omega t+\psi_n)=A_n\sin\psi_n\cos(n\omega t)+A_n\cos\psi_n\sin(n\omega_nt)</script><p>上式由下面的三角公式得出：</p>
<script type="math/tex; mode=display">
\sin(\alpha\pm\beta)=\sin\alpha\cos\beta\pm\cos\alpha\sin\beta</script><p>记下式为常数项：</p>
<script type="math/tex; mode=display">
a_n=A_n\cdot\sin\psi_n, b_n=A_n\cdot\cos\psi_n</script><p>则：</p>
<script type="math/tex; mode=display">
f(t)=A_0+\sum^{\infty}_{n=1}A_n\sin(n\omega t+\psi_n)=A_0+\sum^{\infty}_{n=1}[a_n\cos(n\omega t)+b_n\sin(n\omega t)]</script><p>从上式可以看出，只需要求解A<sub>0</sub>，a<sub>n</sub>，b<sub>n</sub>的值即可。</p>
<p>由线性代数中已知空间中的一组正交基，那么空间中的任意向量表示为这组基的线性组合：</p>
<script type="math/tex; mode=display">
v=x_1q_q+x_2q_2+...+x_nq_n,矩阵形式为：V=QX</script><p>要求x<sub>1</sub>,直接用q<sub>1</sub>点乘v的线性组合：</p>
<script type="math/tex; mode=display">
q_1^Tv=x_1q_1^Tq_1+x_2q_1^Tq_2+...+x_nq_1^Tq_n=x_1q_1^Tq_1+0+...+0=x_1</script><p>则，</p>
<script type="math/tex; mode=display">
x_i=q_i^Tv</script><p>那么要求上式中的系数a<sub>0</sub>,a<sub>n</sub>,b<sub>n</sub>就需要寻找一组正交基，并与正弦、余弦函数有联系的，可以利用三角函数的正交性，选择下面的三角函数作为空间中的基：</p>
<script type="math/tex; mode=display">
\{1,\sin x, \cos x, \sin 2x, \cos 2x,...,\},互相正交，且线性无关</script><p><strong>利用三角函数的正交性：</strong></p>
<p>对下式在区间[-&pi;, &pi;]积分,</p>
<script type="math/tex; mode=display">
f(t)=A_0+\sum^{\infty}_{n=1}[a_n\cos(n\omega t)+b_n\sin(n\omega t)]\quad\quad(6)</script><script type="math/tex; mode=display">
\int^\pi_{-\pi}f(t)=\int^\pi_{-\pi}A_0+\int^\pi_{-\pi}[a_n\cos(n\omega t)+b_n\sin(n\omega t)]=\int^\pi_{-\pi}A_0+0=A_0|^\pi_{-\pi}=2\pi A_0</script><p>得出:</p>
<script type="math/tex; mode=display">
A_0=\frac{1}{2\pi}\int^\pi_{-\pi}f(t)dt</script><p>用cos(k&omega;t)乘(28)式两边得：</p>
<script type="math/tex; mode=display">
f(t)\cdot\cos(k\omega t)=A_0\cos(k\omega t)+\sum^\infty_{n=1}[a_n\cos(n\omega t)\cdot\cos(k\omega t)+b_n\sin(n\omega t)\cos(k\omega t)]</script><p>对上式从-&pi;到&pi;逐项积分：</p>
<script type="math/tex; mode=display">
\int^\pi_{-\pi}f(t)\cdot\cos(k\omega t)=\mathop {A_0\int^\pi_{-\pi}\cos(k\omega t)}_{(1)}+\sum^\infty_{n=1}[\mathop {a_n\int^\pi_{-\pi}\cos(n\omega t)\cdot\cos(k\omega t)}_{(2)}+\mathop {b_n\int^\pi_{-\pi}\sin(n\omega t)\cos(k\omega t)}_{(3)}]</script><p>根据三角函数得正交性，(1)和(3)为0，(2)仅当k=n时积分不为0，其余项积分为0，所以：</p>
<script type="math/tex; mode=display">
\int^\pi_{-\pi}f(t)\cdot\cos(k\omega t)=a_n\sum^\infty_{n=1}\int^\pi_{-\pi}\cos(k\omega t)\cdot\cos(n\omega t)dt=a_n\int^\pi_{-\pi}\cos^2(n\omega t)dt\\
=\frac{a_n}{2}\int^\pi_{-\pi}(1+\cos2n\omega t)dt(半角公式)\quad\\
=\frac{a_n}{2}\cdot2\pi=a_n\cdot\pi\quad\quad\quad\quad\quad\quad\quad\quad</script><script type="math/tex; mode=display">
\therefore a_n=\frac{1}{\pi}\int^\pi_{-\pi}\cos(n\omega t)\cdot f(t)dt\quad(k=n)</script><p>同理，(28)式两边乘sin(k&omega;t)得：</p>
<script type="math/tex; mode=display">
b_n=\frac{1}{\pi}\int^\pi_{-\pi}\sin(n\omega t)\cdot f(t)dt\quad (k=n)</script><p>由于A<sub>0</sub>的分母为2&pi;，而a<sub>n</sub>、b<sub>n</sub>为&pi;，为了统一，令a<sub>0</sub>=2A<sub>0</sub>，有：</p>
<script type="math/tex; mode=display">
a_0=\frac{2}{T}\int^\pi_{-\pi}f(t)dt,T为一个周期，T=2\pi /\omega</script><p>所以(28)式为：</p>
<script type="math/tex; mode=display">
f(t)=\frac{a_0}{2}+\sum^\infty_{n=1}[a_n\cos(n\omega t)+b_n\sin(n\omega t)]</script><p>则：</p>
<script type="math/tex; mode=display">
a_n=\frac{2}{T}\int^{t_0+T}_{t_0}f(t)\cos(n\omega t)dt</script><script type="math/tex; mode=display">
b_n=\frac{2}{T}\int^{t_0+T}_{t_0}f(t)\sin(n\omega t)dt</script><p><strong>三角函数的正交性：</strong></p>
<p>一个三角函数系：1、cos(x)，sin(x)，cos(2x)，sin(2x)，… ，cos(nx)，sin(nx)，…<strong>如果这一堆函数（包括常数1）中任何两个不同函数的乘积在区间</strong>[-&pi;, &pi;]上的积分等于零，就说三角函数系在区间[-&pi;, &pi;]上正交。</p>
<script type="math/tex; mode=display">
\int^\pi_{-\pi}1\cdot\cos nxdx=0\quad(n=1,2,3,...)</script><script type="math/tex; mode=display">
\int^\pi_{-\pi}1\cdot\sin nxdx=0\quad(n=1,2,3,...)</script><script type="math/tex; mode=display">
\int^\pi_{-\pi}\sin kx \cdot\cos nx dx=0\quad(k,n=1,2,3,...)</script><script type="math/tex; mode=display">
\int^\pi_{-\pi}\cos kx \cdot\cos nx dx=0\quad(k,n=1,2,3,...;k\neq n)</script><script type="math/tex; mode=display">
\int^\pi_{-\pi}\sin kx \cdot\sin nx dx=0\quad(k,n=1,2,3,...;k\neq n)</script><p>证明，因为</p>
<script type="math/tex; mode=display">
\cos kx\cdot \cos nx=\frac{1}{2}[\cos(k+n)x+\cos(k-n)x]\quad (1)</script><script type="math/tex; mode=display">
\sin kx\cdot \sin nx=\frac{1}{2}[\cos(k+n)x-\cos(k-n)x]\quad(2)</script><script type="math/tex; mode=display">
\sin kx\cdot \cos nx=\frac{1}{2}[\sin(k+n)x+\sin(k-n)x]\quad(3)</script><p>证（1）当k&ne;n时，有；</p>
<script type="math/tex; mode=display">
\int^\pi_{-\pi}\cos kx\cdot\cos nx dx=\frac{1}{2}\int^\pi_{-\pi}[\cos(k+n)x+\cos(k-n)x]dx\\
=\frac{1}{2}[\frac{\sin(k+n)x}{k+n}+\frac{\sin(k-n)x}{k-n}]|^\pi_{-\pi}=\frac{1}{2}[0+0]=0</script><p>可见在指定的[-&pi;, &pi;]的区间里，该式的定积分为0。上式k-n一般时小于0的，但sin是奇函数，所以上下的负号抵消。</p>
<p><a href="https://zhuanlan.zhihu.com/p/41455378" target="_blank" rel="noopener">傅里叶级数推导参考来自于知乎-leinlin</a></p>
<p><strong>傅里叶级数的复数形式</strong></p>
<script type="math/tex; mode=display">
\because \cos\theta=\frac{1}{2}(e^{i\theta}+e^{-i\theta})\quad \sin\theta=-\frac{1}{2}i(e^{i\theta}-e^{-i\theta})</script><script type="math/tex; mode=display">
式(49)代入式(37)得：
\\f(t)=\frac{a_0}{2}+\sum^\infty_{n=1}[a_n\cdot\frac{1}{2}(e^{in\omega t}+e^{-in\omega t})-\frac{1}{2}ib_n(e^{in\omega t}-e^{-in\omega t})]\quad \quad \quad \quad \quad \quad\\
=\frac{a_0}{2}+\sum^\infty_{n=1}\frac{a_n-ib_n}{2}e^{in\omega t}+\sum^{\infty}_{n=1}\frac{a_n+ib_n}{2}e^{in\omega t}，\quad 第三项让n变“-n”\\
=\frac{a_0}{2}+\sum^\infty_{n=1}\frac{a_n-ib_n}{2}e^{in\omega t}+\sum^{-1}_{n=-\infty}\frac{a_{-n}+ib_{-n}}{2}e^{in\omega t}\quad \quad \quad \quad \quad \quad \\
=\sum^0_{n=0}\frac{a_0}{2}e^{in\omega t}+\sum^\infty_{n=1}\frac{a_n-ib_n}{2}e^{in\omega t}+\sum^{-1}_{n=-\infty}\frac{a_{-n}+ib_{-n}}{2}e^{in\omega t}\quad \quad \\
=\sum^\infty_{-\infty}C_ne^{in\omega t},C_n为系数\quad \quad \quad \quad \quad \quad\quad \quad \quad \quad \quad \quad\quad \quad \quad \quad \quad</script><script type="math/tex; mode=display">
C_n=\begin{cases}\frac{a_0}{2},& n=0\\
\frac{a_n-ib_n}{2}, & n=1,2,3,4...\\
\frac{a_{-n}+ib_{-n}}{2}, & n=-1,-2,-3,-4...
\end{cases}</script><p>由式(34)、式(35)和式(36):</p>
<script type="math/tex; mode=display">
a_0=\frac{2}{T}\int^T_0f(t)dt,a_n=\frac{2}{T}\int^T_0f(t)\cos n\omega tdt,b_n=\frac{2}{T}\int^T_0f(t)\sin n\omega tdt</script><p>由式(51)和式(52)得：</p>
<script type="math/tex; mode=display">
n=0,C_0=\frac{a_0}{2}=\frac{1}{2}\cdot\frac{2}{T}\int^T_0f(t)dt=\frac{1}{T}\int^T_0f(t)dt</script><p>当n=1,2,3…</p>
<script type="math/tex; mode=display">
C_n=\frac{1}{2}\cdot\frac{2}{T}\int^T_0f(t)\cos n\omega tdt-\frac{1}{2}i\cdot \frac{2}{T}\int^T_0f(t)\sin n\omega tdt \quad \quad \quad \\
=\frac{1}{T}\int^T_0f(t)(\cos n\omega t-i\sin n\omega t)dt\quad,cos偶函数，sin奇函数\\ 
=\frac{1}{T}\int^T_0f(t)(\cos(-n\omega t)+i\sin(-n\omega t))dt,\quad 由欧拉公式可得 \\
=\frac{1}{T}\int^T_0f(t)e^{-in\omega t}dt\quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad \quad</script><p>当n=-1,-2,-3…</p>
<script type="math/tex; mode=display">
C_n=\frac{1}{2}(\frac{2}{T}\int^T_0f(t)\cos(-n)\omega tdt+i\frac{2}{T}\int^T_0f(t)\sin(-n)\omega tdt)\quad\\
=\frac{1}{T}\int^T_0f(t)(\cos n\omega t-i\sin n\omega t)dt=\frac{1}{T}\int^T_0f(t)e^{-in\omega t}dt</script><p>当n=0时，因为式(54)和式(55)最后的形式一样，且当n为0时：</p>
<script type="math/tex; mode=display">
\frac{1}{T}\int^T_0f(t)e^0dt=\frac{1}{T}\int^T_0f(t)dt=C_0</script><p>所以可以用一个统一的形式表达傅里叶级数。一个周期为T的函数f(t)=f(t+T)展开为傅里叶级数，它的复数形式可以表达为：</p>
<script type="math/tex; mode=display">
f(t)=\sum^\infty_{-\infty}C_ne^{in\omega t},Cn=\frac{1}{T}\int^T_0f(t)e^{-in\omega t}dt</script><p><strong>补充知识：</strong>泰勒级数即为任意一个函数都可以用一个多项式来逼近：</p>
<script type="math/tex; mode=display">
f(x)=A+Bx+Cx^2+Dx^3+...</script><p>利用麦克劳林公式中的待定系数法：</p>
<script type="math/tex; mode=display">
f'(x)=B+2Cx+3Dx^2,f''(x)=2C+6Dx,...</script><p>每个等式中令x=0，然后由待定系数法可以解出A,B,C…的值</p>
<script type="math/tex; mode=display">
A=f(0),B=f'(0),C=f''(0)/2,D=f'''(0)/(1*2*3)),即：N=f^n/n!</script><p>众所周知三角函数在一个周期内的积分为0。</p>
<p>上面是周期函数的傅里叶级数的两种形式(三角函数形式和复数形式)，<strong>那么非周期函数的傅里叶积分是什么呢？</strong></p>
<p>假设之前周期函数的周期为2l, 当l趋近于无穷时，可以将原先的周期函数看作是非周期函数，可以借鉴周期函数的傅里叶级数看非周期函数的展开形式：</p>
<script type="math/tex; mode=display">
\because \omega_n=\frac{n\pi}{l},n=...,-2,-1,0,1,2,...\quad \Delta\omega_n=\omega_{n+1}-\omega_n=\frac{\pi}{l}\quad 两个相邻的\omega 之间的间隔，说明两个相邻的正弦波是跳跃变化的</script><script type="math/tex; mode=display">
周期(2l)的函数\underrightarrow{l\to\infty}非周期函数，\Delta\omega_n=\frac{\pi}{l} \underrightarrow{l\to\infty}\quad0,\quad \omega_n\to\omega,变成了一个连续函数，非周期函数是连续变化的</script><script type="math/tex; mode=display">
\because 周期函数的傅里叶级数f(x)=\sum^{\infty}_{-\infty}c_ne^{i\omega_nx},\quad \therefore 非周期函数可以表示为：f(x)=\lim_{l \to \infty}\sum^{\infty}_{n=-\infty}c_ne^{i\omega_nx}</script><script type="math/tex; mode=display">
\because c_n=\frac{1}{2l}\int^l_{-l}f(t)e^{-i\omega_nt}dt,\quad 代入上式的非周期函数\therefore f(x)=\lim_{l \to \infty}\sum^{\infty}_{n=-\infty}[\frac{1}{2l}\int^l_{-l}f(t)e^{-i\omega_n t}dt]e^{i\omega_nx}</script><script type="math/tex; mode=display">
\because \Delta\omega_n=\frac{\pi}{l},\quad \therefore\frac{1}{l}=\frac{\Delta\omega_n}{\pi},l\to\infty,\Delta\omega_n\to0</script><script type="math/tex; mode=display">
\frac{1}{2l}=\frac{\Delta\omega_n}{2\pi},代入上式非周期函数f(x)=\lim_{\Delta\omega_n\to0}\sum^{\infty}_{n=-\infty}\left[\frac{1}{2\pi}\int^\infty_{-\infty}f(t)e^{-i\omega_nt}dt\right]e^{i\omega_nx}\Delta\omega_n</script><script type="math/tex; mode=display">
由积分的定义\int_lf(z)dz=\lim_{n \to \infty}\sum^{\infty}_{k=0}f(\xi_k)\Delta_{z_k}, max|\Delta x_k\to0|</script><p>则式(68)可转化为：</p>
<script type="math/tex; mode=display">
f(x)=\frac{1}{2\pi}\int^{\infty}_{-\infty}\left[\int^{\infty}_{-\infty}f(t)e^{-i\omega_nt}dt\right]e^{i\omega_nx}d\omega,\quad 傅氏积分</script><p>周期函数是傅氏级数，非周期函数是傅氏积分</p>
<p>傅氏积分存在的条件, (1)满足狄氏条件；(2)绝对可积 </p>
<p><strong>一维傅里叶变换</strong></p>
<script type="math/tex; mode=display">
上式(69)中\int^\infty_{-\infty}f(t)e^{-i\omega t}dt\quad 积分出来是\omega 的函数</script><p>所以，定义f(x)的傅氏变换为：</p>
<script type="math/tex; mode=display">
G(\omega)=\int^\infty_{-\infty}f(t)e^{-i\omega t}dt=F[f(x)],f(x)的傅里叶变换</script><p>则：</p>
<script type="math/tex; mode=display">
f(x)=\frac{1}{2\pi}\int^\infty_{-\infty}G(\omega)e^{i\omega x}d\omega=F^{-1}[G(\omega)],显然，F^{-1}F[f(x)]=f(x)</script><p>对f(t)进行积分得到变量为&omega;的傅里叶变换后的频谱图(分离出来的正弦波的振幅图)对应频域，在对G(&omega;)进行积分得到变量为x的时间域f(x),相当通过傅里叶逆变换得到f(x)。</p>
<p>举例：</p>
<script type="math/tex; mode=display">
\begin{aligned}& F[e^{-ax^2}]=?,函数e^{-ax^2}的傅里叶变换是什么? \\
& 由(71)得：\int^\infty_{-\infty}e^{-ax^2}e^{-i\omega x}dx=2\int^\infty_0e^{-ax^2}\cdot \cos\omega  xdx,\quad e^{-i\omega t}叫做积分变换核 \\
& 上式中e^{-ax^2}是偶函数，e^{-i\omega x}由欧拉公式可以化为cos和sin的形式，sin为奇函数，奇函数乘偶函数为奇函数，所以可以舍弃，只保留cos。\\
& 在热传导中有，\int^\infty_0e^{-ax^2}cosbxdx=\frac{1}{2}e^{-\frac{\omega^2}{4a}}\cdot\sqrt\frac{\pi}{a},\quad \therefore F[e^{-ax^2}]=e^{-\frac{\omega^2}{4a}}\cdot\sqrt\frac{\pi}{a}\quad (-\infty<\omega<+\infty)\quad \quad \quad \quad \quad \quad \quad \quad \quad\\
& 利用傅里叶逆变换求f(x):\frac{1}{2\pi}\int^\infty_{-\infty}G(\omega)e^{iwx}d\omega; \frac{1}{2\pi}\sqrt\frac{\pi}{a}\int^\infty_{-\infty}e^{-\frac{\omega^2}{4a}}e^{i\omega x}d\omega=\frac{1}{2\pi}\sqrt\frac{\pi}{a}\int^\infty_{-\infty}e^{-\frac{1}{4a}\omega^2}\cos x\omega d\omega=\frac{1}{2\pi}\sqrt\frac{\pi}{a}e^{-ax^2}2\sqrt{\pi a}=e^{-ax^2}=f(x)\end{aligned}</script>]]></content>
      <categories>
        <category>Image Processing</category>
      </categories>
      <tags>
        <tag>Image Processing</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-Security-Plus</title>
    <url>/2021/06/27/Spring-Security-Plus/</url>
    <content><![CDATA[<h2 id="详解Spring-Security"><a href="#详解Spring-Security" class="headerlink" title="详解Spring Security"></a>详解Spring Security</h2><h4 id="这里插入一些基础的Spring知识点："><a href="#这里插入一些基础的Spring知识点：" class="headerlink" title="* 这里插入一些基础的Spring知识点："></a>* 这里插入一些基础的Spring知识点：</h4><p>面向对象设计（OOD）有助于我们开发出高性能、易扩展以及易复用的程序。其中，OOD有一个重要的思想那就是依赖倒置原则（DIP），并由此引申出IoC、DI以及Ioc容器等概念。</p>
<h5 id="1、依赖倒置原则-DIP-一种软件架构设计的原则（抽象概念）。"><a href="#1、依赖倒置原则-DIP-一种软件架构设计的原则（抽象概念）。" class="headerlink" title="1、依赖倒置原则(DIP):  一种软件架构设计的原则（抽象概念）。"></a>1<strong>、</strong>依赖倒置原则(DIP):  一种软件架构设计的原则（抽象概念）。</h5><p>依赖倒置原则，它<strong>转换了依赖关系</strong>，高层模块不依赖于低层模块的实现，而低层模块依赖于高层模块定义的接口。通俗的讲，就是高层模块定义接口，低层模块负责实现。从而更好的支持了<strong>设计模式</strong>中的<strong>开放封闭原则</strong>。以下为DIP的优点：</p>
<ul>
<li><strong>系统更柔韧：</strong>可以修改一部分代码而不影响其他模块。</li>
<li><strong>系统更健壮：</strong>可以修改一部分代码而不会让系统崩溃。</li>
<li><strong>系统更高效：</strong>组件松耦合，且可复用，提高开发效率。</li>
</ul>
<h5 id="2、控制反转-IoC-一种反转流、依赖和接口的方式（DIP的具体实现方式）。"><a href="#2、控制反转-IoC-一种反转流、依赖和接口的方式（DIP的具体实现方式）。" class="headerlink" title="2、控制反转(IoC):   一种反转流、依赖和接口的方式（DIP的具体实现方式）。"></a>2、<strong>控制反转(IoC):</strong>   一种反转<strong>流</strong>、<strong>依赖</strong>和<strong>接口</strong>的方式（DIP的具体实现方式）。</h5><p>DIP是一种 <strong>软件设计原则</strong>，它仅仅告诉你两个模块之间应该如何依赖，但是它并没有告诉如何做。IoC则是一种 <strong>软件设计模式</strong>，它告诉你应该如何做，来解除相互依赖模块的耦合。</p>
<p>控制反转（IoC），它为相互依赖的组件提供抽象，将依赖（低层模块）对象的获得交给第三方（系统）来控制<strong>，</strong>即依赖对象不在被依赖模块的类中直接通过new来获取。也就是说<strong>高层模块不会主动感知底层模块</strong>。</p>
<h5 id="3、依赖注入（DI）：IoC的一种实现方式，用来反转依赖（IoC的具体实现方式）。"><a href="#3、依赖注入（DI）：IoC的一种实现方式，用来反转依赖（IoC的具体实现方式）。" class="headerlink" title="3、依赖注入（DI）：IoC的一种实现方式，用来反转依赖（IoC的具体实现方式）。"></a>3、<strong>依赖注入（DI）：</strong>IoC的一种实现方式，用来反转依赖（IoC的具体实现方式）。</h5><p>依赖注入是控制反转（IoC）一种重要的方式，<strong>就是将依赖对象的创建和绑定转移到被依赖对象类的外部来实现</strong>。依赖注入（DI），<strong>它提供一种机制，将需要依赖（低层模块）对象的引用传递给被依赖（高层模块）对象</strong>。<strong>如何注入？</strong></p>
<p>1、<strong>构造函数注入：</strong>构造函数的参数必然用来接收一个依赖对象，而该依赖类型应该是一个抽象类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//高层模块</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDataAccess</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Add</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//第一种底层模块</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class SqlServerDal:IDataAccess</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Console.WriteLine(<span class="string">"在数据库中添加一条订单！"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//第二种底层模块</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class AccessDal:IDataAccess</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Console.WriteLine(<span class="string">"在ACCESS数据库中添加一条记录！"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Order</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> IDataAccess _ida;<span class="comment">//定义一个私有变量保存抽象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//构造函数注入</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Order</span><span class="params">(IDataAccess ida)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _ida = ida;<span class="comment">//传递依赖</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _ida.Add();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>2、<strong>属性注入：</strong>属性注入是通过属性来传递依赖</p>
<figure class="highlight c#"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Order</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> IDataAccess _ida;<span class="comment">//定义一个私有变量保存抽象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//属性，接受依赖</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">public</span> IDataAccess Ida</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">set</span> &#123; _ida = <span class="keyword">value</span>; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">get</span> &#123; <span class="keyword">return</span> _ida; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span>(<span class="params"></span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _ida.Add();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Collections.Generic;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Linq;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> System.Text;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">namespace</span> <span class="title">DIPTest</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">class</span> <span class="title">Program</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Main</span>(<span class="params"><span class="keyword">string</span>[] args</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>        &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            AccessDal dal = <span class="keyword">new</span> AccessDal();<span class="comment">//在外部创建依赖对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            Order order = <span class="keyword">new</span> Order();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            order.Ida = dal;<span class="comment">//给属性赋值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            order.Add();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            Console.Read();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>3、<strong>接口注入：</strong>具体思路是先定义一个接口，包含一个设置依赖的方法。然后依赖类，继承并实现这个接口。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IDependent</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">SetDependence</span><span class="params">(IDataAccess ida)</span></span>;<span class="comment">//设置依赖项</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class Order : IDependent</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> IDataAccess _ida;<span class="comment">//定义一个私有变量保存抽象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//实现接口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SetDependence</span><span class="params">(IDataAccess ida)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _ida = ida;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Add</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        _ida.Add();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h5 id="4、IoC容器：依赖注入的框架，用来映射依赖，管理对象创建和生存周期（DI框架）。"><a href="#4、IoC容器：依赖注入的框架，用来映射依赖，管理对象创建和生存周期（DI框架）。" class="headerlink" title="4、IoC容器：依赖注入的框架，用来映射依赖，管理对象创建和生存周期（DI框架）。"></a>4、<strong>IoC容器：依赖注入的框架</strong>，用来映射依赖，管理对象创建和生存周期（DI框架）。</h5><p>前面的例子中都是通过<strong>手动</strong>的方式来创建依赖对象，并将引用传递给被依赖模块。IoC容器实际上是一个DI框架，它能简化我们的工作量。</p>
<ul>
<li>动态创建、注入依赖对象。</li>
<li>管理对象生命周期。</li>
<li>映射依赖关系。</li>
</ul>
<p>具体的IoC容器如何使用可以根据自己的项目中所用到的IoC容器类型进行学习。</p>
<h5 id="5、AOP"><a href="#5、AOP" class="headerlink" title="5、AOP"></a>5、<strong>AOP</strong></h5><p>AOP（Aspect Oriented Programming），即面向切面编程，可以说是OOP（Object Oriented  Programming，面向对象编程）的补充和完善。OOP引入封装、继承、多态等概念来建立一种对象层次结构，用于模拟公共行为的一个集合。不过OOP允许开发者定义纵向的关系，但并不适合定义横向的关系，例如日志功能。日志代码往往横向地散布在所有对象层次中，而与它对应的对象的核心功能毫无关系对于其他类型的代码，如安全性、异常处理和透明的持续性也都是如此，这种散布在各处的无关的代码被称为横切（cross cutting），在OOP设计中，它导致了大量代码的重复，而不利于各个模块的重用。</p>
<p>AOP技术恰恰相反，它利用一种称为”横切”的技术，剖解开封装的对象内部，并将那些影响了多个类的公共行为封装到一个可重用模块，并将其命名为”Aspect”，即切面。所谓”切面”，简单说就是将那些与业务无关，却被业务模块所共同调用的逻辑或责任封装起来，便于减少系统的重复代码，降低模块之间的耦合度，并有利于未来的可操作性和可维护性。</p>
<p>面向切面编程是通过预编译方式和运行期动态代理的方式实现不修改源代码的情况下给程序动态统一添加功能的技术。使用”横切”技术，AOP把软件系统分为两个部分：<strong>核心关注点</strong>和<strong>横切关注点</strong>。业务处理的主要流程是核心关注点，与之关系不大的部分是横切关注点。横切关注点的一个特点是，他们经常发生在核心关注点的多处，而各处基本相似，比如权限认证、日志、事物。AOP的作用在于分离系统中的各种关注点，将核心关注点和横切关注点分离开来。</p>
<hr>
<div class="table-container">
<table>
<thead>
<tr>
<th>AOP核心概念</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>横切关注点</td>
<td>对哪些方法进行拦截，拦截后怎么处理，这些关注点称之为横切关注点</td>
</tr>
<tr>
<td>切面(aspect)</td>
<td>类是对物体特征的抽象，切面就是对横切关注点的抽象</td>
</tr>
<tr>
<td>连接点(joinpoint)</td>
<td>被拦截到的点，因为Spring只支持方法类型的连接点，所以在Spring中连接点指的就是被拦截到的方法，实际上连接点还可以是字段或者构造器</td>
</tr>
<tr>
<td>切入点(pointcut)</td>
<td>对连接点进行拦截的定义</td>
</tr>
<tr>
<td>通知(advice)</td>
<td>所谓通知指的就是指拦截到连接点之后要执行的代码，通知分为前置@Before、后置@After、异常@AfterThrowing、最终@AfterReturning、环绕@Around通知五类</td>
</tr>
<tr>
<td>目标对象</td>
<td>代理的目标对象</td>
</tr>
<tr>
<td>织入(weave)</td>
<td>将切面应用到目标对象并导致代理对象创建的过程</td>
</tr>
<tr>
<td>引入(introduction)</td>
<td>在不修改代码的前提下，引入可以在<strong>运行期</strong>为类动态地添加一些方法或字段</td>
</tr>
</tbody>
</table>
</div>
<p>AOP只是一个概念并没有设定具体语言的实现，它能克服那些只有单继承特性语言的缺点。实现AOP的技术主要分为两类：一类是<strong>采用动态代理技术</strong>利用截取消息的方式，对消息进行装饰以取代原有对象行为的执行。另一类是<strong>采用静态织入</strong>的方式，引入特定语法创建切面，从而使编译器可以在编译期间织入相关的切面代码。</p>
<p><strong>Spring对AOP的支持</strong></p>
<p><strong>Spring中AOP代理由Spring的IOC容器负责生成、管理，其依赖关系也由IOC容器负责管理</strong>。因此，AOP代理可以直接使用容器中的其它bean实例作为目标，这种关系可由IOC容器的依赖注入提供。Spring创建代理的规则为：</p>
<ol>
<li><strong>默认使用Java动态代理来创建AOP代理</strong>，这样就可以为任何接口实例创建代理了。</li>
<li><strong>当需要代理的类不是代理接口的时候，Spring会切换为使用CGLIB代理</strong>，也可强制使用CGLIB。</li>
</ol>
<p>AOP编程其实是很简单的事情，纵观AOP编程，程序员只需要参与三个部分：</p>
<ol>
<li>定义普通业务组件。</li>
<li>定义切入点，一个切入点可能横切多个业务组件。</li>
<li>定义增强处理，增强处理就是在AOP框架为普通业务组件织入的处理动作。</li>
</ol>
<p>所以进行AOP编程的关键就是定义切入点和定义增强处理，一旦定义了合适的切入点和增强处理，AOP框架将自动生成AOP代理，即：<strong>代理对象的方法=增强处理+被代理对象</strong>的方法。</p>
<p>下面给出一个Spring AOP的.xml文件模板，名字叫做aop.xml，之后的内容都在aop.xml上进行扩展：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>
<p><strong>基于Spring的AOP简单实现</strong></p>
<p>注意一下，在讲解之前，说明一点：使用Spring AOP，要成功运行起代码，只用Spring提供给开发者的jar包是不够的，请额外上网下载两个jar包：1、aopalliance.jar；2、aspectjweaver.jar</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//先定义一个接口：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HelloWorld</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">printHelloWorld</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doPrint</span><span class="params">()</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//定义两个接口实现类：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldImpl1</span> <span class="keyword">implements</span> <span class="title">HelloWorld</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printHelloWorld</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Enter HelloWorldImpl1.printHelloWorld()"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPrint</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Enter HelloWorldImpl1.doPrint()"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldImpl2</span> <span class="keyword">implements</span> <span class="title">HelloWorld</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printHelloWorld</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Enter HelloWorldImpl2.printHelloWorld()"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPrint</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"Enter HelloWorldImpl2.doPrint()"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> ;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//横切关注点，这里是打印时间</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TimeHandler</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTime</span><span class="params">()</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">    </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(<span class="string">"CurrentTime = "</span> + System.currentTimeMillis());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>有这三个类就可以实现一个简单的Spring AOP了，看一下aop.xml的配置:</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans-4.2.xsd</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop/spring-aop-4.2.xsd"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorldImpl1"</span> <span class="attr">class</span>=<span class="string">"com.xrq.aop.HelloWorldImpl1"</span> /&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"helloWorldImpl2"</span> <span class="attr">class</span>=<span class="string">"com.xrq.aop.HelloWorldImpl2"</span> /&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"timeHandler"</span> <span class="attr">class</span>=<span class="string">"com.xrq.aop.TimeHandler"</span> /&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;<span class="name">aop:aspect</span> <span class="attr">id</span>=<span class="string">"time"</span> <span class="attr">ref</span>=<span class="string">"timeHandler"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"addAllMethod"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.xrq.aop.HelloWorld.*(..))"</span> /&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">aop:before</span> <span class="attr">method</span>=<span class="string">"printTime"</span> <span class="attr">pointcut-ref</span>=<span class="string">"addAllMethod"</span> /&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="tag">&lt;<span class="name">aop:after</span> <span class="attr">method</span>=<span class="string">"printTime"</span> <span class="attr">pointcut-ref</span>=<span class="string">"addAllMethod"</span> /&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="tag">&lt;/<span class="name">aop:aspect</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ApplicationContext ctx = </span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"aop.xml"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">    HelloWorld hw1 = (HelloWorld)ctx.getBean(<span class="string">"helloWorldImpl1"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    HelloWorld hw2 = (HelloWorld)ctx.getBean(<span class="string">"helloWorldImpl2"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hw1.printHelloWorld();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hw1.doPrint();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hw2.printHelloWorld();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    System.out.println();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hw2.doPrint();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>运行结果为：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">CurrentTime = 1446129611993</span></pre></td></tr><tr><td class="code"><pre><span class="line">Enter HelloWorldImpl1.printHelloWorld()</span></pre></td></tr><tr><td class="code"><pre><span class="line">CurrentTime = 1446129611993</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">CurrentTime = 1446129611994</span></pre></td></tr><tr><td class="code"><pre><span class="line">Enter HelloWorldImpl1.doPrint()</span></pre></td></tr><tr><td class="code"><pre><span class="line">CurrentTime = 1446129611994</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">CurrentTime = 1446129611994</span></pre></td></tr><tr><td class="code"><pre><span class="line">Enter HelloWorldImpl2.printHelloWorld()</span></pre></td></tr><tr><td class="code"><pre><span class="line">CurrentTime = 1446129611994</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">CurrentTime = 1446129611994</span></pre></td></tr><tr><td class="code"><pre><span class="line">Enter HelloWorldImpl2.doPrint()</span></pre></td></tr><tr><td class="code"><pre><span class="line">CurrentTime = 1446129611994</span></pre></td></tr></table></figure>
<p>看到给HelloWorld接口的两个实现类的所有方法都加上了代理，代理内容就是打印时间。</p>
<h5 id="参考资料-DIP-DI-IoC"><a href="#参考资料-DIP-DI-IoC" class="headerlink" title="参考资料: DIP/DI/IoC"></a><a href="https://www.cnblogs.com/liuhaorain/p/3747470.html" target="_blank" rel="noopener">参考资料: DIP/DI/IoC</a></h5><h5 id="参考资料-AOP"><a href="#参考资料-AOP" class="headerlink" title="参考资料: AOP"></a><a href="https://www.cnblogs.com/hongwz/p/5764917.html" target="_blank" rel="noopener">参考资料: AOP</a></h5><h4 id="一、概括"><a href="#一、概括" class="headerlink" title="一、概括"></a>一、概括</h4><p>Spring Security是一个高度自定义的<strong>安全框架</strong>。利用Spring IoC/DI和AOP功能，为系统提供了<strong>声明式安全访问控制功能</strong>，减少了为系统安全而编写大量重复代码的工作。</p>
<p>Spring Security 解决了javaEE的Servlet规范或EJB规范中的安全功能缺乏典型企业应用场景的缺陷。同时，它提供了许多其他有用的、可定制的安全功能。</p>
<p>在web安全方面主要有<strong>“认证”</strong>和<strong>“授权”</strong>两个主要的模块，这两者也是Spring Security重要核心功能。<strong>“认证”</strong>，是建立一个他声明的主体的过程（一个“主体”一般是指用户，设备或一些可以在你的应用程序中执行动作的其他系统），通俗点说就是系统认为用户<strong>是否能登录</strong>。<strong>“授权”</strong>指确定一个主体是否允许在你的应用程序执行一个动作的过程。通俗点讲就是系统判断用户<strong>是否有权限去做</strong>某些事情</p>
<h5 id="1、权限管理：一般指根据系统设置的安全规则或者安全策略。用户可以访问而且只能访问自己被授权的资源。但需要系统具备根据用户名核密码进行认证的操作。下面是权限管理中两个重要的概念："><a href="#1、权限管理：一般指根据系统设置的安全规则或者安全策略。用户可以访问而且只能访问自己被授权的资源。但需要系统具备根据用户名核密码进行认证的操作。下面是权限管理中两个重要的概念：" class="headerlink" title="1、权限管理：一般指根据系统设置的安全规则或者安全策略。用户可以访问而且只能访问自己被授权的资源。但需要系统具备根据用户名核密码进行认证的操作。下面是权限管理中两个重要的概念："></a>1、<strong>权限管理：</strong>一般指根据系统设置的安全规则或者安全策略。用户可以访问而且只能访问自己被授权的资源。但需要系统具备根据用户名核密码进行认证的操作。下面是权限管理中两个重要的概念：</h5><p><strong>认证：</strong>通过用户名和密码成功登录系统后，让系统得到当前用户的角色身份。</p>
<p><strong>授权：</strong>系统根据当前用户的角色，给授予对应可以操作的权限资源。</p>
<h5 id="2、完成权限管理需要的三个对象："><a href="#2、完成权限管理需要的三个对象：" class="headerlink" title="2、完成权限管理需要的三个对象："></a>2、<strong>完成权限管理需要的三个对象：</strong></h5><ol>
<li>用户：主要包含用户名、密码和当前用户的角色信息，可以实现认证操作。</li>
<li>角色：主要包含角色名称，角色描述和当前角色拥有的权限信息，可实现授权操作。</li>
<li>权限：成为菜单，主要包含当前权限的名称，url地址等信息，为了实现动态展示菜单。</li>
</ol>
<p>三者之间都是<strong>多对多</strong>的关系。</p>
<h5 id="3、Spring-Security概念"><a href="#3、Spring-Security概念" class="headerlink" title="3、Spring Security概念"></a>3、Spring Security概念</h5><p>Spring Security是spring采用AOP思想，基于servlet过滤器实现的安全框架。它提供了完善的认证机制和方法级的授权功能。是一款非常优秀的<strong>权限管理框架</strong>。</p>
<h4 id="二、开启Spring-Security项目"><a href="#二、开启Spring-Security项目" class="headerlink" title="二、开启Spring Security项目"></a>二、开启Spring Security项目</h4><h5 id="1、导入依赖"><a href="#1、导入依赖" class="headerlink" title="1、导入依赖"></a>1、导入依赖</h5><p>Spring Security已经被Spring boot进行集成，使用时直接引入启动器即可。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--这个是Spring Web工程中需要导入的依赖--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-config<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.security<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-security-taglibs<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.5.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--这是在Spring Boot的环境下需要导入的包--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr></table></figure>
<h5 id="2、访问页面"><a href="#2、访问页面" class="headerlink" title="2、访问页面"></a>2、访问页面</h5><p>导入spring-boot-starter-security启动器后，Spring Security已经生效，默认拦截全部请求，如果用户没有登录，跳转到内置登录页面。</p>
<p>在项目中新建login.html页面后，在浏览器输入：<a href="http://localhost:8080/login.html后会显示下面页面" target="_blank" rel="noopener">http://localhost:8080/login.html后会显示下面页面</a></p>
<p><img src="/2021/06/27/Spring-Security-Plus/Users\aaa\Desktop\2.png" alt="img"></p>
<p>默认的username为user，password打印在控制台中。在浏览器中输入账号和密码后会显示login.html页面内容。</p>
<h5 id="3、应用场景"><a href="#3、应用场景" class="headerlink" title="3、应用场景"></a>3、应用场景</h5><p>在很多技术中都可能有web访问控制页面。例如：www.baidu.com就有web管理页面。不需要进行登录，只要知道ip和端口任何人都可以进行访问的。可能导致网站中数据不安全问题。为了保证数据安全性，可以在Spring Boot项目中添加Spring Security。</p>
<p><strong>如何自定义用户名和密码？</strong></p>
<p>通过修改application.properties/application.yml</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">spring.security.user.name=smallming</span></pre></td></tr><tr><td class="code"><pre><span class="line">spring.security.user.password=smallming</span></pre></td></tr></table></figure>
<h5 id="4、Spring-Security过滤器链"><a href="#4、Spring-Security过滤器链" class="headerlink" title="4、Spring Security过滤器链"></a>4、Spring Security过滤器链</h5><p>过滤器是一种典型的AOP思想</p>
<p><strong>1、org.springframework.security.web.context.SecurityContextPersistenceFilter:</strong> 初始化SecurityContext这个域/容器，放到SecurityContextHolder对象中，为后续filter建立所需的上下文。SecurityContext中存储了当前用户的认证以及权限信息。</p>
<p><strong>2、org.springframework.security.web.context.request.async.WebAsyncManageIntegrationFilter:</strong> 此过滤器用于集成SecurityContext到Spring异步执行机制中的WebAsyncManager。否者Spring Security与Spring和Web容器无法整合。</p>
<p><strong>3、org.springframework.security.web.header.HeaderWriterFilter:</strong> 向请求的Header中添加相应的信息，可在http标签内部使用security:header来控制，仅限与jsp动态页面。</p>
<p><strong>4、org.springframework.security.web.csrf.CsrfFilter:</strong> csrf成为跨域伪造请求，SpringSecurity会对所有post请求验证是否包含系统生成的csrf的token信息，如果不包含，则报错。起到防止csrf攻击的效果。</p>
<p><strong>5、org.springframework.security.web.authentication.logout.LogoutFilter:</strong> 退出登录的过滤器，匹配URL为/logout的请求，实现用户退出，清除认证信息。</p>
<p><strong>6、org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter:</strong> 认证操作全靠这个过滤器，默认匹配URL为/login且必须为POST请求。</p>
<p><strong>7、org.springframework.security.web.authentication.ui.DefaultLoginPageGeneratingFilter:</strong> 如果没有在配置文件中指定认证页面，则由该过滤器生成一个默认的认证页面。</p>
<p><strong>8、org.springframework.security.web.authentication.ui.DefaultLogoutPageGeneratingFilter:</strong> 此过滤器可以产生一个默认的退出登录页面。</p>
<p><strong>9、org.springframework.security.web.authentication.www.BasicAuthenticationFilter:</strong> 此过滤器会自动解析HTTP请求中头部名字为Authentication，且以Basic开头的头信息。</p>
<p><strong>10、org.springframework.secutiry.web.savedrequest.RequestCacheAwareFilter:</strong> 通过HttpSessionRequestCache内部维护了一个RequestCache,用于缓冲HttpServletRequest。</p>
<p><strong>11、org.springframework.security.web.servletapi.SecurityContextHolderAwareRequestFilter:</strong> 针对ServletRequest进行了一次包装，使得request具有更加丰富的API。</p>
<p><strong>12、org.springframework.security.web.authentication.AnonymousAuthenticationFilter:</strong> 当SecurityContextHolder中认证信息为空，则会创建一个匿名用户存入到SecurityContextHolder中。spring security为了兼容未登录的访问，也走了一套认证流程，只不过是一个匿名的身份。</p>
<p><strong>13、org.springframework.security.web.session.SessionManagementFilter:</strong> SecurityContextRepository限制同一用户开启多个会话的数量。</p>
<p><strong>14、org.springframework.security.web.access.ExceptionTranslationFilter:</strong> 用于转换整个链路中出现的异常。</p>
<p><strong>15、org.springframework.security.web.access.intercept.FilterSecurityInterceptor:</strong> 获取所配置资源访问的授权信息，根据SecurityContextHolder中存储的用户信息来决定其是否有权限。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- spring security.xml --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--释放静态资源--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">pattern</span>=<span class="string">"/css/**"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">pattern</span>=<span class="string">"/img/**"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">pattern</span>=<span class="string">"/plugins/**"</span> <span class="attr">security</span>=<span class="string">"none"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置springSecurity--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">auto-config="true" 表示自动加载sprignsecurity的配置文件</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">use-expressions="true" 表示使用spring的EL表达式来配置springsecurity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">security:http</span> <span class="attr">auto-config</span>=<span class="string">"true"</span> <span class="attr">use-expression</span>=<span class="string">"true"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!--让认证页面可以匿名访问--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/login.jsp"</span> <span class="attr">access</span>=<span class="string">"permitAll()"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">&lt;!--拦截资源--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!--</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	pattren="/**" 表示拦截所有资源</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	accesee="hasAnyRole('ROLE_USER')" 表示只有ROLE_USER角色才能访问资源</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">	--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">security:intercept-url</span> <span class="attr">pattern</span>=<span class="string">"/**"</span> <span class="attr">access</span>=<span class="string">"hasAnyRole('ROLE_USER')"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!--配置认证信息--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">security:form-login</span> <span class="attr">login-page</span>=<span class="string">"/login.jsp"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">                         <span class="attr">login-processing-url</span>=<span class="string">"/login"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">                         <span class="attr">default-target-url</span>=<span class="string">"/index.jsp"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">                         <span class="attr">authentication-failure-url</span>=<span class="string">"/failer.jsp"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!--配置退出登录信息--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">security:logout</span> <span class="attr">logout-url</span>=<span class="string">"/logout"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">                     <span class="attr">logout-success-url</span>=<span class="string">"/login.jsp"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">security:csrf</span> <span class="attr">disabled</span>=<span class="string">"true"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!--开启remember me过滤器，设置token存储时间为60秒--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">security:remember-me</span> </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">             <span class="attr">data-source-ref</span>=<span class="string">"dataSource"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">             <span class="attr">token-validity-second</span>=<span class="string">"60"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--把密码对象放入IoC容器中--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"passwordEncoder"</span> <span class="attr">class</span>=<span class="string">"org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--设置Spring Security认证用户信息的来源--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">springsecurity默认的认证必须是加密的，加上(noop)表示不加密认证。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">security:authentication-manager</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">security:authentication-provider</span> <span class="attr">user-service-ref</span>=<span class="string">"userServiceImpl"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">security:password-encoder</span> <span class="attr">ref</span>=<span class="string">"passwordEncoder"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">security:authentication-provider</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">security:authentication-manager</span>&gt;</span></span></pre></td></tr></table></figure>
<h4 id="三、UserDetailService详解"><a href="#三、UserDetailService详解" class="headerlink" title="三、UserDetailService详解"></a>三、UserDetailService详解</h4><p>当什么也没有配置的时候，账号和密码是由Spring Security定义生成的。而在实际项目中账号和密码都是从数据库中查询出来的。 所以我们要通过自定义逻辑控制认证逻辑。及需要实现UserDetailsService接口即可，定义如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//重写loadUserByUsername使自己的数据库与spring security做衔接，下面是spring security默认的接口</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetailService</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">UserDetails <span class="title">loadUserByUsername</span><span class="params">(String name)</span> <span class="keyword">throws</span> UsernameNonFoundException</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//返回值 UserDetails</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserDetails</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Collection&lt;? extends GranteAuthority&gt; getAuthorities(); <span class="comment">//获取所有权限</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">String <span class="title">getPassword</span><span class="params">()</span></span>; <span class="comment">//获取密码</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function">String <span class="title">getUsername</span><span class="params">()</span></span>; <span class="comment">//获取用户名</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonExpired</span><span class="params">()</span></span>; <span class="comment">//是否账号过期</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAccountNonLocked</span><span class="params">()</span></span>; <span class="comment">//是否账号被锁定</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCredentialsNonExpired</span><span class="params">()</span></span>; <span class="comment">//凭证是否过期</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isEnabled</span><span class="params">()</span></span>; <span class="comment">//是否可用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//UserDetails接口的实现类为User,由org.springframework.security.core.userdetails.User提供</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//下面是User的两个构造函数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">User(String, String, Collection&lt;? extends GrantedAuthority&gt;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">User(String, String, <span class="keyword">boolean</span>, <span class="keyword">boolean</span>, <span class="keyword">boolean</span>, <span class="keyword">boolean</span>, Collection&lt;? extends GranteAuthority&gt;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> enabled 是否可用</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> accountNonExpired 账号是否失效</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> credentialsNonExpired 密码是否失效</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> accountNonLocked 账户是否锁定</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//上面四个boolean值，只要有一个为false，则不能使用</span></span></pre></td></tr></table></figure>
<p>用户通过传入用户名和密码，后台通过用户名从数据库中获取对应的密码。如果一致，则认证通过；如果不一致，则认证失败。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *认证业务</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *<span class="doctag">@param</span> username 用户在浏览器输入的用户名</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *<span class="doctag">@return</span> UserDetails 是springsecurity自己的用户对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"> *<span class="doctag">@throws</span> UsernameNotFoundExcetion</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">**/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> UserDetails <span class="title">loadUserByUsername</span><span class="params">(String username)</span> <span class="keyword">throws</span> UsernameNotFoundException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">//根据username做查询</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">try</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		SysUser sysUser = userDao.findByName(username);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">if</span>(sysUser == <span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">return</span> <span class="keyword">null</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;SimpleGrantedAuthority&gt; authorities = <span class="keyword">new</span> ArrayList&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;SysRole&gt; roles = sysUser.getRoles();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(SysRole role : roles) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        	authorities.add(<span class="keyword">new</span> SimpleGrantedAuthority(role));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//(noop)后面的密码，springsecurity会认为是原文</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		UserDetails userDetails = <span class="keyword">new</span> User(sysUser.getUsername(),<span class="string">"sysUser.getPassword(),authorities);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">        return userDetails;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">	&#125;catch(Exception e) &#123;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">		e.printStackTrace();</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">		return null; //认证失败</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">	&#125;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="string">&#125;</span></span></pre></td></tr></table></figure>
<p>认证通过后authorities中的认证信息中包含了用户具有的权限，以供授权部分使用。通常都是通过AuthorityUtils.commaSeparatedStringToAuthorityList(“”)来创建authorities集合对象的。参数时一个字符串，多个权限使用逗号分隔。</p>
<h4 id="四、注意"><a href="#四、注意" class="headerlink" title="四、注意"></a>四、注意</h4><p>如果开启了csrf防护功能，logout处理器便只能支持POST请求方式！</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--退出登录--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;!--修改header.jsp中注销请求--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;form action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/logout"</span> method=<span class="string">"post"</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;security:csrfInput/&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"注销"</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;/form&gt;</span></pre></td></tr></table></figure>
<p><strong>remember me功能</strong>，1、插入数据库；2、将认证写入Cookie</p>
<p>remember me安全性分析：因为Cookie是保存在客户端的，容易被盗取，并且与用户名和密码相关。所以不太安全。因此，需要用完后手动退出登录，情况认证信息。</p>
<p>此外，SpringSecurity提供了remember me的另一种相对安全的实现机制：在客户端cookie中，保存一个无意义的加密串(与用户名、密码等敏感数据无关)，然后在DB中保存改加密串-用户信息的对应关系，自动登录时，用Cookie中的加密串，到DB中验证，如果通过，自动登录才算通过。</p>
<p>创建一张表，名称和字段固定</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="string">`persistent_logins`</span> (</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="string">`username`</span> <span class="built_in">varchar</span>(<span class="number">64</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    `series` varchar(64) NOT NULL;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    `token` varchar(64) NOT NULL;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    `last_used` timestamp NOT NULL;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    PRIMARY KEY (`series`)</span></pre></td></tr><tr><td class="code"><pre><span class="line">) ENGINE=InnoDB DEFAULT CHARSET=utf8</span></pre></td></tr></table></figure>
<p>需要在Spring Security的配置文件中添加数据源dataSource，该数据源在IoC父容器的配置文件中添加</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.jdbc.Driver"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql:///security_authority"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span></pre></td></tr></table></figure>
<h4 id="五、授权"><a href="#五、授权" class="headerlink" title="五、授权"></a>五、授权</h4><p>产品和订单两个业务不同的操作人员具有不同的权限。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;ul&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;security:authorize access=<span class="string">"hasAnyRole('ROLE_PRODUCT', 'ROLE_ADMIN')"</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;li id=<span class="string">"system-setting"</span>&gt;&lt;a href=<span class="string">"$&#123;pageContext.request.contextPath&#125;/product/findAll"</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;i class="fa fa-circle-o"&gt;&lt;/i&gt;产品管理</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;/a&gt;&lt;/li&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;/security:authorize&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;security:authorize access=<span class="string">"hasAnyRole('ROLE_ORDER', 'ROLE_ADMIN')"</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;li id=<span class="string">"system-setting"</span>&gt;&lt;a href=<span class="string">"$&#123;pageContext.request.contextPath&#125;/order/findAll"</span>&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;i class="fa fa-circle-o"&gt;&lt;/i&gt;产品管理</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;/a&gt;&lt;/li&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;/security:authorize&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;/ul&gt;</span></pre></td></tr></table></figure>
<p><strong>IoC容器的结构：</strong>任何web工程都有一个最大的容器，servletContext容器。web中如果加入了spring，那么还会有SpringIoC容器(由spring的核心监听器加载，是一个父容器)，加载Spring配置文件对应的是Service和DAO。如果又加入了SpringMVC，那么在SpringIoC父容器中又放入了一个SprignIoC子容器(由前端控制器加载)，加载SprignMVC配置文件(换句说加载的是Controller控制器对象)。</p>
<p>子容器可以访问父容器，子容器中的对象还可以被http请求访问。父容器中的对象可以被子容器调用，父容器的对象不能被http请求访问。</p>
<p><img src="/2021/06/27/Spring-Security-Plus/Users\aaa\Desktop\3.png" alt="img"></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--spring-security.xml--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">开启权限控制的注解支持</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">secured-annotations="enabled"   springSecurity内部的权限控制注解开关</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">pre-post-annotations="enabled"  spring指定的权限控制的注解开关</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">jsr250-annotations="enabled"    开启java250注解支持</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">security:http</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">security:global-method-security</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">             <span class="attr">secured-annotations</span>=<span class="string">"enabled"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">             <span class="attr">pre-post-annotations</span>=<span class="string">"enabled"</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">             <span class="attr">jsr250-annotations</span>=<span class="string">"enabled"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></span></pre></td></tr></table></figure>
<p><strong>注意：</strong>注解的支持位置不要放错，要与所对应的IoC容器对应，父容器的注解支持要放在父容器的配置文件中(applicationContext.xml/spring-security.xml)，并添加到Service或Dao中，子容器的注解支持要放在子容器spring-mvc.xml的配置文件中，并添加到Controller中。按理说正常需要放在父容器中，这样更加的安全。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Secured</span>(&#123;<span class="string">"ROLE_PRODUCT"</span>,<span class="string">"ROLE_ADMIN"</span>&#125;) <span class="comment">//springSecurity内部制定的注解</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@RolesAllowd</span>(&#123;<span class="string">"ROLE_PRODUCT"</span>, <span class="string">"ROLE_ADMIN"</span>&#125;) <span class="comment">//jsr250注解</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@PreAuthorize</span>(<span class="string">"hasAnyAuthority('ROLE_PRODUCT','ROLE_ADMIN')"</span>) <span class="comment">//spring的el表达式注解</span></span></pre></td></tr></table></figure>
<h4 id="六、处理异常"><a href="#六、处理异常" class="headerlink" title="六、处理异常"></a>六、处理异常</h4><p>Spring Security提供了一种处理403异常的方式。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">security:http</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">&lt;!--处理403异常--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">security:access-denied-handler</span> <span class="attr">error-page</span>=<span class="string">"/403.jsp"</span>/&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">security:http</span>&gt;</span></span></pre></td></tr></table></figure>
<p>web.xml只在在web工程中(Spring Security在Spring-MVC中的使用)，对于前后端分离的项目，比如spring-boot项目中，里面没有web.xml配置文件(当然也能配置web配置类，但是一般不用)。</p>
<p><strong>web.xml中处理异常的方式：</strong>（目前不常用，都往spring上靠）</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!--处理403异常--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>403<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">location</span>&gt;</span>/403.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">&lt;!--处理404异常--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">error-page</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">error-code</span>&gt;</span>404<span class="tag">&lt;/<span class="name">error-code</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">location</span>&gt;</span>/404.jsp<span class="tag">&lt;/<span class="name">location</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">error-page</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span></pre></td></tr></table></figure>
<p><strong>Spring中的异常处理方式：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//最佳方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerControllerAdvice</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@ExceptionHandler</span>(AccessDeniedException<span class="class">.<span class="keyword">class</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">    <span class="title">public</span> <span class="title">String</span> <span class="title">handlerException</span>() </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"redirect:/403.jsp"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@ExceptionHandler</span>(RuntimeException<span class="class">.<span class="keyword">class</span>)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="class">    <span class="title">public</span> <span class="title">String</span> <span class="title">runtimeHandlerException</span>() </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> <span class="string">"forward:/500.jsp"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//redirect:访问的链接重定向到后面的403.jsp - 跟视图解析器有关</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//forward:访问的链接保持不变 </span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//可选方式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerControllerException</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">/**</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> httpServletRequest</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> httpservletResponse</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> o 出现异常的对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@param</span> e 出现的异常信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">     * <span class="doctag">@return</span> ModelAndView</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">    **/</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//将异常信息放入request域中，基本不用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        mv.addObject(<span class="string">"errorMsg"</span>, e.getMessage());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//指定不同异常跳转的页面</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(e <span class="keyword">instanceof</span> AccessDeniedException) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            mv.setViewName(<span class="string">"forward:/403.jsp"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            mv.setViewName(<span class="string">"redirect:/500.jsp"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> mv;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//spring控制器最后返回一个ModelAndView(urlName),其中urNamel可以是一个视图名称,由视图解析器负责解析后将响应流写回客户端;也可以通过redirect/forward:url方式转到另一个控制器进行处理.</span></span></pre></td></tr></table></figure>
<h4 id="七、SpringSecurity与Spring-Boot"><a href="#七、SpringSecurity与Spring-Boot" class="headerlink" title="七、SpringSecurity与Spring Boot"></a>七、SpringSecurity与Spring Boot</h4><p>在Spring MVC中添加Spring Security需要在配置文件web.xml中添加相应的过滤器，而在Spring Boot中则只需要在pom中导入Spring Security的依赖jar包即可，依赖的版本不需要指定，与parent的版本相同。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-security<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr></table></figure>
<p>SpringBoot官方是不推荐在SpringBoot中使用jsp的，但是还是可以使用的。不过需要导入tomcat插件启动项目，不能再用SpringBoot默认的tomcat了。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--导入SpringBoot的tomcat启动插件jar包--&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.tomcat.embed<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>tomcat-embed-jasper<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span></pre></td></tr></table></figure>
<p><strong>如何导入静态资源？</strong></p>
<pre><code>    1. 新建webapp
    2. pom中加入&lt;packaging&gt;war&lt;/packaging&gt;
    3. import
    4. 将静态资源拷贝到webapp下面
</code></pre><p>在SpringBoot中添加SpringSecurity的配置类，相当于之前的spring-security.xml</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@EnableWebSecurity</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecurityConfig</span> <span class="keyword">extends</span> <span class="title">WebSecurityConfigurerAdapter</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//继承了WebSecurityConfigurerAdapter这个类之后，相当于拥有了Spring Security的所有默认配置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//要修改里面里面的配置，就要重写里面的方法</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//认证用户的来源[内存，数据库]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        auth.inMemoryAuthencation()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .withUser(<span class="string">"user"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .password(<span class="string">"&#123;noop&#125;123"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .roles(<span class="string">"USER"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//配置SpringSecurity相关信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//释放静态资源，指定路径/资源拦截规则，指定自定义认证页面，指定退出认证配置，csrf配置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        http.authorizeRequests()   <span class="comment">//默认且必须为第一个</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            .andMatchers(<span class="string">"/login.jsp"</span>,<span class="string">"/failer.jsp"</span>,<span class="string">"/css/**"</span>,<span class="string">"/img/**"</span>,<span class="string">"/plugins/**"</span>).permitAll() <span class="comment">//指出这些资源不被拦截</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">			.andMatchers(<span class="string">"/**"</span>).hasAnyRole(<span class="string">"USER"</span>,<span class="string">"ADMIN"</span>) <span class="comment">//指定角色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            .anyRequest()  <span class="comment">//其他所有的资源只有在认证后才能被使用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            .authenticated()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .and()   <span class="comment">//表示一个新的配置的开始</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            .formLogin()   <span class="comment">//指定以表单的形式登陆</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            .loginPage(<span class="string">"/login.jsp"</span>)   <span class="comment">//登陆的一个page</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            .loginProcessingUrl(<span class="string">"/login"</span>)   <span class="comment">//登陆的url地址</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            .successForwardUrl(<span class="string">"/index.jsp"</span>)  <span class="comment">//成功的跳转页面</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            .failureForwardUrl(<span class="string">"/failer.jsp"</span>) <span class="comment">//失败的跳转页面</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            .permitAll()  <span class="comment">//清空上面的配置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            .and()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .logout()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .logoutUrl(<span class="string">"/logout"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .logoutSuccessUrl(<span class="string">"/login.jsp"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .invalidateHttpSession(<span class="keyword">true</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .permitAll()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .and()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .csrf()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .disable();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><strong>从数据库中加载用户</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> UserService userService;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> BCryptPasswordEncoder <span class="title">passwordEncoder</span><span class="params">()</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> BCryptPasswordEncoder();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(AuthenticationManagerBuilder auth)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    auth.userDetailService(userService).passwordEncoder(passwordEncoder());</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><strong>在SpringSecurity配置类中开启授权</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableGlobalMethodSecurity</span>(securedEnabled=<span class="keyword">true</span>)</span></pre></td></tr></table></figure>
<p><strong>设置异常拦截器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ControllerAdvice</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HandlerControllerException</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="meta">@ExceptionHandler</span>(RuntimeException.calss)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">handlerException</span><span class="params">(RuntimeException e)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(e <span class="keyword">instanceof</span> AccessDeniedException) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="string">"redirect:/403.jsp"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">return</span> <span class="string">"redirect:/500.jsp"</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><strong>分布式认证概念</strong></p>
<p>分布式认证，也就是单点登录，简称SSO。指在多应用系统的项目中，用户只需要登陆一次，就可以访问所有互相信任的应用系统。</p>
<p>首先，在分布式项目中，每台服务器都有各自独立的session，而这些session之间是无法直接共享资源的，所以，session通常不能被作为单点登录的技术方案。</p>
<p><img src="/2021/06/27/Spring-Security-Plus/Users\aaa\Desktop\5.png" alt="img"></p>
<p><strong>单点登录的两大环节</strong></p>
<ol>
<li>用户认证：这一环节主要是用户向认证服务器发起认证请求，认证服务器给用户返回一个成功的令牌token，主要在认证服务器A中完成（认证服务器只能有一个）。</li>
<li>身份校验：这一环节是用户携带token去访问其他服务器时，在其他服务器中要对token的真伪进行检验，主要在资源服务器B中完成（资源服务器B可以有多个）。</li>
</ol>
<p><strong>JWT(SON Web Token)介绍</strong></p>
<p>jwt是一款出色的分布式身份校验方案，可以生成token，也可以解析检验token。</p>
<p>JWT生成的token由三部分组成：</p>
<ul>
<li>头部：主要设置一些规范信息，签名部分的编码格式。</li>
<li>载荷：token中存放有效信息的部分，比如用户名、用户角色、过期时间等。但不要放密码，不安全。</li>
<li>签名：将头部与载荷分别采用base64编码后，用”.”相连，在加入盐，最后使用头部声明的编码类型进行编码，就得到了签名。</li>
</ul>
<p><strong>非对称加密RSA介绍</strong></p>
<p>同时生成两把秘钥：私钥和公钥，私钥隐秘保存，公钥可以下发给信任客户端。</p>
<ul>
<li>私钥加密</li>
<li>公钥加密</li>
</ul>
<p><strong>在分布式环境下SpringSecurity的使用与SpringBoot还不一样</strong>，一般使用SpringSecurity+JWT+RSA做分布式认证</p>
<p><strong>在集中式认证流程中：</strong></p>
<ul>
<li>用户认证：使用UsernamePasswordAuthenticationFilter过滤器中的attemptAuthentication方法实现认证功能。该过滤器父类中successfulAuthentication方法实现认证成功后的操作。</li>
<li>身份校验：使用BasicAuthenticationFilter过滤器中的doFilterInternal方法验证是否登陆，以决定能否进入后续过滤器。</li>
</ul>
<p><strong>分布式认证流程：</strong></p>
<ul>
<li>用户认证：由于分布式项目多数是前后端分离的架构设计，所以需要满足接收异步post的认证请求参数，需要修改UsernamePasswordAuthenticationFilter过滤器中attemptAuthentication方法，让其能够接收请求体。另外，默认successfulAuthentication方法在认证通过后，把用户信息直接放入session中，现在根据分布式的流程，需要将认证通过后的token返回给用户。</li>
<li>身份校验：原来BasicAuthenticationFilter过滤器中doFilterInternal方法校验用户是否登陆，就是看session中是否有用户信息。现在需要修改为验证用户携带的token是否合法，并解析出用户信息，交给SpringSecurity以便于后续的授权。</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtLoginFilter</span> <span class="keyword">extends</span> <span class="title">UsernamePasswordAuthenticationFilter</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> AuthenticationManager authenticationManager;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> RsaKeyProperties prop;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JwtLoginFilter</span><span class="params">(AuthenticationManager authenticationManager, RsaKeyProperties prop)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.authenticationManager = authenticationManager;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.prop = prop;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> Authentication <span class="title">attemptAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> AuthenticationException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           SysUser sysUser = <span class="keyword">new</span> ObjectMapper().reader(request.getInputStream(), SysUser<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            UsernamePasswordAuthenticationToken authRequest = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(sysUser.getUserName(), sysUser.getPassword());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">return</span> authenticationManager.authenticate(authRequest);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">catch</span>(Exception e)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">try</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                response.setContexType(<span class="string">"application/json;charset=utf-8"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                response.sestStatus(HttpServletResponse.SC_UNAUTHORIZED);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                PrintWriter out = response.getWriter();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Map resultMap = <span class="keyword">new</span> HashMap();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                resultMap.put(<span class="string">"code"</span>, HttpServletResponse.SC_UNAUTHORIZED);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                resultMap.put(<span class="string">"msg"</span>, <span class="string">"用户名或密码错误！"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(resultMap));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                out.flush();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                out.close();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">catch</span>(Exception e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            	outEx.printStackTrace();    </span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">successfuaAuthentication</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain, Authentication authResult)</span> <span class="keyword">throws</span> IOException, ServletException </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        SysUser user = <span class="keyword">new</span> SysUser();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        user.setUsername(authResult.getName)();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        user.setRoles(List&lt;SysRole&gt;) authResult.getAuthorities();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String token = JwtUtils.generateTokenExpireInMinutes(user, prop.getPrivateKey(), <span class="number">24</span>*<span class="number">60</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        response.addHeader(<span class="string">"Authorization"</span>, <span class="string">"Bearer "</span>+token);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">try</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            response.setContexType(<span class="string">"application/json;charset=utf-8"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            response.sestStatus(HttpServletResponse.SC_OK);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            PrintWriter out = response.getWriter();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Map resultMap = <span class="keyword">new</span> HashMap();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            resultMap.put(<span class="string">"code"</span>, HttpServletResponse.SC_OK);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            resultMap.put(<span class="string">"msg"</span>, <span class="string">"认证通过！"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(resultMap));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            out.flush();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            out.close();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">catch</span>(Exception e) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            outEx.printStackTrace();    </span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><strong>重写授权的过滤器</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JwtVerifyFilter</span> <span class="keyword">extends</span> <span class="title">BasicAuthenticationFilter</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">private</span> RsaKeyProperties prop;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">JwtVerifyFilter</span><span class="params">(AuthenticationManager authenticationManager, RsaKeyProperties prop)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">super</span>(authenticationManager);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">this</span>.prop = prop;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doFilterInternal</span><span class="params">(HttpServletRequest request, HttpServletResponse response, FilterChain chain)</span> throw IOException</span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String header = request.getHeader(<span class="string">"Authorization"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(header == <span class="keyword">null</span> || !header.startsWith(<span class="string">"Bearer "</span>)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//如果携带了错误的token，则给用户提示请登录</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            chain.doFilter(requet, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            response.setContexType(<span class="string">"application/json;charset=utf-8"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            response.sestStatus(HttpServletResponse.SC_FORBIDDEN);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            PrintWriter out = response.getWriter();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Map resultMap = <span class="keyword">new</span> HashMap();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            resultMap.put(<span class="string">"code"</span>, HttpServletResponse.SC_FORBIDDEN);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            resultMap.put(<span class="string">"msg"</span>, <span class="string">"请登录！"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            out.write(<span class="keyword">new</span> ObjectMapper().writeValueAsString(resultMap));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            out.flush();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            out.close();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//如果携带了正确格式的token，要先得到token进行验证</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            String token = header.replace(<span class="string">"Bearer"</span>, <span class="string">""</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Payload&lt;SysUser&gt; payload = JwtUtils.getInfoFormToken(token,prop.getPublicKey(), SysUser<span class="class">.<span class="keyword">class</span>)</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            SysUser user = payload.getUserInfo();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(user != <span class="keyword">null</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                UsernamePasswordAuthenticationToken authResult = <span class="keyword">new</span> UsernamePasswordAuthenticationToken(user.getUserName(),<span class="keyword">null</span>, user.getAuthorities());</span></pre></td></tr><tr><td class="code"><pre><span class="line">                SecurityContextHolder.getContext().setAuthentication(authResult);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                chain.doFilter(requet, response);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            </span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><strong>改写SpringSecurity配置类</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> RsaKeyProperties prop;    </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//配置SpringSecurity相关信息</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(HttpSecurity http)</span> <span class="keyword">throws</span> Exception </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//释放静态资源，指定路径/资源拦截规则，指定自定义认证页面，指定退出认证配置，csrf配置</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    http.csrf()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .disable()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .authorizeRequests()   <span class="comment">//默认且必须为第一个</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        .andMatchers(<span class="string">"/**"</span>).hasAnyRole(<span class="string">"USER"</span>,<span class="string">"ADMIN"</span>) <span class="comment">//指定角色</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        .anyRequest()  <span class="comment">//其他所有的资源只有在认证后才能被使用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        .authenticated()</span></pre></td></tr><tr><td class="code"><pre><span class="line">        .and()   <span class="comment">//表示一个新的配置的开始</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        .addFilter(<span class="keyword">new</span> JwtLoginFilter(<span class="keyword">super</span>.authenticationManager(), prop))   <span class="comment">//添加认证过滤器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        .addFilter(<span class="keyword">new</span> JwtVerifyFilter(<span class="keyword">super</span>.authenticationManager(), prop))  <span class="comment">//添加授权过滤器</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        .sessionManagement().sessionCreationPolicy(SessionCreationPolicy.STATELESS); <span class="comment">//禁用session管理</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><a href="https://zhuanlan.zhihu.com/p/349962352" target="_blank" rel="noopener">Spring Security: 参考1</a></p>
<p><a href="https://www.bilibili.com/video/av370800402/?p=22&amp;spm_id_from=pageDriver" target="_blank" rel="noopener">Spring Security: 参考2</a></p>
]]></content>
      <categories>
        <category>Cloud Compute</category>
      </categories>
      <tags>
        <tag>Cloud Compute</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-Mybatis-Label-SQL</title>
    <url>/2021/06/27/Spring-Mybatis-Label-SQL/</url>
    <content><![CDATA[<h2 id="Mybatis动态SQL"><a href="#Mybatis动态SQL" class="headerlink" title="Mybatis动态SQL"></a>Mybatis动态SQL</h2><h4 id="一、动态SQL"><a href="#一、动态SQL" class="headerlink" title="一、动态SQL"></a>一、动态SQL</h4><p>动态SQL是在应用程序运行时被编译和执行的SQL，根据用户的输入选择对应的数据库筛选条件。可以有效的减小Mybatis中映射文件xml的大小，使SQL的增、删、改、查更加灵活。</p>
<p>Mybatis动态SQL借助于OGNL表达式对SQL进行拼接。OGNL类似于EL，是用存取对象属性，调用对象方法的表达式语言。</p>
<h4 id="二、常用的OGNL表达式"><a href="#二、常用的OGNL表达式" class="headerlink" title="二、常用的OGNL表达式"></a>二、常用的OGNL表达式</h4><div class="table-container">
<table>
<thead>
<tr>
<th>关键符号作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>or: 或者(并集)、and: 和(交集)</td>
</tr>
<tr>
<td>eq(==)、neq(!=)、lt(&lt;)、lte(&lt;=)、gt(&gt;)、gte(&gt;=)</td>
</tr>
<tr>
<td>算术运算：+、-、*、/、%等</td>
</tr>
<tr>
<td>非、取反</td>
</tr>
<tr>
<td>调用对象方法</td>
</tr>
<tr>
<td>对象属性值</td>
</tr>
</tbody>
</table>
</div>
<h4 id="三、Mybatis动态SQL标签"><a href="#三、Mybatis动态SQL标签" class="headerlink" title="三、Mybatis动态SQL标签"></a>三、Mybatis动态SQL标签</h4><h5 id="3-1-if"><a href="#3-1-if" class="headerlink" title="3.1 if"></a>3.1 if</h5><p>单条件分支标签<strong>if</strong>，test属性<strong>(必填)</strong></p>
<ul>
<li>值为符合OGNL要求的判断表达式，结果可以为true或false</li>
<li>结果为true则执行标签体内容，否则不执行</li>
<li>另外所有非0值都为true，只有0为false</li>
</ul>
<p>例子：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ONGL表达式，集合非空判断 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span> = <span class="string">"list !=null and list.size() &gt; 0"</span> &gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">​	<span class="comment">&lt;!-- 执行内容 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ONGL表达式，数组非空判断 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span> = <span class="string">"array !=null and array.length &gt; 0"</span> &gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">​	<span class="comment">&lt;!-- 执行内容 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- ONGL表达式，字段name非空判断 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span> = <span class="string">"name !=null and name != ''"</span> &gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">​	<span class="comment">&lt;!-- 执行内容 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">if</span>&gt;</span></span></pre></td></tr></table></figure>
<h5 id="3-2-trim-where-set"><a href="#3-2-trim-where-set" class="headerlink" title="3.2 trim(where, set)"></a>3.2 trim(where, set)</h5><p>辅助元素，专门用于SQL拼接去掉多余的and和or等，trim能实现所有where和set实现的内容。</p>
<p><strong>where标签: </strong>包含的元素中有返回值，则插入一个where；如where后的字符串以AND或OR开头，则将他们剔除。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">&lt;!-- where标签包含的内容 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span></pre></td></tr></table></figure>
<p><strong>set标签：</strong>包含的元素中有返回值，则插入一个set；如set后的字符串以逗号结尾，则将该逗号剔除。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">set</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">&lt;!-- set标签包含的内容 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">set</span>&gt;</span></span></pre></td></tr></table></figure>
<p><strong>#{}为参数占位符 “ ? “,即sql预编译；${}为字符串替换，即sql拼接，eg:’%${bname}%’</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 方法一，trim比where高一层，需要指定前缀和覆盖的量 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 使用if+trim标签实现多条件查询 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectById"</span> <span class="attr">parameterType</span>=<span class="string">"Book"</span> <span class="attr">resultType</span>=<span class="string">"Book"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">select * from book</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"where"</span> <span class="attr">prefixOverrides</span>=<span class="string">"and|or"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"bname!=null"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        and bname like '%$&#123;bname&#125;%'</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"bAuthor!=null"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        and bAuthor like '%$&#123;bAuthor&#125;%'</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"bPublisher!=null"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        and bPublisher like '%$&#123;bPublisher&#125;%'</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 方法二， 使用where，如果有and的话会直接忽略第一个and或or --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectById"</span> <span class="attr">parameterType</span>=<span class="string">"Book"</span> <span class="attr">resultType</span>=<span class="string">"Book"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">select * from book</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">where</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"bname!=null"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        and bname like '%$&#123;bname&#125;%'</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"bAuthor!=null"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        and bAuthor like '%$&#123;bAuthor&#125;%'</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"bPublisher!=null"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        and bPublisher like '%$&#123;bPublisher&#125;%'</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">where</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- set有结果则插入set,且删掉最后一个逗号 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateBookById"</span> <span class="attr">parameterType</span>=<span class="string">"Book"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">set</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"bname!=null and bname!=''"</span>&gt;</span>bname=#&#123;bname&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"bAuthor!=null and bAuthor!=''"</span>&gt;</span>bAuthor=#&#123;bAuthor&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"bPublisher!=null and bPublisher!=''"</span>&gt;</span>bPublisher=#&#123;bPublisher&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"bPrice!=null and bPrice!=''"</span>&gt;</span>bPrice=#&#123;bPrice&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"bPubdate!=null and bPubdate!=''"</span>&gt;</span>bPubdate=#&#123;bPubdate&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"bDetail!=null and bDetail!=''"</span>&gt;</span>bDetail=#&#123;bDetail&#125;,<span class="tag">&lt;/<span class="name">if</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    where bid=#&#123;bid&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">update</span>&gt;</span></span></pre></td></tr></table></figure>
<h5 id="3-3-choose-when-otherwise"><a href="#3-3-choose-when-otherwise" class="headerlink" title="3.3 choose(when, otherwise)"></a>3.3 choose(when, otherwise)</h5><p>多条件分支标签，类似JSTL的choose和Java中的switch，用于从多个分支中选择其一项。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">choose</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"title!=null"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- 执行条件1内容 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"author!=null"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- 执行条件2内容 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">&lt;!-- 上述条件都不满足的执行内容 --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"selectByIdAndName"</span> <span class="attr">resultType</span>=<span class="string">"Book"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    SELECT * FROM book WHERE 1=1</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">choose</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"bId!=null and bId&gt;0"</span>&gt;</span> and bid=#&#123;bId&#125;<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"bName!=null and bName!=''"</span>&gt;</span> and bName=#&#123;bName&#125;<span class="tag">&lt;/<span class="name">when</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span>and 1=2<span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span></pre></td></tr></table></figure>
<h5 id="3-4-foreach"><a href="#3-4-foreach" class="headerlink" title="3.4 foreach"></a>3.4 foreach</h5><p>通常用于构建IN条件语句</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">SELECT * FROM BOOK WHERE BID IN(1,3,5);</span></pre></td></tr></table></figure>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性名</th>
<th>作用</th>
</tr>
</thead>
<tbody>
<tr>
<td>collection</td>
<td>必填，值为要迭代循环的属性名</td>
</tr>
<tr>
<td>item</td>
<td>变量名，值为从迭代对象中取出的每个值</td>
</tr>
<tr>
<td>index</td>
<td>索引的属性名，集合、数组情况下值为当前索引值，迭代对象是Map时，值为Map的key</td>
</tr>
<tr>
<td>open</td>
<td>整个循环内容开头的字符串</td>
</tr>
<tr>
<td>seperator</td>
<td>每次循环的分隔符</td>
</tr>
<tr>
<td>close</td>
<td>整个循环内容结尾的字符串</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">&lt;!-- 循环体，例如：#&#123;item&#125; --&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span></pre></td></tr></table></figure>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteBookBatch"</span> <span class="attr">parameterType</span>=<span class="string">list</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    DELETE FROM book WHERE bId In</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">item</span>=<span class="string">"item"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">seperator</span>=<span class="string">","</span><span class="attr">close</span>=<span class="string">")"</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        #&#123;item&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span></pre></td></tr></table></figure>
<h4 id="四、不相关扩展"><a href="#四、不相关扩展" class="headerlink" title="四、不相关扩展"></a>四、不相关扩展</h4><p><strong>如何用postman跳过cookie和鉴权</strong></p>
<p>1、Google浏览器登陆，F12-&gt;找一个请求，查看Request Headers-&gt;查看x-auth-header；将x-auth-header这个key和对应的value添加在postman的Header中。</p>
<p>2、postman-&gt;Authorization-&gt;TYPE-&gt;Basic Auth；输入用户名和密码即可。其中TYPE中有许多中不同类型的鉴权方式，可以根据自己的需求进行选择</p>
<p><img src="/2021/06/27/Spring-Mybatis-Label-SQL/Users\aaa\Desktop\1.png" alt="Mybatis-SQL"></p>
]]></content>
      <categories>
        <category>Cloud Compute</category>
      </categories>
      <tags>
        <tag>Cloud Compute</tag>
      </tags>
  </entry>
  <entry>
    <title>Image-Process-Three</title>
    <url>/2021/06/20/Image-Process-Three/</url>
    <content><![CDATA[<h2 id="图像处理学习"><a href="#图像处理学习" class="headerlink" title="图像处理学习"></a>图像处理学习</h2><h5 id="几何变换：改进图像中像素间的空间关系。在数字图像处理中，几何变换由两个基本操作组成：-1-坐标的空间变换；-2-图像内插，即对空间变换后的像素赋灰度值。"><a href="#几何变换：改进图像中像素间的空间关系。在数字图像处理中，几何变换由两个基本操作组成：-1-坐标的空间变换；-2-图像内插，即对空间变换后的像素赋灰度值。" class="headerlink" title="几何变换：改进图像中像素间的空间关系。在数字图像处理中，几何变换由两个基本操作组成：(1)坐标的空间变换；(2)图像内插，即对空间变换后的像素赋灰度值。"></a>几何变换：改进图像中像素间的空间关系。在数字图像处理中，几何变换由两个基本操作组成：(1)坐标的空间变换；(2)图像内插，即对空间变换后的像素赋灰度值。</h5><h3 id="仿射变换（Affine-Transformations）"><a href="#仿射变换（Affine-Transformations）" class="headerlink" title="仿射变换（Affine Transformations）"></a>仿射变换（Affine Transformations）</h3><p>坐标变换的表示：</p>
<script type="math/tex; mode=display">
(x,y)=T\{(v,w)\}</script><p>其中，(v, w)是原图像中像素的坐标，(x, y)是变换后图像中像素的坐标。仿射变换是最常用的空间坐标变换之一。其一般形式如下：</p>
<script type="math/tex; mode=display">
[x\quad y\quad 1]=[v\quad w\quad 1]T=[v\quad w\quad 1]\cdot\begin{bmatrix}t_{11} & t_{12} & 0 \\ t_{12} & t_{22} & 0 \\
t_{31} & t_{32} & 1
\end{bmatrix}</script><p>在用仿射变换求变换后坐标对应的灰度值的时候，有两种基本的方法。第一种方法称为<strong>前向映射</strong>。它由扫描输入图像的像素在每个位置(v ,w)处计算输出图像中相应像素的空间位置(x, y)组成。但有一个问题是输入图像中的两个或更多个像素可被变换到输出图像中的同一位置。第二种方法称为<strong>反向映射</strong>，扫描输出图像中像素的位置，并在每一个位置(x, y)使用(v, w)=T<sup>-1</sup>(x, y)计算输入图像中的相应位置。然后使用图像内插获得输出图像像素的灰度值。</p>
<p>仿射变换逆变换如下：</p>
<script type="math/tex; mode=display">
\begin{pmatrix} x\\ y\\ \end{pmatrix}=\frac{1}{a\cdot d-b\cdot c} \begin{pmatrix} d & -b\\ -c & a\\ \end{pmatrix}\cdot \begin{pmatrix} x'\\ y'\\ \end{pmatrix}-\begin{pmatrix}t_x \\ t_y\end{pmatrix}</script><h4 id="一、平行移动"><a href="#一、平行移动" class="headerlink" title="一、平行移动"></a>一、平行移动</h4><script type="math/tex; mode=display">
\begin{pmatrix} x'\\ y'\\ 1\\ \end{pmatrix}=\begin{pmatrix} 1 & 0 & t_x\\ 0 & 1 & t_y\\ 0 & 0 & 1\\ \end{pmatrix}\cdot \begin{pmatrix} x\\ y\\ 1\\ \end{pmatrix}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Affine</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">affine</span><span class="params">(_img, a=<span class="number">1</span>, b=<span class="number">0</span>, c=<span class="number">0</span>, d=<span class="number">1</span>, tx=<span class="number">30</span>, ty=<span class="number">-30</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  	H, W, C = _img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># temporary image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	img = np.zeros((H+<span class="number">2</span>, W+<span class="number">2</span>, C), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	img[<span class="number">1</span>:H+<span class="number">1</span>, <span class="number">1</span>:W+<span class="number">1</span>] = _img</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># get new image shape</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	H_new = np.round(H * d).astype(np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	W_new = np.round(W * a).astype(np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.zeros((H_new+<span class="number">1</span>, W_new+<span class="number">1</span>, C), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># get position of new image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	x_new = np.tile(np.arange(W_new), (H_new, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	y_new = np.arange(H_new).repeat(W_new).reshape(H_new, <span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># get position of original image by affine</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	adbc = a * d - b * c</span></pre></td></tr><tr><td class="code"><pre><span class="line">	x = np.round((d * x_new  - b * y_new) / adbc).astype(np.int) - tx + <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	y = np.round((-c * x_new + a * y_new) / adbc).astype(np.int) - ty + <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#X和Y逐位进行比较,选择最小值.最少接受两个参数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#&gt;&gt; np.maximum([-3, -2, 0, 1, 2], 0); 输出array([0, 0, 0, 1, 2])</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	x = np.minimum(np.maximum(x, <span class="number">0</span>), W+<span class="number">1</span>).astype(np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	y = np.minimum(np.maximum(y, <span class="number">0</span>), H+<span class="number">1</span>).astype(np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># assgin pixcel to new image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out[y_new, x_new] = img[y, x]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = out[:H_new, :W_new]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// affine</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">affine</span><span class="params">(cv::Mat img, <span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c, <span class="keyword">double</span> d, <span class="keyword">double</span> tx, <span class="keyword">double</span> ty)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get detriment</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> det = a * d - b * c;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// Resize width and height</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> resized_width = (<span class="keyword">int</span>)(<span class="built_in">width</span> * a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> resized_height = (<span class="keyword">int</span>)(<span class="built_in">height</span> * d);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// other parameters</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> x_before, y_before;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> dx, dy, wx, wy, w_sum;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> _x, _y;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(resized_height, resized_width, CV_8UC3);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// Affine transformation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; resized_height; y++)&#123;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; resized_width; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// get original position x</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      x_before = (<span class="keyword">int</span>)((d * x - b * y) / det - tx);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> ((x_before &lt; <span class="number">0</span>) || (x_before &gt;= <span class="built_in">width</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// get original position y</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      y_before = (<span class="keyword">int</span>)((-c * x + a * y) / det - ty);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> ((y_before &lt; <span class="number">0</span>) || (y_before &gt;= <span class="built_in">height</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// assign pixel to new position</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        out.at&lt;cv::Vec3b&gt;(y, x)[c] = img.at&lt;cv::Vec3b&gt;(y_before, x_before)[c];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="二、放大缩小"><a href="#二、放大缩小" class="headerlink" title="二、放大缩小"></a>二、放大缩小</h4><script type="math/tex; mode=display">
\begin{pmatrix} x'\\ y'\\ 1\\ \end{pmatrix}=\begin{pmatrix} c_x & 0 & t_x\\ 0 & c_y & t_y\\ 0 & 0 & 1\\ \end{pmatrix}\cdot \begin{pmatrix} x\\ y\\ 1\\ \end{pmatrix}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Affine</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">affine</span><span class="params">(_img, a=<span class="number">1.3</span>, b=<span class="number">0</span>, c=<span class="number">0</span>, d=<span class="number">0.8</span>, tx=<span class="number">30</span>, ty=<span class="number">-30</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  	H, W, C = _img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># temporary image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	img = np.zeros((H+<span class="number">2</span>, W+<span class="number">2</span>, C), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	img[<span class="number">1</span>:H+<span class="number">1</span>, <span class="number">1</span>:W+<span class="number">1</span>] = _img</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># get new image shape</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	H_new = np.round(H * d).astype(np.int)  <span class="comment">#d-&gt;cy-&gt;h(宽)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	W_new = np.round(W * a).astype(np.int)  <span class="comment">#a-&gt;cx-&gt;w(高)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#这里的+1是为了防止当a,d的小数部分小于0.5数组溢出</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.zeros((H_new+<span class="number">1</span>, W_new+<span class="number">1</span>, C), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># get position of new image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	x_new = np.tile(np.arange(W_new), (H_new, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	y_new = np.arange(H_new).repeat(W_new).reshape(H_new, <span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># get position of original image by affine</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	adbc = a * d - b * c</span></pre></td></tr><tr><td class="code"><pre><span class="line">	x = np.round((d * x_new  - b * y_new) / adbc).astype(np.int) - tx + <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	y = np.round((-c * x_new + a * y_new) / adbc).astype(np.int) - ty + <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#将坐标限制在合适范围内</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	x = np.minimum(np.maximum(x, <span class="number">0</span>), W+<span class="number">1</span>).astype(np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	y = np.minimum(np.maximum(y, <span class="number">0</span>), H+<span class="number">1</span>).astype(np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># assgin pixcel to new image，因为为img[h,w]所以为y,x</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out[y_new, x_new] = img[y, x]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = out[:H_new, :W_new]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// affine</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">affine</span><span class="params">(cv::Mat img, <span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c, <span class="keyword">double</span> d, <span class="keyword">double</span> tx, <span class="keyword">double</span> ty)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get detriment</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> det = a * d - b * c;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// Resize width and height</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> resized_width = (<span class="keyword">int</span>)(<span class="built_in">width</span> * a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> resized_height = (<span class="keyword">int</span>)(<span class="built_in">height</span> * d);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// other parameters</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> x_before, y_before;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> dx, dy, wx, wy, w_sum;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> _x, _y;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(resized_height, resized_width, CV_8UC3);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// Affine transformation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; resized_height; y++)&#123;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; resized_width; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// get original position x</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      x_before = (<span class="keyword">int</span>)((d * x - b * y) / det - tx);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> ((x_before &lt; <span class="number">0</span>) || (x_before &gt;= <span class="built_in">width</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// get original position y</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      y_before = (<span class="keyword">int</span>)((-c * x + a * y) / det - ty);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> ((y_before &lt; <span class="number">0</span>) || (y_before &gt;= <span class="built_in">height</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// assign pixel to new position</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        out.at&lt;cv::Vec3b&gt;(y, x)[c] = img.at&lt;cv::Vec3b&gt;(y_before, x_before)[c];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="三、旋转"><a href="#三、旋转" class="headerlink" title="三、旋转"></a>三、旋转</h4><p>下面的式子进行逆时针方向旋转 度的仿射变换：</p>
<script type="math/tex; mode=display">
\begin{pmatrix} x'\\ y'\\ 1\\ \end{pmatrix}=\begin{pmatrix} cos(A) & -sin(A) & t_x\\ sin(A) & cos(A) & t_y\\ 0 & 0 & 1\\ \end{pmatrix}\cdot \begin{pmatrix} x\\ y\\ 1\\ \end{pmatrix}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># affine</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">affine</span><span class="params">(_img, a, b, c, d, tx, ty)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	H, W, C = _img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># temporary image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	img = np.zeros((H+<span class="number">2</span>, W+<span class="number">2</span>, C), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	img[<span class="number">1</span>:H+<span class="number">1</span>, <span class="number">1</span>:W+<span class="number">1</span>] = _img</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># get shape of new image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	H_new = np.round(H).astype(np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	W_new = np.round(W).astype(np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.zeros((H_new, W_new, C), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># get position of new image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	x_new = np.tile(np.arange(W_new), (H_new, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	y_new = np.arange(H_new).repeat(W_new).reshape(H_new, <span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># get position of original image by affine</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	adbc = a * d - b * c</span></pre></td></tr><tr><td class="code"><pre><span class="line">	x = np.round((d * x_new  - b * y_new) / adbc).astype(np.int) - tx + <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	y = np.round((-c * x_new + a * y_new) / adbc).astype(np.int) - ty + <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># adjust center by affine</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	dcx = (x.max() + x.min()) // <span class="number">2</span> - W // <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	dcy = (y.max() + y.min()) // <span class="number">2</span> - H // <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	x -= dcx</span></pre></td></tr><tr><td class="code"><pre><span class="line">	y -= dcy</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	x = np.clip(x, <span class="number">0</span>, W + <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	y = np.clip(y, <span class="number">0</span>, H + <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># assign pixcel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out[y_new, x_new] = img[y, x]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Read image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">_img = cv2.imread(<span class="string">"imori.jpg"</span>).astype(np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Affine</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">A = <span class="number">30.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">theta = - np.pi * A / <span class="number">180.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">out = affine(img, a=np.cos(theta), b=-np.sin(theta), c=np.sin(theta), d=np.cos(theta),</span></pre></td></tr><tr><td class="code"><pre><span class="line"> tx=<span class="number">0</span>, ty=<span class="number">0</span>)</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// affine</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">affine</span><span class="params">(cv::Mat img, <span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c, <span class="keyword">double</span> d, <span class="keyword">double</span> tx, <span class="keyword">double</span> ty, <span class="keyword">double</span> theta)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get detriment</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> det = a * d - b * c;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (theta != <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Affine parameters</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> rad = theta / <span class="number">180.</span> * M_PI;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    a = <span class="built_in">std</span>::<span class="built_in">cos</span>(rad);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    b = - <span class="built_in">std</span>::<span class="built_in">sin</span>(rad);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    c = <span class="built_in">std</span>::<span class="built_in">sin</span>(rad);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    d = <span class="built_in">std</span>::<span class="built_in">cos</span>(rad);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    tx = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ty = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> det = a * d - b * c;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// center transition</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> cx = <span class="built_in">width</span> / <span class="number">2.</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> cy = <span class="built_in">height</span> / <span class="number">2.</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> new_cx = (d * cx - b * cy) / det;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> new_cy = (- c * cx + a * cy) / det;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    tx = new_cx - cx;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ty = new_cy - cy;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// Resize width and height</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> resized_width = (<span class="keyword">int</span>)(<span class="built_in">width</span> * a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> resized_height = (<span class="keyword">int</span>)(<span class="built_in">height</span> * d);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (theta != <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    resized_width = (<span class="keyword">int</span>)(<span class="built_in">width</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    resized_height = (<span class="keyword">int</span>)(<span class="built_in">height</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// other parameters</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> x_before, y_before;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> dx, dy, wx, wy, w_sum;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> _x, _y;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(resized_height, resized_width, CV_8UC3);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// Affine transformation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; resized_height; y++)&#123;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; resized_width; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// get original position x</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      x_before = (<span class="keyword">int</span>)((d * x - b * y) / det - tx);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> ((x_before &lt; <span class="number">0</span>) || (x_before &gt;= <span class="built_in">width</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// get original position y</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      y_before = (<span class="keyword">int</span>)((-c * x + a * y) / det - ty);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> ((y_before &lt; <span class="number">0</span>) || (y_before &gt;= <span class="built_in">height</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// assign pixel to new position</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        out.at&lt;cv::Vec3b&gt;(y, x)[c] = img.at&lt;cv::Vec3b&gt;(y_before, x_before)[c];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="四、倾斜（偏移变换-水平、垂直）"><a href="#四、倾斜（偏移变换-水平、垂直）" class="headerlink" title="四、倾斜（偏移变换-水平、垂直）"></a>四、倾斜（偏移变换-水平、垂直）</h4><p>假设原图像的大小为(h, w)，倾斜角度为A，则：</p>
<p>水平倾斜：</p>
<script type="math/tex; mode=display">
s_h=\frac{A}{h}\\\begin{pmatrix} x'\\ y'\\ 1\\ \end{pmatrix}=\begin{pmatrix} 1 & s_h & t_x\\ 0 & 1 & t_y\\ 0 & 0 & 1\\ \end{pmatrix}\cdot \begin{pmatrix} x\\ y\\ 1\\ \end{pmatrix}</script><p>垂直倾斜：</p>
<script type="math/tex; mode=display">
s_v=\frac{A}{w}\\\begin{pmatrix} x'\\ y'\\ 1\\ \end{pmatrix}=\begin{pmatrix} 1 & 0 & t_x\\ s_v & 1 & t_y\\ 0 & 0 & 1\\ \end{pmatrix}\cdot \begin{pmatrix} x\\ y\\ 1\\ \end{pmatrix}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Affine</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">affine</span><span class="params">(img, dx=<span class="number">30</span>, dy=<span class="number">30</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># get shape</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># Affine hyper parameters</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    a = <span class="number">1.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    b = dx / H</span></pre></td></tr><tr><td class="code"><pre><span class="line">    c = dy / W</span></pre></td></tr><tr><td class="code"><pre><span class="line">    d = <span class="number">1.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    tx = <span class="number">0.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    ty = <span class="number">0.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># prepare temporary</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    _img = np.zeros((H+<span class="number">2</span>, W+<span class="number">2</span>, C), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># insert image to center of temporary</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    _img[<span class="number">1</span>:H+<span class="number">1</span>, <span class="number">1</span>:W+<span class="number">1</span>] = img</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># prepare affine image temporary</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    H_new = np.ceil(dy + H).astype(np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    W_new = np.ceil(dx + W).astype(np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = np.zeros((H_new, W_new, C), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># preprare assigned index</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    x_new = np.tile(np.arange(W_new), (H_new, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">    y_new = np.arange(H_new).repeat(W_new).reshape(H_new, <span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># prepare inverse matrix for affine</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    adbc = a * d - b * c</span></pre></td></tr><tr><td class="code"><pre><span class="line">    x = np.round((d * x_new  - b * y_new) / adbc).astype(np.int) - tx + <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    y = np.round((-c * x_new + a * y_new) / adbc).astype(np.int) - ty + <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    x = np.minimum(np.maximum(x, <span class="number">0</span>), W+<span class="number">1</span>).astype(np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    y = np.minimum(np.maximum(y, <span class="number">0</span>), H+<span class="number">1</span>).astype(np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># assign value from original to affine image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    out[y_new, x_new] = _img[y, x]</span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// affine</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">affine</span><span class="params">(cv::Mat img, <span class="keyword">double</span> a, <span class="keyword">double</span> b, <span class="keyword">double</span> c, <span class="keyword">double</span> d, <span class="keyword">double</span> tx, <span class="keyword">double</span> ty, <span class="keyword">double</span> theta, <span class="keyword">double</span> dx, <span class="keyword">double</span> dy)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get detriment</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> det = a * d - b * c;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (dx != <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    b = dx / <span class="built_in">height</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (dy != <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    c = dy / <span class="built_in">width</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (theta != <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Affine parameters</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> rad = theta / <span class="number">180.</span> * M_PI;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    a = <span class="built_in">std</span>::<span class="built_in">cos</span>(rad);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    b = - <span class="built_in">std</span>::<span class="built_in">sin</span>(rad);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    c = <span class="built_in">std</span>::<span class="built_in">sin</span>(rad);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    d = <span class="built_in">std</span>::<span class="built_in">cos</span>(rad);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    tx = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ty = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> det = a * d - b * c;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// center transition</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> cx = <span class="built_in">width</span> / <span class="number">2.</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> cy = <span class="built_in">height</span> / <span class="number">2.</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> new_cx = (d * cx - b * cy) / det;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> new_cy = (- c * cx + a * cy) / det;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    tx = new_cx - cx;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ty = new_cy - cy;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// Resize width and height</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> resized_width = (<span class="keyword">int</span>)(<span class="built_in">width</span> * a + dx);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> resized_height = (<span class="keyword">int</span>)(<span class="built_in">height</span> * d + dy);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (theta != <span class="number">0</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    resized_width = (<span class="keyword">int</span>)(<span class="built_in">width</span> + dx);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    resized_height = (<span class="keyword">int</span>)(<span class="built_in">height</span> + dy);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// other parameters</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> x_before, y_before;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(resized_height, resized_width, CV_8UC3);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// Affine transformation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; resized_height; y++)&#123;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; resized_width; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// get original position x</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      x_before = (<span class="keyword">int</span>)((d * x - b * y) / det - tx);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> ((x_before &lt; <span class="number">0</span>) || (x_before &gt;= <span class="built_in">width</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// get original position y</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      y_before = (<span class="keyword">int</span>)((-c * x + a * y) / det - ty);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> ((y_before &lt; <span class="number">0</span>) || (y_before &gt;= <span class="built_in">height</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">continue</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// assign pixel to new position</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> _c = <span class="number">0</span>; _c &lt; channel; _c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        out.at&lt;cv::Vec3b&gt;(y, x)[_c] = img.at&lt;cv::Vec3b&gt;(y_before, x_before)[_c];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Image Processing</category>
      </categories>
      <tags>
        <tag>Image Processing</tag>
      </tags>
  </entry>
  <entry>
    <title>Image-Process-Two-Plus</title>
    <url>/2021/06/20/Image-Process-Two-Plus/</url>
    <content><![CDATA[<h2 id="图像处理学习"><a href="#图像处理学习" class="headerlink" title="图像处理学习"></a>图像处理学习</h2><h4 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分+"></a>第一部分+</h4><h4 id="一、伽马矫正"><a href="#一、伽马矫正" class="headerlink" title="一、伽马矫正"></a>一、伽马矫正</h4><p>伽马校正用来对照相机等电子设备传感器的非线性光电转换特性进行校正。如果图像原样显示在显示器等上，画面就会显得很暗。伽马校正通过预先增大RGB 的值来排除显示器的影响，达到对图像修正的目的。</p>
<script type="math/tex; mode=display">
s=cr^\gamma, \quad 其中c和\gamma 为正常数</script><p>如果图像使用如下的非线性变换而得(x被归一化，限定在[0,1])：</p>
<script type="math/tex; mode=display">
x'=c\cdot I_{in}^\gamma</script><p>则，可以使用如下的式子进行gamma校正</p>
<script type="math/tex; mode=display">
I_{out}=\frac{1}{c}\cdot I_{in}^{\frac{1}{\gamma}}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># gamma correction</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gamma_correction</span><span class="params">(img, c=<span class="number">1</span>, g=<span class="number">2.2</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = img.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out /= <span class="number">255.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = (<span class="number">1</span>/c * out) ** (<span class="number">1</span>/g)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out *= <span class="number">255</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gamma correction</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">gamma_correction</span><span class="params">(cv::Mat img, <span class="keyword">double</span> gamma_c, <span class="keyword">double</span> gamma_g)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// output image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC3);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> val;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// gamma correction</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y&lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	      val = (<span class="keyword">double</span>)img.at&lt;cv::Vec3b&gt;(y, x)[c] / <span class="number">255</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	      out.at&lt;cv::Vec3b&gt;(y, x)[c] = (uchar)(<span class="built_in">pow</span>(val / gamma_c, <span class="number">1</span> / gamma_g) * <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="二、最近邻插值（Nearest-neighbor-Interpolation-）"><a href="#二、最近邻插值（Nearest-neighbor-Interpolation-）" class="headerlink" title="二、最近邻插值（Nearest-neighbor Interpolation ）"></a>二、最近邻插值（Nearest-neighbor Interpolation ）</h4><p>图像内插在放大、收缩、旋转和几何校正等任务中广泛应用的基本工具。最简单的方法是最近邻插值，在图像放大时补充的像素取最临近的像素的值，但是存在某些直边缘的严重失真。所以这一方法并不常用。可以用一下的公式获取最近邻插值的输出值：</p>
<script type="math/tex; mode=display">
I'(x,y)=I([\frac{x}{a}],[\frac{y}{a}]),I'为放大后图像，I为放大前图像，a为放大率</script><p>上式中的中括号是四舍五入的操作</p>
<p><img src="/2021/06/20/Image-Process-Two-Plus/1.png" alt="Image-Process-Two-Plus"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Nereset Neighbor interpolation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nn_interpolate</span><span class="params">(img, ax=<span class="number">1</span>, ay=<span class="number">1</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	aH = int(ay * H)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	aW = int(ax * W)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">##np.arange()函数返回一个有终点和起点的固定步长的排列</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#numpy.arange()有三种情况</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#1、一个参数时，参数值为终点，起点取默认值0，步长取默认值1。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#2、两个参数时，第一个参数为起点，第二个参数为终点，步长取默认值1。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#3、三个参数时，第一个参数为起点，第二个参数为终点，第三个参数为步长。其中步长支持小数。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#np.repeat()将矩阵A按照给定的axis将每个元素重复repeats次数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">##numpy.repeat(a,repeats,axis=None) repeats可以为一个数，也可以为一个矩阵</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#1、axis=None，时候就会flatten当前矩阵，实际上就是变成了一个行向量</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#2、axis=0,沿着y轴复制，实际上增加了行数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#3、axis=1,沿着x轴复制，实际上增加列数</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">##np.reshape()在不改变数据内容的情况下，改变一个数组的格式</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#numpy.reshape(a,newshape,order='C')</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#order:使用索引顺序读取a的元素，并按照索引顺序将元素放到变换后的的数组中。如果不进行order参数的设置，默认参数为C。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#numpy.arange(n).reshape(a, b) 依次生成n个自然数，并且以a行b列的数组形式显示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#mat (or array).reshape(c, -1) 必须是矩阵格式或者数组格式，才能使用 .reshape(c, -1) 函数， 表示将此矩阵或者数组重组，以 c行d列的形式表示</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#-1的作用就在此: 自动计算d：d=数组或者矩阵里面所有的元素个数/c, d必须是整数，不然报错）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#（reshape(-1, m)即列数固定，行数需要计算）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">##np.tile() 将原矩阵横向、纵向地复制</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#numpy.tile(a,(channel,cols,rows)) #(维度方向,列方向,行方向)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#numpy.tile(a,(cols,rows)) #(列方向,行方向)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#numpy.tile(a,rows) #(行方向)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	y = np.arange(aH).repeat(aW).reshape(aW, <span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	x = np.tile(np.arange(aW), (aH, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	y = np.round(y / ay).astype(np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	x = np.round(x / ax).astype(np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = img[y,x]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Nearest Neighbor</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">out = nn_interpolate(img, ax=<span class="number">1.5</span>, ay=<span class="number">1.5</span>)</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// nearest nieghbor</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">nearest_neighbor</span><span class="params">(cv::Mat img, <span class="keyword">double</span> rx, <span class="keyword">double</span> ry)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get resized shape</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> resized_width = (<span class="keyword">int</span>)(<span class="built_in">width</span> * rx);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> resized_height = (<span class="keyword">int</span>)(<span class="built_in">height</span> * ry);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> x_before, y_before;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// output image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(resized_height, resized_width, CV_8UC3);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// nearest neighbor interpolation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; resized_height; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    y_before = (<span class="keyword">int</span>)round(y / ry);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    y_before = fmin(y_before, <span class="built_in">height</span> - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; resized_width; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      x_before = (<span class="keyword">int</span>)round(x / rx);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      x_before = fmin(x_before, <span class="built_in">width</span> - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      </span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// assign pixel to new position</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	      out.at&lt;cv::Vec3b&gt;(y, x)[c] = img.at&lt;cv::Vec3b&gt;(y_before, x_before)[c];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="三、双线性插值（-Bilinear-Interpolation-）"><a href="#三、双线性插值（-Bilinear-Interpolation-）" class="headerlink" title="三、双线性插值（ Bilinear Interpolation ）"></a>三、双线性插值（ <strong>Bilinear Interpolation</strong> ）</h4><p>双线性插值考察 邻域的像素点，并根据距离设置权值。虽然计算量增大使得处理时间变长，但是可以有效抑制画质劣化。</p>
<p><img src="/2021/06/20/Image-Process-Two-Plus/2.png" alt="Image-Process-Two-Plus"></p>
<ol>
<li>放大后图像的座标 (x’, y’)除以放大率a，可以得到对应原图像的座标 (&lfloor; x’ /a &rfloor;,&lfloor; y’/a&rfloor;)。</li>
<li>求原图像的座标(&lfloor; x’ /a &rfloor;,&lfloor; y’/a&rfloor;)周围邻域的座标I(x,y), I(x+1,y),I(x,y+1). I(x+1,y+1)。</li>
<li>分别求这4个点与(&lfloor; x’ /a &rfloor;,&lfloor; y’/a&rfloor;)的距离，根据距离设置权重：w=d/(&sum;d)。</li>
<li>根据下式求得放大后图像(x’,y’)处的像素值：</li>
</ol>
<script type="math/tex; mode=display">
d_x=\frac{x'}{a}-a,\quad d_y=\frac{y'}{a}-y</script><script type="math/tex; mode=display">
I'(x',y')=(1-d_x)\cdot(1-d_y)\cdot I(x,y)+d_x\cdot (1-d_y)I(x+1,y)+(1-d_x)\cdot d_y\cdot I(x,y+1)+d_x\cdot d_y\cdot I(X+1,Y+1)</script><p>推导：</p>
<p>由双线性插值的实现，分别在两个方向计算了共3次单线性插。所以</p>
<script type="math/tex; mode=display">
f(R1)=\frac{x_2-x}{x_2-x_1}f(Q_{11})+\frac{x-x1}{x_2-x_1}f(Q_{21})</script><script type="math/tex; mode=display">
f(R2)=\frac{x_2-x}{x_2-x_1}f(Q_{12})+\frac{x-x1}{x_2-x_1}f(Q_{22})</script><script type="math/tex; mode=display">
f(P)=\frac{y_2-y}{y_2-y_1}f(R1)+\frac{y-y_1}{y_2-y_1}f(R2),将上面两式带入得</script><script type="math/tex; mode=display">
f(p)=\frac{f(Q_{11})}{(y_2-y_1)(x_2-x_1)}(y_2-y)(x_2-x)+\frac{f(Q_{21})}{(y_2-y_1)(x_2-x_1)}(y_2-y)(x-x_1)\\
+\frac{f(Q_{12})}{(y_2-y_1)(x_2-x_1)}(y-y_1)(x_2-x)+\frac{f(Q_{11})}{(y_2-y_1)(x_2-x_1)}(y-y_1)(x-x_1)</script><script type="math/tex; mode=display">
\because y_2=y_1+1, x_2=x_1+1;\quad \therefore y_2-y1=1,x_2-x_1=1</script><script type="math/tex; mode=display">
f(p)=f(Q_{11})(y_2-y)(x_2-x)+f(Q_{21})(y_2-y)(x-x_1)+f(Q_{12})(y-y_1)(x_2-x)+f(Q_{11})(y-y_1)(x-x_1)</script><p>因此，f(Q<sub>11</sub>)对应I(x,y),1-d<sub>x</sub>对应x<sub>2</sub>-x。一一对应上去就行</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Bi-Linear interpolation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bl_interpolate</span><span class="params">(img, ax=<span class="number">1.</span>, ay=<span class="number">1.</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	aH = int(ay * H)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	aW = int(ax * W)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># get position of resized image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	y = np.arange(aH).repeat(aW).reshape(aW, <span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	x = np.tile(np.arange(aW), (aH, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># get position of original position</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	y = (y / ay)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	x = (x / ax)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	ix = np.floor(x).astype(np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	iy = np.floor(y).astype(np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	ix = np.minimum(ix, W<span class="number">-2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	iy = np.minimum(iy, H<span class="number">-2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># get distance </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	dx = x - ix</span></pre></td></tr><tr><td class="code"><pre><span class="line">	dy = y - iy</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	dx = np.repeat(np.expand_dims(dx, axis=<span class="number">-1</span>), <span class="number">3</span>, axis=<span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	dy = np.repeat(np.expand_dims(dy, axis=<span class="number">-1</span>), <span class="number">3</span>, axis=<span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># interpolation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = (<span class="number">1</span>-dx) * (<span class="number">1</span>-dy) * img[iy, ix] + dx * (<span class="number">1</span> - dy) * img[iy, ix+<span class="number">1</span>] + (<span class="number">1</span> - dx) * dy * img[iy+<span class="number">1</span>, ix] + dx * dy * img[iy+<span class="number">1</span>, ix+<span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.clip(out, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bilinear</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">bilinear</span><span class="params">(cv::Mat img, <span class="keyword">double</span> rx, <span class="keyword">double</span> ry)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get resized shape</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> resized_width = (<span class="keyword">int</span>)(<span class="built_in">width</span> * rx);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> resized_height = (<span class="keyword">int</span>)(<span class="built_in">height</span> * ry);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> x_before, y_before;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> dx, dy;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> val;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// output image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(resized_height, resized_width, CV_8UC3);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// bi-linear interpolation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; resized_height; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    y_before = (<span class="keyword">int</span>)<span class="built_in">floor</span>(y / ry);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    y_before = fmin(y_before, <span class="built_in">height</span> - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dy = y / ry - y_before;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; resized_width; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      x_before = (<span class="keyword">int</span>)<span class="built_in">floor</span>(x / rx);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      x_before = fmin(x_before, <span class="built_in">width</span> - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      dx = x / rx - x_before;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      </span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// compute bi-linear</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        val = (<span class="number">1.</span> - dx) * (<span class="number">1.</span> - dy) * img.at&lt;cv::Vec3b&gt;(y_before, x_before)[c] +</span></pre></td></tr><tr><td class="code"><pre><span class="line">          dx * (<span class="number">1.</span> - dy) * img.at&lt;cv::Vec3b&gt;(y_before, x_before + <span class="number">1</span>)[c] +</span></pre></td></tr><tr><td class="code"><pre><span class="line">          (<span class="number">1.</span> - dx) * dy * img.at&lt;cv::Vec3b&gt;(y_before + <span class="number">1</span>, x_before)[c] +</span></pre></td></tr><tr><td class="code"><pre><span class="line">          dx * dy * img.at&lt;cv::Vec3b&gt;(y_before + <span class="number">1</span>, x_before)[c];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// assign pixel to new position</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        out.at&lt;cv::Vec3b&gt;(y, x)[c] = (uchar)val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="四、双三次插值（Bicubic-Interpolation）"><a href="#四、双三次插值（Bicubic-Interpolation）" class="headerlink" title="四、双三次插值（Bicubic Interpolation）"></a>四、双三次插值（Bicubic Interpolation）</h4><p>双三次插值是双线性插值的扩展，双三次插值又叫立方卷积插值，它是利用了待求像素点在源图像中相邻的16个像素点的值，即这16个像素点的加权平均。双三次内插在保持细节方面比双线性内插相对要好。</p>
<p><img src="/2021/06/20/Image-Process-Two-Plus/3.png" alt="Image-Process-Two-Plus"></p>
<p>双立法和三次卷积只是这个插值算法的两种不同叫法而已，可以自行推导，会发现最终可以将求值转化为卷积公式：</p>
<script type="math/tex; mode=display">
f(i+u,j+v)=A\times B\times C</script><p>其中：</p>
<script type="math/tex; mode=display">
A=[w(1+u),w(u),w(1-u),w(2-u)]</script><script type="math/tex; mode=display">
C=[w(1+v),w(v),w(1-v),w(2-v)]^T</script><script type="math/tex; mode=display">
B=\begin{bmatrix}f(i-1,j-1) & f(i-1,j+0) & f(i-1,j+1) & f(i-1,j+2) \\ f(i+0,j-1) & f(i+0,j+0) & f(i+0,j+1) & f(i+0,j+2)\\f(i+1,j-1) & f(i+1,j+0) & f(i+1,j+1) & f(i+1,j+2)\\f(i+2,j-1) & f(i+2,j+0) & f(i+2,j+1) & f(i+2,j+2)  \end{bmatrix}</script><p>插值核w(x)为：</p>
<script type="math/tex; mode=display">
w(x)=\begin{cases}
1-2|x|^2+|x|^3, & \text{|x|<1}  \\
4-8|x|+5|x|^2-|x|^3, & 1\leq|x|<2 \\
0, & |x| \geq2
\end{cases}</script><p><img src="/2021/06/20/Image-Process-Two-Plus/4.png" alt="Image-Process-Two-Plus"></p>
<p>各自像素间的距离由下式决定：</p>
<script type="math/tex; mode=display">
d_{x_1}=\left|\frac{x'}{ax}-(x-1) \right|,d_{x_2}=\left|\frac{x'}{ax}-x \right|,d_{x_3}=\left|\frac{x'}{ax}-(x+1) \right|,d_{x_4}=\left|\frac{x'}{ax}-(x+2) \right|</script><script type="math/tex; mode=display">
d_{y_1}=\left|\frac{y'}{ax}-(y-1) \right|,d_{y_2}=\left|\frac{y'}{ay}-y \right|,d_{y_3}=\left|\frac{y'}{ay}-(y+1) \right|,d_{y_4}=\left|\frac{y'}{ay}-(y+2) \right|</script><script type="math/tex; mode=display">
上式中，\frac{x'}{ax}-x=u;\frac{y'}{ay}-y=v.所以和上面A矩阵中w的变量是一致的</script><p>利用上面得到的权重w，通过下面的式子扩大图像。将每个像素与权重的乘积之和除以权重的和。</p>
<script type="math/tex; mode=display">
I'(x',y')=\frac{1}{\sum^4_{j=1}\sum^4_{i=1}w(d_{x_i})w(d_{y_j})}\cdot \sum^4_{j=1}\sum^4_{i=1}I(x+i-2,y+j-2)w(d_{x_i})w(d_{y_j})</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Bi-cubic interpolation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">bc_interpolate</span><span class="params">(img, ax=<span class="number">1.</span>, ay=<span class="number">1.</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	aH = int(ay * H)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	aW = int(ax * W)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># get positions of resized image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	y = np.arange(aH).repeat(aW).reshape(aW, <span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	x = np.tile(np.arange(aW), (aH, <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	y = (y / ay)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	x = (x / ax)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># get positions of original image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	ix = np.floor(x).astype(np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	iy = np.floor(y).astype(np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	ix = np.minimum(ix, W<span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	iy = np.minimum(iy, H<span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># get distance of each position of original image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	dx2 = x - ix</span></pre></td></tr><tr><td class="code"><pre><span class="line">	dy2 = y - iy</span></pre></td></tr><tr><td class="code"><pre><span class="line">	dx1 = dx2 + <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	dy1 = dy2 + <span class="number">1</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	dx3 = <span class="number">1</span> - dx2</span></pre></td></tr><tr><td class="code"><pre><span class="line">	dy3 = <span class="number">1</span> - dy2</span></pre></td></tr><tr><td class="code"><pre><span class="line">	dx4 = <span class="number">1</span> + dx3</span></pre></td></tr><tr><td class="code"><pre><span class="line">	dy4 = <span class="number">1</span> + dy3</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	dxs = [dx1, dx2, dx3, dx4]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	dys = [dy1, dy2, dy3, dy4]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># bi-cubic weight</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="function"><span class="keyword">def</span> <span class="title">weight</span><span class="params">(t)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		a = <span class="number">-1.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		at = np.abs(t)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		w = np.zeros_like(t)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		ind = np.where(at &lt;= <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		w[ind] = ((a+<span class="number">2</span>) * np.power(at, <span class="number">3</span>) - (a+<span class="number">3</span>) * np.power(at, <span class="number">2</span>) + <span class="number">1</span>)[ind]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		ind = np.where((at &gt; <span class="number">1</span>) &amp; (at &lt;= <span class="number">2</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">		w[ind] = (a*np.power(at, <span class="number">3</span>) - <span class="number">5</span>*a*np.power(at, <span class="number">2</span>) + <span class="number">8</span>*a*at - <span class="number">4</span>*a)[ind]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">return</span> w</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	w_sum = np.zeros((aH, aW, C), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.zeros((aH, aW, C), dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># interpolate</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="number">-1</span>, <span class="number">3</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">-1</span>, <span class="number">3</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			ind_x = np.minimum(np.maximum(ix + i, <span class="number">0</span>), W<span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			ind_y = np.minimum(np.maximum(iy + j, <span class="number">0</span>), H<span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">			wx = weight(dxs[i+<span class="number">1</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">			wy = weight(dys[j+<span class="number">1</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">			wx = np.repeat(np.expand_dims(wx, axis=<span class="number">-1</span>), <span class="number">3</span>, axis=<span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">			wy = np.repeat(np.expand_dims(wy, axis=<span class="number">-1</span>), <span class="number">3</span>, axis=<span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">			w_sum += wx * wy</span></pre></td></tr><tr><td class="code"><pre><span class="line">			out += wx * wy * img[ind_y, ind_x]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out /= w_sum</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.clip(out, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// weight function</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">h</span><span class="params">(<span class="keyword">double</span> t)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> a = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (<span class="built_in">fabs</span>(t) &lt;= <span class="number">1</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> (a + <span class="number">2</span>) * <span class="built_in">pow</span>(<span class="built_in">fabs</span>(t), <span class="number">3</span>) - (a + <span class="number">3</span>) * <span class="built_in">pow</span>(<span class="built_in">fabs</span>(t), <span class="number">2</span>) + <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">fabs</span>(t) &lt;= <span class="number">2</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> a * <span class="built_in">pow</span>(<span class="built_in">fabs</span>(t), <span class="number">3</span>) - <span class="number">5</span> * a * <span class="built_in">pow</span>(<span class="built_in">fabs</span>(t), <span class="number">2</span>) + <span class="number">8</span> * a * <span class="built_in">fabs</span>(t) - <span class="number">4</span> * a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125; </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// clip value [*, *] -&gt; [min, max]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">val_clip</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> <span class="built_in">min</span>, <span class="keyword">int</span> <span class="built_in">max</span>)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> fmin(fmax(x, <span class="built_in">min</span>), <span class="built_in">max</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// bicubic</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">bicubic</span><span class="params">(cv::Mat img, <span class="keyword">double</span> rx, <span class="keyword">double</span> ry)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get resized shape</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> resized_width = (<span class="keyword">int</span>)(<span class="built_in">width</span> * rx);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> resized_height = (<span class="keyword">int</span>)(<span class="built_in">height</span> * ry);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> x_before, y_before;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> dx, dy, wx, wy, w_sum;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> _x, _y;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// output image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(resized_height, resized_width, CV_8UC3);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// bi-cubic interpolation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; resized_height; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    dy = y / ry;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    y_before = (<span class="keyword">int</span>)<span class="built_in">floor</span>(dy);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; resized_width; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      dx = x / rx;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      x_before = (<span class="keyword">int</span>)<span class="built_in">floor</span>(dx);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      </span></pre></td></tr><tr><td class="code"><pre><span class="line">      </span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        w_sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        val = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// bi-cubic computation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">-1</span>; j &lt; <span class="number">3</span>; j++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          _y = val_clip(y_before + j, <span class="number">0</span>, <span class="built_in">height</span> - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          wy = h(<span class="built_in">fabs</span>(dy - _y));</span></pre></td></tr><tr><td class="code"><pre><span class="line">          </span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">-1</span>; i &lt; <span class="number">3</span>; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            _x = val_clip(x_before + i, <span class="number">0</span>, <span class="built_in">width</span> - <span class="number">1</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            wx = h(<span class="built_in">fabs</span>(dx - _x));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            w_sum += wy * wx;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            val += (<span class="keyword">double</span>)img.at&lt;cv::Vec3b&gt;(_y, _x)[c] * wx * wy;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	      val /= w_sum;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	      val = val_clip(val, <span class="number">0</span>, <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// assign pixel to new position</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	      out.at&lt;cv::Vec3b&gt;(y, x)[c] = (uchar)val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<blockquote>
<p>Cubic Convolution Interpolation for Digital Image Processing</p>
</blockquote>
<p><a href="https://dailc.github.io/2017/11/01/imageprocess_bicubicinterpolation.html" target="_blank" rel="noopener">双三次插值：参考</a></p>
]]></content>
      <categories>
        <category>Image Processing</category>
      </categories>
      <tags>
        <tag>Image Processing</tag>
      </tags>
  </entry>
  <entry>
    <title>Image-Process-Two</title>
    <url>/2021/06/19/Image-Process-Two/</url>
    <content><![CDATA[<h2 id="图像处理学习"><a href="#图像处理学习" class="headerlink" title="图像处理学习"></a>图像处理学习</h2><h4 id="一、直方图"><a href="#一、直方图" class="headerlink" title="一、直方图"></a>一、直方图</h4><p>图像直方图主要用来分析图像灰度的分布情况，从直方图的统计中可以看出图像是整体偏暗还是整体偏亮。一幅图像由不同灰度值的像素组成，图像中灰度的分布情况是该图像的一个重要特征。图像的灰度直方图就描述了图像中灰度分布情况，能够很直观的展示出图像中各个灰度级所占的多少。</p>
<p>灰度级范围[0, L-1]的数字直方图是离散函数h(r<sub>k</sub>)=n<sub>k</sub>,其中r<sub>k</sub>是第k极灰度级，n<sub>k</sub>是图像中灰度为r<sub>k</sub>的像素个数。在实践中，经常用MN表示的图像像素的总数除以每个分量的个数来归一化直方图(M和N代表一张图的行和列)。因此，归一化的直方图由p(r<sub>k</sub>)=n<sub>k</sub>/MN给出，其中，k=0, 1, … , L-1。所以归一化后的直方图所有分量和应该为1。</p>
<p>直方图可以给出表示特定灰度值的像素个数，归一化后的直方图表示特定灰度值在一张图中出现的概率。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//gray image histogram</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">calHistogram</span><span class="params">(cv::Mat img, Map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &amp;histogram)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> h = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> w = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>; c&lt;h; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; r&lt;w; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> grayValue = img.at&lt;uchar&gt;(y,x);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">auto</span> iter = histogram.<span class="built_in">find</span>(grayValue);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span>(iter == histogram.<span class="built_in">end</span>())&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                histogram[grayValue]=<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;<span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                iter-&gt;second += <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="二、直方图归一化-Histogram-Normalization"><a href="#二、直方图归一化-Histogram-Normalization" class="headerlink" title="二、直方图归一化(Histogram Normalization)"></a>二、直方图归一化(Histogram Normalization)</h4><p>h[i] (i=0, 1, … , 255)是任意灰度级为i处像素的概率。H[i]是累积密度分布函数，H[255]=1</p>
<script type="math/tex; mode=display">
h[i]=\frac{Number\quad of\quad pixels\quad of\quad gray\quad level\quad i}{Total \quad number \quad of \quad pixels},\quad\quad  H[i]=\sum^{j}_{i=0}h[i],\quad (j=0,1,...,255)</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Here is the code for finding the histogram of a given image img of glevel=256 gray levels(an 8-bit image) and of size M x N:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>; k&lt;glevel; k++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    H[k]=h[k]=<span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;M; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;N; j++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        g=img[i][j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        h[g]=h[g]+<span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">H[<span class="number">0</span>]=h[<span class="number">0</span>]/M/N;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">1</span>; k&lt;glevel; k++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    h[k]=h[k]/M/N;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    H[k]=H[k<span class="number">-1</span>]=h[k];</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>为了正确显示灰度图像，它的取值范围必须在[0, 255]内(2^8=256)。然而在经过某种处理操作后，图像的灰度级可能发生了变化，所以需要进行归一化(normalized or rescaled)。</p>
<script type="math/tex; mode=display">
y=f(x)=255\cdot\frac{x-x_{min}}{x_{max}-x_{min}}</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">min</span>=LARGE;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="built_in">max</span>=-<span class="built_in">min</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;M; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;N; j++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(img[i][j] &lt; <span class="built_in">min</span>) <span class="built_in">min</span>=img[i][j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span>(img[i][j] &gt; <span class="built_in">max</span>) <span class="built_in">max</span>=img[i][j];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">scale = <span class="number">255.0</span> / (<span class="built_in">max</span>-<span class="built_in">min</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;M; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>; j&lt;N; j++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        img[i][j]=scale*(img[i][j]-<span class="built_in">min</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><a href="http://fourier.eng.hmc.edu/e161/lectures/digital_image/node9.html" target="_blank" rel="noopener">参考</a></p>
<h4 id="三、High-Dynamic-Range-HDR-imaging"><a href="#三、High-Dynamic-Range-HDR-imaging" class="headerlink" title="三、High Dynamic Range (HDR) imaging"></a>三、High Dynamic Range (HDR) imaging</h4><p>大多数数码相机和显示器以 24 位矩阵的形式捕获或显示彩色图像。 每个颜色通道有 8 位，因此每个通道的像素值在 0 – 255 的范围内。 换句话说，普通相机或显示器的动态范围有限。 </p>
<p>然而，我们周围的世界具有非常大的动态范围。 当灯光关闭时，车库内可能会变得漆黑一片，如果您直视太阳，它会变得非常亮。 即使不考虑这些极端情况，在日常情况下，8 位也几乎不足以捕捉场景。 因此，相机会尝试估计照明并自动设置曝光，以便图像最有趣的方面具有良好的动态范围，而太暗和太亮的部分分别被剪裁为 0 和 255。</p>
<p><strong>如何生成高动态范围的图像？</strong></p>
<ul>
<li><h3 id="Step-1-Capture-multiple-images-with-different-exposures"><a href="#Step-1-Capture-multiple-images-with-different-exposures" class="headerlink" title="Step 1: Capture multiple images with different exposures"></a>Step 1: Capture multiple images with different exposures</h3><p>当我们使用相机拍照时，我们每个通道只有 8 位来表示场景的动态范围（亮度范围）。 但是我们可以通过改变快门速度以不同的曝光拍摄场景的多张图像。 大多数单反相机都有一项称为自动包围曝光 (AEB) 的功能，只需按一下按钮，我们就可以以不同的曝光度拍摄多张照片。 如果您使用的是 iPhone，您可以使用这个 AutoBracket HDR 应用程序，如果您是安卓用户，您可以尝试 A Better Camera 应用程序。 </p>
<ol>
<li>曝光不足的图像：此图像比正确曝光的图像更暗。 目标是捕获图像中非常明亮的部分。 </li>
<li>正确曝光的图像：这是相机根据其估计的照明度拍摄的常规图像。 </li>
<li>过度曝光的图像：该图像比正确曝光的图像更亮。 目标是捕获图像中非常暗的部分。 </li>
</ol>
</li>
<li><h3 id="Step-2-Align-Images"><a href="#Step-2-Align-Images" class="headerlink" title="Step 2: Align Images"></a>Step 2: Align Images</h3><p>用于合成 HDR 图像的图像未对齐会导致严重的伪影。</p>
</li>
<li><h3 id="Step-3-Recover-the-Camera-Response-Function"><a href="#Step-3-Recover-the-Camera-Response-Function" class="headerlink" title="Step 3: Recover the Camera Response Function"></a>Step 3: Recover the Camera Response Function</h3><p>典型相机的响应与场景亮度不是线性的。 这意味着什么？ 假设用相机拍摄了两个物体，其中一个物体的亮度是现实世界中另一个物体的两倍。 当你测量照片中两个物体的像素强度时，较亮物体的像素值不会是较暗物体的两倍！ 如果不估计相机响应函数 (CRF)，我们将无法将图像合并为一张 HDR 图像。 </p>
<p>如果我们知道每张图像的曝光时间，就可以从图像中估计 CRF。 与计算机视觉中的许多问题一样，找到 CRF 的问题被设置为优化问题，其目标是最小化由数据项和平滑项组成的目标函数。 这些问题通常归结为线性最小二乘问题，这些问题使用奇异值分解 (SVD) 解决，这是所有线性代数包的一部分。</p>
</li>
<li><h3 id="Step-4-Merge-Images"><a href="#Step-4-Merge-Images" class="headerlink" title="Step 4: Merge Images"></a>Step 4: Merge Images</h3><p>一旦估计了CRF，就可以使用 MergeDebevec 将曝光图像合并为一张 HDR 图像。</p>
</li>
<li><h3 id="Step-5-Tone-mapping"><a href="#Step-5-Tone-mapping" class="headerlink" title="Step 5: Tone mapping"></a>Step 5: Tone mapping</h3><p>尽管我们已经使用多张图像恢复了相对亮度信息，但我们现在面临着将这些信息保存为 24 位图像以供显示的挑战。 有几种色调映射算法。 OpenCV 实现了其中的四个。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">readImagesAndTimes</span><span class="params">(<span class="built_in">vector</span>&lt;Mat&gt; &amp;images, <span class="built_in">vector</span>&lt;<span class="keyword">float</span>&gt; &amp;times)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	  <span class="keyword">int</span> numImages = <span class="number">4</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	  <span class="comment">// List of exposure times</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">float</span> timesArray[] = &#123;<span class="number">1</span>/<span class="number">30.0f</span>,<span class="number">0.25</span>,<span class="number">2.5</span>,<span class="number">15.0</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	  times.assign(timesArray, timesArray + numImages);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	  <span class="comment">// List of image filenames</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	  <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* filenames[] = &#123;<span class="string">"img_0.033.jpg"</span>, <span class="string">"img_0.25.jpg"</span>, <span class="string">"img_2.5.jpg"</span>, <span class="string">"img_15.jpg"</span>&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	  <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; numImages; i++)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	  &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	    Mat im = imread(filenames[i]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	    images.push_back(im);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Ptr&lt;AlignMTB&gt; alignMTB = createAlignMTB();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    alignMTB-&gt;<span class="built_in">process</span>(images, images);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Obtain Camera Response Function (CRF)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Mat responseDebevec;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Ptr&lt;CalibrateDebevec&gt; calibrateDebevec = createCalibrateDebevec();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    calibrateDebevec-&gt;<span class="built_in">process</span>(images, responseDebevec, times);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Merge images into an HDR linear image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Mat hdrDebevec;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Ptr&lt;MergeDebevec&gt; mergeDebevec = createMergeDebevec();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    mergeDebevec-&gt;<span class="built_in">process</span>(images, hdrDebevec, times, responseDebevec);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Save HDR image.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    imwrite(<span class="string">"hdrDebevec.hdr"</span>, hdrDebevec);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//createTonemapDrago(</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//	float gamma = 1.0f,</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//	float saturation = 1.0f, </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//	float bias = 0.85f)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// Tonemap using Drago's method to obtain 24-bit color image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Mat ldrDrago;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Ptr&lt;TonemapDrago&gt; tonemapDrago = createTonemapDrago(<span class="number">1.0</span>, <span class="number">0.7</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    tonemapDrago-&gt;<span class="built_in">process</span>(hdrDebevec, ldrDrago);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ldrDrago = <span class="number">3</span> * ldrDrago;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    imwrite(<span class="string">"ldr-Drago.jpg"</span>, ldrDrago * <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p><a href="https://learnopencv.com/high-dynamic-range-hdr-imaging-using-opencv-cpp-python/" target="_blank" rel="noopener">参考</a></p>
<h4 id="四、直方图操作"><a href="#四、直方图操作" class="headerlink" title="四、直方图操作"></a>四、直方图操作</h4><h5 id="4-1-分段线性变换函数（分为线性和非线性）"><a href="#4-1-分段线性变换函数（分为线性和非线性）" class="headerlink" title="4.1 分段线性变换函数（分为线性和非线性）"></a><strong>4.1 分段线性变换函数</strong>（分为线性和非线性）</h5><p>一种情况，像素点取值范围从[c,d]转换到[a,b]的过程由下式定义:</p>
<script type="math/tex; mode=display">
x_{out}=\begin{cases} a \quad \quad \quad \quad \quad \quad \quad  \quad(if\quad x_{in}<c) \\ \frac{b-a}{d-c}\cdot(x_{in}-c)+a\quad (else\quad if\quad c\leq x_{in}<d) \\
b\quad \quad \quad \quad \quad \quad \quad \quad(else)
\end{cases}</script><p>下面以直方图归一化为例，参照第二部分</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># histogram normalization</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hist_normalization</span><span class="params">(img, a=<span class="number">0</span>, b=<span class="number">255</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># get max and min</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	c = img.min()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	d = img.max()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = img.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># normalization</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = (b-a) / (d - c) * (out - c) + a</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out[out &lt; a] = a</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out[out &gt; b] = b</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// histogram normalization</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">histogram_normalization</span><span class="params">(cv::Mat img, <span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> c, d;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> val;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC3);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get [c, d]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> _c = <span class="number">0</span>; _c &lt; channel; _c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        val = (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[_c];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        c = fmin(c, val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        d = fmax(d, val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// histogram transformation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> _c = <span class="number">0</span>; _c &lt; <span class="number">3</span>; _c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        val = img.at&lt;cv::Vec3b&gt;(y, x)[_c];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">if</span> (val &lt; a)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          out.at&lt;cv::Vec3b&gt;(y, x)[_c] = (uchar)a;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (val &lt;= b)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          out.at&lt;cv::Vec3b&gt;(y, x)[_c] = (uchar)((b - a) / (d - c) * (val - c) + a);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          out.at&lt;cv::Vec3b&gt;(y, x)[_c] = (uchar)b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>最简单的分段线性函数之一是<strong>对比度拉伸变换</strong>。低对比度图像可由照明不足、成像传感器动态范围大小，甚至在图像获取过程中镜头光圈设置错误引起。对比度拉伸时扩展图像灰度级动态范围的处理，因此，它可以跨越记录介质和显示装置的全部灰度范围。</p>
<h4 id="五、直方图均衡化"><a href="#五、直方图均衡化" class="headerlink" title="五、直方图均衡化"></a>五、直方图均衡化</h4><p>假设图像具有连续的灰度值，变量r表示待处理图像的灰度，假设r的取值范围为[0, L-1]，r=0表示黑色，r=L-1表示白色。要让一幅图像的像素倾向于占据整个灰度级并且分布均匀。那么考虑下面的变换函数：</p>
<script type="math/tex; mode=display">
s=T(r),\quad 0\leq r \leq L-1\quad (灰度映射)</script><p>对于输入图像中的每个具有r值的像素值，产生一个输出灰度值s。假设：</p>
<ol>
<li>T(r)在区间0 &leq; r &leq; L-1上为单调递增函数</li>
<li>当0 &leq; r &leq; L-1时，0 &leq; T(r) &leq; L-1</li>
</ol>
<script type="math/tex; mode=display">
r=T^{-1}(s), 0\leq s \leq L-1</script><p>上式需要条件1为严格单调递增函数。<strong>两个方向的映射都是一对一的</strong></p>
<p>一副图像的灰度级可看作是区间[0, L-1]内的随机变量。而随机变量的基本描述子是其概率密度函数(PDF)。令p<sub>r</sub>和p<sub>s</sub>分别为随机变量r和随机变量s的概率密度函数。</p>
<p>由于随机变量r, s为随机变量，且s=T(r), r的随机概率密度函数为p<sub>r</sub>,T(r)连续，可微。则可以推导出变换(映射)后随机变量s的概率密度函数为：</p>
<script type="math/tex; mode=display">
p_S(s)=p_r(r)\left\lvert\frac{dr}{ds}\right\rvert, \quad \frac{dr}{ds}\geq0（非负性）</script><p>推导，由概率论中随机变量函数的分布(这里是一维)的知识可知：</p>
<p>设X的概率密度函数为f<sub>X</sub>(x)，y=g(x)，Y=g(X)，求f<sub>Y</sub>(x) </p>
<script type="math/tex; mode=display">
1、用F_X(x)表示F_Y(x); 2、两边对x求导。其中，F_X(x)=P\{X\leq x\},F_Y(x)=p\{Y\leq x\}</script><p>则：（S和R表示随机变量，集体到表达式用s，r表示）</p>
<script type="math/tex; mode=display">
F_S(s)=P\{S\leq s\}=P\{T(R)\leq s\}(解不等式)\quad \\=P\{R\leq T^{-1}(s)\}=F_R\{T^{-1}(s)\}</script><p>两边同时对s求导，得：</p>
<script type="math/tex; mode=display">
\frac{\partial F_S(s)}{\partial s}=\frac{\partial F_R(T^{-1}(s))}{\partial s} (复合函数求导)  \quad \quad \quad \quad \quad \quad \quad \quad</script><script type="math/tex; mode=display">
p_S(s)=F_R^\prime(T^{-1}(s))\cdot\frac{\partial(T^{-1}(s))}{\partial s}=p_R[T^{-1}(s)]\cdot[T^{-1}(s)]^\prime</script><script type="math/tex; mode=display">
\because s=T(r),r=T^{-1}(s), \quad \therefore p_S(s)=p_R(r)\cdot\left \lvert\frac{dr}{ds}\right\rvert</script><p>同时，由于灰度值s满足的1和2的条件，可以得出<strong>变换函数</strong>的形式为：(均衡化的关键)</p>
<script type="math/tex; mode=display">
s=T(r)=(L-1)\int_0^rp_r(w)dw, (w为积分变量)\\r\in[0,L-1],\int_0^rp_r(w)dw=p\in[0,1]</script><p>由基本积分学中莱布尼茨准则，关于上限的定积分的导数是被积函数在该上线上的值，即</p>
<script type="math/tex; mode=display">
\frac{ds}{dr}=\frac{dT(r)}{dr}=(L-1)\cdot \frac{d}{dr}\left[\int_0^rp_r(w)dw\right]=(L-1)\cdot p_r(r)</script><p>则：</p>
<script type="math/tex; mode=display">
p_s(s)=p_r(r)\left|\frac{dr}{ds}\right|=p_r(r)\cdot \left|\frac{1}{(L-1)}\right|=\frac{1}{L-1}, 0\leq s\leq L-1</script><p>得出，p<sub>s</sub>是一个均匀概率密度函数，且与p<sub>r</sub>的形式无关。尽管s的取值与p<sub>r</sub>有关。</p>
<p>对于离散的情况，使用概率(直方图纵坐标值)和求和来代替概率密度函数和积分，一副图像中灰度级为r<sub>k</sub>出现的概率为：</p>
<script type="math/tex; mode=display">
p_r(k_r)=\frac{n_k}{MN},K=0,1,2,...,L-1</script><p>则上述s的离散形式为：</p>
<script type="math/tex; mode=display">
s_k=T(r_k)=(L-1)\sum^{k}_{j=0}p_r(r_j)=\frac{(L-1)}{MN}\sum^{k}_{j=0}n_j,j=0,1,2,...,L-1</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># histogram equalization</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hist_equal</span><span class="params">(img, z_max=<span class="number">255</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line">	S = H * W * C * <span class="number">1.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = img.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	sum_h = <span class="number">0.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, <span class="number">255</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">		ind = np.where(img == i)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		sum_h += len(img[ind])</span></pre></td></tr><tr><td class="code"><pre><span class="line">		z_prime = z_max / S * sum_h</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out[ind] = z_prime</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// histogram equalization</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">histogram_equalization</span><span class="params">(cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// output image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC3);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// histogram equalization hyper-parameters</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> Zmax = <span class="number">255</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> hist[<span class="number">255</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> S = <span class="built_in">height</span> * <span class="built_in">width</span> * channel;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> hist_sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// histogram initialization</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">255</span>; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">     hist[i] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get histogram sum</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        val = (<span class="keyword">int</span>)img.at&lt;cv::Vec3b&gt;(y, x)[c];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        hist[val] ++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// histogram equalization</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        val = (<span class="keyword">int</span>)img.at&lt;cv::Vec3b&gt;(y, x)[c];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// get histogram sum &lt;= current pixel value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        hist_sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> l = <span class="number">0</span>; l &lt; val; l++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          hist_sum += hist[l];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// assign equalized value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        out.at&lt;cv::Vec3b&gt;(y, x)[c] = (uchar)(Zmax / S * hist_sum);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="六、直方图匹配（直方图规定化）"><a href="#六、直方图匹配（直方图规定化）" class="headerlink" title="六、直方图匹配（直方图规定化）"></a>六、直方图匹配（直方图规定化）</h4><p>对于某些应用，采用均匀直方图的基本增强并不是最好的方法，有时希望处理后的图像具有规定的直方图形状可能更有用。这种用于产生处理后有特殊直方图的方法称为直方图匹配或直方图规定化。</p>
<p>假设存在连续随机变量r和z，并令p<sub>r</sub>(r)和p<sub>z</sub>(z)表示他们所对应的连续概率密度函数。r和z分别表示输入图像和输出图像的灰度级。要求z=G(y)，y=T(r)，使得z具有规定的直方图。如何将z和r进行映射？通过直方图均衡化，假设r和z图像均衡化后的直方图一致。</p>
<p>令s为一个有如下特性的随机变量：(什么特性？s的概率密度函数是一个均匀分布，也就是经过了直方图均衡化图像后的灰度图像)</p>
<script type="math/tex; mode=display">
s=T(r)=(L-1)\int_0^rp_r(w)dw, (w为积分假变量)\quad （1）</script><p>假设规定直方图的随机变量为z，z具有如下的特性(s<sup>*</sup>和s没有直接关系):</p>
<script type="math/tex; mode=display">
s^* =G(z)=(L-1)\int_0^zp_z(t)dt,(t为积分假变量)\quad （2）</script><p>假设两者均衡化后的结果相同，即：</p>
<script type="math/tex; mode=display">
p_S(s)=\frac{1}{L-1},0\leq s\leq L-1</script><p>那么，</p>
<script type="math/tex; mode=display">
G(z)=s=T(r)</script><p>因此，</p>
<script type="math/tex; mode=display">
z=G^{-1}[T(r)]=G^{-1}(s)</script><p>可以看出，z的取值由s给出，而s的取值由输入图像中的灰度r给出。</p>
<p>那么如何由一副给定图像得到一副其灰度级具有指定概率密度函数的图像？</p>
<ol>
<li>由输入图像得到p<sub>r</sub>，并由(1)求得s的值。</li>
<li>由(2)中指定的概率密度函数求得变换函数G(z)。</li>
<li>求得反变换函数z=G<sup>-1</sup>(s)；因为z由s映射得到，所以该处理是s到z的映射。</li>
<li>利用第1步得到的均衡后的输出图像(像素值为s)中的每个像素执行第3步中的反映射，从而获得输出图像。</li>
</ol>
<p>在输入函数的概率密度函数和规定化图像的概率密度函数已知的情况下，可以直接根据r到s的映射和s到z的映射，直接获得r到z的映射。</p>
<p>上述给出了直方图规定化的原理，但在具体的实践中，困难在于寻找满足规定化的直方图和原始图像的概率密度函数需要在直方图均衡化后的概率密度函数相同。在处理离散量时，该问题被大大简化。仅希望得到一个近似的直方图。</p>
<p>由于直方图均衡化变换的离散形式如下：</p>
<script type="math/tex; mode=display">
s_k=T(r_k)=(L-1)\sum^{k}_{j=0}p_r(r_j)=\frac{(L-1)}{MN}\sum^{k}_{j=0}n_j,j=0,1,2,...,L-1</script><p>给定一个规定的s<sub>k</sub>值，式2的离散形式涉及计算变换函数：</p>
<script type="math/tex; mode=display">
G(z_q)=(L-1)\sum_{i=0}^{q}p_z(z_i),对于一个q值，有G(z_q)=s_k</script><p>其中，p<sub>z</sub>(z<sub>i</sub>)是规定的直方图的第i个值的概率。与前面一样，用反变换找到期望的值z<sub>q</sub></p>
<script type="math/tex; mode=display">
z_q=G^{-1}(s_k)</script><p>该操作对每一个s值给出一个z值。</p>
<p>具体离散的例子可以看数字图像处理(第三版)例(3-8)</p>
<p><strong>给出一个正太分布的例子</strong>：将平均值为m标准差为s的直方图变成平均值为m<sub>0</sub>标准差为s<sub>0</sub>的直方图。可以使用下式计算：</p>
<script type="math/tex; mode=display">
x_{out}=\frac{s_0}{s_1}\cdot(x_{in}-m)+m_0</script><p>用直方图规定化进行推导：</p>
<p>正态分布的概率密度函数为：</p>
<script type="math/tex; mode=display">
\phi(x)=\frac{1}{\sqrt{2\pi}\cdot\sigma}\cdot e^{-\frac{(x-\mu)^2}{2\cdot\sigma^2}},-\infty\leq x\leq\infty\quad 记为X\sim N(\mu,\sigma^2)</script><p>对应的分布函数为：</p>
<script type="math/tex; mode=display">
\Phi(X)=\frac{1}{\sqrt{2\pi}}\cdot\int_{-\infty}^xe^{-\frac{(t-\mu)^2}{2\cdot \sigma^2}}dt</script><p>标准的正态分布的概率密度函数：</p>
<script type="math/tex; mode=display">
\phi_0(x)=\frac{1}{\sqrt{2\pi}}\cdot e^{-\frac{x^2}{2}},-\infty\leq x\leq\infty\quad 记为X\sim N(0,1)</script><p>对应的分布函数为：</p>
<script type="math/tex; mode=display">
\Phi_0(X)=\frac{1}{\sqrt{2\pi}}\cdot\int_{-\infty}^xe^{-\frac{t^2}{2}}dt</script><p>计算的时候要将一般的正态分布转换为标准的正态分布</p>
<p>概率密度函数的转换：</p>
<script type="math/tex; mode=display">
\phi(x)=\frac{1}{\sqrt{2\pi}\cdot\sigma}\cdot e^{-\frac{(x-\mu)^2}{2\cdot\sigma^2}}=\frac{1}{\sigma}\cdot\left[\frac{1}{\sqrt{2\pi}}\cdot e^{-\frac{(\frac{x-u}{\sigma})^2}{2}}\right]=\frac{1}{\sigma}\phi_0\left(\frac{x-u}{\sigma}\right)</script><p>分布函数的转换：</p>
<script type="math/tex; mode=display">
\Phi(X)=\frac{1}{\sqrt{2\pi}}\cdot\int_{-\infty}^xe^{-\frac{(t-\mu)^2}{2\cdot \sigma^2}}dt=\frac{1}{\sqrt{2\pi}}\int_{-\infty}^xe^{-\frac{(\frac{t-\mu}{\sigma})^2}{2}}d(\frac{t-\mu}{\sigma})=\Phi_0\left(\frac{x-u}{\sigma}\right)</script><p>在这里，利用直方图规定化中的特定概率密度函数的公式1和公式2：</p>
<script type="math/tex; mode=display">
s=T(r)=(L-1)\int_0^r\Phi_R(x)dx=(L-1)\int_0^r\frac{1}{\sqrt{2\pi}\cdot\sigma}\cdot e^{-\frac{(x-\mu)^2}{2\cdot\sigma^2}}dx=(L-1)\Phi_0\left(\frac{r-\mu_0}{\sigma_0}\right)</script><p>同理：</p>
<script type="math/tex; mode=display">
G(z)=\int_0^z\Phi_Z(t)dt=(L-1)\int_0^z\frac{1}{\sqrt{2\pi}\cdot\sigma}\cdot e^{-\frac{(t-\mu)^2}{2\cdot\sigma^2}}dt=(L-1)\Phi_0\left(\frac{z-\mu_1}{\sigma_1}\right)=s</script><p>所以：</p>
<script type="math/tex; mode=display">
(L-1)\Phi_0\left(\frac{r-\mu_0}{\sigma_0}\right)=(L-1)\Phi_0\left(\frac{z-\mu_1}{\sigma_1}\right)</script><p>因为标准正态分布的概率密度函数一致，所以要想两者一致，需要满足下式：</p>
<script type="math/tex; mode=display">
\frac{r-\mu_0}{\sigma_0}=\frac{z-\mu_1}{\sigma_1}\Rightarrow z=\frac{\sigma_1}{\sigma_0}(r-\mu_0)+\mu_1</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hist_mani</span><span class="params">(img, m0=<span class="number">128</span>, s0=<span class="number">52</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	m = np.mean(img)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	s = np.std(img)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = img.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># normalize</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = s0 / s * (out - m) + m0</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out[out &lt; <span class="number">0</span>] = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out[out &gt; <span class="number">255</span>] = <span class="number">255</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = out.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// histogram transform</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">histogram_transform</span><span class="params">(cv::Mat img, <span class="keyword">int</span> m0, <span class="keyword">int</span> s0)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// histogram transformation hyper-parameters</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> m, s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> sum = <span class="number">0.</span>, squared_sum = <span class="number">0.</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> val;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// output image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC3);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get sum</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">3</span>; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        val = (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[c];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        sum += val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        squared_sum += (val * val);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get standard deviation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  m = sum / (<span class="built_in">height</span> * <span class="built_in">width</span> * channel);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  s = <span class="built_in">sqrt</span>(squared_sum / (<span class="built_in">height</span> * <span class="built_in">width</span> * channel) - m * m);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// histogram transformation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> ( <span class="keyword">int</span> c = <span class="number">0</span>; c &lt; <span class="number">3</span>; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        val = img.at&lt;cv::Vec3b&gt;(y, x)[c];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        out.at&lt;cv::Vec3b&gt;(y, x)[c] = (uchar)(s0 / s * (val - m) + m0);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Image Processing</category>
      </categories>
      <tags>
        <tag>Image Processing</tag>
      </tags>
  </entry>
  <entry>
    <title>Image-Process-One-Plus</title>
    <url>/2021/06/19/Image-Process-One-Plus/</url>
    <content><![CDATA[<h2 id="图像处理学习"><a href="#图像处理学习" class="headerlink" title="图像处理学习"></a>图像处理学习</h2><h3 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分+"></a>第一部分+</h3><h4 id="一、Prewitt滤波器"><a href="#一、Prewitt滤波器" class="headerlink" title="一、Prewitt滤波器"></a>一、<strong>Prewitt滤波器</strong></h4><p> Prewitt是一种常用的检测图像边缘的滤波器，它分为横向和纵向算子，分别用于检测纵向和横向的边缘（注意：横向形式的滤波器检测图像的纵向边缘，纵向形式的滤波器检测图像的横向边缘）。</p>
<p>Prewitt算子是一种一阶<a href="https://baike.baidu.com/item/微分算子/9706908" target="_blank" rel="noopener">微分算子</a>的<a href="https://baike.baidu.com/item/边缘检测/3221648" target="_blank" rel="noopener">边缘检测</a>，利用像素点上下、左右邻点的<a href="https://baike.baidu.com/item/灰度/4615393" target="_blank" rel="noopener">灰度</a>差，在边缘处达到极值检测边缘，去掉部分伪边缘，对噪声具有平滑作用 。其原理是在图像空间利用两个方向模板与图像进行<a href="https://baike.baidu.com/item/邻域/6323269" target="_blank" rel="noopener">邻域</a><a href="https://baike.baidu.com/item/卷积/9411006" target="_blank" rel="noopener">卷积</a>来完成的，这两个方向模板一个检测水平边缘，一个检测垂直边缘。</p>
<p>纵向算子：</p>
<script type="math/tex; mode=display">
K=\begin{bmatrix}
-1 & -1 & -1\\
0 & 0 & 0 \\
1 & 1 & 1
\end{bmatrix}</script><p>横向算子：</p>
<script type="math/tex; mode=display">
K=\begin{bmatrix}
-1 & 0 & 1\\
-1 & 0 & 1 \\
-1 & 0 & 1
\end{bmatrix}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># prewitt filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">prewitt_filter</span><span class="params">(img, K_size=<span class="number">3</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> len(img.shape) == <span class="number">3</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">		H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">else</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">		img = np.expand_dims(img, axis=<span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># Zero padding</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	pad = K_size // <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.zeros((H + pad * <span class="number">2</span>, W + pad * <span class="number">2</span>), dtype=np.float64)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out[pad: pad + H, pad: pad + W] = gray.copy().astype(np.float64ss)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	tmp = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out_v = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out_h = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">## prewitt vertical kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	Kv = [[<span class="number">-1.</span>, <span class="number">-1.</span>, <span class="number">-1.</span>],[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>], [<span class="number">1.</span>, <span class="number">1.</span>, <span class="number">1.</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">## prewitt horizontal kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	Kh = [[<span class="number">-1.</span>, <span class="number">0.</span>, <span class="number">1.</span>],[<span class="number">-1.</span>, <span class="number">0.</span>, <span class="number">1.</span>],[<span class="number">-1.</span>, <span class="number">0.</span>, <span class="number">1.</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			out_v[pad + y, pad + x] = np.sum(Kv * (tmp[y: y + K_size, x: x + K_size]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">			out_h[pad + y, pad + x] = np.sum(Kh * (tmp[y: y + K_size, x: x + K_size]))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out_v = np.clip(out_v, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out_h = np.clip(out_h, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out_v = out_v[pad: pad + H, pad: pad + W].astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out_h = out_h[pad: pad + H, pad: pad + W].astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out_v, out_h</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// prewitt filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">prewitt_filter</span><span class="params">(cv::Mat img, <span class="keyword">int</span> kernel_size, <span class="keyword">bool</span> horizontal)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> kernel[kernel_size][kernel_size] = &#123;&#123;<span class="number">-1</span>, <span class="number">-1</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (horizontal)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">0</span>][<span class="number">2</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">2</span>][<span class="number">0</span>] = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> pad = <span class="built_in">floor</span>(kernel_size / <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// filtering  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> dy = -pad; dy &lt; pad + <span class="number">1</span>; dy++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dx = -pad; dx &lt; pad + <span class="number">1</span>; dx++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">if</span> (((y + dy) &gt;= <span class="number">0</span>) &amp;&amp; (( x + dx) &gt;= <span class="number">0</span>) &amp;&amp; ((y + dy) &lt; <span class="built_in">height</span>) &amp;&amp; ((x + dx) &lt; <span class="built_in">width</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v += img.at&lt;uchar&gt;(y + dy, x + dx) * kernel[dy + pad][dx + pad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = fmax(v, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = fmin(v, <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (uchar)v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="二、拉普拉斯滤波器"><a href="#二、拉普拉斯滤波器" class="headerlink" title="二、拉普拉斯滤波器"></a>二、拉普拉斯滤波器</h4><p>拉普拉斯算子一般是使用二阶微分进行图像锐化。该方法基本上是先定义一个二阶微分的离散公式，然后构造一个基于该公式的滤波器模板。二维函数的二阶微分关注的是一种各向同性滤波器，这种滤波器的响应与滤波器作用的图像的突变方向无关—各向同性滤波器是旋转不变的，即将原图像旋转后进行滤波处理给出的结果与先对图像滤波然后在旋转结果相同。<strong>因为任意阶微分都是线性操作，所以拉普拉斯变换也是一个线性算子</strong></p>
<p>Laplacian滤波器是对图像亮度进行二次微分，从而检测边缘的滤波器。由于数字图像是离散的， x方向和y方向的一次微分分别按照以下式子计算：</p>
<script type="math/tex; mode=display">
I_x(x,y)=\frac{I(x+1,y)-I(x,y)}{(x+1)-x}=I(x+1,y)-I(x,y)</script><script type="math/tex; mode=display">
I_y(x,y)=\frac{I(x,y+1)-I(x,y)}{(y+1)-y}=I(x,y+1)-I(x,y)</script><p>二次微分按照一下式子计算：</p>
<script type="math/tex; mode=display">
I_{xx}(x,y)=\frac{I_x(x,y)-I_x(x-1,y)}{(x+1)-x}=I_x(x,y)-I_x(x-1,y)\\
\quad \quad =[I(x+1,y)-I(x,y)]-[I(x,y)-I(x-1,y)] \\
=I(x+1,y)-2\cdot I(x,y)+I(x-1,y)\quad</script><p>同理：</p>
<script type="math/tex; mode=display">
I_{yy}=I(x,y+1)-2\cdot I(x,y)+I(x,y-1)</script><p>特此，Laplacian表达式如下：</p>
<script type="math/tex; mode=display">
\nabla^2I(x,y)=I_{xx}(x,y)+I_{yy}(x,y)\\
=I(x-1,y)+I(x,y-1)-4\cdot I(x,y)+I(x+1,y)+I(x,y+1)</script><script type="math/tex; mode=display">
\nabla^2f=\begin{bmatrix}
0 & I(x,y-1) & 0\\
I(x-1,y) & -4\cdot I(x,y) & I(x+1,y) \\
0 & I(x,y+1) & 0
\end{bmatrix}</script><p>通过上式可以给出以90&deg;为增量进行旋转的一个各向同性的卷积核(近似于拉普拉斯算子的二阶导数离散卷积核)：</p>
<script type="math/tex; mode=display">
K_1=\begin{bmatrix}
0 & 1 & 0\\
1 & -4 & 1 \\
0 & 1 & 0
\end{bmatrix} \quad \quad K_2=\begin{bmatrix}
0 & -1 & 0\\
-1 & 4 & -1 \\
0 & -1 & 0
\end{bmatrix}</script><p>由于拉普拉斯是一种微分算子，因此强调的是图像中灰度的突变，并不强调缓慢变化的区域。将原图像和拉普拉斯图像叠加在一起，可以复原背景特性并保持拉普拉斯锐化处理的效果。</p>
<script type="math/tex; mode=display">
g(x,y)=f(x,y)+c[\nabla^2f(x,y)]</script><p>f(x,y)和g(x,y)分别是输入图像和锐化后的图像, K<sub>1</sub>时，c=-1; K<sub>2</sub>时，c=1。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># laplacian filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">laplacian_filter</span><span class="params">(img, K_size=<span class="number">3</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># zero padding</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	pad = K_size // <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.zeros((H + pad * <span class="number">2</span>, W + pad * <span class="number">2</span>), dtype=np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out[pad: pad + H, pad: pad + W] = gray.copy().astype(np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	tmp = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># laplacian kernle</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	K = [[<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>],[<span class="number">1.</span>, <span class="number">-4.</span>, <span class="number">1.</span>], [<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			out[pad + y, pad + x] = np.sum(K * (tmp[y: y + K_size, x: x + K_size]))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.clip(out, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = out[pad: pad + H, pad: pad + W].astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// laplacian filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">laplacian_filter</span><span class="params">(cv::Mat img, <span class="keyword">int</span> kernel_size)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> kernel[kernel_size][kernel_size] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">-4</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> pad = <span class="built_in">floor</span>(kernel_size / <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// filtering  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> dy = -pad; dy &lt; pad + <span class="number">1</span>; dy++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dx = -pad; dx &lt; pad + <span class="number">1</span>; dx++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">if</span> (((y + dy) &gt;= <span class="number">0</span>) &amp;&amp; (( x + dx) &gt;= <span class="number">0</span>) &amp;&amp; ((y + dy) &lt; <span class="built_in">height</span>) &amp;&amp; ((x + dx) &lt; <span class="built_in">width</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v += img.at&lt;uchar&gt;(y + dy, x + dx) * kernel[dy + pad][dx + pad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = fmax(v, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = fmin(v, <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (uchar)v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="三、Emboss滤波器"><a href="#三、Emboss滤波器" class="headerlink" title="三、Emboss滤波器"></a>三、<strong>Emboss滤波器</strong></h4><p>Emboss滤波器常用于检测图像的边缘和轮廓，能够有效地增强图像的高频信息（边缘和轮廓），并保留图像的低频信息（图像内容）。浮雕过滤器为图像提供3D阴影效果，结果对于图像的凹凸贴图非常有用。它可以通过在中心的一侧取一个像素并从中减去另一侧的一个像素来实现。像素可以得到正面或者负面的结果。</p>
<script type="math/tex; mode=display">
K_1=\begin{bmatrix}
-1 & -1 & 0\\
-1 & 0 & 1 \\
0 & 1 & 1
\end{bmatrix} \quad \quad K_2=\begin{bmatrix}
-2 & -1 & 0\\
-1 & 1 & 1 \\
0 & 1 & 2
\end{bmatrix}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># emboss filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">emboss_filter</span><span class="params">(img, K_size=<span class="number">3</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># zero padding</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	pad = K_size // <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.zeros((H + pad * <span class="number">2</span>, W + pad * <span class="number">2</span>), dtype=np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out[pad: pad + H, pad: pad + W] = gray.copy().astype(np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	tmp = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># emboss kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	K = [[<span class="number">-2.</span>, <span class="number">-1.</span>, <span class="number">0.</span>],[<span class="number">-1.</span>, <span class="number">1.</span>, <span class="number">1.</span>], [<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">2.</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			out[pad + y, pad + x] = np.sum(K * (tmp[y: y + K_size, x: x + K_size]))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#这里也可以使用负数的绝对值，而非0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.clip(out, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = out[pad: pad + H, pad: pad + W].astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// emboss filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">emboss_filter</span><span class="params">(cv::Mat img, <span class="keyword">int</span> kernel_size)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> kernel[kernel_size][kernel_size] = &#123;&#123;<span class="number">-2</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>&#125;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> pad = <span class="built_in">floor</span>(kernel_size / <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// filtering  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> dy = -pad; dy &lt; pad + <span class="number">1</span>; dy++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dx = -pad; dx &lt; pad + <span class="number">1</span>; dx++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">if</span> (((y + dy) &gt;= <span class="number">0</span>) &amp;&amp; (( x + dx) &gt;= <span class="number">0</span>) &amp;&amp; ((y + dy) &lt; <span class="built_in">height</span>) &amp;&amp; ((x + dx) &lt; <span class="built_in">width</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v += img.at&lt;uchar&gt;(y + dy, x + dx) * kernel[dy + pad][dx + pad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = fmax(v, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = fmin(v, <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (uchar)v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="四、LoG滤波器"><a href="#四、LoG滤波器" class="headerlink" title="四、LoG滤波器"></a>四、LoG滤波器</h4><p> LoG即高斯-拉普拉斯（Laplacian of Gaussian）的缩写，使用高斯滤波器使图像平滑化之后再使用拉普拉斯滤波器使图像的轮廓更加清晰。</p>
<p>目的是为了防止拉普拉斯滤波器计算二次微分会使得图像噪声更加明显，所以我们首先使用高斯滤波器来抑制噪声。</p>
<p> LoG 滤波器使用以下式子定义：</p>
<script type="math/tex; mode=display">
LoG(x,y)=\frac{x^2+y^2-s^2}{2\cdot\pi\cdot s^6}\cdot e^{-\frac{x^2+y^2}{2\cdot s^2}}, \quad s=\sigma(标准差)</script><p>说明：由于卷积操作具有结合律，因此我们先将高斯平滑滤波器与拉普拉斯滤波器进行卷积，然后利用得到的混合滤波器去对图片进行卷积以得到所需的结果。优点如下：</p>
<ol>
<li>由于高斯和拉普拉斯核通常都比图像小得多，所以这种方法通常只需要很少的算术运算。</li>
<li>LoG (Laplacian of Gaussian)内核的参数可以预先计算，因此在运行时只需要对图像执行一遍的卷积即可。</li>
</ol>
<p><strong>如何得到LoG?</strong></p>
<p>1、二维的高斯平滑卷积核可以采用一下公式表示：</p>
<script type="math/tex; mode=display">
G_\sigma(x,y)=\frac{1}{2\pi\sigma^2}exp^{-\frac{x^2+y^2}{2\sigma^2}}</script><p>2、结合高斯卷积核和拉普拉斯卷积核，求二阶导</p>
<script type="math/tex; mode=display">
\frac{\partial }{\partial x}G_\sigma(x,y)=\frac{\partial}{\partial x}e^{-(x^2+y^2)/2\sigma^2}=-\frac{x}{\sigma^2}e^{-(x^2+y^2)\backslash2\sigma^2}</script><p>且：</p>
<script type="math/tex; mode=display">
\frac{\partial^2}{\partial x^2}G_\sigma(x,y)=\frac{x^2}{\sigma^4}e^{-(x^2+y^2)\backslash2\sigma^2}-\frac{1}{\sigma^2}e^{-(x^2+y^2)\backslash2\sigma^2}=\frac{x^2-\sigma^2}{\sigma^4}e^{-(x^2+y^2)\backslash2\sigma^2}</script><p>同理：</p>
<script type="math/tex; mode=display">
\frac{\partial^2}{\partial y^2}G_\sigma(x,y)=\frac{y2-\sigma^2}{\sigma^4}e^{-(x^2+y^2)\backslash2\sigma^2}</script><p>则LoG的卷积核可以定义为</p>
<script type="math/tex; mode=display">
LoG\triangleq\Delta G_\sigma(x,y)=\frac{\partial^2 }{\partial x^2}G_\sigma(x,y)+\frac{\partial^2}{\partial y^2}G_\sigma(x,y)=\frac{x^2+y2-2\sigma^2}{\sigma^4}e^{-(x^2+y^2)\backslash2\sigma^2}\cdot\frac{1}{2\cdot\pi\cdot\sigma^2}\\
\triangleq 是一个AMS二元关系符，读作德尔塔等于Delta \quad Equal \quad To, eg：f(x)\triangleq g(x)+sgn(x),意思是把f(x)定义为g(x)+sgn(x)</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># LoG filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">LoG_filter</span><span class="params">(img, K_size=<span class="number">5</span>, sigma=<span class="number">3</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># zero padding</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	pad = K_size // <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.zeros((H + pad * <span class="number">2</span>, W + pad * <span class="number">2</span>), dtype=np.float64)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out[pad: pad + H, pad: pad + W] = gray.copy().astype(np.float64)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	tmp = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># LoG Kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	K = np.zeros((K_size, K_size), dtype=np.float64)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> range(-pad, -pad + K_size):</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(-pad, -pad + K_size):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			K[y + pad, x + pad] = (x ** <span class="number">2</span> + y ** <span class="number">2</span> - sigma ** <span class="number">2</span>) * np.exp( -(x ** <span class="number">2</span> + y ** <span class="number">2</span>) / (<span class="number">2</span> * (sigma ** <span class="number">2</span>)))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	K /= (<span class="number">2</span> * np.pi * (sigma ** <span class="number">6</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	K /= K.sum()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			out[pad + y, pad + x] = np.sum(K * tmp[y: y + K_size, x: x + K_size])</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.clip(out, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = out[pad: pad + H, pad: pad + W].astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// LoG filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">LoG_filter</span><span class="params">(cv::Mat img, <span class="keyword">int</span> kernel_size, <span class="keyword">double</span> sigma)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> pad = <span class="built_in">floor</span>(kernel_size / <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> kernel[kernel_size][kernel_size];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> kernel_sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> _x, _y;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; kernel_size; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; kernel_size; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _y = y - pad;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _x = x - pad; </span></pre></td></tr><tr><td class="code"><pre><span class="line">      kernel[y][x] = (_x * _x + _y * _y - sigma * sigma) / (<span class="number">2</span> * M_PI * <span class="built_in">pow</span>(sigma, <span class="number">6</span>)) * <span class="built_in">exp</span>( - (_x * _x + _y * _y) / (<span class="number">2</span> * sigma * sigma));</span></pre></td></tr><tr><td class="code"><pre><span class="line">      kernel_sum += kernel[y][x];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; kernel_size; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; kernel_size; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      kernel[y][x] /= kernel_sum;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// filtering  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> dy = -pad; dy &lt; pad + <span class="number">1</span>; dy++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dx = -pad; dx &lt; pad + <span class="number">1</span>; dx++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">if</span> (((y + dy) &gt;= <span class="number">0</span>) &amp;&amp; (( x + dx) &gt;= <span class="number">0</span>) &amp;&amp; ((y + dy) &lt; <span class="built_in">height</span>) &amp;&amp; ((x + dx) &lt; <span class="built_in">width</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v += img.at&lt;uchar&gt;(y + dy, x + dx) * kernel[dy + pad][dx + pad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = fmax(v, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = fmin(v, <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (uchar)v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>1、卷积核的一些规则：</p>
<ul>
<li>它的大小必须是不均匀的，以便它有一个中心，例如：3&times;3, 5&times;5,7&times;7都可以</li>
<li>如果希望卷积后生成的图像和原始图像具有相同的亮度，则过滤器所有元素的总和应该是1，不是必须</li>
<li>如果元素之和大于1，则结果将是更亮的图像；如果小于1，则结果将是更暗的图像；如果总和为0，则生成的图像不一定是全黑，但是会非常暗。</li>
</ul>
<p>2、上述的过滤器是一些非常典型的小过滤器，主要用于模糊、边缘检测和浮雕</p>
<p>3、一些例子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//显示原始图像</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> filterWidth 3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> filterHeight 3</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> filter[filterWidth][filterHeight] = </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>,</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> factor = <span class="number">1.0</span>; <span class="comment">//The factor will be multiplied with the result.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> bias = <span class="number">0.0</span>;   <span class="comment">//The bias added to it, if you want to make the resulting image brighter.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[])</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//load the image into the buffer</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> w = <span class="number">0</span>, h = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ColorRGB&gt; <span class="built_in">image</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="built_in">loadImage</span>(<span class="built_in">image</span>, w, h, <span class="string">"photo.png"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ColorRGB&gt; <span class="title">result</span><span class="params">(<span class="built_in">image</span>.<span class="built_in">size</span>())</span></span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//set up the screen</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    screen(w, h, <span class="string">"Filters"</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    ColorRGB color; <span class="comment">//the color for the pixels</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//apply the filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;w; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;h; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">double</span> red = <span class="number">0.0</span>, green=<span class="number">0.0</span>, blue = <span class="number">0.0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> filterY=<span class="number">0</span>; filterY &lt; filterHeight; filterY++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> filterX=<span class="number">0</span>; filterX &lt; filterWidth; filterX++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">int</span> imageX = (x - filterWidth / <span class="number">2</span> + filterX + w) % w;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    <span class="keyword">int</span> imageY = (y - filterHeight /<span class="number">2</span>  + filterY + h) % h;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    </span></pre></td></tr><tr><td class="code"><pre><span class="line">                    red += <span class="built_in">image</span>[imageY * w + imageX].r * filter[filterY][filterX];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    green += <span class="built_in">image</span>[imageY * w + imageX].g * filter[filterY][filterX];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    red += <span class="built_in">image</span>[imageY * w + imageX].b * filter[filterY][filterX];</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//truncate values smaller than zero and larger than 255</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            result[y * w + x].r = <span class="built_in">min</span>(<span class="built_in">max</span>(<span class="keyword">int</span>(factor * red + bias), <span class="number">0</span>), <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            result[y * w + x].g = <span class="built_in">min</span>(<span class="built_in">max</span>(<span class="keyword">int</span>(factor * green + bias), <span class="number">0</span>), <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            result[y * w + x].b = <span class="built_in">min</span>(<span class="built_in">max</span>(<span class="keyword">int</span>(factor * blue + bias), <span class="number">0</span>), <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//draw the result buffer to the screen</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> y=<span class="number">0</span>; y&lt;h; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> x=<span class="number">0</span>; x&lt;w; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            pset(x,y, result[y * x + x]);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">//redraw &amp; sleep</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    redraw();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sleep();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>4、更大的模糊滤波器，能够得到更大的模糊效果，或者效的滤波器使用多次。</p>
<p>5、空间滤波器模板的产生：生成一个大小为m&times;n的线性空间滤波器要求制定mn个模板系数。这些系数是根据该滤波器支持什么样的操作来选择的 。</p>
<p>6、对于一维函数f(x)，其一阶微分的基本定义是差值：</p>
<script type="math/tex; mode=display">
\frac{\partial f}{\partial x}=f(x+1)-f(x)</script><p>对于二维函数f(x, y)，二阶微分定义为如下差分：</p>
<script type="math/tex; mode=display">
\frac{\partial^2f}{\partial x^2}=f(x+1)+f(x-1)-2f(x)</script><p><a href="https://zhuanlan.zhihu.com/p/92143464" target="_blank" rel="noopener">参考:LoG</a></p>
<p><a href="https://lodev.org.cgtutor/filtering.html" target="_blank" rel="noopener">参考</a></p>
]]></content>
      <categories>
        <category>Image Processing</category>
      </categories>
      <tags>
        <tag>Image Processing</tag>
      </tags>
  </entry>
  <entry>
    <title>Image-Process-One</title>
    <url>/2021/06/13/Image-Process-One/</url>
    <content><![CDATA[<h2 id="图像处理学习"><a href="#图像处理学习" class="headerlink" title="图像处理学习"></a>图像处理学习</h2><h4 id="一、均值滤波器"><a href="#一、均值滤波器" class="headerlink" title="一、均值滤波器"></a>一、均值滤波器</h4><h5 id="1、部分概念的记录"><a href="#1、部分概念的记录" class="headerlink" title="1、部分概念的记录"></a>1、部分概念的记录</h5><p>均值滤波器可以归为低通滤波器，是一种线性滤波器，其输出为邻域模板内的像素的简单平均值，主要用于图像的模糊和降噪。均值滤波器的概念非常的直观，使用滤波器窗口内的像素的平均灰度值代替图像中的像素值，这样的结果就是降低图像中的“尖锐”变化。</p>
<p>频率：分为高、中、低频。高频是目标像素跟周围像素相差比较大。低频是目标像素跟周边像素相差不大。低通滤波=模糊，高通滤波=锐化。方法：线性和非线性滤波器。</p>
<h5 id="2、存在的问题或缺点"><a href="#2、存在的问题或缺点" class="headerlink" title="2、存在的问题或缺点"></a>2、存在的问题或缺点</h5><ul>
<li><p>某个突变像素回影响到周围像素的值</p>
</li>
<li><p>均值滤波会导致边缘信息丢失</p>
</li>
</ul>
<h5 id="3、实现"><a href="#3、实现" class="headerlink" title="3、实现"></a>3、实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># mean filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">mean_filter</span><span class="params">(img, K_size=<span class="number">3</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># zero padding</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    pad = K_size // <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = np.zeros((H + pad * <span class="number">2</span>, W + pad * <span class="number">2</span>, C), dtype=np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    out[pad: pad + H, pad: pad + W] = img.copy().astype(np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    tmp = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(C):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                out[pad + y, pad + x, c] = np.mean(tmp[y: y + K_size, x: x + K_size, c])</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = out[pad: pad + H, pad: pad + W].astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// mean filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">mean_filter</span><span class="params">(cv::Mat img, <span class="keyword">int</span> kernel_size)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC3);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> pad = <span class="built_in">floor</span>(kernel_size / <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> vs[kernel_size * kernel_size];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      </span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// get pixel sum</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> dy = -pad; dy &lt; pad + <span class="number">1</span>; dy++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dx = -pad; dx &lt; pad + <span class="number">1</span>; dx++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">if</span> (((y + dy) &gt;= <span class="number">0</span>) &amp;&amp; ((x + dx) &gt;= <span class="number">0</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v += (<span class="keyword">int</span>)img.at&lt;cv::Vec3b&gt;(y + dy, x + dx)[c];</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// assign mean value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      v /= (kernel_size * kernel_size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;cv::Vec3b&gt;(y, x)[c] = (uchar)v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="二、Motion-Filter"><a href="#二、Motion-Filter" class="headerlink" title="二、Motion Filter"></a>二、Motion Filter</h4><h5 id="2-1-使用的场景"><a href="#2-1-使用的场景" class="headerlink" title="2.1 使用的场景"></a>2.1 使用的场景</h5><p>图像去模糊是一个经典的图像复原任务。造成图像模糊的原因有很多：</p>
<ul>
<li>离焦模糊：场景中的物体处于成像景深范围之外而变得模糊。离焦模糊的去除一般对应着景深的扩展技术</li>
<li>像差模糊：镜头加工和制造的缺陷造成了物方的一个点在成像平面形成了一个弥散斑</li>
<li>运动模糊：成像过程中相机运动或者场景变化所造成的不同空间位置信息的混叠</li>
</ul>
<p>图像运动模糊是由于成像过程中相机运动或者场景变化所造成的不同空间位置信息的混叠。拍摄图像时往往需要一定的曝光时间，如果在这一段曝光时间内投射到传感器上的画面运动超过单个像素尺寸，那么模糊就会出现。曝光时间越长，图像中的模糊往往就剧烈。场景点的运动轨迹累计形成的图像即为模糊核，其记录着在曝光时间内，当前场景点在图像上的能量分布和影响范围。</p>
<h5 id="2-2-为什么需要Motion-Filter"><a href="#2-2-为什么需要Motion-Filter" class="headerlink" title="2.2 为什么需要Motion Filter"></a>2.2 为什么需要Motion Filter</h5><p>高斯滤波，或者Box滤波。传统上进行动作滤波的方式是逐像素的进行时域上的低通滤波，一般会采用时间域上的滑动窗口来进行，这样就会滤除掉时域上的短期的、高速的变化。这种方式有一点点平滑的作用，但它也会带来明显的问题，即不同物体的像素也被平均掉了，因此结果很难看</p>
<script type="math/tex; mode=display">
J(x,y,t)=f(I(x,y,\{ k\}_{t-\delta_t}^{t+\delta_t})</script><h5 id="2-3-简单的运动滤波器"><a href="#2-3-简单的运动滤波器" class="headerlink" title="2.3 简单的运动滤波器"></a>2.3 简单的运动滤波器</h5><script type="math/tex; mode=display">
\begin{bmatrix}\frac{1}{3} & 0 & 0\\ 0 & \frac{1}{3} & 0\\ 0 & 0 & \frac{1}{3} \end{bmatrix}</script><h5 id="2-4-实现"><a href="#2-4-实现" class="headerlink" title="2.4 实现"></a>2.4 实现</h5><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># motion filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">motion_filter</span><span class="params">(img, K_size=<span class="number">3</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># Kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    K = np.diag( [<span class="number">1</span>] * K_size ).astype(np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    K /= K_size</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># zero padding</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    pad = K_size // <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = np.zeros((H + pad * <span class="number">2</span>, W + pad * <span class="number">2</span>, C), dtype=np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    out[pad: pad + H, pad: pad + W] = img.copy().astype(np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    tmp = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(C):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                out[pad + y, pad + x, c] = np.sum(K * tmp[y: y + K_size, x: x + K_size, c])</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = out[pad: pad + H, pad: pad + W].astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// motion filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">motion_filter</span><span class="params">(cv::Mat img, <span class="keyword">int</span> kernel_size)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC3);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> pad = <span class="built_in">floor</span>(kernel_size / <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> kernel[kernel_size][kernel_size];<span class="comment">//&#123;&#123;1./3, 0, 0&#125;, &#123;0, 1./3, 0&#125;, &#123;0, 0, 1./3&#125;&#125;;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; kernel_size; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; kernel_size; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (y == x)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        kernel[y][x] = <span class="number">1.</span> / kernel_size;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        kernel[y][x] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> dy = -pad; dy &lt; pad + <span class="number">1</span>; dy++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dx = -pad; dx &lt; pad + <span class="number">1</span>; dx++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">if</span> (((y + dy) &gt;= <span class="number">0</span>) &amp;&amp; (( x + dx) &gt;= <span class="number">0</span>) &amp;&amp; ((y + dy) &lt; <span class="built_in">height</span>) &amp;&amp; ((x + dx) &lt; <span class="built_in">width</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v += (<span class="keyword">double</span>)img.at&lt;cv::Vec3b&gt;(y + dy, x + dx)[c] * kernel[dy + pad][dx + pad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;cv::Vec3b&gt;(y, x)[c] = (uchar)v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h5 id="2-5-更复杂的运动滤波知识"><a href="#2-5-更复杂的运动滤波知识" class="headerlink" title="2.5 更复杂的运动滤波知识"></a>2.5 更复杂的运动滤波知识</h5><p>运动滤波与计算机摄影密切相关，在延时摄影等场景下往往会导致各种运行模糊，所以需要运用运动滤波等一些方法取恢复真是的图像，或者图像中相关人员关注的部分。</p>
<blockquote>
<p><strong>Motion Denoising with Applicaition to Time-Lapse Photography</strong></p>
<p>Levin et al., “Motion-Invariant Photography,” SIGGRAPH 2008</p>
</blockquote>
<p><a href="https://link.zhihu.com/?target=http%3A//people.csail.mit.edu/mrub/PhDThesis/RubinsteinThesisDefense.zip">Michael Rubinstein: Thesis Defense for Analysis and Visualization of Temporal Variations in Video</a></p>
<p><a href="https://link.zhihu.com/?target=http%3A//people.csail.mit.edu/mrub/PhDThesis/RubinsteinThesisDefense.pdf">Michael Rubistein: Analysis and Visualization of Temporal Variations in Video(PDF)</a></p>
<p><a href="https://link.zhihu.com/?target=http%3A//people.csail.mit.edu/mrub/timelapse/timelapse-posterCVPR2011.pdf">CVPR2011 Poster: Motion Denoising with Application to Time-lapse Photography</a></p>
<p><a href="https://link.zhihu.com/?target=http%3A//people.csail.mit.edu/mrub/PhDThesis/">Analysis and Visualization of Temporal Variations in Video</a> (Author Homework)</p>
<p><a href="https://link.zhihu.com/?target=http%3A//graphics.cs.cmu.edu/courses/15-463/2017_fall/lectures/lecture18.pptx">CMU 2017 Fall Computational Photography Course 15-463,      Lecture 18</a></p>
<p><a href="https://link.zhihu.com/?target=http%3A//web.media.mit.edu/~raskar/deblur/">Raskar et al., “Coded      Exposure Photography: Motion Deblurring using Fluttered Shutter,” SIGGRAPH      2006.</a></p>
<p><a href="https://link.zhihu.com/?target=http%3A//groups.csail.mit.edu/graphics/pubs/MotionInvariant/">Levin et al., “Motion-Invariant      Photography,” SIGGRAPH 2008</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/56335422" target="_blank" rel="noopener">图像处理的应用-运动滤波</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/126580277" target="_blank" rel="noopener">如何消除摄影中的运动模糊</a></p>
<h4 id="三、MAX-MIN滤波器"><a href="#三、MAX-MIN滤波器" class="headerlink" title="三、MAX-MIN滤波器"></a>三、MAX-MIN滤波器</h4><p>MAX-MIN滤波器使用网格内像素的最大值和最小值的差值对网格内像素重新赋值。通常用于<strong>边缘检测</strong>。边缘检测通常作用于灰度图像上。</p>
<script type="math/tex; mode=display">
\begin{bmatrix}P_1 & P_2 & P_3\\ P_4 & P_5 & P_6\\ P_7 & P_8 & P_9 \end{bmatrix}</script><script type="math/tex; mode=display">
P_5=Max(P_1,P_2,\cdots,P_9)-Min(P_1,P_2,\cdots,P_9)</script><p>图像的细节属于低频信息，图像的边缘属于高频信息。我们使用一定大小的 Max-Min  滤波器作用于图像，当滤波器作用于图像细节时，输出结果往往趋向于0（黑色）；而滤波器作用于图像边缘时，Max-Min  输出结果往往趋向于255（白色）。所以 最大-最小滤波器 能有效地用于检测图像的边缘和轮廓。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_min_filter</span><span class="params">(img, K_size=<span class="number">3</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    H, W = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># Zero padding</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    pad = K_size // <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = np.zeros((H + pad * <span class="number">2</span>, W + pad * <span class="number">2</span>), dtype=np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    out[pad: pad + H, pad: pad + W] = gray.copy().astype(np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    tmp = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            out[pad + y, pad + x] = np.max(tmp[y: y + K_size, x: x + K_size]) - \</span></pre></td></tr><tr><td class="code"><pre><span class="line">                np.min(tmp[y: y + K_size, x: x + K_size])</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = out[pad: pad + H, pad: pad + W].astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// max min filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">max_min_filter</span><span class="params">(cv::Mat img, <span class="keyword">int</span> kernel_size)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> pad = <span class="built_in">floor</span>(kernel_size / <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> vmax = <span class="number">0</span>, vmin = <span class="number">999</span>, v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// filtering  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      vmax = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      vmin = <span class="number">999</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> dy = -pad; dy &lt; pad + <span class="number">1</span>; dy++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dx = -pad; dx &lt; pad + <span class="number">1</span>; dx++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">if</span> (((y + dy) &gt;= <span class="number">0</span>) &amp;&amp; (( x + dx) &gt;= <span class="number">0</span>) &amp;&amp; ((y + dy) &lt; <span class="built_in">height</span>) &amp;&amp; ((x + dx) &lt; <span class="built_in">width</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v = (<span class="keyword">double</span>)img.at&lt;uchar&gt;(y + dy, x + dx);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (v &gt; vmax)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              vmax = v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (v &lt; vmin)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              vmin = v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (uchar)(vmax - vmin);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="四、差分滤波器"><a href="#四、差分滤波器" class="headerlink" title="四、差分滤波器"></a>四、差分滤波器</h4><p>差分滤波器对图像亮度急剧变化的边缘有提取效果，可以获得邻接像素的差值。</p>
<h5 id="4-1-简单介绍一下数字滤波器"><a href="#4-1-简单介绍一下数字滤波器" class="headerlink" title="4.1 简单介绍一下数字滤波器"></a>4.1 简单介绍一下数字滤波器</h5><ul>
<li><p>Analog Filter: 模拟滤波器。滤波器从模拟时代产生的一个器件。如下是一个阻容滤波器（由一个电阻、电容构成，对输入的连续信号进行频域上的修正），比如输入一个正弦信号（他有一些直流分量在上面），通过阻容滤波器将正弦信号压制下去，变成直流分量输出。</p>
<p><img src="/2021/06/13/Image-Process-One/1.png" alt="Image-Process-One"></p>
</li>
<li><p>Digtial Filter: 数字滤波器。连续的模拟信号输入，经过A/D Converter(模数转换器，经过采样、量化、编码)，输出数字信号，然后经过Digital filer处理输出，信号的频率特性发生改变。</p>
<p><img src="/2021/06/13/Image-Process-One/2.png" alt="Image-Process-On"></p>
<p><img src="/2021/06/13/Image-Process-One/3.png" alt="Image-Process-One"></p>
</li>
<li><p>Optical Filter: 光学滤波器，把光波的频域进行修正。</p>
</li>
</ul>
<h5 id="4-2-时域、频域、采样定理"><a href="#4-2-时域、频域、采样定理" class="headerlink" title="4.2 时域、频域、采样定理"></a>4.2 时域、频域、采样定理</h5><p>时域信号可以分解成为多个不同频率正弦信号的合成；在变换到频域上可以看到不同成分的幅度，在时域和频域之间进行反变换；</p>
<p>采样定理：  要想正确恢复一个信号，就必须高于这个信号2倍以上的采样频率才可以。</p>
<p><img src="/2021/06/13/Image-Process-One/4.png" alt="Image-Process-One"></p>
<h5 id="4-3-对图像信号而言，什么叫高频，中频，低频信号？"><a href="#4-3-对图像信号而言，什么叫高频，中频，低频信号？" class="headerlink" title="4.3 对图像信号而言，什么叫高频，中频，低频信号？"></a>4.3 对图像信号而言，什么叫高频，中频，低频信号？</h5><p>当前采用值与之前采样值，之后采样值的偏差大小&Delta;表征了信号的频率，所有以它是一个相对概念。</p>
<h5 id="4-4-Differentiator-差分器"><a href="#4-4-Differentiator-差分器" class="headerlink" title="4.4 Differentiator 差分器"></a>4.4 Differentiator 差分器</h5><p>输入信号和输入信号的delay(延迟)进行做差，再输出。</p>
<p><img src="/2021/06/13/Image-Process-One/5.png" alt="Image-Process-One"></p>
<p>如下图，经过差分器后，信号的高频部分被保留了下来，在图像信号上的表现是物体轮廓部分被保留下来。</p>
<p><img src="/2021/06/13/Image-Process-One/6.png" alt="Image-Process-One"></p>
<p>纵向，用于提取图像的水平线条</p>
<script type="math/tex; mode=display">
K_1=\begin{bmatrix}0 & -1 & 0\\ 0 & 1 & 0\\ 0 & 0 & 0 \end{bmatrix}</script><p>横向，用于提取图像的垂直线条</p>
<script type="math/tex; mode=display">
K_2=\begin{bmatrix}0 & 0 & 0\\ -1 & 1 & 0\\ 0 & 0 & 0 \end{bmatrix}</script><p>举例，利用纵向差分滤波器</p>
<script type="math/tex; mode=display">
Input=\begin{bmatrix}0 & 0 & 0 & 0 & 0 & 0 & 0\\0 & 1 & 1 & 1 & 1 & 1 & 0\\0 & 9 & 9 & 9 & 9 & 9 & 0\\0 & 2 & 2 & 2 & 2 & 2 & 0\\0 &1 &1 & 1 & 1 &1 & 0 \\ 0 & 0 & 0 & 0 & 0 & 0 & 0\end{bmatrix}</script><p>使用K<sub>1</sub>后的输出为：（负数可以clip掉，用0替换）</p>
<script type="math/tex; mode=display">
Output=\begin{bmatrix}1 & 1 & 1 & 1 & 1\\ 8 & 8 & 8 & 8 & 8\\ -7 & -7 & -7 & -7 & -7 \\ -1 & -1 & -1 & -1 & -1 \end{bmatrix}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># different filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">different_filter</span><span class="params">(img, K_size=<span class="number">3</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># Zero padding</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	pad = K_size // <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.zeros((H + pad * <span class="number">2</span>, W + pad * <span class="number">2</span>), dtype=np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out[pad: pad + H, pad: pad + W] = gray.copy().astype(np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	tmp = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out_v = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out_h = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># vertical kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	Kv = [[<span class="number">0.</span>, <span class="number">-1.</span>, <span class="number">0.</span>],[<span class="number">0.</span>, <span class="number">1.</span>, <span class="number">0.</span>],[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># horizontal kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	Kh = [[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>],[<span class="number">-1.</span>, <span class="number">1.</span>, <span class="number">0.</span>], [<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			out_v[pad + y, pad + x] = np.sum(Kv * (tmp[y: y + K_size, x: x + K_size]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">			out_h[pad + y, pad + x] = np.sum(Kh * (tmp[y: y + K_size, x: x + K_size]))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out_v = np.clip(out_v, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out_h = np.clip(out_h, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out_v = out_v[pad: pad + H, pad: pad + W].astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out_h = out_h[pad: pad + H, pad: pad + W].astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out_v, out_h</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// max min filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">diff_filter</span><span class="params">(cv::Mat img, <span class="keyword">int</span> kernel_size, <span class="keyword">bool</span> horizontal)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> kernel[kernel_size][kernel_size] = &#123;&#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (horizontal)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">-1</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> pad = <span class="built_in">floor</span>(kernel_size / <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// filtering  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> dy = -pad; dy &lt; pad + <span class="number">1</span>; dy++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dx = -pad; dx &lt; pad + <span class="number">1</span>; dx++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">if</span> (((y + dy) &gt;= <span class="number">0</span>) &amp;&amp; (( x + dx) &gt;= <span class="number">0</span>) &amp;&amp; ((y + dy) &lt; <span class="built_in">height</span>) &amp;&amp; ((x + dx) &lt; <span class="built_in">width</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v += img.at&lt;uchar&gt;(y + dy, x + dx) * kernel[dy + pad][dx + pad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = fmax(v, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = fmin(v, <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (uchar)v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>下面分别为lena的原图，以及水平、垂直差分算法得到的边缘检测图</p>
<center class="half">
    <img src="/2021/06/13/Image-Process-One/7.jpg" width="30%">
    <img src="/2021/06/13/Image-Process-One/8.jpg" width="30%">
    <img src="/2021/06/13/Image-Process-One/9.jpg" width="30%">
</center>

<h4 id="五、Sobel滤波器"><a href="#五、Sobel滤波器" class="headerlink" title="五、Sobel滤波器"></a>五、Sobel滤波器</h4><p>索贝尔算子是计算机视觉领域的一种重要处理方法。主要用于获得数字图像的一阶梯度，常见的应用和物理意义是边缘检测。该算子包含两组3x3的矩阵，分别为横向及纵向，将之与图像作平面卷积，即可分别得出横向及纵向的亮度差分近似值。在图像的任何一点使用此算子，将会产生对应的梯度矢量或是其法矢量。</p>
<p>如果以A代表原始图像，Gx及Gy分别代表经横向及纵向边缘检测的图像，其公式如下:</p>
<script type="math/tex; mode=display">
G_x=\begin{bmatrix} -1 & 0 & 1\\ -2 & 0 & 2\\ -1 & 0 & 1 \end{bmatrix} \ast A \quad \quad and \quad \quad Gy=\begin{bmatrix} 1 & 2 & 1\\ 0 & 0 & 0\\ -1 & -2 & -1 \end{bmatrix}\ast A</script><p>图像的每一个像素的横向及纵向梯度近似值可用以下的公式结合，来计算梯度的大小。</p>
<script type="math/tex; mode=display">
G=\sqrt{G_x^2+G_y^2}</script><p>梯度方向为：</p>
<script type="math/tex; mode=display">
\theta=tan^{-1}\left(\frac{G_y}{G_x}\right)</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># sobel filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sobel_filter</span><span class="params">(img, K_size=<span class="number">3</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> len(img.shape) == <span class="number">3</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">		H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">else</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">		img = np.expand_dims(img, axis=<span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># Zero padding</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	pad = K_size // <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.zeros((H + pad * <span class="number">2</span>, W + pad * <span class="number">2</span>), dtype=np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out[pad: pad + H, pad: pad + W] = gray.copy().astype(np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	tmp = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out_v = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out_h = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">## Sobel vertical</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	Kv = [[<span class="number">1.</span>, <span class="number">2.</span>, <span class="number">1.</span>],[<span class="number">0.</span>, <span class="number">0.</span>, <span class="number">0.</span>], [<span class="number">-1.</span>, <span class="number">-2.</span>, <span class="number">-1.</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">## Sobel horizontal</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	Kh = [[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">-1.</span>],[<span class="number">2.</span>, <span class="number">0.</span>, <span class="number">-2.</span>],[<span class="number">1.</span>, <span class="number">0.</span>, <span class="number">-1.</span>]]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			out_v[pad + y, pad + x] = np.sum(Kv * (tmp[y: y + K_size, x: x + K_size]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">			out_h[pad + y, pad + x] = np.sum(Kh * (tmp[y: y + K_size, x: x + K_size]))</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out_v = np.clip(out_v, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out_h = np.clip(out_h, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out_v = out_v[pad: pad + H, pad: pad + W].astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out_h = out_h[pad: pad + H, pad: pad + W].astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out_v, out_h</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sobel filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">sobel_filter</span><span class="params">(cv::Mat img, <span class="keyword">int</span> kernel_size, <span class="keyword">bool</span> horizontal)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> kernel[kernel_size][kernel_size] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (horizontal)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">-2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> pad = <span class="built_in">floor</span>(kernel_size / <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// filtering  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> dy = -pad; dy &lt; pad + <span class="number">1</span>; dy++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dx = -pad; dx &lt; pad + <span class="number">1</span>; dx++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">if</span> (((y + dy) &gt;= <span class="number">0</span>) &amp;&amp; (( x + dx) &gt;= <span class="number">0</span>) &amp;&amp; ((y + dy) &lt; <span class="built_in">height</span>) &amp;&amp; ((x + dx) &lt; <span class="built_in">width</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v += img.at&lt;uchar&gt;(y + dy, x + dx) * kernel[dy + pad][dx + pad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = fmax(v, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = fmin(v, <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (uchar)v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Sobel filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">sobel_filter</span><span class="params">(cv::Mat img, <span class="keyword">int</span> kernel_size, <span class="keyword">bool</span> horizontal)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> kernel[kernel_size][kernel_size] = &#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">-2</span>, <span class="number">-1</span>&#125;&#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">if</span> (horizontal)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">0</span>][<span class="number">1</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">2</span>][<span class="number">1</span>] = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">1</span>][<span class="number">0</span>] = <span class="number">2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    kernel[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">-2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> pad = <span class="built_in">floor</span>(kernel_size / <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// filtering  </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> dy = -pad; dy &lt; pad + <span class="number">1</span>; dy++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dx = -pad; dx &lt; pad + <span class="number">1</span>; dx++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">if</span> (((y + dy) &gt;= <span class="number">0</span>) &amp;&amp; (( x + dx) &gt;= <span class="number">0</span>) &amp;&amp; ((y + dy) &lt; <span class="built_in">height</span>) &amp;&amp; ((x + dx) &lt; <span class="built_in">width</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v += img.at&lt;uchar&gt;(y + dy, x + dx) * kernel[dy + pad][dx + pad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = fmax(v, <span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = fmin(v, <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = (uchar)v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>下面分别为lena经过sobel算子，垂直、水平和叠加后的边缘检测图</p>
<center class="half">
    <img src="/2021/06/13/Image-Process-One/10.jpg" width="30%">
    <img src="/2021/06/13/Image-Process-One/11.jpg" width="30%">
    <img src="/2021/06/13/Image-Process-One/12.jpg" width="30%">
</center>
]]></content>
      <categories>
        <category>Image Processing</category>
      </categories>
      <tags>
        <tag>Image Processing</tag>
      </tags>
  </entry>
  <entry>
    <title>Image-Process-Zero-Plus</title>
    <url>/2021/06/12/Image-Process-Zero-Plus/</url>
    <content><![CDATA[<h2 id="图像处理学习"><a href="#图像处理学习" class="headerlink" title="图像处理学习"></a>图像处理学习</h2><h4 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分+"></a>第一部分+</h4><h5 id="一、HSV的深探"><a href="#一、HSV的深探" class="headerlink" title="一、HSV的深探"></a>一、HSV的深探</h5><p>一般我们对RGB图像比较熟悉，那么为什么要有这么多个图像形式呢？如：HSV色彩空间，HSL颜色空间等</p>
<h6 id="1、RGB的局限性"><a href="#1、RGB的局限性" class="headerlink" title="1、RGB的局限性"></a>1、RGB的局限性</h6><p>1.1 RGB 是我们接触最多的颜色空间，由三个通道表示一幅图像，分别为红色(R)，绿色(G)和蓝色(B)。这三种颜色的不同组合可以形成几乎所有的其他颜色。</p>
<p>1.2 RGB 颜色空间是图像处理中最基本、最常用、面向硬件的颜色空间。</p>
<p>1.3 RGB 颜色空间利用三个颜色分量的线性组合来表示颜色，任何颜色都与这三个分量有关，而且这三个分量是高度相关的，所以连续变换颜色时并不直观，想对图像的颜色进行调整需要更改这三个分量才行。</p>
<p><img src="/2021/06/12/Image-Process-Zero-Plus/1.jpg" alt="Image-Process-Zero-Plus"></p>
<p>1.4 自然环境下获取的图像容易受自然光照、遮挡和阴影等情况的影响，即对亮度比较敏感。而 RGB 颜色空间的三个分量都与亮度密切相关，即只要亮度改变，三个分量都会随之相应地改变，而没有一种更直观的方式来表达。</p>
<p>1.5 人眼对于这三种颜色分量的敏感程度是不一样的，在单色中，人眼对红色最不敏感，蓝色最敏感，所以 RGB  颜色空间是一种均匀性较差的颜色空间。如果颜色的相似性直接用欧氏距离来度量，其结果与人眼视觉会有较大的偏差。对于某一种颜色，我们很难推测出较为精确的三个分量数值来表示。</p>
<p><strong>总结：RGB 颜色空间适合于显示系统，却并不适合于图像处理。</strong></p>
<h5 id="2、为什么要使用HSV"><a href="#2、为什么要使用HSV" class="headerlink" title="2、为什么要使用HSV?"></a>2、为什么要使用HSV?</h5><p>2.1 在图像处理中使用较多的是 HSV 颜色空间，它比 RGB 更接近人们对彩色的感知经验。非常直观地表达颜色的色调、鲜艳程度和明暗程度，方便进行颜色的对比。</p>
<p>2.2 在 HSV 颜色空间下，它比 BGR 更容易跟踪某种颜色的物体，常用于分割指定颜色的物体。</p>
<h5 id="3、HSV的说明"><a href="#3、HSV的说明" class="headerlink" title="3、HSV的说明"></a>3、HSV的说明</h5><p>Hue -&gt; 色调、色相；Saturation -&gt; 饱和度、色彩纯净度; Value -&gt; 明度</p>
<p><img src="/2021/06/12/Image-Process-Zero-Plus/2.jpg" alt="Image-Process-Zero-Plus"></p>
<p>这个圆柱体来表示 HSV 颜色空间，圆柱体的横截面可以看做是一个极坐标系 ，H 用极坐标的极角表示，S 用极坐标的极轴长度表示，V 用圆柱中轴的高度表示。Hue 用角度度量，取值范围为0～360°，表示色彩信息，即所处的光谱颜色的位置。</p>
<p><img src="/2021/06/12/Image-Process-Zero-Plus/3.jpg" alt="Image-Process-Zero-Plus"></p>
<p>颜色圆环上所有的颜色都是光谱上的颜色，从红色开始按逆时针方向旋转，Hue=0 表示红色，Hue=120 表示绿色，Hue=240 表示蓝色等等。</p>
<p>在 GRB中 颜色由三个值共同决定，比如黄色为即 (255,255,0)；在HSV中，黄色只由一个值决定，Hue=60即可。</p>
<p><img src="/2021/06/12/Image-Process-Zero-Plus/4.jpg" alt="Image-Process-Zero-Plus"></p>
<p>其中水平方向表示饱和度，饱和度表示颜色接近光谱色的程度。饱和度越高，说明颜色越深，越接近光谱色饱和度越低，说明颜色越浅，越接近白色。饱和度为0表示纯白色。取值范围为0～100%，值越大，颜色越饱和。</p>
<p>竖直方向表示明度，决定颜色空间中颜色的明暗程度，明度越高，表示颜色越明亮，范围是 0-100%。明度为0表示纯黑色（此时颜色最暗）。</p>
<p><strong>通俗的理解:</strong>在Hue一定的情况下，<em>饱和度减小</em>，就是往光谱色中添加白色，光谱色所占的比例也在减小，饱和度减为0，表示光谱色所占的比例为零，导致整个颜色呈现白色; <em>明度减小</em>，就是往光谱色中添加黑色，光谱色所占的比例也在减小，明度减为0，表示光谱色所占的比例为零，导致整个颜色呈现黑色。</p>
<h5 id="4、HSV的优点"><a href="#4、HSV的优点" class="headerlink" title="4、HSV的优点"></a>4、HSV的优点</h5><p>HSV  对用户来说是一种比较直观的颜色模型。我们可以很轻松地得到单一颜色，即指定颜色角H，并让V=S=1，然后通过向其中加入黑色和白色来得到我们需要的颜色。增加黑色可以减小V而S不变，同样增加白色可以减小S而V不变。例如，要得到深蓝色，V=0.4 S=1 H=240度。要得到浅蓝色，V=1 S=0.4 H=240度。</p>
<h5 id="5、HSV的应用"><a href="#5、HSV的应用" class="headerlink" title="5、HSV的应用"></a>5、HSV的应用</h5><p>利用颜色空间进行图像分割，如果图像的颜色特征比强度特征更好，则可以尝试将其转换为HSV，然后在H通道上进行自适应二值化处理。</p>
<p><img src="/2021/06/12/Image-Process-Zero-Plus/567.png" alt="Image-Process-Zero-Plus"></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">segImg</span><span class="params">(imagePath)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    img = cv2.imread(imagePath)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cv2.imshow(<span class="string">'img'</span>, img)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cv2.destroyAllWindows()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    hsv = cv2.cvtColor(img, cv2.COLOR_BGR2HSV)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cv2.imwrite(<span class="string">"out_2.jpg"</span>, hsv[:,:,<span class="number">0</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cv2.imshow(<span class="string">'hsv'</span>, hsv[:,:,<span class="number">0</span>])</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cv2.destroyAllWindows()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    (thresh, im_bw) = cv2.threshold(hsv[:,:,<span class="number">0</span>], <span class="number">0</span>, <span class="number">255</span>, cv2.THRESH_BINARY | cv2.THRESH_OTSU)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cv2.imwrite(<span class="string">"out_3.jpg"</span>, im_bw)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cv2.imshow(<span class="string">'otsu'</span>, im_bw)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    cv2.destroyAllWindows()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">path = <span class="string">"./_5.jpg"</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">segImg(path)</span></pre></td></tr></table></figure>
<h5 id="6、RGB和HSV的相互转换"><a href="#6、RGB和HSV的相互转换" class="headerlink" title="6、RGB和HSV的相互转换"></a>6、RGB和HSV的相互转换</h5><h6 id="6-1-RGB转HSV"><a href="#6-1-RGB转HSV" class="headerlink" title="6.1 RGB转HSV"></a>6.1 RGB转HSV</h6><script type="math/tex; mode=display">
R^* = R/255,\quad G^*=G/255; \quad B^*=B/255</script><script type="math/tex; mode=display">
Cmax=max(R^*,G^*,B^*);\quad Cmin=min(R^*,G^*,B^*)</script><script type="math/tex; mode=display">
\Delta=Cmax-Cmin</script><p>H(Hue)的计算：</p>
<script type="math/tex; mode=display">
H=\begin{cases}
0^\circ,\quad \quad \quad \quad \quad\quad \quad \quad \Delta=0 \\
60^\circ\times(\frac{G^*-B^*}{\Delta}+0),\quad Cmax=R^* \\
60^\circ\times(\frac{B^*-R^*}{\Delta}+2),\quad Cmax=G^* \\
60^\circ\times(\frac{R^*-G^*}{\Delta}+4),\quad Cmax=B^* 
\end{cases}</script><p>或以最小值来算</p>
<script type="math/tex; mode=display">
H=\begin{cases}
0^\circ,\quad \quad \quad \quad \quad\quad \quad \quad(if\quad Min=Max) \\
60^\circ\times(\frac{G^*-B^*}{\Delta}+1),\quad (if\quad Min=B^*) \\
60^\circ\times(\frac{B^*-R^*}{\Delta}+3),\quad (if\quad Min=R^*) \\
60^\circ\times(\frac{R^*-G^*}{\Delta}+5),\quad (if\quad Min=G^*)
\end{cases}</script><p>S(Saturation)的计算：</p>
<script type="math/tex; mode=display">
S=\begin{cases}
0, \quad \quad \quad Cmax=0\\
\frac{\Delta}{Cmax}, \quad  Cmax\neq0 
\end{cases}</script><p>或以最小值来算</p>
<script type="math/tex; mode=display">
S=Cmax-Cmin</script><p>V(Value)的计算：</p>
<script type="math/tex; mode=display">
V=Cmax</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># BGR -&gt; HSV</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BGR2HSV</span><span class="params">(_img)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	img = _img.copy() / <span class="number">255.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#输入为矩阵x,输出为形状和x一致的矩阵，其元素全部为0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	hsv = np.zeros_like(img, dtype=np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">#get max min</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#np.max()返回指定轴的最大值，而np.argmax()返回指定轴的最大值对应的索引，指定哪个轴，就按哪个轴进行拆分。</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	max_v = np.max(img, axis=<span class="number">2</span>).copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	min_v = np.min(img, axis=<span class="number">2</span>).copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#比如输入图像是(128,128,3) axis=2,就是分成三个128x128的面，三个面逐点比较大小得到128x128大小值位置的索引矩阵，索引值范围为[0,1,2]</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	min_arg = np.argmin(img, axis=<span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># H</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	hsv[..., <span class="number">0</span>][np.where(max_v == min_v)]= <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">## if min == B</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	ind = np.where(min_arg == <span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#Min = B, (G-R)/(Max-Min) BGR-&gt;[0,1,2],注意Max和Min坐标对应的索引</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	hsv[..., <span class="number">0</span>][ind] = <span class="number">60</span> * (img[..., <span class="number">1</span>][ind] - img[..., <span class="number">2</span>][ind]) / (max_v[ind] - min_v[ind]) + <span class="number">60</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">## if min == R</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	ind = np.where(min_arg == <span class="number">2</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	hsv[..., <span class="number">0</span>][ind] = <span class="number">60</span> * (img[..., <span class="number">0</span>][ind] - img[..., <span class="number">1</span>][ind]) / (max_v[ind] - min_v[ind]) + <span class="number">180</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">## if min == G</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	ind = np.where(min_arg == <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	hsv[..., <span class="number">0</span>][ind] = <span class="number">60</span> * (img[..., <span class="number">2</span>][ind] - img[..., <span class="number">0</span>][ind]) / (max_v[ind] - min_v[ind]) + <span class="number">300</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">		</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># S</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	hsv[..., <span class="number">1</span>] = max_v.copy() - min_v.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># V</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	hsv[..., <span class="number">2</span>] = max_v.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> hsv</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">HSV2BGR</span><span class="params">(_img, hsv)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	img = _img.copy() / <span class="number">255.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># get max and min</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	max_v = np.max(img, axis=<span class="number">2</span>).copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	min_v = np.min(img, axis=<span class="number">2</span>).copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.zeros_like(img)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	H = hsv[..., <span class="number">0</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	S = hsv[..., <span class="number">1</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">	V = hsv[..., <span class="number">2</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	C = S</span></pre></td></tr><tr><td class="code"><pre><span class="line">	H_ = H / <span class="number">60.</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	X = C * (<span class="number">1</span> - np.abs( H_ % <span class="number">2</span> - <span class="number">1</span>))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	Z = np.zeros_like(H)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	vals = [[Z,X,C], [Z,C,X], [X,C,Z], [C,X,Z], [C,Z,X], [X,Z,C]]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">6</span>):</span></pre></td></tr><tr><td class="code"><pre><span class="line">		ind = np.where((i &lt;= H_) &amp; (H_ &lt; (i+<span class="number">1</span>)))</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out[..., <span class="number">0</span>][ind] = (V - C)[ind] + vals[i][<span class="number">0</span>][ind]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out[..., <span class="number">1</span>][ind] = (V - C)[ind] + vals[i][<span class="number">1</span>][ind]</span></pre></td></tr><tr><td class="code"><pre><span class="line">		out[..., <span class="number">2</span>][ind] = (V - C)[ind] + vals[i][<span class="number">2</span>][ind]</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out[np.where(max_v == min_v)] = <span class="number">0</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.clip(out, <span class="number">0</span>, <span class="number">1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = (out * <span class="number">255</span>).astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Read image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"../imori.jpg"</span>).astype(np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># RGB &gt; HSV</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">hsv = BGR2HSV(img)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Transpose Hue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">hsv[..., <span class="number">0</span>] = (hsv[..., <span class="number">0</span>] + <span class="number">180</span>) % <span class="number">360</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># HSV &gt; RGB</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">out = HSV2BGR(img, hsv)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Save result</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">"out.jpg"</span>, out)</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"result"</span>, out)</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
<p><a href="https://blog.csdn.net/weixin_41560402/article/details/105277069" target="_blank" rel="noopener">参考资料</a></p>
<h5 id="6-2-HSV转RGB"><a href="#6-2-HSV转RGB" class="headerlink" title="6.2 HSV转RGB"></a>6.2 HSV转RGB</h5><script type="math/tex; mode=display">
C=S;\quad H'=H/60;\quad X=C(1-|H'mod2-1|)</script><p>mod是一个求余函数，mod(exp1,exp2), 即是两个数值表达式作除法运算后的余数</p>
<script type="math/tex; mode=display">
(R、G、B)=(V-C)(1,1,1)+\begin{cases}
(0,0,0)\quad \quad (H\quad is\quad undefined) \\
(C,X,0)\quad \quad (0\leq H'<1) \\
(X,C,0)\quad \quad (1\leq H'<2) \\
(0,C,X)\quad \quad (2\leq H'<3) \\
(0,X,C)\quad \quad (3\leq H'<4) \\
(X,0,C)\quad \quad (4\leq H'<5) \\
(C,0,X)\quad \quad (5\leq H'<6) 
\end{cases}</script><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core.hpp&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// BGR -&gt; HSV</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">BGR2HSV</span><span class="params">(cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">float</span> r, g, b;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">float</span> h, s, v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">float</span> _max, _min;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat hsv = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_32FC3);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// each y, x</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// BGR -&gt; HSV</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      r = (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">2</span>] / <span class="number">255</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      g = (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">1</span>] / <span class="number">255</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      b = (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">0</span>] / <span class="number">255</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      _max = fmax(r, fmax(g, b));</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _min = fmin(r, fmin(g, b));</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// get Hue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span>(_max == _min)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	      h = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_min == b) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	      h = <span class="number">60</span> * (g - r) / (_max - _min) + <span class="number">60</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_min == r) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	      h = <span class="number">60</span> * (b - g) / (_max - _min) + <span class="number">180</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_min == g) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	      h = <span class="number">60</span> * (r - b) / (_max - _min) + <span class="number">300</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// get Saturation</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      s = _max - _min;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// get Value</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = _max;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      hsv.at&lt;cv::Vec3f&gt;(y, x)[<span class="number">0</span>] = h;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      hsv.at&lt;cv::Vec3f&gt;(y, x)[<span class="number">1</span>] = s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      hsv.at&lt;cv::Vec3f&gt;(y, x)[<span class="number">2</span>] = v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> hsv;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// HSV -&gt; BGR</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">HSV2BGR</span><span class="params">(cv::Mat hsv)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = hsv.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = hsv.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">float</span> h, s, v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> c, _h, _x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> r, g, b;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC3);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// each y, x</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      h = hsv.at&lt;cv::Vec3f&gt;(y, x)[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      s = hsv.at&lt;cv::Vec3f&gt;(y, x)[<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = hsv.at&lt;cv::Vec3f&gt;(y, x)[<span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      c = s;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _h = h / <span class="number">60</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _x = c * (<span class="number">1</span> - <span class="built_in">abs</span>(<span class="built_in">fmod</span>(_h, <span class="number">2</span>) - <span class="number">1</span>));</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      r = g = b = v - c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      </span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (_h &lt; <span class="number">1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        r += c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        g += _x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_h &lt; <span class="number">2</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        r += _x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        g += c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_h &lt; <span class="number">3</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	  g += c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	  b += _x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_h &lt; <span class="number">4</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	  g += _x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	  b += c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_h &lt; <span class="number">5</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	  r += _x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	  b += c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (_h &lt; <span class="number">6</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	  r += c;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	  b += _x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">0</span>] = (uchar)(b * <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">1</span>] = (uchar)(g * <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">2</span>] = (uchar)(r * <span class="number">255</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// inverse Hue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">inverse_hue</span><span class="params">(cv::Mat hsv)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = hsv.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = hsv.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">//hue值为[0,360], inverse Hue就是找圆上对称的那个点，181对称的就是1。类似于二值图像的反像-&gt;色相反转</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      hsv.at&lt;cv::Vec3f&gt;(y, x)[<span class="number">0</span>] = <span class="built_in">fmod</span>(hsv.at&lt;cv::Vec3f&gt;(y, x)[<span class="number">0</span>] + <span class="number">180</span>, <span class="number">360</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> hsv;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// read image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat img = cv::imread(<span class="string">"imori.jpg"</span>, cv::IMREAD_COLOR);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// BGR -&gt; HSV</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat hsv = BGR2HSV(img);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// Inverse Hue</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  hsv = inverse_hue(hsv);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// Gray -&gt; Binary</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = HSV2BGR(hsv);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//cv::imwrite("out.jpg", out);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::imshow(<span class="string">"sample"</span>, out);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::waitKey(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::destroyAllWindows();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr></table></figure>
<h4 id="二、减色处理"><a href="#二、减色处理" class="headerlink" title="二、减色处理"></a>二、减色处理</h4><h5 id="1、为什么需要艰涩处理？"><a href="#1、为什么需要艰涩处理？" class="headerlink" title="1、为什么需要艰涩处理？"></a>1、为什么需要艰涩处理？</h5><p>RGB的像素值在0~255之间，当想要用更少的内存空间表征一张图像时，可以采用减色处理。</p>
<h5 id="2、减色处理的说明"><a href="#2、减色处理的说明" class="headerlink" title="2、减色处理的说明"></a>2、减色处理的说明</h5><p>RGB的像素值在0~255之间，将图像用 32、96、160、224 这4个像素值表示。即将图像由256³压缩至4³，RGB的值只取{32,96,160,224}，这被称作色彩量化。</p>
<script type="math/tex; mode=display">
val=\begin{cases}
32\quad \quad \quad (0\leq var<64) \\
96\quad \quad \quad (64\leq var<128) \\
160\quad \quad (128\leq var<192) \\
224\quad \quad (192\leq var<256) 
\end{cases}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Dicrease color</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dicrease_color</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = img.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = out // <span class="number">64</span> * <span class="number">64</span> + <span class="number">32</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Dedcrease color</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">decrease_color</span><span class="params">(cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC3);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        out.at&lt;cv::Vec3b&gt;(y, x)[c] = (uchar)(<span class="built_in">floor</span>((<span class="keyword">double</span>)img.at&lt;cv::Vec3b&gt;(y, x)[c] / <span class="number">64</span>) * <span class="number">64</span> + <span class="number">32</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="三、平均池化"><a href="#三、平均池化" class="headerlink" title="三、平均池化"></a>三、平均池化</h4><p>将图片使用均等大小网格分割，并求网格内代表值的操作称为<strong>池化（Pooling）</strong>。</p>
<p>将图片分割成固定大小网格，池化后图像的像素值取每个网格内所有像素的平均值的操作成为<strong>平均池化</strong>。</p>
<p>池化操作是<strong>卷积神经网络（Convolution Neural Network）</strong>中重要的图像处理方式。平均池化按照下式定义：</p>
<script type="math/tex; mode=display">
v=\frac{1}{|R|}\cdot\sum^{R}_{i = 1}{v_i}</script><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># average pooling</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">average_pooling</span><span class="params">(img, G=<span class="number">8</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = img.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Nh = int(H / G)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Nw = int(W / G)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">#out = np.zeros([Nh, Nw, 3], np.uint8)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(Nh):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(Nw):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(C):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">#这里out的意思是8*8的区域都用该区域的平均值赋值，输出和输入的尺寸是一样的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">#正常的池化后的输出为输入的1/G,步长应该为G,但输出的效果不容易看</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                <span class="comment">#下面np.int在新版的numpy中已经被废弃，需要用int32或其他精度</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">                out[G*y:G*(y+<span class="number">1</span>),G*x:G*(x+<span class="number">1</span>),c]=np.mean(out[G*y:G*(y+<span class="number">1</span>), G*x:G*(x+<span class="number">1</span>), c]).astype(np.int)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    			<span class="comment">#out[y, x, c] = np.mean(input[G*y:G*(y+1), G*x:G*(x+1), c]).astype(np.uint8)</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// average pooling</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">average_pooling</span><span class="params">(cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC3);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> r = <span class="number">8</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y+=r)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x+=r)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dy = <span class="number">0</span>; dy &lt; r; dy++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> dx = <span class="number">0</span>; dx &lt; r; dx++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v += (<span class="keyword">double</span>)img.at&lt;cv::Vec3b&gt;(y + dy, x + dx)[c];</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        v /= (r * r);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dy = <span class="number">0</span>; dy &lt; r; dy++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> dx = <span class="number">0</span>; dx &lt; r; dx++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            out.at&lt;cv::Vec3b&gt;(y + dy, x + dx)[c] = (uchar)v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="四、最大池化"><a href="#四、最大池化" class="headerlink" title="四、最大池化"></a>四、最大池化</h4><p>网格内的值不取平均值，而是取网格内的最大值进行池化操作。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># max pooling</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">max_pooling</span><span class="params">(img, G=<span class="number">8</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># Max Pooling</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = img.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Nh = int(H / G)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Nw = int(W / G)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(Nh):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(Nw):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(C):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                out[G*y:G*(y+<span class="number">1</span>), G*x:G*(x+<span class="number">1</span>), c] = np.max(out[G*y:G*(y+<span class="number">1</span>), G*x:G*(x+<span class="number">1</span>), c])</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// max pooling</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">max_pooling</span><span class="params">(cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC3);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> r = <span class="number">8</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y+=r)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x+=r)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dy = <span class="number">0</span>; dy &lt; r; dy++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> dx = <span class="number">0</span>; dx &lt; r; dx++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v = fmax(img.at&lt;cv::Vec3b&gt;(y + dy, x + dx)[c], v);</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dy = <span class="number">0</span>; dy &lt; r; dy++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">for</span> (<span class="keyword">int</span> dx = <span class="number">0</span>; dx &lt; r; dx++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            out.at&lt;cv::Vec3b&gt;(y + dy, x + dx)[c] = (uchar)v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="五、高斯滤波"><a href="#五、高斯滤波" class="headerlink" title="五、高斯滤波"></a>五、高斯滤波</h4><p>高斯滤波器是一种可以使图像<strong>平滑</strong>的滤波器，用于去除<strong>噪声</strong>。可用于去除噪声的滤波器还有中值滤波器，平滑滤波器、LoG滤波器。</p>
<p>高斯滤波器一般使用(3x3)的卷积核。高斯滤波器将中心像素周围的像素按照高斯分布加权平均进行平滑化。这样的(二维)权值通常被称为<strong>卷积核（kernel）</strong>或者<strong>滤波器（fifilter）</strong></p>
<p>由于为了保持输入和输出图像的尺寸保持一致。因此，我们需要在图像的四边缘补 0。这种方法称作<strong>Zero Padding</strong>。并且权值 g(卷积核)要进行归一化操作。</p>
<script type="math/tex; mode=display">
\sum_{}{g}=1</script><p>高斯分布公式计算权值：</p>
<script type="math/tex; mode=display">
g(x,y,\sigma)=\frac{1}{2\cdot\pi\cdot\sigma^2}\cdot e^{-\frac{x^2+y^2}{2\sigma^2}}</script><p>标准差&sigma;=1.3的8-近邻高斯滤波器如下：</p>
<script type="math/tex; mode=display">
K=\frac{1}{16}
\begin{bmatrix}1 & 2 & 1 \\ 
2 & 4 & 2\\
1 & 2 & 1
\end{bmatrix}</script> <figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Gaussian filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">gaussian_filter</span><span class="params">(img, K_size=<span class="number">3</span>, sigma=<span class="number">1.3</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">if</span> len(img.shape) == <span class="number">3</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">		H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">else</span>:</span></pre></td></tr><tr><td class="code"><pre><span class="line">		img = np.expand_dims(img, axis=<span class="number">-1</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">		H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">## Zero padding</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	pad = K_size // <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#左右，上下个扩充pad个像素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.zeros((H + pad * <span class="number">2</span>, W + pad * <span class="number">2</span>, C), dtype=np.float64)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#将原始图像嵌套到扩充边的里面</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out[pad: pad + H, pad: pad + W] = img.copy().astype(np.float64)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment">## prepare Kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	K = np.zeros((K_size, K_size), dtype=np.float64)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> x <span class="keyword">in</span> range(-pad, -pad + K_size):</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> y <span class="keyword">in</span> range(-pad, -pad + K_size):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			K[y + pad, x + pad] = np.exp( -(x ** <span class="number">2</span> + y ** <span class="number">2</span>) / (<span class="number">2</span> * (sigma ** <span class="number">2</span>)))</span></pre></td></tr><tr><td class="code"><pre><span class="line">	K /= (<span class="number">2</span> * np.pi * sigma * sigma)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	K /= K.sum()</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">	tmp = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="comment"># filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="code"><pre><span class="line">		<span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="code"><pre><span class="line">			<span class="keyword">for</span> c <span class="keyword">in</span> range(C):</span></pre></td></tr><tr><td class="code"><pre><span class="line">				out[pad + y, pad + x, c] = np.sum(K * tmp[y: y + K_size, x: x + K_size, c])</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = np.clip(out, <span class="number">0</span>, <span class="number">255</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">#去掉padding的部分，保持图像的原始尺寸不变</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	out = out[pad: pad + H, pad: pad + W].astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// gaussian filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">gaussian_filter</span><span class="params">(cv::Mat img, <span class="keyword">double</span> sigma, <span class="keyword">int</span> kernel_size)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC3);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> pad = <span class="built_in">floor</span>(kernel_size / <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> _x = <span class="number">0</span>, _y = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> kernel_sum = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get gaussian kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">float</span> kernel[kernel_size][kernel_size];</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; kernel_size; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; kernel_size; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _y = y - pad;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      _x = x - pad; </span></pre></td></tr><tr><td class="code"><pre><span class="line">      kernel[y][x] = <span class="number">1</span> / (<span class="number">2</span> * M_PI * sigma * sigma) * <span class="built_in">exp</span>( - (_x * _x + _y * _y) / (<span class="number">2</span> * sigma * sigma));</span></pre></td></tr><tr><td class="code"><pre><span class="line">      kernel_sum += kernel[y][x];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; kernel_size; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; kernel_size; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      kernel[y][x] /= kernel_sum;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> dy = -pad; dy &lt; pad + <span class="number">1</span>; dy++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dx = -pad; dx &lt; pad + <span class="number">1</span>; dx++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">if</span> (((x + dx) &gt;= <span class="number">0</span>) &amp;&amp; ((y + dy) &gt;= <span class="number">0</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            v += (<span class="keyword">double</span>)img.at&lt;cv::Vec3b&gt;(y + dy, x + dx)[c] * kernel[dy + pad][dx + pad];</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;cv::Vec3b&gt;(y, x)[c] = v;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="/2021/06/12/Image-Process-Zero-Plus/8.jpg" width="300"></div><div class="group-picture-column" style="width: 50%;"><img src="/2021/06/12/Image-Process-Zero-Plus/9.jpg" width="300"></div></div></div></div>
<h4 id="六、中值滤波"><a href="#六、中值滤波" class="headerlink" title="六、中值滤波"></a>六、中值滤波</h4><p>中值滤波器是一种可以使图像平滑的滤波器。中值滤波本质上是一种统计排序滤波器。对于原图像中某点（i，j），中值滤波以该点为中心的邻域内的所有像素的统计排序中值作为（i，j）点的响应。</p>
<p>当像素点太大或者太小时都不同意被选中，所以中值滤波对像素值比较大或者比较小的噪声滤除的效果比较好，如：椒盐噪声，对比较均匀的噪声滤除的效果一般，如：高斯噪声。同线性平滑滤波器相比，中值滤波在降噪同时引起的模糊效应较低。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="comment"># Median filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">median_filter</span><span class="params">(img, K_size=<span class="number">3</span>)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    H, W, C = img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">## Zero padding</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    pad = K_size // <span class="number">2</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = np.zeros((H + pad*<span class="number">2</span>, W + pad*<span class="number">2</span>, C), dtype=np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    out[pad:pad+H, pad:pad+W] = img.copy().astype(np.float)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    tmp = out.copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment"># filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> y <span class="keyword">in</span> range(H):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> x <span class="keyword">in</span> range(W):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">for</span> c <span class="keyword">in</span> range(C):</span></pre></td></tr><tr><td class="code"><pre><span class="line">                out[pad+y, pad+x, c] = np.median(tmp[y:y+K_size, x:x+K_size, c])</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    out = out[pad:pad+H, pad:pad+W].astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> out</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// median filter</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">median_filter</span><span class="params">(cv::Mat img, <span class="keyword">int</span> kernel_size)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> channel = img.channels();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC3);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare kernel</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> pad = <span class="built_in">floor</span>(kernel_size / <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// filtering</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> vs[kernel_size * kernel_size];</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> count = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c &lt; channel; c++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      v = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      count = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      </span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; kernel_size * kernel_size; i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        vs[i] = <span class="number">999</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      </span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// get neighbor pixels</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> dy = -pad; dy &lt; pad + <span class="number">1</span>; dy++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> dx = -pad; dx &lt; pad + <span class="number">1</span>; dx++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          <span class="keyword">if</span> (((y + dy) &gt;= <span class="number">0</span>) &amp;&amp; ((x + dx) &gt;= <span class="number">0</span>))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            vs[count++] = (<span class="keyword">int</span>)img.at&lt;cv::Vec3b&gt;(y + dy, x + dx)[c];</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// get and assign median</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="built_in">std</span>::sort(vs, vs + (kernel_size * kernel_size));</span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;cv::Vec3b&gt;(y, x)[c] = (uchar)vs[<span class="keyword">int</span>(<span class="built_in">floor</span>(count / <span class="number">2</span>)) + <span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<div class="group-picture"><div class="group-picture-container"><div class="group-picture-row"><div class="group-picture-column" style="width: 50%;"><img src="/2021/06/12/Image-Process-Zero-Plus/8.jpg" width="300"></div><div class="group-picture-column" style="width: 50%;"><img src="/2021/06/12/Image-Process-Zero-Plus/10.jpg" width="300"></div></div></div></div>
<p><a href="https://zhuanlan.zhihu.com/p/67930839" target="_blank" rel="noopener">参考:1</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/116426192" target="_blank" rel="noopener">参考:2</a></p>
]]></content>
      <categories>
        <category>Image Processing</category>
      </categories>
      <tags>
        <tag>Image Processing</tag>
      </tags>
  </entry>
  <entry>
    <title>Image-Process-Zero</title>
    <url>/2021/06/11/Image-Process-Zero/</url>
    <content><![CDATA[<h2 id="图像处理学习"><a href="#图像处理学习" class="headerlink" title="图像处理学习"></a>图像处理学习</h2><h4 id="参考的网上链接：Image-Processing"><a href="#参考的网上链接：Image-Processing" class="headerlink" title="参考的网上链接：Image Processing"></a>参考的网上链接：<a href="https://github.com/gzr2017/ImageProcessing100Wen/tree/master" target="_blank" rel="noopener">Image Processing</a></h4><h4 id="第一部分"><a href="#第一部分" class="headerlink" title="第一部分"></a>第一部分</h4><h4 id="一、图像通道的处理"><a href="#一、图像通道的处理" class="headerlink" title="一、图像通道的处理"></a>一、图像通道的处理</h4><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="comment">#cv2.imread()读取的是图像是按照BGR的顺序排列的</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#所以BGR转RGB，需要读取每个通道，在按照R、G、B的顺序赋值进去</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;<span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;img = cv2.imread(<span class="string">"imori.jpg"</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;red = img[:,:,<span class="number">2</span>].copy() <span class="comment">#列表拷贝赋值函数，进行备份复制列表</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">#通过print(id(red))和print(id(img[:,:,2]))可以看到id是不一样的，说明存储位置发生了变化，起到了保护原始数据的作用</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;print(img)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[[[ <span class="number">65</span> <span class="number">134</span> <span class="number">107</span>]   <span class="comment">#[ 65 134 107]这是一个像素的BGR值</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  [ <span class="number">65</span> <span class="number">134</span> <span class="number">107</span>]   <span class="comment">#第二个像紿</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  [ <span class="number">65</span> <span class="number">134</span> <span class="number">107</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ..., </span></pre></td></tr><tr><td class="code"><pre><span class="line">  [ <span class="number">33</span>  <span class="number">90</span>  <span class="number">69</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  [ <span class="number">33</span>  <span class="number">90</span>  <span class="number">69</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  [ <span class="number">31</span>  <span class="number">90</span>  <span class="number">69</span>]]   <span class="comment">#图像中第一行的最后一个像素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"> [[ <span class="number">64</span> <span class="number">133</span> <span class="number">106</span>]    <span class="comment">#图像中第二行的第一个像素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  [ <span class="number">64</span> <span class="number">133</span> <span class="number">106</span>]    <span class="comment">#以此类推</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  [ <span class="number">64</span> <span class="number">133</span> <span class="number">106</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...,             <span class="comment">#这里的...,并不表示说什么，不是分层的意思</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  [ <span class="number">17</span>  <span class="number">55</span>  <span class="number">59</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  [ <span class="number">19</span>  <span class="number">57</span>  <span class="number">61</span>]</span></pre></td></tr><tr><td class="code"><pre><span class="line">  [ <span class="number">20</span>  <span class="number">58</span>  <span class="number">62</span>]]]</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Save result</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.imwrite(<span class="string">"out.jpg"</span>, img)</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.imshow(<span class="string">"result"</span>, img)</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.waitKey(<span class="number">0</span>)</span></pre></td></tr><tr><td class="code"><pre><span class="line">cv2.destroyAllWindows()</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core.hpp&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Channel swap</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">channel_swap</span><span class="params">(cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output, 注意height和width的顺序</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC3); </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// each y, x</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// R -&gt; B</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">0</span>] = img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">2</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// B -&gt; R</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">2</span>] = img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// G -&gt; G</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">1</span>] = img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">1</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  </span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//&lt;Vec3f&gt; 浮点</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//&lt;Vec3d&gt; double</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//&lt;Vec3b&gt; 8U类型的RGB彩色图像(0-255),可以看作是vector&lt;uchar,3&gt;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//由于在OpenCV中，使用imread读取到的Mat图像数据，都是用uchar类型的数据存储，对于RGB三通道的图像，每个点的数据都是一个Vec3b类型的数据。可以使用at定位到每一个像素</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//单通道：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//img.at&lt;uchar&gt;(x,y) = 25;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//多通道：</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//img.at&lt;cv::Vec3b&gt;(x,y)[0] = 25; //B</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//img.at&lt;cv::Vec3b&gt;(x,y)[1] = 25; //G</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">//img.at&lt;cv::Vec3b&gt;(x,y)[2] = 25; //R</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// read image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat img = cv::imread(<span class="string">"imori.jpg"</span>, cv::IMREAD_COLOR);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// channel swap</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = channel_swap(img);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::imwrite(<span class="string">"out.jpg"</span>, out);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::imshow(<span class="string">"sample"</span>, out);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::waitKey(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::destroyAllWindows();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h5 id="二、图像的灰度化"><a href="#二、图像的灰度化" class="headerlink" title="二、图像的灰度化"></a>二、图像的灰度化</h5><p>灰度是一种图像亮度的表示方法，是单通道的图像，通过下式计算：</p>
<script type="math/tex; mode=display">
Y = 0.2126\cdot R+0.7152\cdot G + 0.0722\cdot B</script><figure class="highlight py"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> cv2</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">BGR2GRAY</span><span class="params">(img)</span>:</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">	r = img[:,:,<span class="number">2</span>].copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	g = img[:,:,<span class="number">0</span>].copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	b = img[:,:,<span class="number">1</span>].copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	gray = <span class="number">0.2126</span> * r + <span class="number">0.7152</span> * g + <span class="number">0.0722</span> * b</span></pre></td></tr><tr><td class="code"><pre><span class="line">	<span class="keyword">return</span> gray.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Read image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">img = cv2.imread(<span class="string">"imori.jpg"</span>).astype(np.float) </span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># astype 转换数组的数据类型，dtype 用于说明一个数组数据类型的对象</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment"># Grayscale</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">out = BGR2GRAY(img)</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core.hpp&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">BRG2GRAY</span><span class="params">(cv::Mat img)</span> </span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    cv::Mat output = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="comment">// each y, x</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">// BGR -&gt; Gray</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        output.at&lt;uchar&gt;(y, x) = <span class="number">0.2126</span> * (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">2</span>] \</span></pre></td></tr><tr><td class="code"><pre><span class="line">          + <span class="number">0.7152</span> * (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">1</span>] \</span></pre></td></tr><tr><td class="code"><pre><span class="line">          + <span class="number">0.0722</span> * (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// read image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat img = cv::imread(<span class="string">"imori.jpg"</span>, cv::IMREAD_COLOR);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//IMREAD_UNCHANGED-&gt;指定用图片的原来格式打开，即以不改变图片的方式打开，图片是彩色就是彩色，图片是灰度图像就是灰度图像</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//IMREAD_GRAYSCALE-&gt;指定用灰度图像的方式打开图片，即将原始图像转化为灰度图像再打开</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//IMREAD_COLOR-&gt;指定用彩色图像打开图片</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// BGR -&gt; Gray</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = BGR2GRAY(img);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//cv::imwrite("out.jpg", out);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::imshow(<span class="string">"sample"</span>, out);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::waitKey(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::destroyAllWindows();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h5 id="三、图像的二值化"><a href="#三、图像的二值化" class="headerlink" title="三、图像的二值化"></a>三、图像的二值化</h5><p>二值化：将图像使用黑和白两种颜色表示的方法。</p>
<script type="math/tex; mode=display">
y=\begin{cases}
0,\quad (if \quad y <128) \\
255, \quad else
\end{cases}</script><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def binarization(img, th&#x3D;128):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    img[img &lt; th] &#x3D; 0</span></pre></td></tr><tr><td class="code"><pre><span class="line">    img[img &gt;&#x3D; th] &#x3D; 255</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return img</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Gray -&gt; Binary</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">Binarize</span><span class="params">(cv::Mat gray, <span class="keyword">int</span> th)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = gray.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = gray.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// each y, x</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// Binarize</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (gray.at&lt;uchar&gt;(y, x) &gt; th)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        out.at&lt;uchar&gt;(y, x) = <span class="number">255</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        out.at&lt;uchar&gt;(y, x) = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h5 id="四、大津二值化算法-Otsu"><a href="#四、大津二值化算法-Otsu" class="headerlink" title="四、大津二值化算法(Otsu)"></a>四、大津二值化算法(Otsu)</h5><p>最大类间方差法，是一种可以自动确定二值化中阈值的算法。</p>
<p>令{0,1,2,…,L-1}表示一副大小为<em>M x N</em>像素的数字图像中的L<em>个不同的灰度级，n<sub>i</sub> 表示灰度级为</em>i*的像素数。</p>
<p>图像中的像素总数为：</p>
<script type="math/tex; mode=display">
N=n_0+n_1+...+n_{L-1}</script><p>像素的灰度级为i* 的概率为：</p>
<script type="math/tex; mode=display">
p_i = n_i / N, \quad p_i\geq 0, \quad \displaystyle \sum^{L}_{i = 1}{p_i = 1}.\quad \quad (1)</script><p>现在假设通过一个灰度级为k的阈值将这些像素点划分为两类C<sub>0</sub>(目标)和C<sub>1</sub>(背景)，C<sub>0</sub>表示灰度级为[1,…,k]的像素点，C<sub>1</sub>表示灰度级为[k+1,…,L]的像素点。</p>
<p>像素被分类到C<sub>0</sub>和C<sub>1</sub>中的概率为：</p>
<script type="math/tex; mode=display">
w_0=P_r(C_0)=\sum^{k}_{i=1}{p_i}=w(k) \quad \quad (2)</script><script type="math/tex; mode=display">
w_1=P_r(C_1)=\sum^{L}_{i=k+1}{p_i}=1-w(k) \quad \quad (3)</script><p>各类的平均灰度级为：</p>
<script type="math/tex; mode=display">
\mu_0 = \sum^{k}_{i=1}{iP_r(i|C_0)} = \sum^{k}_{i=1}{\frac{iPr(C_0|i)p(i)}{P_r(C_0)}}= \sum^{k}_{i=1}{ip_i/w_0}=\mu(k)/w(k), \quad P_r(C_0|i)=1 \quad (i=i...k)\quad \quad (4)</script><script type="math/tex; mode=display">
\mu_1 = \sum^{L}_{i=k+1}{iP_r(i|C_1)} = \sum^{L}_{i=k+1}{\frac{iPr(C_1|i)p(i)}{P_r(C_1)}}= \sum^{L}_{i=k+1}{ip_i/w_1}=\frac{\mu_T-\mu(k)}{1-w(k)} \quad \quad (5)</script><p>其中：</p>
<script type="math/tex; mode=display">
w(k)=\sum^{k}_{i=1}{p_i}\quad \quad (6) ,\quad \mu(k)=\sum^{k}_{i=1}{ip_i}\quad \quad (7)</script><p>上面分别为灰度级1到k的累积出现的概率和平均灰度级(一阶累计距)。</p>
<script type="math/tex; mode=display">
\mu_T=\mu(L)=\sum^{L}_{i=1}{ip_i}\quad \quad (8)</script><p>上式是整幅图像的平均灰度级。可以看出，对于任意选定的k, 都有：</p>
<script type="math/tex; mode=display">
w_0\mu_0+w_1\mu_1=\mu_T,\quad w_0+w_1=1.\quad \quad (9)</script><p>这两类的类内方差由下面的公式给出：(二阶累积距)</p>
<script type="math/tex; mode=display">
\sigma_0^2=\sum^{k}_{i=1}{(i-\mu_0)^2P_r(i|C_0)}=\sum^{k}_{i=1}{(i-\mu_0)^2p_i/w_0}.\quad \quad (10)</script><script type="math/tex; mode=display">
\sigma_1^2=\sum^{L}_{i=k+1}{(i-\mu_1)^2P_r(i|C_1)}=\sum^{L}_{i=k+1}{(i-\mu_1)^2p_i/w_1}.\quad \quad (11)</script><p>为了评价灰度级k这个阈值或门限的”好坏”的程度，我们需要引入判别式分析中使用的判别式标准来测量:</p>
<script type="math/tex; mode=display">
\lambda=\sigma_B^2/\sigma_W^2, \quad K=\sigma_T^2/\sigma_W^2, \quad \eta=\sigma_B^2/\sigma_T^2\quad \quad (12)</script><p>其中:</p>
<script type="math/tex; mode=display">
\sigma_W^2=w_0\sigma_0^2+w_1\sigma_1^2\quad \quad (13)</script><script type="math/tex; mode=display">
\sigma_B^2=w_0(\mu_o-\mu_T)^2+w_1(\mu_1-\mu_T)^2=w_0w_1(\mu_1-\mu_0)^2\quad \quad (14)</script><p>根据公式(9)，可以得出：</p>
<script type="math/tex; mode=display">
\sigma_T^2=\sum^{L}_{i=1}{(i-\mu_T)^2p_i} ，是一个常数\quad \quad (15)</script><p>式13是类内方差，式14是类间方差，式15是灰度级的总方差。此时的目标即便为一个优化问题，即寻找一个门限k使12)式中给出的一个目标函数取最大值。</p>
<p>上面给出的判别式标准是分别求取λ、κ和η的最大值。</p>
<script type="math/tex; mode=display">
\sigma_W^2+\sigma_B^2=\sigma_T^2. \quad \sigma_W^2和\sigma_B^2是门限k的函敿</script><script type="math/tex; mode=display">
\eta(k)=\sigma_B^2(k)/\sigma_T^2.\quad \sigma_B^2基于一阶统计(类均值)，比\sigma_W^2基于二阶统计(类方差)简单</script><script type="math/tex; mode=display">
\sigma_B^2(k)=\frac{[\mu_Tw(k)-\mu(k)]^2}{w(k)[1-w(k)]}</script><p>最佳门限k<sup>*</sup> 为：</p>
<script type="math/tex; mode=display">
\sigma_B^2(k^*)=arg\,\max_{1\leq k\leq L} \sigma_B^2(k)</script><p>根据公式6和7，依次选择不同的k值顺序搜索，寻找最佳门限k<sup>*</sup> 使得n取最大值。</p>
<p>证明类间方差：</p>
<script type="math/tex; mode=display">
\sigma^2=w_1(\mu_1-\mu)^2+w_2(\mu_2-\mu), \quad \quad 
\begin{cases}
w_1+w_2=1 \\
w_1\mu_1+w_2\mu_2=\mu
\end{cases}</script><script type="math/tex; mode=display">
\sigma^2=w_1(\mu_1^2-2\mu_1\mu+\mu^2)+w_2(\mu_2^2-2\mu_2\mu+\mu^2)</script><script type="math/tex; mode=display">
\sigma^2=w_1\mu_1^2-2w_1\mu_1\mu+w_1\mu^2+w_2\mu_2^2-2w_2\mu_2\mu+w_2\mu^2</script><script type="math/tex; mode=display">
\sigma^2=w_1\mu_1^2+w_2\mu_2^2-2(w_1\mu_1+w_2\mu_2)\mu+(w_1+w_2)\mu^2</script><script type="math/tex; mode=display">
\sigma^2=w_1\mu_1^2+w_2\mu_2^2-2(w_1\mu_1+w_2\mu_2)\mu+\mu^2=w_1\mu_1^2+w_2\mu_2^2-\mu^2</script><script type="math/tex; mode=display">
\sigma^2=w_1\mu_1^2+w_2\mu_2^2-(w_1\mu_1+w_2\mu_2)^2</script><script type="math/tex; mode=display">
\sigma^2=w_1\mu_1^2+w_2\mu_2^2-(w_1\mu_1)^2-2w_1\mu_1w_2\mu_2-(w_2\mu_2)^2</script><script type="math/tex; mode=display">
\sigma^2=w_1w_2(\frac{1}{w_2}\mu_1^2+\frac{1}{w_1}\mu_2^2-\frac{w_1}{w_2}\mu_1^2-2\mu_1\mu_2-\frac{w_2}{w_1}\mu_2^2)</script><script type="math/tex; mode=display">
\sigma^2=(\mu_1^2-w\mu_1\mu_2+\mu_2^2)=w_1w_2(\mu_1-\mu_2)^2</script><p> 大津算法的步骤：</p>
<ol>
<li><p>先转化为灰度图，计算输入图像的归一化直方图</p>
</li>
<li><p>计算像素被分配到各个类别的概率</p>
</li>
<li><p>计算各类的平均灰度值</p>
</li>
<li><p>计算全局灰度均值</p>
</li>
<li><p>计算类间方差</p>
</li>
<li><p>遍历各个灰度级，得到类间方差最大的k值。如果最大值不唯一，则取平均值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import cv2</span></pre></td></tr><tr><td class="code"><pre><span class="line">import numpy as np</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># Gray scale</span></pre></td></tr><tr><td class="code"><pre><span class="line">def BGR2GRAY(img):</span></pre></td></tr><tr><td class="code"><pre><span class="line">	b &#x3D; img[:,:,0].copy() </span></pre></td></tr><tr><td class="code"><pre><span class="line">	g &#x3D; img[:,:,1].copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	r &#x3D; img[:,:,2].copy()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out &#x3D; 0.2126 * r + 0.7152 * g + 0.0722 * b</span></pre></td></tr><tr><td class="code"><pre><span class="line">	out &#x3D; out.astype(np.uint8)</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	return out</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># Otsu Binarization</span></pre></td></tr><tr><td class="code"><pre><span class="line">def otus_binarization(img, th&#x3D;128):</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 	max_sigma &#x3D; 0 </span></pre></td></tr><tr><td class="code"><pre><span class="line"> 	max_th &#x3D; 0</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 	</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 	for _t in range(1, 255):</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 		pix0 &#x3D; img[np.where(img &lt; _t)]</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 		m0 &#x3D; np.mean(pix0) if len(pixs) &gt; 0 else 0.</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 		w0 &#x3D; len(pix0) &#x2F; (H * W)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 		pix1 &#x3D; img[np.where(img &lt; _t)]</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 		m1 &#x3D; np.mean(pix1) if len(pix1) &gt; 0 else 0.</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 		w1 &#x3D; len(pix1) &#x2F; (H * W)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 		sigma &#x3D; w0 * w1 * ((m0 - m1) ** 2)</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 		if sigma &gt; max_sigma:</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 			max_sigma &#x3D; sigma</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 			max_th &#x3D; _t</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 	th &#x3D; max_th</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 	img[img &lt; th] &#x3D; 0</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 	img[out &gt;&#x3D; th] &#x3D; 255</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 	</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 	return img</span></pre></td></tr><tr><td class="code"><pre><span class="line"> 	</span></pre></td></tr><tr><td class="code"><pre><span class="line"># Read image</span></pre></td></tr><tr><td class="code"><pre><span class="line">img &#x3D; cv2.imread(&quot;imori.jpg&quot;).astype(np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line">H, W, C &#x3D;img.shape</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># Grayscale</span></pre></td></tr><tr><td class="code"><pre><span class="line">out &#x3D; BGR2GRAY(img)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># Otsu&#39;s binarization</span></pre></td></tr><tr><td class="code"><pre><span class="line">out &#x3D; otsu_binarization(out)</span></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/core.hpp&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;opencv2/highgui.hpp&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// BGR -&gt; Gray</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">BGR2GRAY</span><span class="params">(cv::Mat img)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// get height and width</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = img.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = img.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// each y, x</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// BGR -&gt; Gray</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      out.at&lt;uchar&gt;(y, x) = <span class="number">0.2126</span> * (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">2</span>] \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        + <span class="number">0.7152</span> * (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">1</span>] \</span></pre></td></tr><tr><td class="code"><pre><span class="line">        + <span class="number">0.0722</span> * (<span class="keyword">float</span>)img.at&lt;cv::Vec3b&gt;(y, x)[<span class="number">0</span>];</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="comment">// Gray -&gt; Binary</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function">cv::Mat <span class="title">Binarize_Otsu</span><span class="params">(cv::Mat gray)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">width</span> = gray.cols;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> <span class="built_in">height</span> = gray.rows;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// determine threshold</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> w0 = <span class="number">0</span>, w1 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> m0 = <span class="number">0</span>, m1 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">double</span> max_sb = <span class="number">0</span>, sb = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> th = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">int</span> val;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// Get threshold</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; <span class="number">255</span>; t++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    w0 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    w1 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    m0 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    m1 = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      	<span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        	val = (<span class="keyword">int</span>)(gray.at&lt;uchar&gt;(y, x));</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (val &lt; t)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                w0++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                m0 += val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                w1++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                m1 += val;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    m0 /= w0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    m1 /= w1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    w0 /= (<span class="built_in">height</span> * <span class="built_in">width</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    w1 /= (<span class="built_in">height</span> * <span class="built_in">width</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sb = w0 * w1 * <span class="built_in">pow</span>((m0 - m1), <span class="number">2</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">if</span>(sb &gt; max_sb)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      	max_sb = sb;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      	th = t;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"threshold:"</span> &lt;&lt; th &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// prepare output</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = cv::Mat::zeros(<span class="built_in">height</span>, <span class="built_in">width</span>, CV_8UC1);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// each y, x</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> y = <span class="number">0</span>; y &lt; <span class="built_in">height</span>; y++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> x = <span class="number">0</span>; x &lt; <span class="built_in">width</span>; x++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="comment">// Binarize</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">      <span class="keyword">if</span> (gray.at&lt;uchar&gt;(y, x) &gt; th)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        out.at&lt;uchar&gt;(y, x) = <span class="number">255</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125; <span class="keyword">else</span> &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        out.at&lt;uchar&gt;(y, x) = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> out;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// read image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat img = cv::imread(<span class="string">"imori.jpg"</span>, cv::IMREAD_COLOR);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// BGR -&gt; Gray</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat gray = BGR2GRAY(img);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">// Gray -&gt; Binary</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::Mat out = Binarize_Otsu(gray);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="comment">//cv::imwrite("out.jpg", out);</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::imshow(<span class="string">"sample"</span>, out);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::waitKey(<span class="number">0</span>);</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cv::destroyAllWindows();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h5 id="五、HSV变换"><a href="#五、HSV变换" class="headerlink" title="五、HSV变换"></a>五、HSV变换</h5><p>HSV即使用色相(Hue)、饱和度(Saturation)、明度(Value)来表示色彩的一种方式。</p>
<p>色相：将颜色使用0&deg;到60&deg;表示，就是平常所说的颜色名称，如红色、蓝色。色相与数值按下表</p>
<p>对应。</p>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">红</th>
<th style="text-align:center">黄</th>
<th style="text-align:center">绿</th>
<th style="text-align:center">青</th>
<th style="text-align:center">蓝</th>
<th style="text-align:center">品红</th>
<th style="text-align:center">红</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">0°</td>
<td style="text-align:center">60°</td>
<td style="text-align:center">120°</td>
<td style="text-align:center">180°</td>
<td style="text-align:center">240°</td>
<td style="text-align:center">300°</td>
<td style="text-align:center">360°</td>
</tr>
</tbody>
</table>
</div>
<p>   饱和度：是指色彩的纯度，饱和度越低则颜色越暗淡（0 &lt;=S &lt; 1)</p>
<p>   明度：即颜色的明暗程度。数值越高越接近白色，数值越低越接近黑色(0&lt;=V&lt;1)</p>
]]></content>
      <categories>
        <category>Image Processing</category>
      </categories>
      <tags>
        <tag>Image Processing</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-Cloud-MicroService</title>
    <url>/2021/06/11/Spring-Cloud-MicroService/</url>
    <content><![CDATA[<h1 id="微服务"><a href="#微服务" class="headerlink" title="微服务"></a>微服务</h1><h3 id="1、什么是微服务"><a href="#1、什么是微服务" class="headerlink" title="1、什么是微服务"></a>1、什么是微服务</h3><h4 id="集群-cluster-：同一种软件服务的多个服务节点共同为系统提供服务过程"><a href="#集群-cluster-：同一种软件服务的多个服务节点共同为系统提供服务过程" class="headerlink" title="集群(cluster)：同一种软件服务的多个服务节点共同为系统提供服务过程"></a>集群(cluster)：同一种软件服务的多个服务节点共同为系统提供服务过程</h4><h4 id="分布式-distribute-：不同软件集群共同为一个系统提供服务"><a href="#分布式-distribute-：不同软件集群共同为一个系统提供服务" class="headerlink" title="分布式(distribute)：不同软件集群共同为一个系统提供服务"></a>分布式(distribute)：不同软件集群共同为一个系统提供服务</h4><h4 id="微服务：一种新的架构，特点如下："><a href="#微服务：一种新的架构，特点如下：" class="headerlink" title="微服务：一种新的架构，特点如下："></a>微服务：一种新的架构，特点如下：</h4><ol>
<li><p>基于原来单个应用开发出一系列微小服务</p>
</li>
<li><p>每个服务运行在自己计算机进程里面，每个服务都是一个Spring Boot应用</p>
</li>
<li><p>每个服务基于项目的业务进行拆分</p>
</li>
<li><p>拆分出来的每个服务可以独立部署</p>
</li>
<li><p>这些服务都是基于分布式管理</p>
<h4 id="通俗定义：微服务是一种架构，这种架构是将单个的整体应用程序分割成更小的项目关联的独立的服务。一个服务通常实现一组独立的特性或功能，包含自己的业务逻辑和适配器。各个微服务之间的关联通过暴露api来实现。这些独立的微服务不需要部署在同一个虚拟机，同一个系统和同一个应用服务器中。"><a href="#通俗定义：微服务是一种架构，这种架构是将单个的整体应用程序分割成更小的项目关联的独立的服务。一个服务通常实现一组独立的特性或功能，包含自己的业务逻辑和适配器。各个微服务之间的关联通过暴露api来实现。这些独立的微服务不需要部署在同一个虚拟机，同一个系统和同一个应用服务器中。" class="headerlink" title="通俗定义：微服务是一种架构，这种架构是将单个的整体应用程序分割成更小的项目关联的独立的服务。一个服务通常实现一组独立的特性或功能，包含自己的业务逻辑和适配器。各个微服务之间的关联通过暴露api来实现。这些独立的微服务不需要部署在同一个虚拟机，同一个系统和同一个应用服务器中。"></a>通俗定义：微服务是一种架构，这种架构是将单个的整体应用程序分割成更小的项目关联的独立的服务。一个服务通常实现一组独立的特性或功能，包含自己的业务逻辑和适配器。各个微服务之间的关联通过暴露api来实现。这些独立的微服务不需要部署在同一个虚拟机，同一个系统和同一个应用服务器中。</h4></li>
</ol>
<h2 id="2、为什么使用微服务"><a href="#2、为什么使用微服务" class="headerlink" title="2、为什么使用微服务"></a>2、为什么使用微服务</h2><h4 id="单体应用架构"><a href="#单体应用架构" class="headerlink" title="单体应用架构"></a>单体应用架构</h4><p><img src="/2021/06/11/Spring-Cloud-MicroService/1.jpg" alt="Spring-Cloud-MicroService"></p>
<p><img src="/2021/06/11/Spring-Cloud-MicroService/2.jpg" alt="Spring-Cloud-MicroService"></p>
<h5 id="1、优点"><a href="#1、优点" class="headerlink" title="1、优点"></a>1、优点</h5><h5 id="单一架构模式在项目初期很小的时候，开发方便，测试方便，部署方便，运行良好。"><a href="#单一架构模式在项目初期很小的时候，开发方便，测试方便，部署方便，运行良好。" class="headerlink" title="单一架构模式在项目初期很小的时候，开发方便，测试方便，部署方便，运行良好。"></a>单一架构模式在项目初期很小的时候，开发方便，测试方便，部署方便，运行良好。</h5><h5 id="2、缺点"><a href="#2、缺点" class="headerlink" title="2、缺点"></a>2、缺点</h5><ul>
<li>​    应用随时间的推进，加入的功能越来越多，最终会变得巨大，一个项目中很可能数百万行的代码，相互之间繁琐的jar包。</li>
<li>开发效率低，代码维护困难。</li>
<li>整体架构想改变或查用新的技术，新的框架或者语言，是不可能的。</li>
<li>任何模块的漏洞或者错误都会影像这个应用，降低系统的可能性。</li>
</ul>
<h4 id="微服务架构"><a href="#微服务架构" class="headerlink" title="微服务架构"></a>微服务架构</h4><h5 id="1、优点-1"><a href="#1、优点-1" class="headerlink" title="1、优点"></a>1、优点</h5><ul>
<li>将服务拆分成多个单一职责的小的服务，进行单独部署，服务之间通过网络进行通信</li>
<li>每个服务应该有自己单独的管理团队，高度自治</li>
<li>服务各自有自己单独的职责，服务之间松耦合，避免因一个模块的问题导致服务奔溃</li>
</ul>
<h5 id="2、缺点-1"><a href="#2、缺点-1" class="headerlink" title="2、缺点"></a>2、缺点</h5><ul>
<li>开发人员要处理分布式系统的复杂性</li>
<li>多服务运维难度，随着服务的增加，运维的压力也在增大</li>
<li>服务治理和服务监控 <strong>关键</strong></li>
</ul>
<h2 id="3、架构演变过程"><a href="#3、架构演变过程" class="headerlink" title="3、架构演变过程"></a>3、架构演变过程</h2><h4 id="1、单一架构-All-In-One"><a href="#1、单一架构-All-In-One" class="headerlink" title="1、单一架构  All In One"></a>1、单一架构  All In One</h4><p>所有代码都写在一起 JSP+MySQL+Tomcat</p>
<p>ORM: 如何解决对象关系映射</p>
<h4 id="2、垂直架构"><a href="#2、垂直架构" class="headerlink" title="2、垂直架构"></a>2、垂直架构</h4><p>MVC关键： 控制器关键  springmvc springboot</p>
<h4 id="3、分布式服务架构"><a href="#3、分布式服务架构" class="headerlink" title="3、分布式服务架构"></a>3、分布式服务架构</h4><h5 id="tomcat-集群"><a href="#tomcat-集群" class="headerlink" title="tomcat 集群"></a>tomcat 集群</h5><h5 id="mysql-集群"><a href="#mysql-集群" class="headerlink" title="mysql 集群"></a>mysql 集群</h5><h5 id="redis-集群"><a href="#redis-集群" class="headerlink" title="redis 集群"></a>redis 集群</h5><h5 id="RPC：远程过程调用-作用：服务间通信的一种手段"><a href="#RPC：远程过程调用-作用：服务间通信的一种手段" class="headerlink" title="RPC：远程过程调用  作用：服务间通信的一种手段"></a>RPC：远程过程调用  作用：服务间通信的一种手段</h5><p>RPC比http的通信速度要快</p>
<p>OSI七层：物理层(传输效率高)   数据链路层   网络层   传输层(RPC)   会话层   表示层   应用层(http)</p>
<h4 id="4、SOA-面向服务体系架构"><a href="#4、SOA-面向服务体系架构" class="headerlink" title="4、SOA 面向服务体系架构"></a>4、SOA 面向服务体系架构</h4><p><strong>服务治理和服务监控</strong></p>
<h2 id="4、Spring-Cloud"><a href="#4、Spring-Cloud" class="headerlink" title="4、Spring Cloud"></a>4、Spring Cloud</h2><ol>
<li><h4 id="Spring-Cloud-NetFlix"><a href="#Spring-Cloud-NetFlix" class="headerlink" title="Spring Cloud NetFlix"></a>Spring Cloud NetFlix</h4><p>基于美国Netflix公司开源的组件进行封装，提供了微服务一栈式解决方案</p>
</li>
<li><h4 id="Spring-Cloud-alibaba"><a href="#Spring-Cloud-alibaba" class="headerlink" title="Spring Cloud alibaba"></a>Spring Cloud alibaba</h4><p>在Spring cloud netflix基础上封装了阿里巴巴的微服务解决方案</p>
</li>
<li><h4 id="Spring-Cloud-Spring"><a href="#Spring-Cloud-Spring" class="headerlink" title="Spring Cloud Spring"></a>Spring Cloud Spring</h4><p>目前spring官方趋势正在逐渐吸收Netflix组件的精华，并在此基础进行二次封装优化，打造Spring专有的解决方案</p>
</li>
</ol>
<h4 id="一、什么是Spring-Cloud"><a href="#一、什么是Spring-Cloud" class="headerlink" title="一、什么是Spring Cloud"></a>一、什么是Spring Cloud</h4><p>Spring Cloud是一个涵盖多个子项目的开发工具集，集合了众多的开源框架，它利用了Spring Boot开发的便利性实现了很多功能，如服务注册、服务注册发现、负载均衡等。</p>
<p><strong>通俗定义</strong>：spring cloud含有众多子项目的工具集，能够快速的帮助我们构建微服务，它是微服务工具集合，帮助我们解决微服务中遇到的各种问题。</p>
<h4 id="二、Spring-Cloud命名和Spring-Boot版本的关系"><a href="#二、Spring-Cloud命名和Spring-Boot版本的关系" class="headerlink" title="二、Spring Cloud命名和Spring Boot版本的关系"></a>二、Spring Cloud命名和Spring Boot版本的关系</h4><p>spring cloud是一个由众多独立子项目组成的大型综合项目，原则每个子项目上有不同的发布节奏，都维护自己发布版本号，为了更好的管理spring cloud的版本，为避免与子项目的发布号混淆，所以没有采用版本号的方式，而是采用伦敦地铁站名称的命名方式，从A-Z。<strong>但目前更新到Hoxton版本之后，开始采用版本号命名的方式</strong>。如：2020.0.2</p>
<p>spring cloud和spring boot版本的对应关系查看官方给出的说明</p>
<p><strong>spring cloud parent 管理维护依赖</strong>，不写任何代码，在maven中没有依赖</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!--自定义properties属性--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;properties&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;spring.cloud-version&gt;Hoxton.SR6&lt;/spring.cloud-version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;/properties&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;!--维护版本--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;dependencies&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    	&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    		&lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    		&lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;	</span></pre></td></tr><tr><td class="code"><pre><span class="line">    		&lt;version&gt;$&#123;spring.cloud-version&#125;&lt;/version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    		&lt;type&gt;pom&lt;/type&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;scope&gt;import&lt;/scope&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    	&lt;/dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;/dependencies&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;/dependencyManagement&gt;</span></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Cloud Compute</category>
      </categories>
      <tags>
        <tag>Cloud Compute</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-Security</title>
    <url>/2021/06/11/Spring-Security/</url>
    <content><![CDATA[<h2 id="Spring-Security-认证、授权"><a href="#Spring-Security-认证、授权" class="headerlink" title="Spring-Security 认证、授权"></a>Spring-Security 认证、授权</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Spring Security是一款基于Spring的安全框架，主要包含认证和授权两大安全模块，和另外一款流行的安全框架Apache Shiro相比，它拥有更为强大的功能。Spring Security也可以轻松的自定义扩展以满足各种需求，并且对常见的Web安全攻击提供了防护支持。如果你的Web框架选择的是Spring，那么在安全方面Spring Security会是一个不错的选择。<br>经典的后台框架SSM：采用SpringMVC实现web层，Spring控制业务层事务，mybatis操作数据库<br>权限管理：一般指根据系统设置的安全规则或者安全策略，用户可以访问而且只能访问自己被授权的资源。如：小明被授权订单管理操作，那么他只能操作订单管理页面，小王被授权系统管理，那么他只能操作系统管理页面。<br>权限管理几乎出现在任何系统里面，前提是需要有用户和密码认证的系统。<br><strong>认证：</strong>通过用户名和密码成功登录系统后，让系统得到当前用户的角色身份<br><strong>授权：</strong>系统根据当前用户的角色，给其授予对应可以操作的权限资源</p>
<h3 id="完成权限管理需要的三个对象"><a href="#完成权限管理需要的三个对象" class="headerlink" title="完成权限管理需要的三个对象"></a>完成权限管理需要的三个对象</h3><p><strong>用户：</strong>主要包括用户名、密码和当前用户的角色信息，可以实现认证操作<br><strong>角色：</strong>主要包含角色名称、角色描述和当前角色拥有的权限信息，可实现授权操作<br><strong>权限：</strong>权限可以称为菜单，主要包含当前权限名称，url地址等信息，可以实现动态展示菜单</p>
<h3 id="操作步骤"><a href="#操作步骤" class="headerlink" title="操作步骤"></a>操作步骤</h3><p>1、导入依赖的jar包<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;groupId&gt;org.springframework.security&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;artifactId&gt;spring-security-config&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;version&gt;5.1.5.RELEASE&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependency&gt;</span></pre></td></tr></table></figure><br>2、配置web.xml中编写spring-security的核心过滤器链<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;springSecurityFilterChain名字不能变</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;filter&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;filter-name&gt;springSecurityFilterChain&lt;&#x2F;filter-name&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;filter-class&gt;org.springframework.web.filter.DelegatingFilterProxy&lt;&#x2F;filter-class&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;filter&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;filter-mapping&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;filter-name&gt;springSecurityFilterChain&lt;&#x2F;filter-name&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;url-pattern&gt;&#x2F;*&lt;&#x2F;url-pattern&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;filter-mapping&gt;</span></pre></td></tr></table></figure><br>3、导入约束 spring-security.xml中添加约束<br>xml中添加<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xmlns:security&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schem&#x2F;security&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">xsi:schemaLocation&#x3D;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	http:&#x2F;&#x2F;www&#x2F;springframework.org&#x2F;schem&#x2F;security</span></pre></td></tr><tr><td class="code"><pre><span class="line">	http:&#x2F;&#x2F;www&#x2F;springframework.org&#x2F;schem&#x2F;security&#x2F;spring-security.xsd&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;!--配置springSecurity--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;!--</span></pre></td></tr><tr><td class="code"><pre><span class="line">	auto-config&#x3D;&quot;true&quot; 表示自动加载springsecurity的配置文件</span></pre></td></tr><tr><td class="code"><pre><span class="line">	use-expressions&#x3D;&quot;true&quot; 表示使用spring的el表达式来配置springsecurity</span></pre></td></tr><tr><td class="code"><pre><span class="line">	--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;security:http auto-config&#x3D;&quot;true&quot; use-expressions&#x3D;&quot;true&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;!--拦截资源&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;!--</span></pre></td></tr><tr><td class="code"><pre><span class="line">		pattern&#x3D;&quot;&#x2F;**&quot; 表示拦截所有资源</span></pre></td></tr><tr><td class="code"><pre><span class="line">		access&#x3D;&quot;hasAnyRole(&#39;ROLE_USER&#39;)&quot; 表示只有ROLE_USER角色才能访问资源</span></pre></td></tr><tr><td class="code"><pre><span class="line">		--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;security:intercept-url pattern&#x3D;&quot;&#x2F;**&quot; access&#x3D;&quot;hasAnyRole(&#39;ROLE_USER&#39;)&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;&#x2F;security:http&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;!--spring 模拟虚拟用户</span></pre></td></tr><tr><td class="code"><pre><span class="line">		设置Spring Security认证用户信息的来源</span></pre></td></tr><tr><td class="code"><pre><span class="line">		spring security默认的认证必须是加密的，加上&#123;noop&#125;表示不加密认证</span></pre></td></tr><tr><td class="code"><pre><span class="line">	--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;security:authentication-manager&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;secutiry:authentication-provider&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;security:user-service&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&lt;security:user name&#x3D;&quot;user&quot; password&#x3D;&quot;(noop)user&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">								authenticaties&#x3D;&quot;ROLE_USER&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&lt;security:user name&#x3D;&quot;admin&quot; password&#x3D;&quot;(noop)admin&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">								authenticaties&#x3D;&quot;ROLE_ADMIN&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;&#x2F;security:user-service&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;&#x2F;security:authentication-provider&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;&#x2F;security:authentication-manager&gt;</span></pre></td></tr></table></figure><br><strong>启动一个web工程，只会去加载web.xml中的信息</strong>，如何将spring-security.xml被web.xml加载<br>spring web加载后，整个工程有两个IOC容器，一个父容器Spring容器，一个子容器mvc容器。web容器中子容器可以访问父容器中的配置文件/资源，父容器不可以访问子容器中的配置文件，但外部只能通过子容器进行加载<br>spring-security容器中的内容不希望暴露出去，所以加载到父容器中通过applicationContext.xml一起加载<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;在applicationContext.xml中引入spring security</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;!--引入spring security的配置文件--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;import resource&#x3D;&quot;classpath:spring-security.xml&quot;&#x2F;&gt;</span></pre></td></tr></table></figure><br>启动项目访问8080/index会访问到访问页面，但出现下面的页面<br><img src="/2021/06/11/Spring-Security/1.png" alt="Spring-Security"><br>这个页面不是自己写的index.jsp页面，这是Spring Security提供的(login)。为什么呢？<br>因为在spring security配置中，会拦截所有资源包括index页面，所以只有ROLE_USER用户才能访问到index页面，但ROLE_USER角色只有在user认证过之后才提供。因为没有认证，所以spring security会自动跳转到它提供好的登录页面<br>Spring Security中加载过滤器的过程，doFilter, init, SecurityFilterChain中加载了15个过滤器链<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;配置自己的登录页面</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;security:http auto-config&#x3D;&quot;true&quot; use-expressions&#x3D;&quot;true&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;!--让认证页面可以匿名访问,permitAll表示但仍经过后续的过滤器链，因为会出现登录失败等一些情况--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;security:intercept-url pattern&#x3D;&quot;&#x2F;login.jsp&quot; access&#x3D;&quot;permitAll()&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;!--拦截资源&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;!--</span></pre></td></tr><tr><td class="code"><pre><span class="line">		pattern&#x3D;&quot;&#x2F;**&quot; 表示拦截所有资源</span></pre></td></tr><tr><td class="code"><pre><span class="line">		access&#x3D;&quot;hasAnyRole(&#39;ROLE_USER&#39;)&quot; 表示只有ROLE_USER角色才能访问资源</span></pre></td></tr><tr><td class="code"><pre><span class="line">		--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;security:intercept-url pattern&#x3D;&quot;&#x2F;**&quot; access&#x3D;&quot;hasAnyRole(&#39;ROLE_USER&#39;)&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;!--配置认证信息--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;security:form-login login-page&#x3D;&quot;&#x2F;login.jsp&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">							 login-processing-url&#x3D;&quot;&#x2F;login&quot;   &#x2F;&#x2F;跟security默认的一致</span></pre></td></tr><tr><td class="code"><pre><span class="line">							 default-target-url&#x3D;&quot;&#x2F;index.jsp&quot;  &#x2F;&#x2F;认证成功的跳转页面</span></pre></td></tr><tr><td class="code"><pre><span class="line">							 authentication-failure-url&#x3D;&quot;&#x2F;failer.jsp&quot;&#x2F;&gt;  &#x2F;&#x2F;认证失败的跳转页面</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;!--配置退出登录信息--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;security:logout logout-url&#x3D;&quot;&#x2F;logout&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">						 logout-success-url&#x3D;&quot;&#x2F;login.jsp&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;security:http&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;但由于pattern&#x3D;&quot;&#x2F;**&quot;，会拦截所有的资源，所以静态资源在自定义的界面上显示不出来，因此需要释放，让与secutiry没有关系</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;!--释放静态资源--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;security:http pattern&#x3D;&quot;&#x2F;css&#x2F;**&quot; security&#x3D;&quot;none&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;security:http pattern&#x3D;&quot;&#x2F;img&#x2F;**&quot; security&#x3D;&quot;none&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;security:http pattern&#x3D;&quot;&#x2F;plugins&#x2F;**&quot; security&#x3D;&quot;none&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;网页启动报403错误</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;security:http auto-config&#x3D;&quot;true&quot; use-expressions&#x3D;&quot;true&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;!--去掉csrf拦截的过滤器--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;security:csrf disabled&#x3D;&quot;true&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;security:http&gt;</span></pre></td></tr></table></figure></p>
<h3 id="CSRF介绍"><a href="#CSRF介绍" class="headerlink" title="CSRF介绍"></a>CSRF介绍</h3><p>CSRF(Cross-site request forgery)跨站请求伪造，是一种难以防范的网络攻击方式<br><strong>CSRF攻击</strong>：如果在同一个浏览器已经开启了一个网站，并且已经登录。如果在同一个浏览器打开了另一个网络，该网站中有csrf攻击的病毒，那么该病毒会获取该浏览器中的所有cookie信息，那么就会获取已经登录网站的用户名和密码，从而登录别的网站，让网站不安全。<br>Spring Security中有CsrfFilter过滤器，该过滤器提供了csrf的防护机制<br><strong>如何开启csrf防护</strong><br>通过查看源码，增、删和改是需要csrf验证的，GET，Header等是不需要的，所有在增、删和改的时候需要获取token信息<br>login.jsp中动态添加csrf的token信息，F12从前端开发者页面中可以看到这一项值<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@taglib uri&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;security&#x2F;tags&quot; prefix&#x3D;&quot;security&quot;%&gt;  &#x2F;&#x2F;需要倒taglib的依赖包</span></pre></td></tr><tr><td class="code"><pre><span class="line">在form中添加</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;security:csrfInput&#x2F;&gt;</span></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Cloud Compute</category>
      </categories>
      <tags>
        <tag>Cloud Compute</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-Boot-ThreadPoolExecutor</title>
    <url>/2021/06/11/Spring-Boot-ThreadPoolExecutor/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Spring-Boot-Quartz</title>
    <url>/2021/06/11/Spring-Boot-Quartz/</url>
    <content><![CDATA[<h3 id="Spring-Quartz任务调度器"><a href="#Spring-Quartz任务调度器" class="headerlink" title="Spring-Quartz任务调度器"></a>Spring-Quartz任务调度器</h3><p><strong>问题：</strong> 在Quartz的Job中@Autowired一个Spring Bean的时候报空指针异常。如下例所示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CancelUnpaidOrderTask implements Job &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private AppOrderService orderService;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void execute(JobExecutionContext ctx) throws JobExecutionException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><br>Job对象的实例化过程是在Quartz中进行的，AppOrderService是在Spring容器当中的，那么如何将他们关联到一起呢？<br><strong>分析：</strong>在Spring与Quartz集成时 用到的是org.springframework.scheduling.quartz.SchedulerFactoryBean这个类。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Get Scheduler instance from SchedulerFactory.</span></pre></td></tr><tr><td class="code"><pre><span class="line">try &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	this.scheduler &#x3D; createScheduler(schedulerFactory, this.schedulerName);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	populateSchedulerContext();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (!this.jobFactorySet &amp;&amp; !(this.scheduler instanceof RemoteScheduler)) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#x2F;&#x2F; Use AdaptableJobFactory as default for a local Scheduler, unless when</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#x2F;&#x2F; explicitly given a null value through the &quot;jobFactory&quot; bean property.</span></pre></td></tr><tr><td class="code"><pre><span class="line">		this.jobFactory &#x3D; new AdaptableJobFactory(); &#x2F;&#x2F;重点 如果我们不指定jobFactory，那么Spring就使用AdaptableJobFactory</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (this.jobFactory !&#x3D; null) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		if (this.jobFactory instanceof SchedulerContextAware) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			((SchedulerContextAware) this.jobFactory).setSchedulerContext(this.scheduler.getContext());</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		this.scheduler.setJobFactory(this.jobFactory);</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">package org.springframework.scheduling.quartz;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import java.lang.reflect.Method;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.quartz.Job;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.quartz.Scheduler;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.quartz.SchedulerException;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.quartz.spi.JobFactory;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.quartz.spi.TriggerFiredBundle;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.util.ReflectionUtils;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class AdaptableJobFactory implements JobFactory &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Job newJob(TriggerFiredBundle bundle, Scheduler scheduler) throws SchedulerException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return newJob(bundle);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Job newJob(TriggerFiredBundle bundle) throws SchedulerException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        try &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Object jobObject &#x3D; createJobInstance(bundle);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return adaptJob(jobObject);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        catch (Exception ex) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            throw new SchedulerException(&quot;Job instantiation failed&quot;, ex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    protected Object createJobInstance(TriggerFiredBundle bundle) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; Reflectively adapting to differences between Quartz 1.x and Quartz 2.0...</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Method getJobDetail &#x3D; bundle.getClass().getMethod(&quot;getJobDetail&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Object jobDetail &#x3D; ReflectionUtils.invokeMethod(getJobDetail, bundle);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Method getJobClass &#x3D; jobDetail.getClass().getMethod(&quot;getJobClass&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Class jobClass &#x3D; (Class) ReflectionUtils.invokeMethod(getJobClass, jobDetail);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return jobClass.newInstance(); &#x2F;&#x2F;重点创建了一个Job，写一个类继承它，然后复写这个方法进行对Job的注入</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    protected Job adaptJob(Object jobObject) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if (jobObject instanceof Job) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return (Job) jobObject;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        else if (jobObject instanceof Runnable) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            return new DelegatingJob((Runnable) jobObject);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        else &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            throw new IllegalArgumentException(&quot;Unable to execute job class [&quot; + jobObject.getClass().getName() +</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    &quot;]: only [org.quartz.Job] and [java.lang.Runnable] supported.&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><br><strong>解决：</strong> 1、自定义 JobFactory，2、创建完 Job 实例之后，再将 Job 注入到 Spring 容器中<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;首先自定义一个 JobFactory，通过 AutowireCapableBeanFactory 将创建好的 Job 对象交给 Spring 管理</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class CustomJobFactory extends AdaptableJobFactory &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;&#x2F;这个对象Spring会帮我们自动注入进来,也属于Spring技术范畴.</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private AutowireCapableBeanFactory autowireCapableBeanFactory;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * Create the job instance, populating it with property values taken</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * from the scheduler context, job data map and trigger data map.</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @param bundle</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    protected Object createJobInstance(TriggerFiredBundle bundle) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#x2F;&#x2F;调用父类的方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Object jobInstance &#x3D; super.createJobInstance(bundle);</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&#x2F;&#x2F;进行注入,这属于Spring的技术</span></pre></td></tr><tr><td class="code"><pre><span class="line">        autowireCapableBeanFactory.autowireBean(jobInstance);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return jobInstance;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;再创建一个配置类，将自定义的 JobFactory 设置到 Schedule 中</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class QuartzConfig &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private CustomJobFactory customJobFactory;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @SneakyThrows</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Scheduler scheduler()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        SchedulerFactory schedulerFactory &#x3D; new StdSchedulerFactory();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Scheduler scheduler &#x3D; schedulerFactory.getScheduler();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; 自定义 JobFactory 使得在 Quartz Job 中可以使用 @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">        scheduler.setJobFactory(customJobFactory);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        scheduler.start();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return scheduler;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><br><strong>Cron表达式的学习</strong></p>
<h4 id="字段解析"><a href="#字段解析" class="headerlink" title="字段解析"></a>字段解析</h4><p>0      0      *      *      *      ？      *<br>秒     分     时      日      月     星期   年(一般省略)</p>
<h4 id="符号解析"><a href="#符号解析" class="headerlink" title="符号解析"></a>符号解析</h4><ul>
<li>*: 表示所有可能的值,如秒、分的可能值为(0-59)，时的可能值为(0-23),天月可能值为(1-31，<em>有的月没有31</em>),月的可能值(1-12),天周可能值为(MON-SAT),年的可能值(留空 2020-2099)</li>
<li>/ : 表示数值的增量，简单来说，比如分写上0/5表示从0分开始，每隔5分钟 0 0/5 * * * ?</li>
<li>? : 仅用在天(月)和天(周)，表示不指定值，当其中一个有值时，另外一个需要设为?<h4 id="字段范围解析"><a href="#字段范围解析" class="headerlink" title="字段范围解析"></a>字段范围解析</h4>1、秒：0-59 , - * /</li>
</ul>
<ol>
<li>26：表示第26秒</li>
<li>5,16,27：表示第5秒、第16秒和第27秒</li>
<li>1-5：表示从1秒到5秒，就是1 2 3 4 5 秒</li>
<li>*：表示每一秒</li>
<li>2/15：表示从第2秒开始，每隔15秒，就是2 17 32 47 秒<br>2、分：0-59 , - * /<br>3、时：0-23 , - * /<br>4、日：1-31 , - * / ? L W</li>
<li>31：表示31号（注意有的月份是没有31号的）</li>
<li>5,10,15：表示5号、10号和15号</li>
<li>8-17：表示8号到17号</li>
<li>*：表示所有可能的值（当指定为星号时，天（周）需指定为?）</li>
<li>5/9：表示从5号开始，每隔9天</li>
<li>？：当天（周）指定任意值的时候，天（月）需要设置为?</li>
<li>L：表示一个月中的最后一天</li>
<li>6L：表示倒数第6天</li>
<li>15W：W指工作日，如果15号不是周六日，则表示15号当天；如果15号是周六，则表示14号；如果15号是周日，则表示16号；如果31W是周日，则31W表示29号（周五），不会跨月</li>
<li>LW：指最后一个工作日<br>5、月：1-12 , - * /<br>6、星期：MON-SAT , - * / ? L C #<br>7、留空 2020-2099 , - * /<br><a href="https://www.jianshu.com/p/b4b8950fb987" target="_blank" rel="noopener">参考资料一</a><br><a href="https://haoyongliang.gitee.io/2020/12/01/%E5%B7%A5%E5%85%B7/Cron%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E8%A1%A8%E8%BE%BE%E5%BC%8F/#%E5%AD%97%E7%AC%A6%E5%90%AB%E4%B9%89" target="_blank" rel="noopener">参考资料二</a></li>
</ol>
]]></content>
      <categories>
        <category>Cloud Compute</category>
      </categories>
      <tags>
        <tag>Cloud Compute</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-Boot-Problem-Two</title>
    <url>/2021/06/11/Spring-Boot-Problem-Two/</url>
    <content><![CDATA[<h2 id="Spring-Boot-Problem-Two"><a href="#Spring-Boot-Problem-Two" class="headerlink" title="Spring-Boot-Problem-Two"></a>Spring-Boot-Problem-Two</h2><p><strong>问题1：</strong> 自定义exception异常:{} org.apache.ibatis.binding.BindingException: Invalid bound statement (not found): com.ict.cloud.openstack.resource.mapper.OpenstackResourceMapper.insert<br><img src="/2021/06/11/Spring-Boot-Problem-Two/1.png" alt="Spring-Boot-Problem-Two"><br><strong>解决：</strong> 修改配置文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;修改前</span></pre></td></tr><tr><td class="code"><pre><span class="line">mybatis-plus:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  mapper-locations: classpath:&#x2F;mapper&#x2F;*Mapper.xml</span></pre></td></tr><tr><td class="code"><pre><span class="line">  type-aliases-package: com.chuancey.common.entity</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;修改后</span></pre></td></tr><tr><td class="code"><pre><span class="line">mybatis-plus:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  mapper-locations: classpath*:&#x2F;mapper&#x2F;*Mapper.xml</span></pre></td></tr><tr><td class="code"><pre><span class="line">  type-aliases-package: com.chuancey.common.entity</span></pre></td></tr></table></figure><br><strong>问题2：</strong>mapper找不到报错：Field xxxMapper in xxx required a bean of type ‘xxxMapper’ that could not be found<br>微服务中在别的模块中定义有service和mapper模块，但是要在别的模块中加载，所以提示找不到Mapper对应的目标<br><strong>原因：</strong>因为启动类扫描不到对应的Mapper文件，因此需要将Mapper文件对应的路径加载到启动类中<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@MapperScan(basePackages &#x3D; &#123;&quot;com.ict.cloud.quartz&quot;,&quot;com.ict.cloud.openstack.resource.mapper&quot;&#125;)</span></pre></td></tr></table></figure><br>注意：这里别的文件尽量指定到mapper这一层目录下面；另外检查pom中设置的依赖选项，一般在mybatis依赖中已经添加了下面两个依赖类，不需要在单独添加<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">org.mybatis:mybatis</span></pre></td></tr><tr><td class="code"><pre><span class="line">org.mybatis:mybatis-spring</span></pre></td></tr></table></figure><br><strong>问题3：</strong>在Application.getBean()的时候，代码跟进去一个类注册了两个Bean，导致编译报下图的错<br><img src="/2021/06/11/Spring-Boot-Problem-Two/2.png" alt="Spring-Boot-Problem-Two"><br><strong>原因：</strong>由于上面问题2在加载别的mapper的时候，使用了@MapperScan,需要将本地的报也一起扫描进去。但是扫描的时候没有定位到mapper目录，导致将service目录中的包也一起扫描了进去<br><strong>解决：</strong>方法如下图<br><img src="/2021/06/11/Spring-Boot-Problem-Two/3.png" alt="Spring-Boot-Problem-Two"><br><strong>问题4：</strong>Caused by: org.apache.ibatis.binding.BindingException: Invalid bound statement (not found):这个问题可能与问题1<em>有关</em><br><img src="/2021/06/11/Spring-Boot-Problem-Two/4.png" alt="Spring-Boot-Problem-Two"><br>这里mapper.xml中的namespace对应的是mapper文件接口对应的位置，而不是xml所在的package位置<br>注意：mapper-locations指定的xml的位置可以写多个，type-aliases-package是数据接口所对应的位置<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mybatis:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  mapper-locations: classpath:mybatis&#x2F;*,classpath*:&#x2F;mybatis&#x2F;*.xml</span></pre></td></tr><tr><td class="code"><pre><span class="line">  type-aliases-package: com.ict.cloud.quartz.domain</span></pre></td></tr></table></figure><br><strong>问题5：</strong> openfeign提示找不到Api<br><img src="/2021/06/11/Spring-Boot-Problem-Two/5.png" alt="Spring-Boot-Problem-Two"><br><strong>原因：</strong>因为目前使用的是微服务，所以一个模块为了使用另一个模块，就需要在启动类中能够扫描到别的类的一些Bean，然后注入到容器中。一般问题有两个，一个是启动类的位置不对，另一个是扫描路径不对<br><strong>解决：</strong> 1、添加@ComponentScan、@MapperScan，2、将启动类往前移一层，个人推荐这种方式)<br><img src="/2021/06/11/Spring-Boot-Problem-Two/6.png" alt="Spring-Boot-Problem-Two"><br>如上图，之前启动类是放在了quartz目录的里面，这样的话，配置之类的很麻烦，直接将启动类放到com.ict.cloud目录则直接可以扫描到其他服务的@service和@mapper，这样更加方便<br><strong>关于找不到OpenFeign接口的问题：</strong>是因为@EnableFeignClients//(basePackageClasses = PhysicalServerInstanceApi.class)在@EnableFeignClients开启OpenFeign的时候，指定了一个服务的名称，这样别的服务是找不到的，注释掉这个路径就可以了<br><strong>问题6：</strong> Cause: java.lang.IllegalArgumentException: Result Maps collection already contains value for com.ict.cloud.quartz.BaseResultMap<br><img src="/2021/06/11/Spring-Boot-Problem-Two/7.png" alt="Spring-Boot-Problem-Two"><br><strong>原因：</strong>下面所示，mapper-locations定位的模块mapper路径被导入了两次<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mybatis:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  mapper-locations: classpath:mybatis&#x2F;*,classpath*:&#x2F;mybatis&#x2F;*.xml</span></pre></td></tr><tr><td class="code"><pre><span class="line">  type-aliases-package: com.ict.cloud.quartz.domain</span></pre></td></tr></table></figure><br><strong>解决：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mybatis:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  mapper-locations: classpath*:&#x2F;mybatis&#x2F;*.xml</span></pre></td></tr><tr><td class="code"><pre><span class="line">  type-aliases-package: com.ict.cloud.quartz.domain</span></pre></td></tr></table></figure><br><strong>问题7：</strong>java.lang.RuntimeException: CronExpression ‘0 0/5 <em> </em> <em> ? ‘is invalid<br>明明是对的，为什么会报cron is invalid,因为字符串后面多了一个空格   —这个地方<br><em>*解决：</em></em>可以使用在线的cron生成器<br><img src="/2021/06/11/Spring-Boot-Problem-Two/8.png" alt="Spring-Boot-Problem-Two"></p>
]]></content>
      <categories>
        <category>Cloud Compute</category>
      </categories>
      <tags>
        <tag>Cloud Compute</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-Cloud-Problem</title>
    <url>/2021/05/21/Spring-Cloud-Problem/</url>
    <content><![CDATA[<h2 id="Spring-Cloud-Problem-Summary"><a href="#Spring-Cloud-Problem-Summary" class="headerlink" title="Spring Cloud Problem Summary"></a>Spring Cloud Problem Summary</h2><p><strong>问题1：</strong>org.apache.logging.log4j.LoggingException: log4j-slf4j-impl cannot be present with log4j-to-slf4j<br><img src="/2021/05/21/Spring-Cloud-Problem/1.png" alt="Problem Summary"><br>springcloud项目本身需要spring-boot-starter-web包，自带了spring-boot-starter-log4j2包，然后自己又引入了spring-boot-starter-log4j2包，最后发现是spring-boot-starter冲突了。<br><img src="/2021/05/21/Spring-Cloud-Problem/2.png" alt="Problem Summary"><br><strong>解决</strong> 添加下面的依赖，然后reimport<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;artifactId&gt;spring-boot-starter&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;exclusions&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &lt;exclusion&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &lt;artifactId&gt;spring-boot-starter-logging&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &lt;&#x2F;exclusion&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;&#x2F;exclusions&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;exclusions&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;exclusion&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;artifactId&gt;spring-boot-starter-logging&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;&#x2F;exclusion&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;&#x2F;exclusions&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependency&gt;</span></pre></td></tr></table></figure><br><strong>扩展：</strong>IDEA旗舰版和社区版还是有些差别，所以需要在社区版中setting-&gt;plugin中安装一些插件方便查看依赖冲突等问题，如maven-helper<br><strong>问题2：</strong>springboot security莫名其妙的登录界面Please sign in<br><img src="/2021/05/21/Spring-Cloud-Problem/3.png" alt="Problem Summary"><br><strong>解决</strong> security默认给我们整的一个用户认证的功能，用户名是：user，密码是在启动的控制台打印出来的：<br><img src="/2021/05/21/Spring-Cloud-Problem/4.png" alt="Problem Summary"><br><strong>扩展：</strong>需要自己添加适配器<br><strong>问题3：</strong>was not registered for synchronization because synchronization is not active. JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@418d1c03] will not be managed by Spring<br><img src="/2021/05/21/Spring-Cloud-Problem/5.png" alt="Problem Summary"><br><strong>解决</strong> 1、首先查看对应的POJO映射实体与数据表中的关系是否一致，如表中为非NULL的字段，但被插入时设置为NULL等；2、在对应的数据库语句上未添加事务管理的字段@Transactional<br>针对第二种情况可以添加@Transactional(rollbackFor = Exception.class)，实现异常回滚，避免线程或程序退出。添加的位置可以在mapper文件夹的xxxxMapper中，可以在类上，也可以在函数上。<br><img src="/2021/05/21/Spring-Cloud-Problem/6.png" alt="Problem Summary"><br><strong>问题4：</strong> 启动程序出现数据映射表错误<br><img src="/2021/05/21/Spring-Cloud-Problem/7.png" alt="Problem Summary"><br><strong>解决</strong> 需要在mapper文件中添加@Mapper注解，还有别的实现方式，如下启动类中添加@MapperScan(“com.example.demo.mapper”)<br><strong>问题5：</strong> 如何将配置文件application.yml中的值映射到实体类中,如将下列值映射到AsyncTaskProperties中<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#1、在application.yml中添加下列值</span></pre></td></tr><tr><td class="code"><pre><span class="line">task:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  pool:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    # 核心线程池大小</span></pre></td></tr><tr><td class="code"><pre><span class="line">    core-pool-size: 10</span></pre></td></tr><tr><td class="code"><pre><span class="line">    # 最大线程数</span></pre></td></tr><tr><td class="code"><pre><span class="line">    max-pool-size: 30</span></pre></td></tr><tr><td class="code"><pre><span class="line">    # 活跃时间</span></pre></td></tr><tr><td class="code"><pre><span class="line">    keep-alive-seconds: 60</span></pre></td></tr><tr><td class="code"><pre><span class="line">    # 队列容量</span></pre></td></tr><tr><td class="code"><pre><span class="line">    queue-capacity: 50</span></pre></td></tr><tr><td class="code"><pre><span class="line">#2、添加@ConfigurationProperties(prefix &#x3D; &quot;task.pool&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Data</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Component</span></pre></td></tr><tr><td class="code"><pre><span class="line">@ConfigurationProperties(prefix &#x3D; &quot;task.pool&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class AsyncTaskProperties &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    private int corePoolSize;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    private int maxPoolSize;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    private int keepAliveSeconds;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    private int queueCapacity;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><br><strong>问题6：</strong> nacos服务注册发现时，一直在nacos界面上看不到任务<br>查看依赖maven-dependency结果发现虽然pom中导入了spring-cloud-starter-alibaba-nacos-discovery但是依赖列表中并没有<br><strong>解决</strong> maven-&gt;reimport重新加载一下依赖即可<br><img src="/2021/05/21/Spring-Cloud-Problem/8.png" alt="Problem Summary"><br><strong>问题7：</strong> Quartz在启动Job时出错<br>因为Job的实例是在Quartz内部创建的，与Spring管理的Service不能访问，所以需要继承JobFactory去新建一个Job，并加入Bean中<br>Job的继承者会去实现一些exector的执行逻辑，一般是在这个执行逻辑中出现了错误如下<br><img src="/2021/05/21/Spring-Cloud-Problem/9.png" alt="Problem Summary"><br><strong>问题8：</strong> feign.FeignException$ServiceUnavailable: [503 Service Unavailable] during [POST] to [<a href="http://ace-admin/client/userPubKey?clientId=ace-gate&amp;secret=123456" target="_blank" rel="noopener">http://ace-admin/client/userPubKey?clientId=ace-gate&amp;secret=123456</a>] [ServiceAuthFeign#getUserPublicKey(String,String)]: []<br>两个微服务之间通过api访问的时候，访问不到<br><strong>解决</strong> 1、检查两个微服务是否都在nacos中注册成功，2、检查OpenFeign的服务提供者和消费者的调用逻辑，3、使用http去请求<a href="http://localhost:port/api/v1/jobs(类似这种链接" target="_blank" rel="noopener">http://localhost:port/api/v1/jobs(类似这种链接</a>)<br><img src="/2021/05/21/Spring-Cloud-Problem/10.png" alt="Problem Summary"><br>API的FeignClient注解类似上面的形式<br><strong>重点</strong> 在服务调用者或消费者中使用服务提供者的业务层逻辑时，需要在类上加上@Service，<strong>@Component不起作用</strong>，应该是注册Bean时需要对应上，不能用@Component记载@Service的Bean<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Service</span></pre></td></tr><tr><td class="code"><pre><span class="line">@AllArgsConstructor</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;@Component</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class QuartzTasks &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private OpenstackService serverProvider;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private PhysicalServerInstanceApi physicalServerInstanceApi;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void runSyncOpenstack() throws OperationException &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        boolean valid &#x3D; serverProvider.connectOpenstack();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if(!valid)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            throw new OperationException(&quot;Openstack Connect failed!&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(&quot;connect Openstack success&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        final Nova nova  &#x3D; serverProvider.getNova();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        try&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            ApiResult&lt;List&lt;String&gt;&gt; serversList &#x3D; physicalServerInstanceApi.getPhysicalServerNodes();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            List&lt;String&gt; data &#x3D; serversList.getData();</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.println(data.get(0));</span></pre></td></tr><tr><td class="code"><pre><span class="line">            for(int i&#x3D;0; i&lt;data.size(); i++)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                Integer operateIndex &#x3D; nova.servers.get(data.get(i)).getPowerState();</span></pre></td></tr><tr><td class="code"><pre><span class="line">                ApiResult&lt;Integer&gt; physicalStatus &#x3D; physicalServerInstanceApi.getPhysicalServerStatusById(data.get(i));</span></pre></td></tr><tr><td class="code"><pre><span class="line">                if(!operateIndex.equals(physicalStatus.getData()))&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                    physicalServerInstanceApi.updateNodeStatusById(data.get(i),operateIndex);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.println(&quot;Success&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;catch (Exception e)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.println(e);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            System.out.println(&quot;Failed!&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><br><strong>问题9：</strong> The injection point has the following annotations: - @org.springframework.beans.factory.annotation.<br><img src="/2021/05/21/Spring-Cloud-Problem/11.png" alt="Problem Summary"><br>Autowired 根据类型去spring容器找，找不到那个类，就会报错<br><strong>解决</strong> 在springboot启动类上添加注解 @ComponentScan(basePackages = { “com.jeff” })，<br>@ComponentScan(basePackages = {“com.ict.cloud.quartz”, “com.ict.cloud.openstack”}, excludeFilters = @ComponentScan.Filter(type = FilterType.REGEX, pattern = {“com.ict.cloud.publicmodel.alipay.<em>“}))<br>excludeFilters的意思是排除扫描的Bean类<br><em>*提示：</em></em> 将basePackages放在@SpringBootApplication(scanBasePackages = {“com.ict.cloud.quartz”, “com.ict.cloud.openstack”})上没有作用</p>
]]></content>
      <categories>
        <category>Cloud Compute</category>
      </categories>
      <tags>
        <tag>Cloud Compute</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-Boot-Bean</title>
    <url>/2021/05/21/Spring-Boot-Bean/</url>
    <content><![CDATA[<h2 id="SpringBoot-Bean解析"><a href="#SpringBoot-Bean解析" class="headerlink" title="SpringBoot Bean解析"></a>SpringBoot Bean解析</h2><h3 id="一、简述Bean"><a href="#一、简述Bean" class="headerlink" title="一、简述Bean"></a>一、简述Bean</h3><p>Spring中有两个有名的特性，依赖注入（DI）与切面（AOP），其中围绕的关键就是Bean。<br>Java语言欠缺属性、事件、多重继承功能。所以，如果要在Java程序中实现一些面向对象编程的常见需求，只能手写大量胶水代码。Java Bean正是编写这套胶水代码的惯用模式或约定。这些约定包括getXxx、setXxx、isXxx、addXxxListener、XxxEvent等。遵守上述约定的类可以用于若干工具或库。<br>java Bean是Sun公司为了代码的向后兼容性而提出的一种设计方案，一个java bean其实就是一个普通的java类，对这个类有如下的一些要求：</p>
<ol>
<li>这个类需要是public的，需要有个无参构造函数(能够new出来一个对象)</li>
<li>这个类的属性应该是private的，通过setXXX(), getXXX()来访问</li>
<li>这个类需要能支持”事件”，例如addXXXListenr(xxxEvent e),事件可以是Click事件，keyboard事件等，也可以支持自定义事件</li>
<li>需要提供一个反射机制，这样能在运行时查看java bean定义的类中的各种信息</li>
<li>这个类可以序列化，即可以把bean的状态保存在硬盘上，便于以后恢复(实现serializable接口)<br>最初的Java Bean是为了不破坏插件等的向后兼容性，比如下了一个代码，之后改变了实现逻辑，那么在别人调用升级后的版本时，就会报错。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 编译成 java-int-list_1.0.jar</span></pre></td></tr><tr><td class="code"><pre><span class="line">public final class JavaIntList &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  static class Node &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Node next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public int value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  public Node head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  public int size;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">JavaIntList myList &#x3D; new JavaIntList();</span></pre></td></tr><tr><td class="code"><pre><span class="line">System.out.println(myList.size);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;如上述java实现的单链表</span></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 编译成 java-int-list_2.0.jar</span></pre></td></tr><tr><td class="code"><pre><span class="line">public final class JavaIntList &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  static final class Node &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Node next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public int value;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  public Node head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  public int getSize() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    Node n &#x3D; head;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    int i &#x3D; 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    while (n !&#x3D; null) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      n &#x3D; n.next;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      i++;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return i;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;如果换成了2.0版本，那么别人在使用的时候就会发现size变量找不到了，会报错，兼容性很差</span></pre></td></tr></table></figure>
为了考虑向后兼容性，一般会使用如下形式：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private int size;</span></pre></td></tr><tr><td class="code"><pre><span class="line">public int getSize() &#123; return size; &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;对外开放getSize()，如何改变实现逻辑，只需改变getSize()即可</span></pre></td></tr></table></figure>
<h3 id="二、Bean的创建"><a href="#二、Bean的创建" class="headerlink" title="二、Bean的创建"></a>二、Bean的创建</h3>2.1、注解的方式：一般就是在类上添加@Component, @Service等注解（@Controller表示提供http接口的bean, @Configuration表示配置类Bean)<br>添加上这种注解的类，会被Spring容器扫描加载，自动生成单例的bean，一个典型的实例如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Component</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class AnoDemoBean &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String type &#x3D; &quot;AnoDemoBean&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public String getName(String name) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return name + &quot; _&quot; + type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
如果在实际测试时，发现无法获取上面的bean，就需要注意下bean的包路径，是否在被你程序的扫描路径包含,如：@SpringBootApplication(scanBasePackages = {“com.ict.cloud.*”})<br>2.2、@Bean定义方式<br>这种方式，主要是结合Configuration来定义bean，首先是声明一个配置类，然后再配置类中，通过返回bean对象的方法形式来声明bean，一般使用姿势如下<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Data</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class ConfigDemoBean &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String type &#x3D; &quot;ConfigDemoBean&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public String getName(String name) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return name + &quot; _&quot; + type;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class BeanLoadConfig &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public ConfigDemoBean configDemoBean() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return new ConfigDemoBean();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
需要说明的一点是BeanLoadConfig类本身也被Spring容器看为一个Bean<br>2.3、工厂类方式（以后再说）<h3 id="三、Bean的使用"><a href="#三、Bean的使用" class="headerlink" title="三、Bean的使用"></a>三、Bean的使用</h3>3.1、Autowired注入<br>将注解@Autowired或者@Resource添加到成员变量上，即表示这个成员变量会由Spring容器注入对应的Bean对象<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">private ConfigDemoBean configDemoBean;</span></pre></td></tr></table></figure>
3.2、Setter方法<br>3.3、构造方法<h3 id="四、记录一些项目中需要的名称"><a href="#四、记录一些项目中需要的名称" class="headerlink" title="四、记录一些项目中需要的名称"></a>四、记录一些项目中需要的名称</h3></li>
</ol>
<ul>
<li>PO(persistence object):用于持久化时(例如保存到数据库或者缓存)</li>
<li>VO(value object):用于前端展示使用(例如放置到JSP中解析或者给前端传递数据)</li>
<li>DTO(data transfer object):用于接口互相调用返回,数据传输(例如很多接口调用返回值或消息队列内容)<br><a href="https://www.zhihu.com/question/19773379" target="_blank" rel="noopener">参考</a></li>
</ul>
]]></content>
      <categories>
        <category>Cloud Compute</category>
      </categories>
      <tags>
        <tag>Cloud Compute</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-Boot-Swagger</title>
    <url>/2021/05/21/Spring-Boot-Swagger/</url>
    <content><![CDATA[<h2 id="Spring-Boot-Spring-Cloud与Swagger2"><a href="#Spring-Boot-Spring-Cloud与Swagger2" class="headerlink" title="Spring Boot/Spring Cloud与Swagger2"></a>Spring Boot/Spring Cloud与Swagger2</h2><h3 id="一、认识Swagger"><a href="#一、认识Swagger" class="headerlink" title="一、认识Swagger"></a>一、认识Swagger</h3><p>Swagger 是一个规范和完整的框架，用于生成、描述、调用和可视化 RESTful 风格的 Web 服务。总体目标是使客户端和文件系统作为服务器以同样的速度来更新。文件的方法，参数和模型紧密集成到服务器端的代码，允许API来始终保持同步。<br><strong>作用</strong>：1、接口的文档在线自动生成；2、功能测试<br><strong>Swagger是一组开源项目，其中主要要项目如下：</strong></p>
<ol>
<li><strong>Swagger-tools:</strong>提供各种与Swagger进行集成和交互的工具。例如模式检验、Swagger 1.2文档转换成Swagger 2.0文档等功能。</li>
<li><strong>Swagger-core:</strong> 用于Java/Scala的的Swagger实现。与JAX-RS(Jersey、Resteasy、CXF…)、Servlets和Play框架进行集成。</li>
<li><strong>Swagger-js:</strong> 用于JavaScript的Swagger实现。</li>
<li><strong>Swagger-node-express:</strong> Swagger模块，用于node.js的Express web应用框架。</li>
<li><strong>Swagger-ui:</strong> 一个无依赖的HTML、JS和CSS集合，可以为Swagger兼容API动态生成优雅文档。</li>
<li><strong>Swagger-codegen:</strong> 一个模板驱动引擎，通过分析用户Swagger资源声明以各种语言生成客户端代码。<h3 id="二、工程创建"><a href="#二、工程创建" class="headerlink" title="二、工程创建"></a>二、工程创建</h3>1、添加Maven依赖<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;artifactId&gt;springfox-swagger2&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;groupId&gt;io.springfox&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;artifactId&gt;springfox-swagger-ui&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;version&gt;2.9.2&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependency&gt;</span></pre></td></tr></table></figure>
<strong>使用swagger要求jdk1.8及以上，否则swagger2不能运行</strong><h3 id="三、Swagger2配置-目前以更新到版本3，但由于项目这里先了解Swagger2"><a href="#三、Swagger2配置-目前以更新到版本3，但由于项目这里先了解Swagger2" class="headerlink" title="三、Swagger2配置(目前以更新到版本3，但由于项目这里先了解Swagger2)"></a>三、Swagger2配置(目前以更新到版本3，但由于项目这里先了解Swagger2)</h3>在项目创建成功之后，只需要开发者自己提供一个Docket的Bean即可，如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * Swagger2配置类</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * 在与spring boot集成时，该配置文件放在与Application.java同级或子包下面。</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * 通过@Configuration注解，让Spring来加载该类配置。</span></pre></td></tr><tr><td class="code"><pre><span class="line"> * 再通过@EnableSwagger2注解来启用Swagger2。</span></pre></td></tr><tr><td class="code"><pre><span class="line"> *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableSwagger2</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class SwaggerConfig &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 创建API应用</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * apiInfo() 增加API相关信息</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 通过select()函数返回一个ApiSelectorBuilder实例,用来控制哪些接口暴露给Swagger来展现，</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * 本例采用指定扫描的包路径来定义指定要建立API的目录。</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *</span></pre></td></tr><tr><td class="code"><pre><span class="line">     * @return</span></pre></td></tr><tr><td class="code"><pre><span class="line">     *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Docket createRestApi() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return new Docket(DocumentationType.SWAGGER_2)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .pathMapping(&quot;&#x2F;&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .select()</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .apis(RequestHandlerSelectors.basePackage(&quot;com.xxx.controller&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .paths(PathSelectors.any())</span></pre></td></tr><tr><td class="code"><pre><span class="line">                .build()</span></pre></td></tr><tr><td class="code"><pre><span class="line">				.apiInfo(apiInfo());</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">	 * 创建该API的基本信息（这些基本信息会展现在文档页面中）</span></pre></td></tr><tr><td class="code"><pre><span class="line">	 * 访问地址：http:&#x2F;&#x2F;项目实际地址&#x2F;swagger-ui.html</span></pre></td></tr><tr><td class="code"><pre><span class="line">	 * @return</span></pre></td></tr><tr><td class="code"><pre><span class="line">	 *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	private ApiInfo apiInfo() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		return  new ApiInfoBuilder()</span></pre></td></tr><tr><td class="code"><pre><span class="line">						.title(&quot;SpringBoot整合Swagger&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">						.description(&quot;SpringBoot整合Swagger，详细信息......&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">						.version(&quot;9.0&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">						.contact(new Contact(&quot;你好，世界&quot;,&quot;hello world&quot;,&quot;xxx@xxx.com&quot;))</span></pre></td></tr><tr><td class="code"><pre><span class="line">						.license(&quot;The Apache License&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">						.licenseUrl(&quot;http:&#x2F;&#x2F;www.xxxx.com&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">						.build()</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
上述提供了一个配置类，首先通过@EnableSwagger2注解启用Swagger2，然后配置一个Docket Bean，这个Bean中，配置映射路径和要扫描的接口的位置，在apiInfo中，主要配置一下Swagger2文档网站的信息，例如网站的title，网站的描述，联系人的信息，使用的协议等等。<h3 id="四、Swagger2启动"><a href="#四、Swagger2启动" class="headerlink" title="四、Swagger2启动"></a>四、Swagger2启动</h3>输入<a href="http://localhost:8080/swagger-ui.html" target="_blank" rel="noopener">http://localhost:8080/swagger-ui.html</a><br><img src="/2021/05/21/Spring-Boot-Swagger/1.jpg" alt="Swagger2"><h3 id="五、创建接口"><a href="#五、创建接口" class="headerlink" title="五、创建接口"></a>五、创建接口</h3>用于web展示的条目，在controller文档中<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Api(tags &#x3D; &quot;用户管理相关接口&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">@RequestMapping(&quot;&#x2F;user&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class UserController &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @PostMapping(&quot;&#x2F;&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @ApiOperation(&quot;添加用户的接口&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @ApiImplicitParams(&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            @ApiImplicitParam(name &#x3D; &quot;username&quot;, value &#x3D; &quot;用户名&quot;, defaultValue &#x3D; &quot;李四&quot;),</span></pre></td></tr><tr><td class="code"><pre><span class="line">            @ApiImplicitParam(name &#x3D; &quot;address&quot;, value &#x3D; &quot;用户地址&quot;, defaultValue &#x3D; &quot;深圳&quot;, required &#x3D; true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    )</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public RespBean addUser(String username, @RequestParam(required &#x3D; true) String address) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return new RespBean();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @GetMapping(&quot;&#x2F;&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @ApiOperation(&quot;根据id查询用户的接口&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @ApiImplicitParam(name &#x3D; &quot;id&quot;, value &#x3D; &quot;用户id&quot;, defaultValue &#x3D; &quot;99&quot;, required &#x3D; true)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public User getUserById(@PathVariable Integer id) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        User user &#x3D; new User();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        user.setId(id);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return user;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @PutMapping(&quot;&#x2F;&#123;id&#125;&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @ApiOperation(&quot;根据id更新用户的接口&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public User updateUserById(@RequestBody User user) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return user;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
</li>
</ol>
<div class="table-container">
<table>
<thead>
<tr>
<th>API</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>@Api</td>
<td>可以用来标记当前Controller的功能</td>
</tr>
<tr>
<td>@ApiOperation</td>
<td>用来标记一个方法的作用</td>
</tr>
<tr>
<td>@ApiImplicitParam</td>
<td>用来描述一个参数，可以配置参数的中文含义，也可以给参数设置默认值，这样在接口测试的时候可以避免手动输入</td>
</tr>
<tr>
<td>@ApiImplicitParams</td>
<td>如果有多个参数，则需要使用多个@ApiImplicitParam注解来描述,放在一个@ApiImplicitParams注解中</td>
</tr>
<tr>
<td>@ApiResponses</td>
<td>用于表示一组响应</td>
</tr>
<tr>
<td>@ApiResponse</td>
<td>用在@ApiResponses中，一般用于表达一个错误的响应信息code、message、response</td>
</tr>
<tr>
<td>@ApiModel</td>
<td>描述一个Model的信息（一般用在请求参数无法使用@ApiImplicitParam注解进行描述的时候）</td>
</tr>
<tr>
<td>@ApiModelProperty</td>
<td>描述一个model的属性</td>
</tr>
</tbody>
</table>
</div>
<p>需要注意的是，@ApiImplicitParam注解中虽然可以指定参数是必填的，但是却不能代替@RequestParam(required = true)，前者的必填只是在Swagger2框架内必填，抛弃了Swagger2，这个限制就没用了，所以假如开发者需要指定一个参数必填，@RequestParam(required = true)注解还是不能省略。<br>如果参数是一个对象（例如上文的更新接口），对于参数的描述也可以放在实体类中,如下：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ApiModel</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class User &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @ApiModelProperty(value &#x3D; &quot;用户id&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Integer id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @ApiModelProperty(value &#x3D; &quot;用户名&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String username;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @ApiModelProperty(value &#x3D; &quot;用户地址&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String address;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F;getter&#x2F;setter 可以添加@Data注解自动添加getter，setter方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></p>
<h3 id="六、跨域配置"><a href="#六、跨域配置" class="headerlink" title="六、跨域配置"></a>六、跨域配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.kmair.offical.member.config;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.boot.web.servlet.FilterRegistrationBean;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.annotation.Bean;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.context.annotation.Configuration;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.web.cors.CorsConfiguration;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.web.filter.CorsFilter;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class CorsConfig &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public FilterRegistrationBean corsFilter() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        final UrlBasedCorsConfigurationSource source &#x3D; new UrlBasedCorsConfigurationSource();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        final CorsConfiguration config &#x3D; new CorsConfiguration();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        config.setAllowCredentials(true); &#x2F;&#x2F; 允许cookies跨域</span></pre></td></tr><tr><td class="code"><pre><span class="line">        config.addAllowedOrigin(&quot;*&quot;);&#x2F;&#x2F; #允许向该服务器提交请求的URI，*表示全部允许，在SpringMVC中，如果设成*，会自动转成当前请求头中的Origin</span></pre></td></tr><tr><td class="code"><pre><span class="line">        config.addAllowedHeader(&quot;*&quot;);&#x2F;&#x2F; #允许访问的头信息,*表示全部</span></pre></td></tr><tr><td class="code"><pre><span class="line">        config.setMaxAge(1800L);&#x2F;&#x2F; 预检请求的缓存时间（秒），即在这个时间段里，对于相同的跨域请求不会再预检了</span></pre></td></tr><tr><td class="code"><pre><span class="line">        config.addAllowedMethod(&quot;*&quot;);&#x2F;&#x2F; 允许提交请求的方法，*表示全部允许</span></pre></td></tr><tr><td class="code"><pre><span class="line">        source.registerCorsConfiguration(&quot;&#x2F;**&quot;, config);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        FilterRegistrationBean bean &#x3D; new FilterRegistrationBean(new CorsFilter(source));</span></pre></td></tr><tr><td class="code"><pre><span class="line">        bean.setOrder(0); &#x2F;&#x2F; 跨域的过滤器要放在第一位</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return bean;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h3 id="七、在Security中的配置"><a href="#七、在Security中的配置" class="headerlink" title="七、在Security中的配置"></a>七、在Security中的配置</h3><p>如果我们的Spring Boot项目中集成了Spring Security，那么如果不做额外配置，Swagger2文档可能会被拦截，此时只需要在Spring Security的配置类中重写configure方法，添加如下过滤即可：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">public void configure(WebSecurity web) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    web.ignoring()</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .antMatchers(&quot;&#x2F;swagger-ui.html&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .antMatchers(&quot;&#x2F;v2&#x2F;**&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            .antMatchers(&quot;&#x2F;swagger-resources&#x2F;**&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></p>
<h3 id="八、API分组"><a href="#八、API分组" class="headerlink" title="八、API分组"></a>八、API分组</h3><p>对应于有多个微服务的来说，每个微服务都需要对应一个Swagger界面，所以就需要API分组共功能<br>一般是在每个服务中建立自己的SwaggerConfig文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">public Docket docket1()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group1&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">@Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">public Docket docket1()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	return new Docket(DocumentationType.SWAGGER_2).groupName(&quot;group1&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><br><img src="/2021/05/21/Spring-Boot-Swagger/2.png" alt="Swagger2"><br><strong>注意在正式发布的时候，关闭swagger，出于安全考虑。而且节省运行的内存</strong><br><strong>在前端调试界面的时候用到F12,一定要用chrome，获得的信息更全</strong><br><a href="https://www.cnblogs.com/luweiweicode/p/14276170.html" target="_blank" rel="noopener">参考资料-One</a><br><a href="https://www.cnblogs.com/jpfss/p/11439560.html" target="_blank" rel="noopener">参考资料-Two</a></p>
]]></content>
      <categories>
        <category>Cloud Compute</category>
      </categories>
      <tags>
        <tag>Cloud Compute</tag>
      </tags>
  </entry>
  <entry>
    <title>Machine-Learning-Inductive-Bias</title>
    <url>/2021/05/15/Machine-Learning-Inductive-Bias/</url>
    <content><![CDATA[<h2 id="机器学习中的归纳偏好"><a href="#机器学习中的归纳偏好" class="headerlink" title="机器学习中的归纳偏好"></a>机器学习中的归纳偏好</h2><p><strong>学习，摘录自周志华老师的西瓜书-机器学习</strong>，为了节省时间公式就不编辑了<br><strong>学习</strong>得到的模型对应了假设空间中的一个假设，但由于版本空间的多样性，对于新数据会面临不同的输出空间。<br>那么对于机器学习来说必须要产生一个模型，该如何选择模型呢？<br>根据学习过程中对<strong>某种类型假设的偏好</strong><br>任何一个有效的机器学习算法必须有其归纳偏好，否则它将被假设空间中看似在训练集上”等效”的假设所迷惑，而无法产生确定的学习结果。时而对，时而错，学习的结果显然没有意义。<br><strong>归纳偏好</strong>可看作学习算法自身在一个可能很庞大的假设空间中对假设进行选择的启发式或”价值观”<br>那么如何引导算法确立”正确的”偏好呢？<br><strong>奥卡姆剃刀</strong>是一种常用的，自然科学研究中最基本的原则，即”若有多个假设与观察一致，则选最简单的那个”。如：描述更简单或方程式更简单。<br>事实上，归纳偏好对应了学习算法本身所做出的关于”什么样的模型更好”的假设。在具体的现实问题中，这个假设是否成立，即算法的归纳偏好是否与问题本身匹配，大多数时候直接决定了算法能否取得好的性能。<br><img src="/2021/05/15/Machine-Learning-Inductive-Bias/1.png" alt="Inductive-Bias"><br>上图中如果没有指出对应的场景和偏好，算法A和算法B的优劣情况是一样的。<br><img src="/2021/05/15/Machine-Learning-Inductive-Bias/2.png" alt="Inductive-Bias"><br><img src="/2021/05/15/Machine-Learning-Inductive-Bias/3.png" alt="Inductive-Bias"><br>NFL定义有一个前提，所有”问题”出现的机会相同、或所有问题同等重要。但实际上，我们只关注自己正在试图解决的问题，希望为它找到一个解决方案，至于这个解决方案在别的问题、甚至相似的问题上是否为好的方案，并不关心。<br>脱离具体问题，空谈”什么学习算法更好”毫无意义，必须针对剧吐的学习问题。学习算法自身的归纳偏好与问题是否相配，往往会起到决定性的作用。</p>
<p><strong>从样例中学习</strong>基于神经网络的连接主义学习。<br>连接主义最大的局限性是其”试错性”，学习过程涉及大量参数，而参数的设置缺乏理论指导，主要靠手工”调参”。参数调节上失之毫厘，学习结果可能谬以千里。</p>
<h3 id="机器学习的应用"><a href="#机器学习的应用" class="headerlink" title="机器学习的应用"></a>机器学习的应用</h3><p>今天，在计算机科学的诸多分支学科领域中，无论是多媒体、图形学还是网络通信、软件工程乃至体系结构、芯片设计，都能找到机器学习计数的身影，尤其是在计算机视觉、自然语言处理等领域。<br><strong>大数据时代</strong>的三大关键技术：机器学习、云计算、众包(crowdsourcing)<br>大数据时代需要对数据进行收集、存储、传输、管理，目的是为了”利用”大数据。<br><strong>分析利用大数据</strong>，会想到”数据挖掘”，那么数据挖掘和机器学习的联系是怎么样的呢？<br><strong>数据挖掘</strong>领域涉及的关键技术是:数据库、机器学习、统计学。数据库提供了海量数据管理的作用；机器学习和统计学的研究为数据挖掘提供数据分析技术。但统计学的研究成果通常需要经由机器学习研究来形成有效的学习算法，所以数据挖掘的两大关键支撑是数据库和机器学习。</p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-Boot-Config</title>
    <url>/2021/05/14/Spring-Boot-Config/</url>
    <content><![CDATA[<h2 id="SpringBoot中的一些总结内容"><a href="#SpringBoot中的一些总结内容" class="headerlink" title="SpringBoot中的一些总结内容"></a>SpringBoot中的一些总结内容</h2><h3 id="1、Spring中的-Transactional-rollbackFor-Exception-class-属性详解"><a href="#1、Spring中的-Transactional-rollbackFor-Exception-class-属性详解" class="headerlink" title="1、Spring中的@Transactional(rollbackFor=Exception.class)属性详解"></a>1、Spring中的@Transactional(rollbackFor=Exception.class)属性详解</h3><p>解释：@Transactional这是一个注解。<br>异常Exception分为运行时异常RuntimeException和非运行时异常(IOException、SQLException等)<br><strong>异常会产生的问题</strong>：线程中止，主程序终止。<br>解决方法：使用try{}catch(){} 捕获异常。程序如果出现了异常数据，正常的处理应该是把异常数据舍弃，然后记录日志。不应该由于异常数据而影响对正常数据的影响。<br>为了不让程序退出或产生编译问题，那么就需要写一大堆catch块。如何能够减少这种方式呢？<br><strong>事物管理方式</strong>: 即使出现异常情况，它也可以保证数据的一致性。<br>Spring支持编程式事物管理和声明式事物管理</p>
<ul>
<li>编程式事务管理使用TransactionTemplate或者直接使用底层的PlatformTransactionManager。对于编程式事务管理，spring推荐使用TransactionTemplate。</li>
<li>声明式事务管理建立在AOP之上的。其本质是对方法前后进行拦截，然后在目标方法开始之前创建或者加入一个事务，在执行完目标方法之后<em>根据执行情况</em>提交或者回滚事务。<br>声明式事务管理<ul>
<li>基于tx和aop名字空间的xml配置文件</li>
<li>基于@Transactional注解</li>
</ul>
</li>
</ul>
<p><strong>声明式事物管理的使用说明</strong><br>当作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。<br>在项目中，@Transactional(rollbackFor=Exception.class)，如果类加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。<br>在@Transactional注解中如果不配置rollbackFor属性,那么事物只会在遇到RuntimeException的时候才会回滚,加上rollbackFor=Exception.class,可以让事物在遇到非运行时异常时也回滚</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>类型</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>value</td>
<td>String</td>
<td>可选的限定描述符，指定使用的事务管理器</td>
</tr>
<tr>
<td>propagation</td>
<td>enum: Propagation</td>
<td>可选的事务传播行为设置</td>
</tr>
<tr>
<td>isolation</td>
<td>enum: Isolation</td>
<td>可选的事务隔离级别设置</td>
</tr>
<tr>
<td>readOnly</td>
<td>boolean</td>
<td>读写或只读事务，默认读写</td>
</tr>
<tr>
<td>timeout</td>
<td>int (in seconds granularity)</td>
<td>事务超时时间设置</td>
</tr>
<tr>
<td>rollbackFor</td>
<td>Class对象数组，必须继承自Throwable</td>
<td>导致事务回滚的异常类数组</td>
</tr>
<tr>
<td>rollbackForClassName</td>
<td>类名数组，必须继承自Throwable</td>
<td>导致事务回滚的异常类名字数组</td>
</tr>
<tr>
<td>noRollbackFor</td>
<td>Class对象数组，必须继承自Throwable</td>
<td>不会导致事务回滚的异常类数组</td>
</tr>
<tr>
<td>noRollbackForClassName</td>
<td>类名数组，必须继承自Throwable</td>
<td>不会导致事务回滚的异常类名字数组</td>
</tr>
</tbody>
</table>
</div>
<h3 id="2、Spring-Boot中pom-xml中的内容详解"><a href="#2、Spring-Boot中pom-xml中的内容详解" class="headerlink" title="2、Spring Boot中pom.xml中的内容详解"></a>2、Spring Boot中pom.xml中的内容详解</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;project xmlns&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;maven.apache.org&#x2F;POM&#x2F;4.0.0 http:&#x2F;&#x2F;maven.apache.org&#x2F;xsd&#x2F;maven-4.0.0.xsd&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;!-- 模型版本。maven2.0必须是这样写，现在是maven2唯一支持的版本 --&gt; </span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;modelVersion&gt;4.0.0&lt;&#x2F;modelVersion&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;!-- 项目组织的唯一标识符 ：对应JAVA的包的结构，是main目录里java的目录结构--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;groupId&gt;cn.mg&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;!-- 项目的唯一标志：项目名--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;artifactId&gt;FileManagement&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;!-- 项目的版本号（简明）--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;version&gt;1.0&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;!-- 打包的机制  默认为jar --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;packaging&gt;jar&lt;&#x2F;packaging&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;!-- 让用户更加能够接受的项目名 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;name&gt;FileManagement&lt;&#x2F;name&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;url&gt;http:&#x2F;&#x2F;maven.apache.org&lt;&#x2F;url&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;!-- 此项目继承的项目 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;parent&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;version&gt;1.4.2.RELEASE&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;relativePath &#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;&#x2F;parent&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;!-- 项目的基本属性配置 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;properties&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;!-- 编码格式 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;project.build.sourceEncoding&gt;UTF-8&lt;&#x2F;project.build.sourceEncoding&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;project.reporting.outputEncoding&gt;UTF-8&lt;&#x2F;project.reporting.outputEncoding&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;!-- Java版本  查看方法见下方备注1--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;java.version&gt;1.8&lt;&#x2F;java.version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;!--Hibernate版本号--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;hibernate.version&gt;5.1.12.Final&lt;&#x2F;hibernate.version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&lt;!--启动类--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;start-class&gt;cn.mg.file.FileManageApp&lt;&#x2F;start-class&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;&#x2F;properties&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;!-- 项目的依赖结构 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;dependencies&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;!--原有配置 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;version&gt;3.8.1&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;!--新增：web应用基本环境配置 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;!--新增：常用配置 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;!--Tomcat支持--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;artifactId&gt;spring-boot-starter-tomcat&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;!--scope的值：详细见下方备注2--&gt;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;scope&gt;provided&lt;&#x2F;scope&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;scope&gt;test&lt;&#x2F;scope&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;!--使用JSP必要依赖-&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;groupId&gt;org.apache.tomcat.embed&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;artifactId&gt;tomcat-embed-jasper&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;!--JSP标签库-&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;groupId&gt;javax.servlet&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;artifactId&gt;jstl&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;!--Spring aop支持:面向切面编程--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;artifactId&gt;spring-aop&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;!--事务控制Trancactions--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;artifactId&gt;spring-tx&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;!--对象关系映射 形成orm框架--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;artifactId&gt;spring-orm&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;!--jdbc支持--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;artifactId&gt;spring-jdbc&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;!--json支持--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;artifactId&gt;fastjson&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;version&gt;1.2.3&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;&#x2F;dependencies&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">	 &lt;!--构建设置，主要包含两个部分：plugins设置构建的插件和resources排除或者删除资源文件--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;build&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;!--&lt;!--使用的插件列表  此处直接用父项目的plugins--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;plugins&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;plugin&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;&#x2F;plugin&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;&#x2F;plugins&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;!--项目相关的所有资源路径列表，例如和项目相关的配置文件、属性文件，这些资源被包含在最终的打包文件里。 --&gt; </span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;resources&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;resource&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&lt;directory&gt;src&#x2F;main&#x2F;webapp&lt;&#x2F;directory&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&lt;!--将directory文件打包到targetPath--&gt; </span></pre></td></tr><tr><td class="code"><pre><span class="line">				&lt;targetPath&gt;META-INF&#x2F;resources&lt;&#x2F;targetPath&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&lt;!--包含的模式列表--&gt; </span></pre></td></tr><tr><td class="code"><pre><span class="line">				&lt;includes&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					&lt;include&gt;**&#x2F;**&lt;&#x2F;include&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&lt;&#x2F;includes&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;&#x2F;resource&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;resource&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&lt;directory&gt;src&#x2F;main&#x2F;resources&lt;&#x2F;directory&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&lt;targetPath&gt;BOOT-INF&#x2F;classes&lt;&#x2F;targetPath&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&lt;includes&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">					&lt;include&gt;**&#x2F;**&lt;&#x2F;include&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&lt;&#x2F;includes&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&lt;!--是否将资源文件中的占位符替换成对应的值  详细见下方备注3--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				&lt;filtering&gt;false&lt;&#x2F;filtering&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;&#x2F;resource&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;&#x2F;resources&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;&#x2F;build&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;project&gt;</span></pre></td></tr></table></figure>
<p>scope的取值：compile(编译范围)，provided(已提供范围)，runtime(运行时范围)，test(测试范围)，system(系统范围)</p>
<h3 id="三、查看包：-按住Ctrl-鼠标左键点进去"><a href="#三、查看包：-按住Ctrl-鼠标左键点进去" class="headerlink" title="三、查看包： 按住Ctrl+鼠标左键点进去"></a>三、查看包： 按住Ctrl+鼠标左键点进去</h3><p>查看spring-boot-dependencies-2.1.3.RELEASE.pom<br><strong>dependencyManagement</strong></p>
<ul>
<li>定义了子项目中可能出现的各种依赖及其版本号</li>
<li>子项目在需要的时候引入即可使用，不在需要定义版本号了</li>
</ul>
<p><strong>spring-boot-starter-parent</strong></p>
<ul>
<li>定义了Java编译版本为1.8</li>
<li>使用UTF-8格式编码</li>
<li>继承自 spring-boot-dependencies，这个里边定义了依赖的版本</li>
<li>执行打包操作的配置</li>
<li>自动化的资源过滤</li>
<li>自动化的插件配置</li>
<li>针对application.properties 和 application.yml 的资源过滤，包括通过 profile 定义的不同环境的配置文件<br><strong>不使用parent</strong>：可以自定义parent,继承内部的parent<br>解决方法：自行定义dependencyManagement节点，然后在里面定义好版本号<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependencyManagement&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;dependencies&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;version&gt;2.1.4.RELEASE&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;type&gt;pom&lt;&#x2F;type&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">			&lt;scope&gt;import&lt;&#x2F;scope&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">		&lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;&#x2F;dependencies&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependencyManagement&gt;</span></pre></td></tr></table></figure>
<strong>注</strong>：同样关于打包的插件、编译的JDK版本、文件的编码格式都需要自己配置</li>
</ul>
]]></content>
      <categories>
        <category>Cloud Compute</category>
      </categories>
      <tags>
        <tag>Cloud Compute</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-Boot-Mybatis</title>
    <url>/2021/05/14/Spring-Boot-Mybatis/</url>
    <content><![CDATA[<h2 id="Spring-Mabtis逆向工程"><a href="#Spring-Mabtis逆向工程" class="headerlink" title="Spring-Mabtis逆向工程"></a>Spring-Mabtis逆向工程</h2><p><strong>问题1</strong>: Could not create connection to database server<br>MySQL的版本号与pom配置中mysql-connector版本号不同<br>解决: SQL语句，select version() from dual;<br>修改版本号使两个版本号一致<br>将mysql的驱动改成: com.mysql.cj.jdbc.Driver</p>
<p><strong>问题2</strong>: The server time zone value ‘�й���׼ʱ��‘ is unrecognized<br>时区不一致，UTC是统一标准世界时间<br>解决: generatorConfig.xml中的jdbcConnect-&gt;connectionURL添加?serverTimezone=UTC<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;jdbcConnection driverClass&#x3D;&quot;com.mysql.cj.jdbc.Driver&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				connectionURL&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mydata?serverTimezone&#x3D;UTC&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				userId&#x3D;&quot;root&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">				password&#x3D;&quot;123456&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;jdbcConnection&gt;</span></pre></td></tr></table></figure><br>同时，application.properties中的spring.datasource.url改成如下内容：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#配置数据源</span></pre></td></tr><tr><td class="code"><pre><span class="line">spring.datasource.driverClassName&#x3D;com.mysql.cj.jdbc.Driver</span></pre></td></tr><tr><td class="code"><pre><span class="line">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mydata?serverTimezone&#x3D;UTC</span></pre></td></tr><tr><td class="code"><pre><span class="line">spring.datasource.username&#x3D;root</span></pre></td></tr><tr><td class="code"><pre><span class="line">spring.datasource.password&#x3D;123456</span></pre></td></tr><tr><td class="code"><pre><span class="line">#mybatis</span></pre></td></tr><tr><td class="code"><pre><span class="line">#配置mybatis的mapper.xml文件所在位置</span></pre></td></tr><tr><td class="code"><pre><span class="line">mybatis.mapper-locations&#x3D;classpath:com&#x2F;example&#x2F;springboot_mybaits01&#x2F;mapper&#x2F;*.xmls</span></pre></td></tr></table></figure></p>
<h3 id="一、逆向工程的步骤"><a href="#一、逆向工程的步骤" class="headerlink" title="一、逆向工程的步骤"></a>一、逆向工程的步骤</h3><p>1、创建generatorConfig.xml的生成器配置文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE generatorConfiguration</span></pre></td></tr><tr><td class="code"><pre><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD MyBatis Generator Configuration 1.0&#x2F;&#x2F;EN&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-generator-config_1_0.dtd&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;generatorConfiguration&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;context id&#x3D;&quot;Tables&quot; targetRuntime&#x3D;&quot;MyBatis3&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;!-- 批量插入插件 start 按需启用--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;plugin type&#x3D;&quot;com.itfsw.mybatis.generator.plugins.BatchInsertPlugin&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;property name&#x3D;&quot;allowMultiQueries&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;plugin&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;!-- 批量插入插件 end --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;!--重命名查询class名称--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;plugin type&#x3D;&quot;org.mybatis.generator.plugins.RenameExampleClassPlugin&quot; &gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;property name&#x3D;&quot;searchString&quot; value&#x3D;&quot;Example$&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;property name&#x3D;&quot;replaceString&quot; value&#x3D;&quot;Criteria&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;plugin&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;!-- 查询单条数据插件 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;plugin type&#x3D;&quot;com.itfsw.mybatis.generator.plugins.SelectOneByExamplePlugin&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;!-- MySQL分页插件 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;plugin type&#x3D;&quot;com.itfsw.mybatis.generator.plugins.LimitPlugin&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;!-- 通过配置startPage影响Example中的page方法开始分页的页码，默认分页从0开始 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;property name&#x3D;&quot;startPage&quot; value&#x3D;&quot;1&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;plugin&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;!-- 自定义注释插件 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;plugin type&#x3D;&quot;com.itfsw.mybatis.generator.plugins.CommentPlugin&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;!-- 自定义模板路径 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;property name&#x3D;&quot;template&quot; value&#x3D;&quot;src&#x2F;main&#x2F;resources&#x2F;mybatis-generator-comment.ftl&quot; &#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;plugin&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;!-- Lombok插件 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;plugin type&#x3D;&quot;com.itfsw.mybatis.generator.plugins.LombokPlugin&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;!-- @Builder 必须在 Lombok 版本 &gt;&#x3D; 1.18.2 的情况下 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;property name&#x3D;&quot;@Builder&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;!-- @NoArgsConstructor 和 @AllArgsConstructor 使用规则和Lombok一致 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;property name&#x3D;&quot;@AllArgsConstructor&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;property name&#x3D;&quot;@NoArgsConstructor&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;plugin&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;!-- xml重新生成时覆盖 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;plugin type&#x3D;&quot;org.mybatis.generator.plugins.UnmergeableXmlMappersPlugin&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;!-- 注释 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;commentGenerator&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;property name&#x3D;&quot;javaFileEncoding&quot; value&#x3D;&quot;UTF-8&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;commentGenerator&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;!-- JDBC连接 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;jdbcConnection</span></pre></td></tr><tr><td class="code"><pre><span class="line">                driverClass&#x3D;&quot;com.mysql.cj.jdbc.Driver&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                connectionURL&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis_generator_demo?serverTimezone&#x3D;UTC&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                userId&#x3D;&quot;root&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                password&#x3D;&quot;123456&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;!-- 针对mysql数据库 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;property name&#x3D;&quot;useInformationSchema&quot; value&#x3D;&quot;true&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;jdbcConnection&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;!-- 非必需，类型处理器，在数据库类型和java类型之间的转换控制--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;!-- 默认false，把JDBC DECIMAL 和 NUMERIC 类型解析为 Integer，为 true时把JDBC DECIMAL 和</span></pre></td></tr><tr><td class="code"><pre><span class="line">         NUMERIC 类型解析为java.math.BigDecimal --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;javaTypeResolver&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;!-- 是否使用bigDecimal， false可自动转化以下类型（Long, Integer, Short, etc.） --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;property name&#x3D;&quot;forceBigDecimals&quot; value&#x3D;&quot;false&quot; &#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;javaTypeResolver&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;!-- domain领域模型  其中targetPackage需要根据你自己创建的目录进行改动 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;javaModelGenerator targetPackage&#x3D;&quot;com.chiaki.mybatisgeneratordemo.domain&quot; targetProject&#x3D;&quot;src&#x2F;main&#x2F;java&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;!-- 从数据库返回的值被清理前后的空格 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;property name&#x3D;&quot;trimStrings&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;javaModelGenerator&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;!-- mapper xml文件 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;sqlMapGenerator targetPackage&#x3D;&quot;mapper&quot;  targetProject&#x3D;&quot;src&#x2F;main&#x2F;resources&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;!-- enableSubPackages:是否让schema作为包的后缀 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;sqlMapGenerator&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;!-- Mapper接口 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;javaClientGenerator targetPackage&#x3D;&quot;com.chiaki.mybatisgeneratordemo.mapper&quot; targetProject&#x3D;&quot;src&#x2F;main&#x2F;java&quot; type&#x3D;&quot;XMLMAPPER&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;property name&#x3D;&quot;enableSubPackages&quot; value&#x3D;&quot;true&quot; &#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;javaClientGenerator&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;!-- 配置表信息 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;!-- tableName为对应的数据库表 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;table tableName&#x3D;&quot;student_info&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;property name&#x3D;&quot;useActualColumnNames&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;generatedKey column&#x3D;&quot;id&quot; sqlStatement&#x3D;&quot;Mysql&quot; identity&#x3D;&quot;true&quot; &#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;table&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;table tableName&#x3D;&quot;class_info&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;property name&#x3D;&quot;useActualColumnNames&quot; value&#x3D;&quot;false&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;generatedKey column&#x3D;&quot;id&quot; sqlStatement&#x3D;&quot;Mysql&quot; identity&#x3D;&quot;true&quot; &#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;table&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;context&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;generatorConfiguration&gt;</span></pre></td></tr></table></figure><br>2、创建启动类配置文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># spring配置</span></pre></td></tr><tr><td class="code"><pre><span class="line">spring:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  # 数据库配置</span></pre></td></tr><tr><td class="code"><pre><span class="line">  datasource:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    driver-class-name: com.mysql.cj.jdbc.Driver</span></pre></td></tr><tr><td class="code"><pre><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis_generator_demo?serverTimezone&#x3D;UTC</span></pre></td></tr><tr><td class="code"><pre><span class="line">    username: root</span></pre></td></tr><tr><td class="code"><pre><span class="line">    password: 123456</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">mybatis:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  # 指定xml文件的位置</span></pre></td></tr><tr><td class="code"><pre><span class="line">  mapper-locations: classpath:mapper&#x2F;*.xml</span></pre></td></tr><tr><td class="code"><pre><span class="line">  # 指定domain文件的位置</span></pre></td></tr><tr><td class="code"><pre><span class="line">  type-aliases-package: com.chiaki.domain</span></pre></td></tr><tr><td class="code"><pre><span class="line">  # 添加日志实现类以打印日志</span></pre></td></tr><tr><td class="code"><pre><span class="line">  configuration:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># 服务器配置</span></pre></td></tr><tr><td class="code"><pre><span class="line">server:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  # 指定端口</span></pre></td></tr><tr><td class="code"><pre><span class="line">  port: 8079</span></pre></td></tr></table></figure><br>3、创建数据库和表，并导入<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- ----------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">-- Table structure for sys_quartz_job</span></pre></td></tr><tr><td class="code"><pre><span class="line">-- ----------------------------</span></pre></td></tr><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS &#96;sys_quartz_job&#96;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;sys_quartz_job&#96; (</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#96;job_id&#96; bigint(20) NOT NULL AUTO_INCREMENT COMMENT &#39;ID&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#96;bean_name&#96; varchar(255) DEFAULT NULL COMMENT &#39;Spring Bean名称&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#96;cron_expression&#96; varchar(255) DEFAULT NULL COMMENT &#39;cron 表达式&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#96;is_pause&#96; bit(1) DEFAULT NULL COMMENT &#39;状态：1暂停、0启用&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#96;job_name&#96; varchar(255) DEFAULT NULL COMMENT &#39;任务名称&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#96;method_name&#96; varchar(255) DEFAULT NULL COMMENT &#39;方法名称&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#96;params&#96; varchar(255) DEFAULT NULL COMMENT &#39;参数&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#96;description&#96; varchar(255) DEFAULT NULL COMMENT &#39;备注&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#96;person_in_charge&#96; varchar(100) DEFAULT NULL COMMENT &#39;负责人&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#96;sub_task&#96; varchar(100) DEFAULT NULL COMMENT &#39;子任务ID&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#96;pause_after_failure&#96; bit(1) DEFAULT NULL COMMENT &#39;任务失败后是否暂停&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#96;create_by&#96; varchar(255) DEFAULT NULL COMMENT &#39;创建者&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#96;update_by&#96; varchar(255) DEFAULT NULL COMMENT &#39;更新者&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#96;create_time&#96; datetime DEFAULT NULL COMMENT &#39;创建日期&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#96;update_time&#96; datetime DEFAULT NULL COMMENT &#39;更新时间&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  PRIMARY KEY (&#96;job_id&#96;) USING BTREE,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  KEY &#96;inx_is_pause&#96; (&#96;is_pause&#96;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;7 DEFAULT CHARSET&#x3D;utf8 ROW_FORMAT&#x3D;COMPACT COMMENT&#x3D;&#39;定时任务&#39;;</span></pre></td></tr></table></figure><br>4、添加依赖文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;version&gt;8.0.17&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &lt;version&gt;2.0.0&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;build&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;plugins&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &lt;plugin&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &lt;configuration&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   &lt;excludes&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                       &lt;exclude&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                           &lt;groupId&gt;org.projectlombok&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                           &lt;artifactId&gt;lombok&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                       &lt;&#x2F;exclude&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   &lt;&#x2F;excludes&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &lt;&#x2F;configuration&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &lt;&#x2F;plugin&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &lt;plugin&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &lt;groupId&gt;org.mybatis.generator&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &lt;version&gt;1.3.7&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &lt;configuration&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   &lt;!-- 是否覆盖，true表示会替换生成的Java文件，false则不覆盖 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   &lt;overwrite&gt;true&lt;&#x2F;overwrite&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   &lt;verbose&gt;true&lt;&#x2F;verbose&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &lt;&#x2F;configuration&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &lt;dependencies&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   &lt;!--mysql驱动包--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                       &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                       &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                       &lt;version&gt;8.0.17&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   &lt;!-- mybatis 生成扩展包 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   &lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                       &lt;groupId&gt;com.itfsw&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                       &lt;artifactId&gt;mybatis-generator-plugin&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                       &lt;version&gt;1.3.2&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                   &lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &lt;&#x2F;dependencies&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">           &lt;&#x2F;plugin&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;&#x2F;plugins&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &lt;&#x2F;build&gt;</span></pre></td></tr></table></figure><br>双击: View-&gt;Tool Windows-&gt;Maven-&gt;Plugins-&gt;mybatis-generator-&gt;mybatis-generator:generate<br>产生: java目录下domain和mapper文件夹，resource下产生mapper文件夹</p>
<h3 id="二、逆向工程生成的方法的使用"><a href="#二、逆向工程生成的方法的使用" class="headerlink" title="二、逆向工程生成的方法的使用"></a>二、逆向工程生成的方法的使用</h3><p>如: selectByExample(example)这个example是什么，如何使用？<br><strong>说明：</strong> example用于添加条件，相当于where后面的部分<br>逆向工程生成的文件XxxExample.java中包含一个static的内部类Criteria，Criteria中的方法是定义SQL 语句where后的查询条件。<br>1、查询：selectByPrimaryKey()<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">User user &#x3D; XxxMapper.selectByPrimaryKey(100); &#x2F;&#x2F;相当于select * from user where id &#x3D; 100。</span></pre></td></tr></table></figure><br>2、查询：selectByExample()<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UserExample example &#x3D; new UserExample();</span></pre></td></tr><tr><td class="code"><pre><span class="line">Criteria criteria &#x3D; example.createCriteria();</span></pre></td></tr><tr><td class="code"><pre><span class="line">criteria.andUsernameEqualTo(&quot;wyw&quot;);    &#x2F;&#x2F;where条件</span></pre></td></tr><tr><td class="code"><pre><span class="line">criteria.andUsernameIsNull();					&#x2F;&#x2F;where条件</span></pre></td></tr><tr><td class="code"><pre><span class="line">example.setOrderByClause(&quot;username asc,email desc&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">List&lt;?&gt;list &#x3D; XxxMapper.selectByExample(example);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;相当于：select * from user where username &#x3D; &#39;wyw&#39; and  username is null order by username asc,email desc</span></pre></td></tr></table></figure><br>3、更新数据：updateByExample()<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UserExample example &#x3D; new UserExample();</span></pre></td></tr><tr><td class="code"><pre><span class="line">Criteria criteria &#x3D; example.createCriteria();</span></pre></td></tr><tr><td class="code"><pre><span class="line">criteria.andUsernameEqualTo(&quot;admin&quot;);   &#x2F;&#x2F;where条件</span></pre></td></tr><tr><td class="code"><pre><span class="line">User user &#x3D; new User();</span></pre></td></tr><tr><td class="code"><pre><span class="line">user.setPassword(&quot;wyw&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">XxxMapper.updateByPrimaryKeySelective(user,example);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;相当于：update user set password&#x3D;&#39;wyw&#39; where username&#x3D;&#39;admin&#39;</span></pre></td></tr></table></figure><br>4、删除数据：deleteByExample()<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">UserExample example &#x3D; new UserExample();</span></pre></td></tr><tr><td class="code"><pre><span class="line">Criteria criteria &#x3D; example.createCriteria();</span></pre></td></tr><tr><td class="code"><pre><span class="line">criteria.andUsernameEqualTo(&quot;admin&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">XxxMapper.deleteByExample(example);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;相当于：delete from user where username&#x3D;&#39;admin&#39;</span></pre></td></tr></table></figure></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>example.setOrderByClause(“字段名ASC”)</td>
<td>添加升序排列条件，DESC为降序</td>
</tr>
<tr>
<td>example.setDistinct(false)</td>
<td>去除重复，boolean型，true为选择不重复的记录</td>
</tr>
<tr>
<td>criteria.andXxxIsNull</td>
<td>添加字段xxx为null的条件</td>
</tr>
<tr>
<td>criteria.andXxxIsNotNull</td>
<td>添加字段xxx不为null的条件</td>
</tr>
<tr>
<td>criteria.andXxxEqualTo(value)</td>
<td>添加xxx字段等于value条件</td>
</tr>
<tr>
<td>criteria.andXxxNotEqualTo(value)</td>
<td>添加xxx字段不等于value条件</td>
</tr>
<tr>
<td>criteria.andXxxGreaterThan(value)</td>
<td>添加xxx字段大于value条件</td>
</tr>
<tr>
<td>criteria.andXxxGreaterThanOrEqualTo(value)</td>
<td>添加xxx字段大于等于value条件</td>
</tr>
<tr>
<td>criteria.andXxxLessThan(value)</td>
<td>添加xxx字段小于value条件</td>
</tr>
<tr>
<td>criteria.andXxxLessThanOrEqualTo(value)</td>
<td>添加xxx字段小于等于value条件</td>
</tr>
<tr>
<td>criteria.andXxxIn(List&lt;?&gt;)</td>
<td>添加xxx字段值在List&lt;?&gt;条件</td>
</tr>
<tr>
<td>criteria.andXxxNotIn(List&lt;?&gt;)</td>
<td>添加xxx字段值不在List&lt;?&gt;条件</td>
</tr>
<tr>
<td>criteria.andXxxLike(“%”+value+”%”)</td>
<td>添加xxx字段值为value的模糊查询条件</td>
</tr>
<tr>
<td>criteria.andXxxNotLike(“%”+value+”%”)</td>
<td>添加xxx字段值不为value的模糊查询条件</td>
</tr>
<tr>
<td>criteria.andXxxBetween(value1,value2)</td>
<td>添加xxx字段值在value1和value2之间条件</td>
</tr>
<tr>
<td>criteria.andXxxNotBetween(value1,value2)</td>
<td>添加xxx字段值不在value1和value2之间条件</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>Cloud Compute</category>
      </categories>
      <tags>
        <tag>Cloud Compute</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-Boot-Maven-Plugin</title>
    <url>/2021/05/14/Spring-Boot-Maven-Plugin/</url>
    <content><![CDATA[<h2 id="spring-boot-maven-plugin"><a href="#spring-boot-maven-plugin" class="headerlink" title="spring-boot-maven-plugin"></a>spring-boot-maven-plugin</h2><p>springboot框架提供了一套自己的打包机制，是通过spring-boot-maven-plugin插件来实现的。</p>
<h3 id="1、spring-boot-maven-plugin引入pom"><a href="#1、spring-boot-maven-plugin引入pom" class="headerlink" title="1、spring-boot-maven-plugin引入pom"></a>1、spring-boot-maven-plugin引入pom</h3><p>对于新建的一个springboot项目来说，pom中会加入插件：<br><img src="/2021/05/14/Spring-Boot-Maven-Plugin/1.png" alt="maven"><br>通过idea可以看到maven中包含了spring-boot-maven-plugin插件：<br><img src="/2021/05/14/Spring-Boot-Maven-Plugin/2.png" alt="maven"></p>
<ul>
<li>build-info：生成项目的构建信息文件 build-info.properties</li>
<li>repackage：这个是默认 goal，在 mvn package 执行之后，这个命令再次打包生成可执行的 jar，同时将 mvn package 生成的 jar 重命名为 *.origin</li>
<li>run：这个可以用来运行 Spring Boot 应用</li>
<li>start：这个在 mvn integration-test 阶段，进行 Spring Boot 应用生命周期的管理</li>
<li>stop：这个在 mvn integration-test 阶段，进行 Spring Boot 应用生命周期的管理<h3 id="2、执行打包命令"><a href="#2、执行打包命令" class="headerlink" title="2、执行打包命令"></a>2、执行打包命令</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mvn clean package</span></pre></td></tr></table></figure>
或通过开发工具，如idea执行clean和package命令，View-&gt;Tool Windows-&gt;Maven<br><img src="/2021/05/14/Spring-Boot-Maven-Plugin/3.png" alt="maven"><br>可以生成jar包，使用java -jar xxxxx.jar启动<h3 id="3、jar内部结构"><a href="#3、jar内部结构" class="headerlink" title="3、jar内部结构"></a>3、jar内部结构</h3>解压jar文件，可以获取到如下结构：<br><img src="/2021/05/14/Spring-Boot-Maven-Plugin/4.png" alt="maven"><br>其中BOOT-INF主要是一些启动信息，包含classes和lib文件，classes文件放的是项目里生成的字节文件class和配置文件，lib文件是项目所需要的jar依赖。<br><strong>下面的POM代码段显示了如何控制在uber JAR中应该包含/排除哪些项目依赖关系：</strong><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;project&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;build&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;plugins&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;plugin&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;artifactId&gt;maven-shade-plugin&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;version&gt;3.0.0&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;executions&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &lt;execution&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;phase&gt;package&lt;&#x2F;phase&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;goals&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &lt;goal&gt;shade&lt;&#x2F;goal&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;&#x2F;goals&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;configuration&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &lt;artifactSet&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &lt;excludes&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &lt;exclude&gt;classworlds:classworlds&lt;&#x2F;exclude&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &lt;exclude&gt;junit:junit&lt;&#x2F;exclude&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &lt;exclude&gt;jmock:*&lt;&#x2F;exclude&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &lt;exclude&gt;*:xml-apis&lt;&#x2F;exclude&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &lt;exclude&gt;org.apache.maven:lib:tests&lt;&#x2F;exclude&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &lt;exclude&gt;log4j:log4j:jar:&lt;&#x2F;exclude&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &lt;&#x2F;excludes&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">              &lt;&#x2F;artifactSet&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;&#x2F;configuration&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          &lt;&#x2F;execution&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;executions&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;&#x2F;plugin&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;plugins&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;&#x2F;build&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;project&gt;</span></pre></td></tr></table></figure>
<a href="https://developer.aliyun.com/article/632130" target="_blank" rel="noopener">参考资料</a></li>
</ul>
]]></content>
      <categories>
        <category>Cloud Compute</category>
      </categories>
      <tags>
        <tag>Cloud Compute</tag>
      </tags>
  </entry>
  <entry>
    <title>Compute-Network-RDP</title>
    <url>/2021/05/09/Compute-Network-RDP/</url>
    <content><![CDATA[<h2 id="远程桌面-RDP"><a href="#远程桌面-RDP" class="headerlink" title="远程桌面(RDP)"></a>远程桌面(RDP)</h2><h3 id="RDP介绍"><a href="#RDP介绍" class="headerlink" title="RDP介绍"></a>RDP介绍</h3><p>RDP 基于 T-120 系列协议标准，是该协议的扩展。 支持多通道的协议允许单独的虚拟通道用于传输以下信息：</p>
<ul>
<li>演示文稿数据</li>
<li>串行设备通信</li>
<li>许可信息</li>
<li>高度加密的数据，如键盘、鼠标活动</li>
</ul>
<h3 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h3><p>用于终端服务器和终端服务器客户端之间的通信。RDP 旨在支持许多不同类型的网络拓扑，例如 ISDN、POTS。 RDP 还设计用于支持许多 LAN 协议，例如 IPX、NetBIOS、TCP/IP。 当前版本的 RDP 将仅通过 TCP/IP 运行。 通过客户反馈，以后的版本中可能会添加其他协议支持。<br>通过 RDP 堆栈发送和接收数据所涉及的活动基本上与当今常见 LAN 网络七层 OSI 模型标准相同。 要传输的应用程序或服务的数据通过协议堆栈向下传递。 它经过分节，通过 MCS (定向到) 、加密、封装、帧、打包到网络协议，最后通过线路寻址并发送到客户端。 返回的数据的工作方式仅相反。 数据包将去除其地址，然后解包、解密等。 最后，数据呈现给应用程序供使用。 协议堆栈修改的关键部分发生在第四层和第七层之间，其中数据为：</p>
<ul>
<li>encrypted</li>
<li>已封装</li>
<li>framed</li>
<li>定向到频道</li>
<li>已设置优先级</li>
</ul>
<h3 id="RDP历程"><a href="#RDP历程" class="headerlink" title="RDP历程"></a>RDP历程</h3><p>windows从NT开始提供终端服务，它是微软买来的网络协议技术(Citrix)，服务器端要安装、配置以供客户端连接使用。终端服务使任何一台有权限的终端机，用已知的账号登录服务器，可以使用账号内的资源，包括软件，硬件资源；同时，在协议升级后，客户端连接后可以使用本地的资源，包括本地打印机、声音本地回放，本地磁盘资源和本地硬件接口。所有的计算都在服务器端进行，客户端只需要处理网络连接、接收数据、界面显示和设备数据输出。</p>
<h3 id="RDP协议层次"><a href="#RDP协议层次" class="headerlink" title="RDP协议层次"></a>RDP协议层次</h3><div class="table-container">
<table>
<thead>
<tr>
<th>层次名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>网络连接层</td>
<td>RDP协议建立在TCP/IP协议之上，由于传输的数据量比较大，因此在协议的底层首先定义一层网络连接层。它定义了一个完整的RDP数据逻辑包，以避免由于网络包长度过长而被分割使数据丢失。</td>
</tr>
<tr>
<td>ISO数据层</td>
<td>在网络连接层之上是ISO数据层，它表示RDP数据的正常连接通信。</td>
</tr>
<tr>
<td>虚拟通道层</td>
<td>在ISO数据层之上，RDP协议定义一个虚拟通道层，用以拆分标示不同虚拟通道的数据，加快客户端处理速度，节省占用网络接口的时间。</td>
</tr>
<tr>
<td>加密解密层</td>
<td>在虚拟通道层之上，RDP定义一个数据加密解密层。此层用于对所有的功能数据进行加密、解密处理。</td>
</tr>
<tr>
<td>功能数据层</td>
<td>在加密解密层之上是功能数据，画面信息，本地资源转换，声音数据，打印数据等所有的功能数据信息都在此层进行处理。另外，根据数据类型的不同，这些数据都有各自不同层次的分割，他们的内部层次结构将在各个功能模块中进行阐述。</td>
</tr>
</tbody>
</table>
</div>
<p><strong>连接过程</strong></p>
<ol>
<li>客户端连接服务器</li>
<li>ISO数据层建立连接</li>
<li>发送初始协议相关信息，接受加密、解密密钥</li>
<li>虚拟通道申请</li>
<li>加密形式发送客户端系统信息，同时验证加密协议</li>
<li>平台软件证书验证</li>
<li>各功能建立连接，各功能数据传输，功能实现</li>
</ol>
<h3 id="RDP个模块说明"><a href="#RDP个模块说明" class="headerlink" title="RDP个模块说明"></a>RDP个模块说明</h3><ol>
<li>ISO连接模块:在客户端与服务器的网络套接口建立之后，需要首先建立RDP协议底层连接，得到连接确认后才能正常通信。</li>
<li>协议信息初始模块:当基本的RDP连接建立后，需要进行客户端与服务器的系统环境、RDP连接环境的信息交流与连接确认。</li>
<li>通道申请模块:各种功能数据都是通过单独的虚拟通道传输的。初始连接后，在进一步的信息通信之前，需要开辟相应的通道<ul>
<li>根据当前我们所掌握的信息，RDP协议将图像信息、声音信息、设备信息、剪贴板内容都各自以单一的虚拟通道进行传送，而打印机映射，磁盘映射，端口映射都做为设备信息的内容进行处理</li>
</ul>
</li>
<li>系统初始连接模块:当通道申请各部分通过后，开始系统登录的初始连接。从此数据包开始,所以虚拟通道层以上的网络数据都需要加密。</li>
<li>图形连接模块:在图形数据发送之前，服务器需要对此功能模块验证，验证内容是所有与图形相关的信息，包括鼠标设置、键盘输入、字体类型、画图命令格式、图形显示的各种类型。</li>
</ol>
]]></content>
      <categories>
        <category>Compute-Network</category>
      </categories>
      <tags>
        <tag>Compute-Network</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-WebSocket</title>
    <url>/2021/05/09/Spring-WebSocket/</url>
    <content><![CDATA[<h2 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h2><h3 id="为什么需要WebSocket"><a href="#为什么需要WebSocket" class="headerlink" title="为什么需要WebSocket"></a>为什么需要WebSocket</h3><ol>
<li>HTTP 协议是一种无状态的、无连接的、单向的应用层协议。它采用了请求/响应模型。通信请求只能由客户端发起，服务端对请求做出应答处理。这种通信模型有一个弊端：HTTP 协议无法实现服务器主动向客户端发起消息。</li>
<li>WebSocket 是 HTML5 开始提供的一种在单个 TCP 连接上进行全双工通讯的协议。</li>
<li>WebSocket 使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在 WebSocket API 中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。在 WebSocket API 中，浏览器和服务器只需要做一个握手的动作，然后，浏览器和服务器之间就形成了一条快速通道。两者之间就直接可以数据互相传送。</li>
<li>HTML5 定义的 WebSocket 协议，能更好的节省服务器资源和带宽，并且能够更实时地进行通讯。</li>
<li>浏览器通过 JavaScript 向服务器发出建立 WebSocket 连接的请求，连接建立以后，客户端和服务器端就可以通过 TCP 连接直接交换数据。</li>
</ol>
<h3 id="WebSocket与Html的对比"><a href="#WebSocket与Html的对比" class="headerlink" title="WebSocket与Html的对比"></a>WebSocket与Html的对比</h3><ul>
<li>WebSocket是一种通信协议，区别于HTTP协议，HTTP协议只能实现客户端请求，服务端响应的这种单项通信。</li>
<li>现在，很多网站为了实现推送技术，所用的技术都是 Ajax 轮询。轮询是在特定的的时间间隔（如每1秒），由浏览器对服务器发出HTTP请求，然后由服务器返回最新的数据给客户端的浏览器。这种传统的模式带来很明显的缺点，即浏览器需要不断的向服务器发出请求，然而HTTP请求可能包含较长的头部，其中真正有效的数据可能只是很小的一部分，显然这样会浪费很多的带宽等资源。</li>
</ul>
<h3 id="几种与服务端实时通信的方法"><a href="#几种与服务端实时通信的方法" class="headerlink" title="几种与服务端实时通信的方法"></a>几种与服务端实时通信的方法</h3><p>在不使用WebSocket与服务器实时交互时，一般，使用AJAX轮询和Long Polling长轮询<br>AJAX轮询也就是定时发送请求，也就是普通的客户端与服务端通信过程。每次都需要新建连接，服务器响应后连接关闭，十分的耗费资源。Long Polling长轮询在服务端带有阻塞。客户端发起一个Long Polling,服务端如果没有数据返回的话，会blocking住请求，等有数据时返回给客户端，单次连接结束。客户端在向服务端建立连接。重复。。。<br><img src="/2021/05/09/Spring-WebSocket/1.png" alt="WebSocket"></p>
<h3 id="WebSocket连接过程"><a href="#WebSocket连接过程" class="headerlink" title="WebSocket连接过程"></a>WebSocket连接过程</h3><p>客户端发起HTTP握手，告诉服务端进行WebSocket协议通讯，并告知WebSocket协议版本。服务端确认协议版本，升级为WebSocket协议。之后如果有数据需要推送，会主动推送给客户端。<br>连接开始时，客户端使用HTTP协议和服务端升级协议，升级完成后，后续数据交换遵循WebSocket协议。我们看看Request Headers<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Accept-Encoding: gzip, deflate, br</span></pre></td></tr><tr><td class="code"><pre><span class="line">Accept-Language: zh,zh-TW;q&#x3D;0.9,en-US;q&#x3D;0.8,en;q&#x3D;0.7,zh-CN;q&#x3D;0.6</span></pre></td></tr><tr><td class="code"><pre><span class="line">Cache-Control: no-cache</span></pre></td></tr><tr><td class="code"><pre><span class="line">Connection: Upgrade</span></pre></td></tr><tr><td class="code"><pre><span class="line">Host: 127.0.0.1:3000</span></pre></td></tr><tr><td class="code"><pre><span class="line">Origin: http:&#x2F;&#x2F;localhost:3000</span></pre></td></tr><tr><td class="code"><pre><span class="line">Pragma: no-cache</span></pre></td></tr><tr><td class="code"><pre><span class="line">Sec-WebSocket-Extensions: permessage-deflate; client_max_window_bits</span></pre></td></tr><tr><td class="code"><pre><span class="line">Sec-WebSocket-Key: bwb9SFiJONXhQ&#x2F;A4pLaXIg&#x3D;&#x3D;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Sec-WebSocket-Version: 13</span></pre></td></tr><tr><td class="code"><pre><span class="line">Upgrade: websocket</span></pre></td></tr></table></figure><br>重点的描述信息：</p>
<ul>
<li>Connection: Upgrade 表示要升级协议</li>
<li>Upgrade: websocket 要升级协议到websocket协议</li>
<li>Sec-WebSocket-Version 表示websocket的版本。如果服务端不支持该版本，需要返回一个Sec-WebSocket-Versionheader，里面包含服务端支持的版本号。</li>
<li>Sec-WebSocket-Key 对应服务端响应头的Sec-WebSocket-Accept，由于没有同源限制，websocket客户端可任意连接支持websocket的服务。这个就相当于一个钥匙一把锁，避免多余的，无意义的连接。</li>
</ul>
<p>服务端响应：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Connection: Upgrade</span></pre></td></tr><tr><td class="code"><pre><span class="line">Sec-WebSocket-Accept: 2jrbCWSCPlzPtxarlGTp4Y8XD20&#x3D;</span></pre></td></tr><tr><td class="code"><pre><span class="line">Upgrade: websocket</span></pre></td></tr></table></figure></p>
<ul>
<li>Sec-WebSocket-Accept: 用来告知客服端，服务器愿意发起一个websocket连接， 值根据客户端请求头的Sec-WebSocket-Key计算出来</li>
</ul>
<h3 id="WebSocket的用法"><a href="#WebSocket的用法" class="headerlink" title="WebSocket的用法"></a>WebSocket的用法</h3><p>当你获取 Web Socket 连接后，你可以通过<strong>send()</strong>方法来向服务器发送数据，并通过<strong>onmessage</strong>事件来接收服务器返回的数据。WebSocket 对象提供了用于创建和管理 WebSocket 连接，以及可以通过该连接发送和接收数据的 API。<br>使用 WebSocket() 构造函数来构造一个 WebSocket。</p>
<p>构造函数: WebSocket(url[, protocols]),返回一个WebSocket对象。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>Constant</th>
<th>Value</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>WebSocket.CONNECTING</td>
<td>0</td>
<td>表示连接尚未建立</td>
</tr>
<tr>
<td>WebSocket.OPEN</td>
<td>1</td>
<td>表示连接已建立，可以进行通信</td>
</tr>
<tr>
<td>WebSocket.CLOSING</td>
<td>2</td>
<td>表示连接正在进行关闭</td>
</tr>
<tr>
<td>WebSocket.CLOSED</td>
<td>3</td>
<td>表示连接已经关闭或者连接不能打开</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>WebSocket.binaryType</td>
<td>使用二进制的数据类型连接</td>
</tr>
<tr>
<td>WebSocket.bufferedAmount</td>
<td>未发送至服务器的字节数</td>
</tr>
<tr>
<td>WebSocket.extensions</td>
<td>服务器选择的扩展</td>
</tr>
<tr>
<td>WebSocket.onclose</td>
<td>用于指定连接关闭后的回调函数</td>
</tr>
<tr>
<td>WebSocket.onerror</td>
<td>用于指定连接失败后的回调函数</td>
</tr>
<tr>
<td>WebSocket.onmessage</td>
<td>用于指定当从服务器接受到信息时的回调函数</td>
</tr>
<tr>
<td>WebSocket.onopen</td>
<td>用于指定连接成功后的回调函数</td>
</tr>
<tr>
<td>WebSocket.protocol</td>
<td>服务器选择的下属协议(只读)</td>
</tr>
<tr>
<td>WebSocket.readyState</td>
<td>当前的链接状态只读)</td>
</tr>
<tr>
<td>WebSocket.url</td>
<td>WebSocket 的绝对路径只读)</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>解释</th>
</tr>
</thead>
<tbody>
<tr>
<td>WebSocket.close([code[, reason]])</td>
<td>关闭当前链接</td>
</tr>
<tr>
<td>WebSocket.send(data)</td>
<td>对要传输的数据进行排队</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>事件</th>
<th>事件处理程序</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>open</td>
<td>Socket.onopen</td>
<td>连接建立时触发</td>
</tr>
<tr>
<td>message</td>
<td>Socket.onmessage</td>
<td>客户端接收服务端数据时触发</td>
</tr>
<tr>
<td>error</td>
<td>Socket.onerror</td>
<td>通信发生错误时触发</td>
</tr>
<tr>
<td>close</td>
<td>Socket.onclose</td>
<td>连接关闭时触发</td>
</tr>
</tbody>
</table>
</div>
<p><em>也可以使用addEventListener()来监听上面的事件</em><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Create WebSocket connection.</span></pre></td></tr><tr><td class="code"><pre><span class="line">const socket &#x3D; new WebSocket(&#39;ws:&#x2F;&#x2F;localhost:8080&#39;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Connection opened</span></pre></td></tr><tr><td class="code"><pre><span class="line">socket.addEventListener(&#39;open&#39;, function (event) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    socket.send(&#39;Hello Server!&#39;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; Listen for messages</span></pre></td></tr><tr><td class="code"><pre><span class="line">socket.addEventListener(&#39;message&#39;, function (event) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    console.log(&#39;Message from server &#39;, event.data);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;);</span></pre></td></tr></table></figure></p>
<h3 id="WebSocket实例"><a href="#WebSocket实例" class="headerlink" title="WebSocket实例"></a>WebSocket实例</h3><p>WebSocket 协议本质上是一个基于 TCP 的协议。</p>
<p>为了建立一个 WebSocket 连接，客户端浏览器首先要向服务器发起一个 HTTP 请求，这个请求和通常的 HTTP 请求不同，包含了一些附加头信息，其中附加头信息”Upgrade: WebSocket”表明这是一个申请协议<strong>升级</strong>的 HTTP 请求，服务器端解析这些附加的头信息然后产生应答信息返回给客户端，客户端和服务器端的 WebSocket 连接就建立起来了，双方就可以通过这个连接通道自由的传递信息，并且这个连接会持续存在直到客户端或者服务器端的某一方主动的关闭连接。</p>
<h3 id="客户端的HTML和JavaScript"><a href="#客户端的HTML和JavaScript" class="headerlink" title="客户端的HTML和JavaScript"></a>客户端的HTML和JavaScript</h3><p>目前大部分浏览器支持 WebSocket() 接口，你可以在以下浏览器中尝试实例： Chrome, Mozilla, Opera 和 Safari。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;html&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &lt;head&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &lt;title&gt;菜鸟教程(runoob.com)&lt;&#x2F;title&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         function WebSocketTest()</span></pre></td></tr><tr><td class="code"><pre><span class="line">         &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            if (&quot;WebSocket&quot; in window)</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               alert(&quot;您的浏览器支持 WebSocket!&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">               </span></pre></td></tr><tr><td class="code"><pre><span class="line">               &#x2F;&#x2F; 打开一个 web socket</span></pre></td></tr><tr><td class="code"><pre><span class="line">               var ws &#x3D; new WebSocket(&quot;ws:&#x2F;&#x2F;localhost:9998&#x2F;echo&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                </span></pre></td></tr><tr><td class="code"><pre><span class="line">               ws.onopen &#x3D; function()</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#x2F;&#x2F; Web Socket 已连接上，使用 send() 方法发送数据</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  ws.send(&quot;发送数据&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  alert(&quot;数据发送中...&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                </span></pre></td></tr><tr><td class="code"><pre><span class="line">               ws.onmessage &#x3D; function (evt) </span></pre></td></tr><tr><td class="code"><pre><span class="line">               &#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">                  var received_msg &#x3D; evt.data;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  alert(&quot;数据已接收...&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                </span></pre></td></tr><tr><td class="code"><pre><span class="line">               ws.onclose &#x3D; function()</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &#123; </span></pre></td></tr><tr><td class="code"><pre><span class="line">                  &#x2F;&#x2F; 关闭 websocket</span></pre></td></tr><tr><td class="code"><pre><span class="line">                  alert(&quot;连接已关闭...&quot;); </span></pre></td></tr><tr><td class="code"><pre><span class="line">               &#125;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            </span></pre></td></tr><tr><td class="code"><pre><span class="line">            else</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">               &#x2F;&#x2F; 浏览器不支持 WebSocket</span></pre></td></tr><tr><td class="code"><pre><span class="line">               alert(&quot;您的浏览器不支持 WebSocket!&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;&#x2F;script&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">   &lt;&#x2F;head&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   &lt;body&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   </span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;div id&#x3D;&quot;sse&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         &lt;a href&#x3D;&quot;javascript:WebSocketTest()&quot;&gt;运行 WebSocket&lt;&#x2F;a&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      &lt;&#x2F;div&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      </span></pre></td></tr><tr><td class="code"><pre><span class="line">   &lt;&#x2F;body&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;html&gt;</span></pre></td></tr></table></figure></p>
<h3 id="Spring中WebSocket的使用"><a href="#Spring中WebSocket的使用" class="headerlink" title="Spring中WebSocket的使用"></a>Spring中WebSocket的使用</h3><p>1、添加jar包：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;artifactId&gt;spring-websocket&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &lt;version&gt;$&#123;spring.version&#125;&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependency&gt;</span></pre></td></tr></table></figure><br>2、如何使用WebSocket<br>2.1 创建WebSocket处理器<br>扩展<strong>TextWebSocketHandler</strong>或<strong>BinaryWebSocketHandler</strong>,或实现<strong>WebSocketHandler</strong>,覆盖指定的方法。Spring在收到WebSocket事件时，会自动调用事件对应的方法。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.springframework.web.socket.WebSocketHandler;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.web.socket.WebSocketSession;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.web.socket.TextMessage;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class MyHandler extends TextWebSocketHandler &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void handleTextMessage(WebSocketSession session, TextMessage message) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#x2F;&#x2F; ...</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">public interface WebSocketHandler &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">    * 建立连接后触发的回调</span></pre></td></tr><tr><td class="code"><pre><span class="line">    *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   void afterConnectionEstablished(WebSocketSession session) throws Exception;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">    * 收到消息时触发的回调</span></pre></td></tr><tr><td class="code"><pre><span class="line">    *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   void handleMessage(WebSocketSession session, WebSocketMessage&lt;?&gt; message) throws Exception;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">    * 传输消息出错时触发的回调</span></pre></td></tr><tr><td class="code"><pre><span class="line">    *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   void handleTransportError(WebSocketSession session, Throwable exception) throws Exception;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">    * 断开连接后触发的回调</span></pre></td></tr><tr><td class="code"><pre><span class="line">    *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   void afterConnectionClosed(WebSocketSession session, CloseStatus closeStatus) throws Exception;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">   &#x2F;**</span></pre></td></tr><tr><td class="code"><pre><span class="line">    * 是否处理分片消息</span></pre></td></tr><tr><td class="code"><pre><span class="line">    *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">   boolean supportsPartialMessages();</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><br>2.2 配置WebSocket<br>两种方式：注解和xml,作用是将WebSocket处理器添加到注册中心<br>1、注解的方式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import org.springframework.web.socket.config.annotation.EnableWebSocket;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.web.socket.config.annotation.WebSocketConfigurer;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.web.socket.config.annotation.WebSocketHandlerRegistry;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@Configuration</span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableWebSocket</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class WebSocketConfig implements WebSocketConfigurer &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        registry.addHandler(myHandler(), &quot;&#x2F;myHandler&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Bean</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public WebSocketHandler myHandler() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return new MyHandler();</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><br>2、xml方式<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    xmlns:websocket&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    xsi:schemaLocation&#x3D;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span></pre></td></tr><tr><td class="code"><pre><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span></pre></td></tr><tr><td class="code"><pre><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket</span></pre></td></tr><tr><td class="code"><pre><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;websocket&#x2F;spring-websocket.xsd&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;websocket:handlers&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;websocket:mapping path&#x3D;&quot;&#x2F;myHandler&quot; handler&#x3D;&quot;myHandler&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;websocket:handlers&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;bean id&#x3D;&quot;myHandler&quot; class&#x3D;&quot;org.springframework.samples.MyHandler&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;beans&gt;</span></pre></td></tr></table></figure><br><strong>重点:在启动类中添加注解@EnableWebSocket</strong></p>
<p><a href="https://www.runoob.com/html/html5-websocket.html" target="_blank" rel="noopener">reference</a></p>
]]></content>
      <categories>
        <category>Cloud Compute</category>
      </categories>
      <tags>
        <tag>Cloud Compute</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-MVC</title>
    <url>/2021/05/09/Spring-MVC/</url>
    <content><![CDATA[<h2 id="MVC设计概述"><a href="#MVC设计概述" class="headerlink" title="MVC设计概述"></a>MVC设计概述</h2><p>在早期 Java Web 的开发中，统一把显示层、控制层、数据层的操作全部交给 JSP 或者 JavaBean 来进行处理，我们称之为 Model1：<br><img src="/2021/05/09/Spring-MVC/m1.png" alt="mvc"></p>
<ul>
<li><strong>出现的弊端：</strong></li>
<li>SP 和 Java Bean 之间严重耦合，Java 代码和 HTML 代码也耦合在了一起</li>
<li>要求开发者不仅要掌握 Java ，还要有高超的前端水平</li>
<li>前端和后端相互依赖，前端需要等待后端完成，后端也依赖前端完成，才能进行有效的测试</li>
<li>代码难以复用<br>正因为上面的种种弊端，所以很快这种方式就被 Servlet + JSP + Java Bean 所替代了，早期的 MVC 模型（Model2）如下图：<br><img src="/2021/05/09/Spring-MVC/2.png" alt="mvc"><br>首先用户的请求会到达 Servlet，然后根据请求调用相应的 Java Bean，并把所有的显示结果交给 JSP 去完成，这样的模式我们就称为 MVC 模式<br><strong>M 代表 模型（Model）</strong><br>  模型是什么呢？ 模型就是数据，就是 dao,bean<br><strong>V 代表 视图（View）</strong><br>  视图是什么呢？ 就是网页, JSP，用来展示模型中的数据<br><strong>C 代表 控制器（controller)</strong><br>  控制器是什么？ 控制器的作用就是把不同的数据(Model)，显示在不同的视图(View)上，Servlet 扮演的就是这样的角色<h3 id="Spring-MVC-的架构"><a href="#Spring-MVC-的架构" class="headerlink" title="Spring MVC 的架构"></a>Spring MVC 的架构</h3>为解决持久层中一直未处理好的数据库事务的编程，又为了迎合 NoSQL 的强势崛起，Spring MVC 给出了方案：<br><img src="/2021/05/09/Spring-MVC/3.png" alt="mvc"><br><strong>传统的模型层被拆分为了业务层(Service)和数据访问层（DAO,Data Access Object）</strong>。 在 Service 下可以通过 Spring 的声明式事务操作数据访问层，而在service上还允许我们访问 NoSQL，这样就能够满足异军突起的 NoSQL 的使用了，它可以大大提高互联网系统的性能。<br><strong>优点：</strong>1、结构松散，几乎可以在 Spring MVC 中使用各类视图；2、松耦合，各个模块分离；3、与 Spring 无缝集成<h3 id="创建一个Spring-MVC-demo"><a href="#创建一个Spring-MVC-demo" class="headerlink" title="创建一个Spring MVC demo"></a>创建一个Spring MVC demo</h3><h4 id="第一步：在-IDEA-中新建-Spring-MVC-项目"><a href="#第一步：在-IDEA-中新建-Spring-MVC-项目" class="headerlink" title="第一步：在 IDEA 中新建 Spring MVC 项目"></a>第一步：在 IDEA 中新建 Spring MVC 项目</h4><strong>根据IDEA的不同版本会有不同的创建方式</strong><br>1、IDEA2020的创建方式：File-&gt;New-&gt;Project-&gt;Java-&gt;Next-&gt;Next-&gt;Project name-&gt;Finish<br>2、添加Spring MVC,右击工程名-&gt;Add Framework Support-&gt;Spring-&gt;Spring MVC-&gt;Download-&gt;OK<br><img src="/2021/05/09/Spring-MVC/4-0.png" alt="mvc"><br><img src="/2021/05/09/Spring-MVC/4-1.png" alt="mvc"><br>3、会多出一个lib文件夹(存放Spring MVC的依赖包)和web文件夹<br><img src="/2021/05/09/Spring-MVC/4-2.png" alt="mvc"><br>4、点击idea的File=&gt;选择项目结构（Project Structure）-&gt;点击Artifacts=&gt;Fix(在右下角)-&gt;add以下两个依赖<br><img src="/2021/05/09/Spring-MVC/5-1.png" alt="mvc"><br>5、都添加完之后：Fix会消失，最后一定要点击Apply然后点击ok即可<br>6、添加成功后：项目目录会多出两个配置文件<br><img src="/2021/05/09/Spring-MVC/5-2.png" alt="mvc"><br>目录结构为：<br><img src="/2021/05/09/Spring-MVC/6.png" alt="mvc"><h4 id="第二步：修改-web-xml"><a href="#第二步：修改-web-xml" class="headerlink" title="第二步：修改 web.xml"></a>第二步：修改 web.xml</h4><img src="/2021/05/09/Spring-MVC/7.png" alt="mvc"><br>把<url-pattern>元素的值改为 / ，表示要拦截所有的请求，并交由Spring MVC的后台控制器来处理<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;servlet-mapping&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;servlet-name&gt;dispatcher&lt;&#x2F;servlet-name&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;servlet-mapping&gt;</span></pre></td></tr></table></figure>
<h4 id="第三步：编辑-dispatcher-servlet-xml"><a href="#第三步：编辑-dispatcher-servlet-xml" class="headerlink" title="第三步：编辑 dispatcher-servlet.xml"></a>第三步：编辑 dispatcher-servlet.xml</h4>这个文件名的开头dispatcher 与上面web.xml中的<servlet-name>元素配置的dispatcher对应，这是Spring MVC的映射配置文件（xxx-servlet.xml），我们编辑如下：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;bean id&#x3D;&quot;simpleUrlHandlerMapping&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">          class&#x3D;&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;property name&#x3D;&quot;mappings&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;props&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &lt;!-- &#x2F;hello 路径的请求交给 id 为 helloController 的控制器处理--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &lt;prop key&#x3D;&quot;&#x2F;hello&quot;&gt;helloController&lt;&#x2F;prop&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;&#x2F;props&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;property&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;bean&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;bean id&#x3D;&quot;helloController&quot; class&#x3D;&quot;controller.HelloController&quot;&gt;&lt;&#x2F;bean&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;beans&gt;</span></pre></td></tr></table></figure>
<h4 id="第四步：编写-HelloController"><a href="#第四步：编写-HelloController" class="headerlink" title="第四步：编写 HelloController"></a>第四步：编写 HelloController</h4>在 Package【controller】下创建 【HelloController】类，并实现 org.springframework.web.servlet.mvc.Controller 接口：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package controller;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.web.servlet.ModelAndView;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.web.servlet.mvc.Controller;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class HelloController implements Controller&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return null;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
Spring MVC 通过 ModelAndView 对象把模型和视图结合在一起<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package controller;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.web.servlet.ModelAndView;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.web.servlet.mvc.Controller;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">public class HelloController implements Controller &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ModelAndView mav &#x3D; new ModelAndView(&quot;index.jsp&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mav.addObject(&quot;message&quot;, &quot;Hello Spring MVC&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return mav;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
这里表示视图的是index.jsp，模型数据的是 message，内容是 “Hello Spring MVC”<h4 id="第五步：准备-index-jsp"><a href="#第五步：准备-index-jsp" class="headerlink" title="第五步：准备 index.jsp"></a>第五步：准备 index.jsp</h4>将 index.jsp 的内容修改为：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language&#x3D;&quot;java&quot; contentType&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    pageEncoding&#x3D;&quot;UTF-8&quot; isELIgnored&#x3D;&quot;false&quot;%&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;h1&gt;$&#123;message&#125;&lt;&#x2F;h1&gt;</span></pre></td></tr></table></figure>
<h4 id="第六步：部署-Tomcat-及相关环境"><a href="#第六步：部署-Tomcat-及相关环境" class="headerlink" title="第六步：部署 Tomcat 及相关环境"></a>第六步：部署 Tomcat 及相关环境</h4>在【Run】菜单项下找到【Edit Configurations】<br><img src="/2021/05/09/Spring-MVC/8.png" alt="mvc"><br>配置 Tomcat 环境：<br><img src="/2021/05/09/Spring-MVC/9.png" alt="mvc"><br>选择好本地的 Tomcat 服务器，并改好名字：<br><img src="/2021/05/09/Spring-MVC/10.png" alt="mvc"><br>在 Deployment 标签页下完成如下操作：<br><img src="/2021/05/09/Spring-MVC/11.png" alt="mvc"><h4 id="第七步：重启服务器"><a href="#第七步：重启服务器" class="headerlink" title="第七步：重启服务器"></a>第七步：重启服务器</h4>重启服务器，输入地址：localhost/hello<br><img src="/2021/05/09/Spring-MVC/12.png" alt="mvc"><h3 id="跟踪-Spring-MVC-的请求"><a href="#跟踪-Spring-MVC-的请求" class="headerlink" title="跟踪 Spring MVC 的请求"></a>跟踪 Spring MVC 的请求</h3>每当用户在 Web 浏览器中点击链接或者提交表单的时候，请求就开始工作了，像是邮递员一样，从离开浏览器开始到获取响应返回，它会经历很多站点，在每一个站点都会留下一些信息同时也会带上其他信息，下图为 Spring MVC 的请求流程<br><img src="/2021/05/09/Spring-MVC/13.png" alt="mvc"><br><img src="/2021/05/09/Spring-MVC/00.png" alt="mvc"><h4 id="第一站：DispatcherServlet"><a href="#第一站：DispatcherServlet" class="headerlink" title="第一站：DispatcherServlet"></a>第一站：DispatcherServlet</h4>从请求离开浏览器以后，第一站到达的就是 DispatcherServlet，看名字这是一个 Servlet，通过 J2EE 的学习，我们知道 Servlet 可以拦截并处理 HTTP 请求，DispatcherServlet 会拦截所有的请求，并且将这些请求发送给 Spring MVC 控制器。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;servlet&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;servlet-name&gt;dispatcher&lt;&#x2F;servlet-name&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;&#x2F;servlet-class&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;load-on-startup&gt;1&lt;&#x2F;load-on-startup&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;servlet&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;servlet-mapping&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;servlet-name&gt;dispatcher&lt;&#x2F;servlet-name&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;!-- 拦截所有的请求 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;url-pattern&gt;&#x2F;&lt;&#x2F;url-pattern&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;servlet-mapping&gt;</span></pre></td></tr></table></figure>
<strong>DispatcherServlet 的任务就是拦截请求发送给 Spring MVC 控制器。</strong><h4 id="第二站：处理器映射（HandlerMapping）"><a href="#第二站：处理器映射（HandlerMapping）" class="headerlink" title="第二站：处理器映射（HandlerMapping）"></a>第二站：处理器映射（HandlerMapping）</h4><strong>问题：</strong>典型的应用程序中可能会有多个控制器，这些请求到底应该发给哪一个控制器呢？<br>所以 DispatcherServlet 会查询一个或多个处理器映射来确定请求的下一站在哪里，处理器映射会根据请求所携带的 URL 信息来进行决策，例如上面的例子中，我们通过配置 simpleUrlHandlerMapping 来将 /hello 地址交给 helloController 处理：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;simpleUrlHandlerMapping&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">      class&#x3D;&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;property name&#x3D;&quot;mappings&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;props&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;!-- &#x2F;hello 路径的请求交给 id 为 helloController 的控制器处理--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;prop key&#x3D;&quot;&#x2F;hello&quot;&gt;helloController&lt;&#x2F;prop&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;props&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;property&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;bean&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;helloController&quot; class&#x3D;&quot;controller.HelloController&quot;&gt;&lt;&#x2F;bean&gt;</span></pre></td></tr></table></figure>
<h4 id="第三站：控制器"><a href="#第三站：控制器" class="headerlink" title="第三站：控制器"></a>第三站：控制器</h4>一旦选择了合适的控制器， DispatcherServlet 会将请求发送给选中的控制器，到了控制器，请求会卸下其负载（用户提交的请求）等待控制器处理完这些信息：<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 处理逻辑</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ....</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="第四站：返回-DispatcherServlet"><a href="#第四站：返回-DispatcherServlet" class="headerlink" title="第四站：返回 DispatcherServlet"></a>第四站：返回 DispatcherServlet</h4>当控制器在完成逻辑处理后，通常会产生一些信息，这些信息就是需要返回给用户并在浏览器上显示的信息，它们被称为模型（Model）。仅仅返回原始的信息时不够的——这些信息需要以用户友好的方式进行格式化，一般会是 HTML，所以，信息需要发送给一个视图（view），通常会是 JSP。<br>控制器所做的最后一件事就是将模型数据打包，并且表示出用于渲染输出的视图名（逻辑视图名）。它接下来会将请求连同模型和视图名发送回 DispatcherServlet。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 处理逻辑</span></pre></td></tr><tr><td class="code"><pre><span class="line">    ....</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; 返回给 DispatcherServlet</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return mav;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<h4 id="第五站：视图解析器"><a href="#第五站：视图解析器" class="headerlink" title="第五站：视图解析器"></a>第五站：视图解析器</h4>这样以来，控制器就不会和特定的视图相耦合，传递给 DispatcherServlet 的视图名并不直接表示某个特定的 JSP。（实际上，它甚至不能确定视图就是 JSP）相反，它传递的仅仅是一个逻辑名称，这个名称将会用来查找产生结果的真正视图。<br>DispatcherServlet 将会使用视图解析器（view resolver）来将逻辑视图名匹配为一个特定的视图实现，它可能是也可能不是 JSP<blockquote>
<p>上面的例子是直接绑定到了 index.jsp 视图</p>
<h4 id="第六站：视图"><a href="#第六站：视图" class="headerlink" title="第六站：视图"></a>第六站：视图</h4><p>它的最后一站是视图的实现，在这里它交付模型数据，请求的任务也就完成了。视图使用模型数据渲染出结果，这个输出结果会通过响应对象传递给客户端。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;%@ page language&#x3D;&quot;java&quot; contentType&#x3D;&quot;text&#x2F;html; charset&#x3D;UTF-8&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">         pageEncoding&#x3D;&quot;UTF-8&quot; isELIgnored&#x3D;&quot;false&quot;%&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;h1&gt;$&#123;message&#125;&lt;&#x2F;h1&gt;</span></pre></td></tr></table></figure>
<h3 id="使用注解配置-Spring-MVC"><a href="#使用注解配置-Spring-MVC" class="headerlink" title="使用注解配置 Spring MVC"></a>使用注解配置 Spring MVC</h3><p>上面我们已经对 Spring MVC 有了一定的了解，并且通过 XML 配置的方式创建了第一个 Spring MVC 程序，我们来看看基于注解应该怎么完成上述程序的配置：</p>
<h4 id="第一步：为-HelloController-添加注解"><a href="#第一步：为-HelloController-添加注解" class="headerlink" title="第一步：为 HelloController 添加注解"></a>第一步：为 HelloController 添加注解</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package controller;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.web.bind.annotation.RequestMapping;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import org.springframework.web.servlet.ModelAndView;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@Controller</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class HelloController&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @RequestMapping(&quot;&#x2F;hello&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public ModelAndView handleRequest(javax.servlet.http.HttpServletRequest httpServletRequest, javax.servlet.http.HttpServletResponse httpServletResponse) throws Exception &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        ModelAndView mav &#x3D; new ModelAndView(&quot;index.jsp&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mav.addObject(&quot;message&quot;, &quot;Hello Spring MVC&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return mav;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></blockquote>
</servlet-name></url-pattern></li>
<li>@Controller 注解：用来声明控制器</li>
<li>@RequestMapping 注解：表示路径 /hello 会映射到该方法上<h4 id="第二步：取消之前的-XML-注释"><a href="#第二步：取消之前的-XML-注释" class="headerlink" title="第二步：取消之前的 XML 注释"></a>第二步：取消之前的 XML 注释</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;!--&lt;bean id&#x3D;&quot;simpleUrlHandlerMapping&quot;--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                                        &lt;!--class&#x3D;&quot;org.springframework.web.servlet.handler.SimpleUrlHandlerMapping&quot;&gt;--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;!--&lt;property name&#x3D;&quot;mappings&quot;&gt;--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;!--&lt;props&gt;--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &lt;!--&lt;!&amp;ndash; &#x2F;hello 路径的请求交给 id 为 helloController 的控制器处理&amp;ndash;&gt;--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &lt;!--&lt;prop key&#x3D;&quot;&#x2F;hello&quot;&gt;helloController&lt;&#x2F;prop&gt;--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;!--&lt;&#x2F;props&gt;--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;!--&lt;&#x2F;property&gt;--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;!--&lt;&#x2F;bean&gt;--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;!--&lt;bean id&#x3D;&quot;helloController&quot; class&#x3D;&quot;controller.HelloController&quot;&gt;&lt;&#x2F;bean&gt;--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;!-- 扫描controller下的组件 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;context:component-scan base-package&#x3D;&quot;controller&quot;&#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;beans&gt;</span></pre></td></tr></table></figure>
在 dispatcher-servlet.xml 文件中，注释掉之前的配置，然后增加一句组件扫描。<h4 id="第三步：重启服务器"><a href="#第三步：重启服务器" class="headerlink" title="第三步：重启服务器"></a>第三步：重启服务器</h4>浏览器输入:localhost/hello<h3 id="简述Model-gt-View中的View"><a href="#简述Model-gt-View中的View" class="headerlink" title="简述Model-&gt;View中的View"></a>简述Model-&gt;View中的View</h3>对于不同的表示技术，Spring MVC 支持许多类型的视图。这些包括 JSP、HTML、PDF、Excel 工作表、XML、Velocity 模板、XSLT、JSON、Atom 和 RSS 提要、JasperReports 等等。但我们最常使用利用 JSTL 编写的 JSP 模板。一般存放在/WEB-INF/目录下<br>JSP全称Java Server Pages，是一种动态网页开发技术。它使用JSP标签在HTML网页中插入Java代码。标签通常以&lt;%开头以%&gt;结束。 JSP标签有多种功能，比如访问数据库、记录用户选择信息、访问JavaBeans组件等，还可以在不同的网页中传递控制信息和共享信息。<br><em>哎，学的不过瘾，待下篇记录前后端交互与jsp的关系吧</em><br><a href="https://www.jianshu.com/p/91a2d0a1e45a" target="_blank" rel="noopener">Spring MVC参考资料</a><br>(Spring MVC安装资料)[<a href="https://blog.csdn.net/qq_36890370/article/details/113815490" target="_blank" rel="noopener">https://blog.csdn.net/qq_36890370/article/details/113815490</a>]</li>
</ul>
]]></content>
      <categories>
        <category>Cloud Compute</category>
      </categories>
      <tags>
        <tag>Cloud Compute</tag>
      </tags>
  </entry>
  <entry>
    <title>Http-Html-Jsp</title>
    <url>/2021/05/09/Http-Html-Jsp/</url>
    <content><![CDATA[<h2 id="前后端交互中的一些宏观知识"><a href="#前后端交互中的一些宏观知识" class="headerlink" title="前后端交互中的一些宏观知识"></a>前后端交互中的一些宏观知识</h2><h3 id="一、浏览器中界面如何渲染"><a href="#一、浏览器中界面如何渲染" class="headerlink" title="一、浏览器中界面如何渲染"></a>一、浏览器中界面如何渲染</h3><p>浏览器能通过解析html语句渲染出页面<br><img src="/2021/05/09/Http-Html-Jsp/n1.jpg" alt="html"><br><strong>问题：</strong>浏览器解析所需的html语句怎么来的？<br>1、简述一下这个过程<br>浏览器通过http请求某个页面，服务器根据请求做响应的处理，将处理的结果包装成html返回给浏览器，浏览器解析。<br>问题：服务器响应一般是java写的，如何包装成html的形式呢？<br>答案：使用Servlet，如下所示为Servlet的默认模板<br><img src="/2021/05/09/Http-Html-Jsp/n2.jpg" alt="html"><br>在web开发早期，通常情况是美工写好html静态页面后，丢给Java程序员。Java开发人员在Servlet中调用Service拿到数据后，逐句复制html静态页面上的html语句到Servlet的中，根据情况将后端的数据与html片段拼接在一起。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">out.println(&quot;&lt;span&gt;用户名是：&quot;+user.age+&lt;&quot;&#x2F;span&gt;&quot;);</span></pre></td></tr></table></figure><br><img src="/2021/05/09/Http-Html-Jsp/n3.jpg" alt="html"><br><strong>为了提高效率</strong>，PHP和ASP.Net在html页面中嵌入相应语言来引入动态数据，避免了手动拷贝html片段输出的尴尬局面<br><img src="/2021/05/09/Http-Html-Jsp/n4.jpg" alt="html"><br><strong>主要目的就是希望在最终输出的html的代码中嵌入后台数据</strong>，除了把html语句拿出来在Servlet里拼接好再输出这种方式外，我们也可以直接在JSP之类的动态模板文件中的HTML语句中写入动态数据<br><strong>JSP是SUN公司为了和PHP一样，高校开发前端动态页面而生产的一门语言</strong></p>
<h3 id="二、简述JSP"><a href="#二、简述JSP" class="headerlink" title="二、简述JSP"></a>二、简述JSP</h3><p>JSP全称Java Server Page，直译就是“运行在服务器端的页面”。上面已经介绍过，我们可以直接在JSP文件里写HTML代码，使用上把它当做HTML文件。而且JSP中HTML/CSS/JS等的写法和HTML文件中的写法是一模一样的。但它毕竟不是HTML，而且本质差了十万八千里。因为我们还可以把Java代码内嵌在JSP页面中，很方便地把动态数据渲染成静态页面。这一点，HTML打死都做不到。<br>当有人请求JSP时，服务器内部会经历一次动态资源（JSP）到静态资源（HTML）的转化，服务器会自动帮我们把JSP中的HTML片段和数据拼接成静态资源响应给浏览器<br>也就是说JSP是运行在服务器端，但最终发给客户端的都已经是转换好的HTML静态页面（在响应体里）。JSP本质是一个Java类（Servlet），是在服务器端运行的，只不过它输出结果是HTML。<br><img src="/2021/05/09/Http-Html-Jsp/n5.jpg" alt="html"></p>
<h4 id="JSP执行过程"><a href="#JSP执行过程" class="headerlink" title="JSP执行过程"></a>JSP执行过程</h4><p><img src="/2021/05/09/Http-Html-Jsp/n6.jpg" alt="html"><br>Web浏览器发http请求到Web容器，WEB容器接收到以.jsp为扩展名的URL的访问请求时，它将把该请求交给JSP引擎去处理。Tomcat中的JSP引擎就是一个Servlet程序，它负责解释和执行JSP页面。<br>每个JSP 页面在第一次被访问时，JSP引擎将它翻译成一个Servlet源程序，接着再把这个Servlet源程序编译成Servlet的class类文件，然后再由WEB容器像调用普通Servlet程序一样的方式来装载和解释执行这个由JSP页面翻译成的Servlet程序。 </p>
<h3 id="三、MVC模式与JAVAEE三层架构"><a href="#三、MVC模式与JAVAEE三层架构" class="headerlink" title="三、MVC模式与JAVAEE三层架构"></a>三、MVC模式与JAVAEE三层架构</h3><p><img src="/2021/05/09/Http-Html-Jsp/n7.jpg" alt="html"><br>参考资料：<br>[浅谈JSP]<a href="https://zhuanlan.zhihu.com/p/42343690" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/42343690</a><br>[JavaScript学习]<a href="https://www.w3school.com.cn/js/js_window.asp" target="_blank" rel="noopener">https://www.w3school.com.cn/js/js_window.asp</a></p>
]]></content>
      <categories>
        <category>Cloud Compute</category>
      </categories>
      <tags>
        <tag>Cloud Compute</tag>
      </tags>
  </entry>
  <entry>
    <title>Tensorflow-Step-One</title>
    <url>/2021/05/04/Tensorflow-Step-One/</url>
    <content><![CDATA[<h2 id="TensorFlow源码学习-初探一"><a href="#TensorFlow源码学习-初探一" class="headerlink" title="TensorFlow源码学习-初探一"></a>TensorFlow源码学习-初探一</h2><h3 id="一、Debugging-Tensorflow’s-C-code-behind-the-SWIG-interface"><a href="#一、Debugging-Tensorflow’s-C-code-behind-the-SWIG-interface" class="headerlink" title="一、Debugging Tensorflow’s C++ code behind the SWIG interface"></a>一、Debugging Tensorflow’s C++ code behind the SWIG interface</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#启动一个python程序</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ python</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import tensorflow as tf</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import os</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; os.getpid()</span></pre></td></tr><tr><td class="code"><pre><span class="line">28671 #这里给出该python程序的进程号pid</span></pre></td></tr></table></figure>
<p><strong>使用gdb设置断点，并调试程序</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gdb -p 28671</span></pre></td></tr><tr><td class="code"><pre><span class="line">(gdb) break TF_Session #设置断点，简化操作-&gt;b TF_Session</span></pre></td></tr><tr><td class="code"><pre><span class="line">Breakpoint 1 at 0x7f15f450a4d0</span></pre></td></tr><tr><td class="code"><pre><span class="line">(gdb) continue</span></pre></td></tr><tr><td class="code"><pre><span class="line">Continuing.</span></pre></td></tr></table></figure><br><strong>在第一步python程序中创建一个Session</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#tf.Session是tf.v1的版本，根据不同的tensorflow可以写不同的创建语句</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; sess&#x3D;tf.Session()</span></pre></td></tr></table></figure><br><strong>在gdb调试处获得如下输出</strong><br><img src="/2021/05/04/Tensorflow-Step-One/1.png" alt="Tensorflow"><br><strong>如果上面的gdb attach进程时出现，Could not attach to process</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#解决方法</span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo vi &#x2F;etc&#x2F;sysctl.d&#x2F;10-ptrace.conf</span></pre></td></tr><tr><td class="code"><pre><span class="line">将kernel.yama.ptrace_scope&#x3D;1</span></pre></td></tr><tr><td class="code"><pre><span class="line">改为kernel.yama.ptrace_scope&#x3D;0</span></pre></td></tr></table></figure><br><strong>Tensorflow中python代码跟踪：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;sess &#x3D; tf.Session()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;Class Session(BaseSession)-&gt;super(Session, self).__init__(target, graph, config&#x3D;config)</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;Class BaseSession(SessionInterface),文件在&#x2F;anaconda3&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;tensorflow_core&#x2F;python&#x2F;client&#x2F;session.python</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;self._graph&#x3D;ops.get_default_graph() #ops来自于from tensorflow.python.framework import ops</span></pre></td></tr><tr><td class="code"><pre><span class="line">#ops.py位于&#x2F;anaconda3&#x2F;lib&#x2F;python3.7&#x2F;site-packages&#x2F;tensorflow_core&#x2F;python&#x2F;framework&#x2F;ops.python</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;class _DefaultGraphStack(_DefaultStack)-&gt;_GetGlobalDefaultGraph()-&gt;Graph()</span></pre></td></tr></table></figure><br>可以看出tf.Session就是为了去创建一个graph<br>在使用tensorflowd的操作的时候，例如变量和占位符的时候，都会在graph进行相应参数的设置<br>前端Session与C_API的交互是在pywrap_tensorflow.py中导入的，而pywrap_tensorflow.py中导入了swig生成的pywrap_tensorflow_internal.py文件<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;from tensorflow.python import pywrap_tensorflow as c_api</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;c_api.TFE_Py_UID()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;c_api.TF_GraphGetTensorShapeHelper()</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;c_api.TF_OperationOutputType(tf_output) #等等</span></pre></td></tr></table></figure><br><strong>前端Session的阶段</strong>：<br>1、创建：tf.Session(),系统资源分配，graph引用计数加1;<br>2、运行：tf.Session.run()触发计算执行，client会将graph传递给master;<br>3、关闭：通过tf.Session.close()关闭,系统回收，graph引用计数减1;<br>4、销毁：python垃圾回收器GC调用tf.Session.<strong>del</strong>()回收;<br><strong>用于调试的Tensorflow代码</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import tensorflow as tf</span></pre></td></tr><tr><td class="code"><pre><span class="line">import numpy as np</span></pre></td></tr><tr><td class="code"><pre><span class="line">def add_layer(inputs, in_size, out_size, activation_function&#x3D;None):  # inputs.shape&#x3D;[None,1],in_size.shape&#x3D;1,out_size&#x3D;10 |inputs.shape&#x3D;[None,10]，in_size.shape&#x3D;10,out_size&#x3D;1</span></pre></td></tr><tr><td class="code"><pre><span class="line">    with tf.name_scope(&#39;layer&#39;):</span></pre></td></tr><tr><td class="code"><pre><span class="line">        with tf.name_scope(&#39;weights&#39;):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Weights &#x3D; tf.Variable(tf.random_normal([in_size, out_size]), name&#x3D;&#39;w&#39;)  # [1,10] | [10,1]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        with tf.name_scope(&#39;bias&#39;):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            biases &#x3D; tf.Variable(tf.zeros([1, out_size]) + 0.1, name&#x3D;&#39;b&#39;)  # [1,10]，这个1跟上面那个1貌似不是一个意思 | [1,1]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        with tf.name_scope(&#39;wx_plus_b&#39;):</span></pre></td></tr><tr><td class="code"><pre><span class="line">            Wx_plus_b &#x3D; tf.matmul(inputs, Weights) + biases  # 注意这里顺序，inputs在前。[None,1]×[1,10]+[1,10]（python广播）&#x3D;[None,10] | [None,10]×[10,1]+[1,1]（python广播）&#x3D;[None,1]</span></pre></td></tr><tr><td class="code"><pre><span class="line">        if activation_function is None:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            outputs &#x3D; Wx_plus_b</span></pre></td></tr><tr><td class="code"><pre><span class="line">        else:</span></pre></td></tr><tr><td class="code"><pre><span class="line">            outputs &#x3D; activation_function(Wx_plus_b)</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return outputs</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># 训练集数据和标签</span></pre></td></tr><tr><td class="code"><pre><span class="line">train_data_x &#x3D; np.linspace(-1,1,300, dtype&#x3D;np.float32)[:, np.newaxis]  # shape&#x3D;(300,1)</span></pre></td></tr><tr><td class="code"><pre><span class="line">noise &#x3D; np.random.normal(0, 0.05, train_data_x.shape).astype(np.float32)</span></pre></td></tr><tr><td class="code"><pre><span class="line">label_y &#x3D; np.square(train_data_x) - 0.5 + noise</span></pre></td></tr><tr><td class="code"><pre><span class="line">with tf.name_scope(&#39;inputs&#39;):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    inputer_x &#x3D; tf.placeholder(tf.float32, [None, 1], name&#x3D;&#39;inputer_x&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    inputer_y &#x3D; tf.placeholder(tf.float32, [None, 1], name&#x3D;&#39;inputer_y&#39;)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"># 设计的网络结构是1-10-1的</span></pre></td></tr><tr><td class="code"><pre><span class="line">l1 &#x3D; add_layer(inputer_x, 1, 10, activation_function&#x3D;tf.nn.relu)</span></pre></td></tr><tr><td class="code"><pre><span class="line">prediction &#x3D; add_layer(l1, 10, 1, activation_function&#x3D;None)</span></pre></td></tr><tr><td class="code"><pre><span class="line">with tf.name_scope(&#39;loss&#39;):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    loss &#x3D; tf.reduce_mean(tf.reduce_sum(tf.square(inputer_y-prediction), reduction_indices&#x3D;[1]))</span></pre></td></tr><tr><td class="code"><pre><span class="line">with tf.name_scope(&#39;train_scope&#39;):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    train_step &#x3D; tf.train.GradientDescentOptimizer(0.1).minimize(loss)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">sess &#x3D; tf.Session()</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">init &#x3D; tf.global_variables_initializer()</span></pre></td></tr><tr><td class="code"><pre><span class="line">sess.run(init)</span></pre></td></tr><tr><td class="code"><pre><span class="line">writer &#x3D; tf.summary.FileWriter(&quot;logs&quot;, sess.graph)  # 文件写在该.py文件同级，在命令行中，用tensorboard --logdir&#x3D;.打开</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">for i in range(1000):</span></pre></td></tr><tr><td class="code"><pre><span class="line">    # training</span></pre></td></tr><tr><td class="code"><pre><span class="line">    sess.run(train_step, feed_dict&#x3D;&#123;inputer_x: train_data_x, inputer_y: label_y&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    if i % 50 &#x3D;&#x3D; 0:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        # to see the step improvement</span></pre></td></tr><tr><td class="code"><pre><span class="line">        print(sess.run(loss, feed_dict&#x3D;&#123;inputer_x: train_data_x, inputer_y: label_y&#125;))</span></pre></td></tr></table></figure><br><a href="https://www.cnblogs.com/yao62995/p/5773578.html" target="_blank" rel="noopener">参考</a><br><a href="https://blog.csdn.net/lllxxq141592654/article/details/85289812" target="_blank" rel="noopener">code</a></p>
]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>Docker-Volumes</title>
    <url>/2021/05/03/Docker-Volumes/</url>
    <content><![CDATA[<h2 id="Docker目录挂载和映射以及一些常用的docker指令"><a href="#Docker目录挂载和映射以及一些常用的docker指令" class="headerlink" title="Docker目录挂载和映射以及一些常用的docker指令"></a>Docker目录挂载和映射以及一些常用的docker指令</h2><p><strong>docker和docker-compose可以通过-v参数指定</strong><br>一、启动一个centos容器，并映射主机到容器，/home/xxxx/test:/root/soft<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$docker run --name test_volumes -it --privileged -v &#x2F;home&#x2F;xxxx&#x2F;test:&#x2F;root&#x2F;soft centos:6 &#x2F;bin&#x2F;bash</span></pre></td></tr><tr><td class="code"><pre><span class="line">#--privileged&#x3D;true关闭安全权限，否者在容器内新建目录或文件及在文件中写内容会出现没有权限</span></pre></td></tr><tr><td class="code"><pre><span class="line">#-v挂载目录，主机容:容器目录，在创建前容器是没有指定目录时，docker 容器会自己创建</span></pre></td></tr><tr><td class="code"><pre><span class="line">#-p可以指定端口映射，格式为：主机(宿主)端口:容器端口</span></pre></td></tr><tr><td class="code"><pre><span class="line">#容器内将自动创建soft目录</span></pre></td></tr></table></figure><br><strong>容器目录不能为相对路径</strong>否则会出现”invalid mount config for type bind:invalid mount path:’soft’ mount path must be absolute”。<br>重点:当设置了—privileged后，在容器的soft下面创建文件夹以及文件并在文件内输入信息，都可在宿主目录映射的目录下可以找到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$docker inspect [OPTIONS] NAME|ID [NAME|ID...] #提供了Docker控制容器的详细信息</span></pre></td></tr></table></figure>
<p>通过Mounts可以查看目录的映射关系<br>如果宿主机目录的属主和属组发生了变化，容器销毁后，宿主机目录的属主和属组不会恢复到挂载之前的状态<br>二、docker常用命令<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$docker ps &#x2F;&#x2F;查看所有正在运行的容器</span></pre></td></tr><tr><td class="code"><pre><span class="line">$docker ps -a &#x2F;&#x2F;查看所有容器，包括已经停止的容器</span></pre></td></tr><tr><td class="code"><pre><span class="line">$docker stop containerID|containerName &#x2F;&#x2F;暂停容器</span></pre></td></tr><tr><td class="code"><pre><span class="line">$docker stop $(docker ps -a -q) &#x2F;&#x2F;停止所有容器</span></pre></td></tr><tr><td class="code"><pre><span class="line">$docker rm $(docker ps -a -q) &#x2F;&#x2F;删除所有容器</span></pre></td></tr><tr><td class="code"><pre><span class="line">$dockers restart containerID &#x2F;&#x2F;重启容器</span></pre></td></tr><tr><td class="code"><pre><span class="line">$docker run -p 8080:80 --name test -it -d centos:6 &#x2F;bin&#x2F;bash &#x2F;&#x2F;创建一个新的docker实例 —&gt;&#x2F;bin&#x2F;bash打开一个bash会话</span></pre></td></tr><tr><td class="code"><pre><span class="line">$docker exec [options] container command [arg...] &#x2F;&#x2F;在运行的容器内执行命令</span></pre></td></tr><tr><td class="code"><pre><span class="line">#设置环境变量 -e</span></pre></td></tr></table></figure><br>三、简单介绍一下镜像<br>镜像内部是一个精简的操作系统（OS），同时还包含应用运行所必须的文件和依赖包。镜像构建时通常裁剪掉了不必要的部分。镜像中不包括内核所有容器共享Docker宿主机的内核。<br>镜像可以启动一个或多个容器，通常使用docker container run和docker service create命令从某个镜像启动一个或多个容器。一旦容器从镜像启动后，二者之间就变成了互相依赖的关系。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#拉取镜像</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker image pull xxx:xxx #命名:标签</span></pre></td></tr><tr><td class="code"><pre><span class="line">#查看镜像</span></pre></td></tr><tr><td class="code"><pre><span class="line">docker image ls</span></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>SWIG</title>
    <url>/2021/05/02/SWIG/</url>
    <content><![CDATA[<h2 id="SWIG学习"><a href="#SWIG学习" class="headerlink" title="SWIG学习"></a>SWIG学习</h2><h3 id="一、SWIG介绍"><a href="#一、SWIG介绍" class="headerlink" title="一、SWIG介绍"></a>一、SWIG介绍</h3><p>SWIG(Simplified Wrapper and Interface Generator)简化包装和接口生成器是一种软件开发工具，用于为C/C++程序构建脚本语言接口。<br>目的：简化了将不同语言连接到C和C ++程序的任务。SWIG是一个编译器，它接受C / C ++声明，并创建从其他语言（包括Perl，Python，Tcl，Ruby，Guile和Java）访问这些声明所需的包装器。SWIG通常不需要修改现有代码，并且通常可以在短短几分钟内用于构建可用的界面。<br>SWIG的应用范围：</p>
<ul>
<li>构建到现有C程序的解释接口。 </li>
<li>快速原型开发和应用程序开发。</li>
<li>交互式调试  </li>
<li>将遗留软件重新设计或重构为脚本语言组件 </li>
<li>制作图形用户界面（例如，使用Tk） </li>
<li>测试C库和程序（使用脚本） </li>
<li>构建用于脚本语言的高性能C模块</li>
<li>使C编程更有趣</li>
<li>等等</li>
</ul>
<h3 id="二、为什么需要使用SWIG-gt-为了需要将C-C-的接口提供给别的脚本语言"><a href="#二、为什么需要使用SWIG-gt-为了需要将C-C-的接口提供给别的脚本语言" class="headerlink" title="二、为什么需要使用SWIG-&gt;为了需要将C/C++的接口提供给别的脚本语言"></a>二、为什么需要使用SWIG-&gt;为了需要将C/C++的接口提供给别的脚本语言</h3><p><strong>C/C++的优点：</strong></p>
<ul>
<li>对编写程序库的出色支持。</li>
<li>高性能（数字运算，数据处理，图形等）。</li>
<li>系统编程和系统集成。</li>
<li>大型用户社区和软件库。</li>
</ul>
<p><strong>C/C++的缺点：</strong></p>
<ul>
<li>编写用户界面非常痛苦（例如，考虑使用MFC，X11，GTK或任何其他库进行编程）。</li>
<li>测试很耗时（编译/调试周期）。</li>
<li>不经过重新编译就很难重新配置或自定义。</li>
<li>模块化很棘手。</li>
<li>安全问题（例如缓冲区溢出）。</li>
</ul>
<p><strong>原因：</strong></p>
<ul>
<li>为了解决这些限制，许多程序员得出的结论是，<em>针对不同的任务使用不同的编程语言要容易得多</em>。 例如，使用Python或Tcl这样的脚本语言编写图形用户界面可能要容易得多（如果需要更多证据，请考虑数百万程序员使用Visual Basic这样的语言的原因）。</li>
<li><em>交互式解释器</em>也可以用作有用的调试和测试工具。其他语言（例如Java）可能会大大简化编写分布式计算软件的任务。</li>
<li>关键是<em>不同的编程语言具有不同的优点和缺点</em>。</li>
<li>此外，<em>任何编程都不可能完美无缺</em>，因此，通过<em>将语言组合在一起</em>，您可以利用每种语言的最佳功能并大大简化软件开发的某些方面。 </li>
</ul>
<p><strong>那么使用SWIG的好处：</strong></p>
<ul>
<li>将C / C ++集成到高级语言中通常会导致模块化的设计，更少的代码，更好的灵活性并提高程序员的生产率。</li>
<li>SWIG试图使C / C ++集成的问题尽可能轻松。</li>
<li>它提供了多种自定义功能，使您几乎可以更改语言绑定的每个方面。</li>
</ul>
<p><strong>SWIG的作用：</strong><br>本质上，SWIG是一种用于生成使C / C ++代码可用于其他各种编程语言的代码的工具。 这些高级编程语言是SWIG代码生成器的目标语言，而C或C ++是输入语言。 运行SWIG时，必须指定一种目标语言。 这导致生成C / C ++代码和指定的目标语言以相互接口。 SWIG可以被多次调用，但是每次调用都指定了不同的目标语言。 将C / C ++与许多不同的目标语言接口的能力是SWIG的核心优势和功能之一。<br><strong>SWIG的组成：</strong><br>SWIG大致上由两个部分组成。 核心组件根据输入的ISO C / C ++和SWIG指令（对C / C ++标准的扩展）创建解析树。 然后将解析树传递到第二组件，第二组件是目标语言模块之一，用于生成特定于高级语言的代码。 SWIG支持许多不同的目标语言，这些目标语言的状态为<code>支持&#39;&#39;或</code>实验’’。 提供此状态是为了指示在使用特定目标语言时预期的成熟程度，因为并非所有目标语言都得到了充分开发。 </p>
<h3 id="三、SWIG示例"><a href="#三、SWIG示例" class="headerlink" title="三、SWIG示例"></a>三、SWIG示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* File : example.c *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">double My_variable &#x3D; 3.0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;* Compute factorial of n *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">int fact(int n) &#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">	if (n &lt;&#x3D; 1)    </span></pre></td></tr><tr><td class="code"><pre><span class="line">		return 1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	else    </span></pre></td></tr><tr><td class="code"><pre><span class="line">		return n*fact(n-1);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;* Compute n mod m *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">int my_mod(int n, int m) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	return(n % m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
<p>假设您要访问这些函数以及Tcl中的全局变量My_variable。首先制作如下所示的SWIG接口文件（按照惯例，这些文件带有.i后缀）<br>1、SWIG interface file<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* File : example.i *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">%module example</span></pre></td></tr><tr><td class="code"><pre><span class="line">%&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#x2F;* Put headers and other declarations here *&#x2F;</span></pre></td></tr><tr><td class="code"><pre><span class="line">extern double My_variable;</span></pre></td></tr><tr><td class="code"><pre><span class="line">extern int    fact(int);</span></pre></td></tr><tr><td class="code"><pre><span class="line">extern int    my_mod(int n, int m);</span></pre></td></tr><tr><td class="code"><pre><span class="line">%&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">extern double My_variable;</span></pre></td></tr><tr><td class="code"><pre><span class="line">extern int    fact(int);</span></pre></td></tr><tr><td class="code"><pre><span class="line">extern int    my_mod(int n, int m);</span></pre></td></tr></table></figure><br><em>%module提供了SWIG创建模块的名称</em>，%{ %}提供了将其他代码(C头文件/其他C声明)插入c包装器中的位置。<br>2、The swig command<br>SWIG使用swig命令唤醒，下面的命令被用于构建一个Tcl模块<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unix &gt; swig -tcl example.i</span></pre></td></tr><tr><td class="code"><pre><span class="line">unix &gt; gcc -c -fpic example.c example_wrap.c -I&#x2F;usr&#x2F;local&#x2F;include</span></pre></td></tr><tr><td class="code"><pre><span class="line">unix &gt; gcc -shared example.o example_wrap.o -o example.so</span></pre></td></tr><tr><td class="code"><pre><span class="line">#验证</span></pre></td></tr><tr><td class="code"><pre><span class="line">unix &gt; tclsh% </span></pre></td></tr><tr><td class="code"><pre><span class="line">load .&#x2F;example.so</span></pre></td></tr><tr><td class="code"><pre><span class="line">% fact 424</span></pre></td></tr><tr><td class="code"><pre><span class="line">% my_mod 23 7</span></pre></td></tr><tr><td class="code"><pre><span class="line">2</span></pre></td></tr><tr><td class="code"><pre><span class="line">% expr $My_variable + 4.5</span></pre></td></tr><tr><td class="code"><pre><span class="line">7.5</span></pre></td></tr><tr><td class="code"><pre><span class="line">%</span></pre></td></tr></table></figure><br>swig命令生成了一个名为example_wrap.c的新文件，该文件应与example.c文件一起编译。现在，大多数操作系统和脚本语言都支持<em>动态加载模块</em>。在我们的示例中，我们的Tcl模块已被编译到一个共享库中，该库可以加载到Tcl中。加载后，Tcl现在可以访问SWIG接口中声明的函数和变量。查看文件example_wrap.c会发现一个令人毛骨悚然的混乱局面。但是，您几乎不需要担心它。<br>3、构建一个python模块<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unix &gt; swig -python example.i</span></pre></td></tr><tr><td class="code"><pre><span class="line">unix &gt; gcc -c -fpic example.c example_wrap.c -I&#x2F;usr&#x2F;local&#x2F;include&#x2F;python2.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">unix &gt; gcc -shared example.o example_wrap.o -o _example.so</span></pre></td></tr><tr><td class="code"><pre><span class="line">unix &gt; python</span></pre></td></tr><tr><td class="code"><pre><span class="line">Python 2.0 (#6, Feb 21 2001, 13:29:45)</span></pre></td></tr><tr><td class="code"><pre><span class="line">[GCC egcs-2.91.66 19990314&#x2F;Linux (egcs-1.1.2 release)] on linux2</span></pre></td></tr><tr><td class="code"><pre><span class="line">Type &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; import example</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; example.fact(4)</span></pre></td></tr><tr><td class="code"><pre><span class="line">24</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; example.my_mod(23, 7)</span></pre></td></tr><tr><td class="code"><pre><span class="line">2</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt;&gt;&gt; example.cvar.My_variable + 4.5</span></pre></td></tr><tr><td class="code"><pre><span class="line">7.5</span></pre></td></tr></table></figure><br>4、Shortcuts，不需要额外的接口文件xxx.i，构建一个Perl5模块<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">unix &gt; swig -perl5 -module example example.h            #指定模块名和c头文件</span></pre></td></tr><tr><td class="code"><pre><span class="line">unix &gt; gcc -c example.c example_wrap.c \                #gcc编译 </span></pre></td></tr><tr><td class="code"><pre><span class="line">		-I&#x2F;usr&#x2F;local&#x2F;lib&#x2F;perl5&#x2F;sun4-solaris&#x2F;5.003&#x2F;CORE</span></pre></td></tr><tr><td class="code"><pre><span class="line">unix &gt; ld -G example.o example_wrap.o -o example.so     #ld链接器进行链接</span></pre></td></tr><tr><td class="code"><pre><span class="line">unix &gt; perl5.003</span></pre></td></tr><tr><td class="code"><pre><span class="line">use example;</span></pre></td></tr><tr><td class="code"><pre><span class="line">print example::fact(4), &quot;\n&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">print example::my_mod(23, 7), &quot;\n&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">print $example::My_variable + 4.5, &quot;\n&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;ctrl-d&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">24</span></pre></td></tr><tr><td class="code"><pre><span class="line">27.5</span></pre></td></tr></table></figure></p>
<h3 id="四、SIWG支持的C-特性"><a href="#四、SIWG支持的C-特性" class="headerlink" title="四、SIWG支持的C++特性"></a>四、SIWG支持的C++特性</h3><ul>
<li>完整的C99预处理。</li>
<li>所有ISO C和C ++数据类型。</li>
<li>函数，变量和常量。</li>
<li>类。</li>
<li>单重和多重继承。</li>
<li>重载的函数和方法。</li>
<li>重载的运算符。</li>
<li>C ++模板（包括成员模板，专业化和部分专业化）。</li>
<li>命名空间。</li>
<li>变量 长度参数。</li>
<li>C++智能指针。</li>
</ul>
<p>Most of C++11 is also supported. Details are in the <strong>7 SWIG and C++11</strong> chapter. C++14 support is covered in the <strong>8 SWIG and C++14</strong> chapter. C++17 support is covered in the <em>**9 SWIG and C++17</em> chapter.</p>
<p>如果要深入了解脚本语言如何扩展需要的知识：编译器、链接器、makefile。</p>
<p><strong>如需了解更多的细节可以查看官网文档</strong><br><a href="http://www.swig.org/Doc4.0/SWIGDocumentation.pdf" target="_blank" rel="noopener">SWIG文档</a></p>
]]></content>
      <categories>
        <category>Programming-Language</category>
      </categories>
      <tags>
        <tag>Programming-Language</tag>
      </tags>
  </entry>
  <entry>
    <title>Programming-Language</title>
    <url>/2021/05/02/Programming-Language/</url>
    <content><![CDATA[<h2 id="编程语言及其类型的归纳"><a href="#编程语言及其类型的归纳" class="headerlink" title="编程语言及其类型的归纳"></a>编程语言及其类型的归纳</h2><h3 id="一、脚本语言"><a href="#一、脚本语言" class="headerlink" title="一、脚本语言"></a>一、脚本语言</h3><ul>
<li>介于HTML和C/C++,Java等编程语言之间。HTML通常用于格式化和链接文本，编程语言向及其发出一系列复杂的指令。</li>
<li>和编程语言一样都有变量，但是没有编程语言严格和复杂的语法和规则。</li>
<li>需要有相应的脚本引擎来解释执行，需要解释器,是一种解释性语言。不用像C/C++等语言一样需要编译成二进制文件，最后生成可执行文件。</li>
<li>如JavaScript,ASP,PHP,PERL等</li>
</ul>
<h3 id="二、编程范式：命令式编程-Imperative-、声明式编程-Declarative-和函数式编程-Functional"><a href="#二、编程范式：命令式编程-Imperative-、声明式编程-Declarative-和函数式编程-Functional" class="headerlink" title="二、编程范式：命令式编程(Imperative)、声明式编程(Declarative)和函数式编程(Functional)"></a>二、编程范式：命令式编程(Imperative)、声明式编程(Declarative)和函数式编程(Functional)</h3><p>计算机的最下层是CPU指令，其本质就是用“变量定义+顺序执行+分支判断+循环”所表达的逻辑过程。计算机应用的最上层是实现人类社会的某种功能。所以所有计算机编码的过程，就是用逻辑表达现实的过程。层与层之间定义的借口，越接近现实的表达就叫越“声明式”（declarative），越接近计算机的执行过程就叫越“命令式”（imperative）。注意这不是绝对的概念，而是相对的概念。<br>越是声明式，意味着下层要做更多的东西，或者说能力越强。也意味着效率的损失。越是命令式，意味着上层对下层有更多的操作空间，可以按照自己特定的需求要求下层按照某种方式来处理。</p>
<p><img src="/2021/05/02/Programming-Language/1.png" alt="Language"><br>命令式编程：命令式编程的主要思想是关注计算机执行的步骤，即一步一步告诉计算机先做什么再做什么。<br>声明式编程：声明式编程是以数据结构的形式来表达程序执行的逻辑。它的主要思想是告诉计算机应该做什么，但不指定具体要怎么做。如：SQL<br>函数式编程：和声明式编程的思想是一致的，即只关注做什么而不是怎么做。但函数式编程不仅仅局限于声明式编程。函数式编程最重要的特点是“函数第一位”，即函数可以出现在任何地方，比如你可以把函数作为参数传递给另一个函数，不仅如此你还可以将函数作为返回值。</p>
]]></content>
      <categories>
        <category>Programming-Language</category>
      </categories>
      <tags>
        <tag>Programming-Language</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-Cloud-OpenFeign</title>
    <url>/2021/05/01/Spring-Cloud-OpenFeign/</url>
    <content><![CDATA[<h2 id="OpenFeign实现微服务之间的调用"><a href="#OpenFeign实现微服务之间的调用" class="headerlink" title="OpenFeign实现微服务之间的调用"></a>OpenFeign实现微服务之间的调用</h2><h3 id="带着问题来学习"><a href="#带着问题来学习" class="headerlink" title="带着问题来学习"></a>带着问题来学习</h3><p><strong>什么是Feign,OpenFeign与Feign有啥区别，如何使用</strong></p>
<h3 id="一、Feign介绍"><a href="#一、Feign介绍" class="headerlink" title="一、Feign介绍"></a>一、Feign介绍</h3><p><strong>Feign</strong>是SpringCloud组件中一个轻量级RESTFul的HTTP客户端。其内置了Ribbon实现客户端请求的负载均衡。但是Feign<strong>不支持Spring MVC注解</strong>。</p>
<h3 id="二、OpenFeign介绍"><a href="#二、OpenFeign介绍" class="headerlink" title="二、OpenFeign介绍"></a>二、OpenFeign介绍</h3><p><strong>OpenFeign</strong>在Feign的基础上支持Spring MVC注解，比如@RequestMapping等。OpenFeign的@FeignClient可以解析Spring MVC的@RequestMapping注解下的接口。并通过动态代理生成实现类，实现类做负载均衡并调用其他服务。</p>
<h3 id="三、微服务间调用，该怎么办？"><a href="#三、微服务间调用，该怎么办？" class="headerlink" title="三、微服务间调用，该怎么办？"></a>三、微服务间调用，该怎么办？</h3><p>引入了HTTP客户端，及提供RESTFul API供别的服务调用。此处，引入OpenFeign。<br>如果有多个服务A,B,C,D。如果A要调用B中的接口怎么办，之前Feign是这样做的。如果A要调用B，那么需要在A中写被调用者B的FeignClient。而OpenFeign是，A调用B的话，需要在B服务根目录下单独创建一个B-api目录，里面放一个Feign目录存放被别的服务调用的API接口。这样A服务调用B服务时，直接引入B的api即可。<br><strong>好处</strong>：将被调用服务(如服务B)的FeignClient的编写交给负责被调用模块(如服务B)的开发人员，让更熟悉此模块的人去编写对外开发的FeignClient会更加合理，有效。</p>
<h3 id="四、如何使用"><a href="#四、如何使用" class="headerlink" title="四、如何使用"></a>四、如何使用</h3><p>如有微服务项目中有auth，admin两个服务，auth要调用amdin的load函数，如何实现呢？<br>1、创建admin-api子模块，添加maven依赖(被调用模块)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- OpenFeign --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;!-- OkHttp --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;groupId&gt;io.github.openfeign&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;artifactId&gt;feign-okhttp&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependency&gt;</span></pre></td></tr></table></figure><br>2、定义FeignClient接口<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@FeignClient(&quot;admin&quot;) #这里的admin是服务注册时的服务名，如用nacos</span></pre></td></tr><tr><td class="code"><pre><span class="line">public interface UmsAdminService &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @GetMapping(&quot;&#x2F;users&#x2F;loadUserByName&quot;)  #服务调用地址</span></pre></td></tr><tr><td class="code"><pre><span class="line">    UserDTO loadUserByName(@RequestParam String username);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><br>3、auth添加依赖(调用模块)<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;groupId&gt;com.projectname&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;artifactId&gt;projectname-admin-api&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;version&gt;1.0.0-SNAPSHOT&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependency&gt;</span></pre></td></tr></table></figure><br>4、配置文件开启OpenFeign使用OkHttp作为底层的client,也可以用其他的client，如HttpURLConnection(JDK默认)，feign-httpclient<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">feign:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  okhttp:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    enabled: true</span></pre></td></tr></table></figure><br>5、auth调用端的调用代码<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">private UmsAdminService umsAdminService;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@GetMapping(&quot;&#x2F;loadUserByName&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public Result loadUserByName()&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    UserDTO userDTO &#x3D; umsAdminService.loadUserByName(&quot;admin&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    return Result.success(userDTO);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><br>6、在启动类上添加@EnableFeignClients注解<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableFeignClients</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class TestOpenFeignApplication &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        SpringApplication.run(TestOpenFeignApplication.class,args);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></p>
<p>依次启动项目auth、admin即可<br><strong>注意：@RequestMapping不能在类名上与@FeignClient同时使用</strong></p>
]]></content>
      <categories>
        <category>Cloud Compute</category>
      </categories>
      <tags>
        <tag>Cloud Compute</tag>
        <tag>Spring-Cloud-OpenFeign</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-Cloud-Nacos</title>
    <url>/2021/05/01/Spring-Cloud-Nacos/</url>
    <content><![CDATA[<h2 id="Nacos"><a href="#Nacos" class="headerlink" title="Nacos"></a>Nacos</h2><h3 id="一、安装nacos-server"><a href="#一、安装nacos-server" class="headerlink" title="一、安装nacos-server"></a>一、安装nacos-server</h3><p>1、下载地址: <a href="https://github.com/alibaba/nacos/releases" target="_blank" rel="noopener">https://github.com/alibaba/nacos/releases</a><br>选择nacos-server-x.x.x.zip下载并解压<br>2、本地创建数据库nacos, 导入nacos解压路径下nacos\conf\nacos-mysql.sql完成数据表的创建和数据初始化<br>编辑配置文件nacos\conf\application.properties,修改后的图图下：<br><img src="/2021/05/01/Spring-Cloud-Nacos/1.png" alt="nacos">  </p>
<p>3、启动nacos-server服务，确保本机安装并配置了java环境变量<br>进入nacos\bin，执行startup.cmd -m standalone(采用单机模式)<br>4、进入nacos管理控制台<br>查看地址：<a href="http://localhost:8848/nacos" target="_blank" rel="noopener">http://localhost:8848/nacos</a><br>账号/密码: nacos/nacas<br><strong>对比eureka和nacos:&amp;</strong> <strong>eureka</strong>将注册中心和配置中心分离，分别使用SpringCloud Eureka和SpringCloud Config两个组件，配置更新时需要重启服务或者使用SpringCloud Bus消息总线发出通知到各个服务，进而完成配置。此外，eureka已经停止了更新。<strong>nacos</strong>可以同时实现注册和配置中心，以及配置的动态更新。<br><strong>Nacos两个核心功能:</strong> 服务注册与发现，动态配置管理。致力于发现、配置和管理微服务Nacos支持几乎所有主流类型”服务”的发现、配置和管理，如：Kubernetes Service|gRPC &amp; Dubbo RPC Service|Spring Cloud RESTful Service</p>
<h3 id="Nacos的关键特性包括："><a href="#Nacos的关键特性包括：" class="headerlink" title="Nacos的关键特性包括："></a>Nacos的关键特性包括：</h3><p><strong>1、服务发现和服务健康检测</strong><br><strong>Nacos</strong>支持基于DNS和基于RPC的服务发现。服务提供者使用<em>原生SDK</em>、<em>OpenApi</em>或一个<em>独立的Agent TODO</em>注册Service后。服务消费者可以使用<em>DNS TODO</em>或<em>HTTP&amp;API</em>查找和发现服务。<br><strong>Nacos</strong>提供对服务的实时的<strong>健康检查，阻止向不健康的主机或服务实例发送请求</strong>。Nacos支持传输层(PING或TCP)和应用层(如 HTTP、MySQL、用户自定义)的健康检查。对于复杂的云环境和网络拓扑环境中（如 VPC、边缘网络等）服务的健康检查，Nacos 提供了<strong>agent上报模式</strong>和<strong>服务端主动检测</strong>2种健康检查模式。<br><strong>Nacos</strong>还提供了统一的<strong>健康检查仪表盘</strong>，帮助您根据健康状态管理服务的可用性及流量。<br><strong>2、动态配置服务</strong><br>动态配置服务可以让您以中心化、外部化和动态化的方式管理所有环境的应用配置和服务配置。动态配置消除了配置变更时重新部署应用和服务的需要，让配置管理变得更加高效和敏捷。配置中心化管理让实现无状态服务变得更简单，让服务按需弹性扩展变得更容易。<br><strong>3、动态DNS服务</strong><br>动态 DNS 服务支持权重路由，让您更容易地实现中间层负载均衡、更灵活的路由策略、流量控制以及数据中心内网的简单DNS解析服务。  动态DNS服务还能让您更容易地实现以DNS协议为基础的服务发现，以帮助您消除耦合到厂商私有服务发现 API 上的风险。  </p>
<h3 id="NACOS服务发现"><a href="#NACOS服务发现" class="headerlink" title="NACOS服务发现"></a>NACOS服务发现</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- nacos 依赖--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">#启动类入口添加注解开启服务注册和发现</span></pre></td></tr><tr><td class="code"><pre><span class="line">@EnableDiscoveryClient</span></pre></td></tr><tr><td class="code"><pre><span class="line">@SpringBootApplication</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class AuthApplication &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public static void main(String[] args) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        SpringApplication.run(AuthApplication.class);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">#服务注册中心配置</span></pre></td></tr><tr><td class="code"><pre><span class="line">spring:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  application:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name: project-name</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cloud:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    nacos:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      discovery:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        server-addr: http:&#x2F;&#x2F;localhost:8848</span></pre></td></tr></table></figure>
<p>打开nacos控制台进入服务列表查看  </p>
<h3 id="NACOS服务配置"><a href="#NACOS服务配置" class="headerlink" title="NACOS服务配置"></a>NACOS服务配置</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- nacos-config 依赖--&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;groupId&gt;com.alibaba.cloud&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-config&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">#bootstrap.yml指定nacos配置文件名</span></pre></td></tr><tr><td class="code"><pre><span class="line">spring:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  application:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    name: project-name</span></pre></td></tr><tr><td class="code"><pre><span class="line">  cloud:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    nacos:</span></pre></td></tr><tr><td class="code"><pre><span class="line">      discovery:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        server-addr: http:&#x2F;&#x2F;localhost:8848</span></pre></td></tr><tr><td class="code"><pre><span class="line">      config:</span></pre></td></tr><tr><td class="code"><pre><span class="line">        file-extension: yaml  # 必须修改成yaml</span></pre></td></tr><tr><td class="code"><pre><span class="line">        group: DEFAULT_GROUP  # 缺省即可</span></pre></td></tr><tr><td class="code"><pre><span class="line">        prefix: $&#123;spring.application.name&#125; # 缺省即可</span></pre></td></tr><tr><td class="code"><pre><span class="line">rsa:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  publicKey: 123456</span></pre></td></tr></table></figure>
<p><strong>注意:这里必须使用bootstrap.yml不能是application.yml，避免被nacos自带的配置文件被覆盖</strong><br>SpringBoot读取配置文件的顺序：<br>bootstrap.yml&gt;bootstrap.yaml&gt;bootstrap.properties&gt;nacos settings&gt;application.yml&gt;application.yaml&gt;application.properties</p>
<pre><code>#添加接口读取配置信息并添加动态刷新配置的注解@RefreshScope
@RefreshScope
@RestController
@RequestMapping(&quot;/oauth&quot;)
public class AuthController {

    @Value(&quot;${rsa.publicKey}&quot;)
    public String publicKey;

    @GetMapping(&quot;/publicKey&quot;)
    public Result getPublicKey(){
        return Result.success(this.publicKey);
    }
}
</code></pre><p>可以在nacos管理控制台添加和修改配置，从而保持动态更新<br><strong>简单介绍一下数据库CAP理论</strong><br>CAP理论是说对于分布式数据存储，最多只能同时满足一致性（C，Consistency）、可用性（A， Availability）、分区容错性（P，Partition Tolerance）中的两者。  </p>
<ul>
<li>一致性，是指对于每一次读操作，要么都能够读到最新写入的数据，要么错误。</li>
<li>可用性，是指对于每一次请求，都能够得到一个及时的、非错的响应，但是不保证请求的结果是基于最新写入的数据。</li>
<li>分区容错性，是指由于节点之间的网络问题，即使一些消息对包或者延迟，整个系统能继续提供服务(提供一致性或者可用性)。  </li>
</ul>
<h3 id="服务的订阅和发现"><a href="#服务的订阅和发现" class="headerlink" title="服务的订阅和发现"></a>服务的订阅和发现</h3><p><strong>整个服务注册与发现的过程和大致的设计原理和思路</strong><br>一、服务如何注册<br><img src="/2021/05/01/Spring-Cloud-Nacos/2.jpg" alt="nacos">  </p>
<p><img src="/2021/05/01/Spring-Cloud-Nacos/3.jpg" alt="nacos">  </p>
<p><img src="/2021/05/01/Spring-Cloud-Nacos/4.jpg" alt="nacos">  </p>
<p><img src="/2021/05/01/Spring-Cloud-Nacos/5.jpg" alt="nacos">  </p>
<p>二、服务如何发现<br>服务注册到注册中心后，服务的消费者就可以进行服务发现的流程了，消费者可以直接向注册中心发送获取某个服务实例的请求，这种情况下注册中心将返回所有可用的服务实例给消费者，但是一般不推荐这种情况。另一种方法就是服务的消费者向注册中心订阅某个服务，并提交一个监听器，当注册中心中服务发生变更时，监听器会收到通知，这时消费者更新本地的服务实例列表，以保证所有的服务均是可用的。<br><img src="/2021/05/01/Spring-Cloud-Nacos/6.jpg" alt="nacos">  </p>
<p><img src="/2021/05/01/Spring-Cloud-Nacos/7.jpg" alt="nacos">  </p>
<p>三、Nacos服务注册与订阅的完整流程<br><img src="/2021/05/01/Spring-Cloud-Nacos/8.png" alt="nacos">  </p>
<p>例：服务注册与发现，Dubbo架构为例<br><img src="/2021/05/01/Spring-Cloud-Nacos/9.jpg" alt="nacos">  </p>
<p>0、服务容器负责启动，加载，运行服务提供者。<br>1、服务提供者在启动时，向注册中心注册自己提供的服务。<br>2、服务消费者在启动时，向注册中心订阅自己所需的服务。<br>3、注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。<br>4、服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。<br>5、服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心<br><em>其中图中最上方的 Registry 就是注册中心，负责服务的注册与发现。Dubbo 有自己的 Registry 实现，而 Nacos 则是另一种 Registry 的实现。</em></p>
]]></content>
      <categories>
        <category>Cloud Compute</category>
      </categories>
      <tags>
        <tag>Cloud Compute</tag>
        <tag>Spring-Cloud-Nacos</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-Cloud-Gateway</title>
    <url>/2021/05/01/Spring-Cloud-Gateway/</url>
    <content><![CDATA[<h2 id="介绍Gateway"><a href="#介绍Gateway" class="headerlink" title="介绍Gateway"></a>介绍Gateway</h2><p>API网关:将多个服务对外提供的API汇聚起来，让外部看起来像一个统一的接口。此外，可以在网关中提供额外的功能。可以和以前的单服务做对比，一个服务是一个应用程序由一个统一的进程来管理。<br><img src="/2021/05/01/Spring-Cloud-Gateway/1.jpg" alt="gateway">  </p>
<p>网关的核心功能：主要功能路由转发+过滤器<br>路由转发: 接受外界请求，通过网关的路由转发，转发到后端的服务上<br>过滤器：提供了25种内置功能加自定义的功能，如网关容错、限流以及额外的处理<br>可以和服务注册中心完美结合，例如：Eureka, Consul, Nacos<br><img src="/2021/05/01/Spring-Cloud-Gateway/2.png" alt="gateway">  </p>
<p>Spring Cloud微服务中，1.x版本采用Zuul网关其有阻塞到非阻塞的多个版本<br>gateway是SpringCloud自己开发的网关，旨在为微服务架构提供简单有效的统一的API路由管理方式。功能如下： </p>
<ul>
<li>基于Spring Framework5,Project Reactor和Spring Boot2.0构建</li>
<li>动态路由: 能够匹配任何请求属性</li>
<li>集成Spring Cloud服务发现功能</li>
<li>可以对路由指定Predicate断言和Filter过滤器，并且断言和过滤器易于编写</li>
<li>集成Hystrix的熔断功能</li>
<li>请求限流功能</li>
<li>支持路径重写  </li>
</ul>
<p><img src="/2021/05/01/Spring-Cloud-Gateway/3.png" alt="gateway">  </p>
<p>上图最主要的就是路由，其中，Predicates和Filters作用于特定路由<br>Route(路由):一个路由包括ID，URI,<em>Predicate</em>集合和<em>Filter</em>集合<br>如果聚合谓词为真，则匹配路由<br>Predicate: 允许开发人员匹配HTTP请求中的任何内容，比如Header和参数<br>Filter: 可以在发送下流请求之前或之后修改请求和响应<br><img src="/2021/05/01/Spring-Cloud-Gateway/4.png" alt="gateway">  </p>
<p>客户端向 Spring Cloud Gateway <strong>发出请求</strong>。然后在 Gateway Handler Mapping中 <strong>找到与请求相匹配的路由</strong>，将其<strong>发送到Gateway Web Handler</strong>。Handler 再通过指定的<strong>过滤器链来将请求发送到我们实际的服务执行业务逻辑</strong>，然后返回。过滤器之间用虚线分开是因为过滤器可能会在发送<strong>代理请求之前（“pre”）或之后（“post”）执行业务</strong>逻辑。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Filter-Pre(之前)</th>
<th style="text-align:center">Filter-Post(之后)</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">参数校验</td>
<td style="text-align:center">响应内容</td>
</tr>
<tr>
<td style="text-align:center">权限校验</td>
<td style="text-align:center">响应头的修改</td>
</tr>
<tr>
<td style="text-align:center">流量监控</td>
<td style="text-align:center">日志输出</td>
</tr>
<tr>
<td style="text-align:center">日志输出</td>
<td style="text-align:center">浏览监控</td>
</tr>
<tr>
<td style="text-align:center">协议转换</td>
<td style="text-align:center">等等</td>
</tr>
</tbody>
</table>
</div>
<p>Predicate接受一个输入参数，返回一个布尔值结果。该接口包含多种默认方法将Predicate组合成其他复杂的逻辑如：与、或、非。可以对接口请求进行参数校验，判断新老数据是否有变化，是否需要更新等<br>Spring Cloud Gateway内置了许多Predicate,源码在org.springframework.cloud.gateway.handler.predicate包中只有满足特定要求的请求，并交由router处理。如时间要求，cookie要求，host,method,path等，每一种predicate都会<br>当前的客户端进行判断，是否满足当前的要求。如果满足则交给当前请求处理。如果有很多个Predicate,则按照配置的顺序第一个生效。<br>例一、时间断言<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    cloud:    </span></pre></td></tr><tr><td class="code"><pre><span class="line">        gateway:      </span></pre></td></tr><tr><td class="code"><pre><span class="line">            routes:      </span></pre></td></tr><tr><td class="code"><pre><span class="line">            - id: after_route        </span></pre></td></tr><tr><td class="code"><pre><span class="line">              uri: http:&#x2F;&#x2F;www.google.com        </span></pre></td></tr><tr><td class="code"><pre><span class="line">              predicates:        </span></pre></td></tr><tr><td class="code"><pre><span class="line">              - After&#x3D;2018-12-25T14:33:47.789+08:00 #东八区2018-12-25 14:33:47后，将请求都转跳到Google</span></pre></td></tr></table></figure><br>例二、Cookie断言<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cloud:    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    gateway:  </span></pre></td></tr><tr><td class="code"><pre><span class="line">        routes:      </span></pre></td></tr><tr><td class="code"><pre><span class="line">        - id: cookie_route       </span></pre></td></tr><tr><td class="code"><pre><span class="line">          uri: http:&#x2F;&#x2F;www.google.com        </span></pre></td></tr><tr><td class="code"><pre><span class="line">          predicates:        </span></pre></td></tr><tr><td class="code"><pre><span class="line">          - Cookie&#x3D;cookiename, cookievalue #匹配请求存在cookie名为cookiename, cookie内容匹配ookievalue的，转发到googl</span></pre></td></tr></table></figure><br>例三、Method Route<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    cloud:    </span></pre></td></tr><tr><td class="code"><pre><span class="line">        gateway:      </span></pre></td></tr><tr><td class="code"><pre><span class="line">            routes:      </span></pre></td></tr><tr><td class="code"><pre><span class="line">            - id: method_route        </span></pre></td></tr><tr><td class="code"><pre><span class="line">              uri: http:&#x2F;&#x2F;www.google.com        </span></pre></td></tr><tr><td class="code"><pre><span class="line">              predicates:        </span></pre></td></tr><tr><td class="code"><pre><span class="line">              - Method&#x3D;GET #路由匹配到所有GET方法的请求</span></pre></td></tr></table></figure><br>例四、Path Route<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    cloud:    </span></pre></td></tr><tr><td class="code"><pre><span class="line">        gateway:      </span></pre></td></tr><tr><td class="code"><pre><span class="line">            routes:      </span></pre></td></tr><tr><td class="code"><pre><span class="line">            - id: host_route        </span></pre></td></tr><tr><td class="code"><pre><span class="line">              uri: http:&#x2F;&#x2F;www.google.com       </span></pre></td></tr><tr><td class="code"><pre><span class="line">              predicates:        </span></pre></td></tr><tr><td class="code"><pre><span class="line">              - Path&#x3D;&#x2F;foo&#x2F;&#123;segment&#125;,&#x2F;bar&#x2F;&#123;segment&#125; #path列表作为参数</span></pre></td></tr></table></figure></p>
<p>Hystrix GatewayFilter Factory<br>Hystrix是Netflix实现的断路器模式工具包。The Hystrix GatewayFilter就是将断路器使用在gateway路由上，<br>目的是保护服务器避免级联故障，以及在下游失败时可以降级返回。在分布式系统中，服务应该具有自我保护的<br>能力，当依赖服务不可用时，当前服务启动自我保护功能，从而避免雪崩效应。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Spring Cloud Gateway maven依赖</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;dependency&gt;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">	&lt;groupId&gt;org.springframework.cloud&lt;&#x2F;groupId&gt;   </span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;artifactId&gt;spring-cloud-starter-hystrix&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependency&gt;</span></pre></td></tr></table></figure><br>请求限流：一、方式大量的请求使服务过载，导致服务不可用；二、防止网络攻击。<br><img src="/2021/05/01/Spring-Cloud-Gateway/5.png" alt="gateway">  </p>
<p>Zuul IO模型：采用阻塞式处理模型，所有request请求对应一个servlet。请求进入servlet container就会为其绑定一个线程。这在并发不高的情况下适用，并发上升时，线程数量上涨，严重影像请求响应时间。<br>Webflux服务器：替换了Servlet线程模型，用少量的线程处理request和request io操作称为Loop线程。业务交给响应式编程框架去处理。阻塞操作交给响应式框架work线程中处理，不阻塞操作交给Loop线程处理。</p>
<p><strong>Reactor,Netty通信框架</strong></p>
]]></content>
      <categories>
        <category>Cloud Compute</category>
      </categories>
      <tags>
        <tag>Cloud Compute</tag>
        <tag>Spring-Cloud-Gateway</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-Boot-DB</title>
    <url>/2021/04/24/Spring-Boot-DB/</url>
    <content><![CDATA[<h2 id="Spring-Boot连接数据库学习"><a href="#Spring-Boot连接数据库学习" class="headerlink" title="Spring Boot连接数据库学习"></a>Spring Boot连接数据库学习</h2><p>一、Mysql的版本不同依赖和配置信息也不同<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">查看mysql版本</span></pre></td></tr><tr><td class="code"><pre><span class="line">$ mysql -uroot -p******</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; select version();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&gt; exit;</span></pre></td></tr></table></figure></p>
<p>添加mysql依赖<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;version&gt;8.0.12&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependency&gt;</span></pre></td></tr></table></figure><br>数据源配置，在application.properties<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 数据源配置，请修改为实际配置</span></pre></td></tr><tr><td class="code"><pre><span class="line">spring.datasource.url&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;databasename?serverTimezone&#x3D;Asia&#x2F;Shanghai&amp;zeroDateTimeBehavior&#x3D;convertToNull&amp;autoReconnect&#x3D;true&amp;useSSL&#x3D;false&amp;failOverReadOnly&#x3D;false</span></pre></td></tr><tr><td class="code"><pre><span class="line">spring.datasource.username&#x3D;bimengine</span></pre></td></tr><tr><td class="code"><pre><span class="line">spring.datasource.password&#x3D;fgBQLZpgDaxH7xuu</span></pre></td></tr><tr><td class="code"><pre><span class="line">spring.datasource.driver-class-name&#x3D;com.mysql.cj.jdbc.Driver</span></pre></td></tr></table></figure><br>问题：SpringBoot配置JDBC连接MySQL数据库的时候遇到了报错：HikariPool-1 - Exception during pool initialization  </p>
<ul>
<li>检查application.properties-&gt;spring.datasource中的url是否是对的，例如数据库名等</li>
<li>检查用户名和密码</li>
<li>mysql5和mysql8使用的driver是不一样的注意区别</li>
<li>检查时区，url中添加&amp;serverTimezone=UTC</li>
</ul>
<p>eg:spring.datasource.url=jdbc:mysql://localhost:3306/movie?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC<br><strong>hikari</strong><br>针对需要手动配置datasource的时候，需要使用手动创建HikariConfig,使用该对象去创建datasource<br>jdbc2.0开始使用DataSource接口来创建连接，对比DriverManager的方式创建连接，DataSource会更优雅一些<br><strong>hikari主要连接池属性</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">主要配置</th>
<th style="text-align:center">常用配置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">dataSourceC;assName</td>
<td style="text-align:center">autoCommit</td>
</tr>
<tr>
<td style="text-align:center">jdbcUrl</td>
<td style="text-align:center">connectionTimeout</td>
</tr>
<tr>
<td style="text-align:center">username</td>
<td style="text-align:center">idleTimeout</td>
</tr>
<tr>
<td style="text-align:center">password</td>
<td style="text-align:center">maLifetime</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdbcUrl&#x3D;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;databasename</span></pre></td></tr><tr><td class="code"><pre><span class="line">user&#x3D;test</span></pre></td></tr><tr><td class="code"><pre><span class="line">password&#x3D;test</span></pre></td></tr><tr><td class="code"><pre><span class="line">dataSource.cachePrepStmts&#x3D;true</span></pre></td></tr><tr><td class="code"><pre><span class="line">dataSource.prepStmtCacheSize&#x3D;250</span></pre></td></tr><tr><td class="code"><pre><span class="line">dataSource.prepStmtCacheSqlLimit&#x3D;2048</span></pre></td></tr><tr><td class="code"><pre><span class="line">dataSource.useServerPrepStmts&#x3D;true</span></pre></td></tr><tr><td class="code"><pre><span class="line">dataSource.useLocalSessionState&#x3D;true</span></pre></td></tr><tr><td class="code"><pre><span class="line">dataSource.useLocalTransactionState&#x3D;true</span></pre></td></tr><tr><td class="code"><pre><span class="line">dataSource.rewriteBatchedStatements&#x3D;true</span></pre></td></tr><tr><td class="code"><pre><span class="line">dataSource.cacheResultSetMetadata&#x3D;true</span></pre></td></tr><tr><td class="code"><pre><span class="line">dataSource.cacheServerConfiguration&#x3D;true</span></pre></td></tr><tr><td class="code"><pre><span class="line">dataSource.elideSetAutoCommits&#x3D;true</span></pre></td></tr><tr><td class="code"><pre><span class="line">dataSource.maintainTimeStats&#x3D;false</span></pre></td></tr></table></figure>
<h3 id="二、三种数据库连接方式"><a href="#二、三种数据库连接方式" class="headerlink" title="二、三种数据库连接方式"></a>二、三种数据库连接方式</h3><p><strong>1、准备待操纵的数据库表</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE &#x2F;*!32312 IF NOT EXISTS*&#x2F;&#96;springboot_db&#96; &#x2F;*!40100 DEFAULT CHARACTER SET utf8 *&#x2F;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">USE &#96;springboot_db&#96;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">DROP TABLE IF EXISTS &#96;t_author&#96;;</span></pre></td></tr><tr><td class="code"><pre><span class="line"> </span></pre></td></tr><tr><td class="code"><pre><span class="line">CREATE TABLE &#96;t_author&#96; (</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#96;id&#96; bigint(20) unsigned NOT NULL AUTO_INCREMENT COMMENT &#39;用户ID&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#96;real_name&#96; varchar(32) NOT NULL COMMENT &#39;用户名称&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  &#96;nick_name&#96; varchar(32) NOT NULL COMMENT &#39;用户匿名&#39;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">  PRIMARY KEY (&#96;id&#96;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">) ENGINE&#x3D;InnoDB AUTO_INCREMENT&#x3D;1 DEFAULT CHARSET&#x3D;utf8;</span></pre></td></tr></table></figure><br><strong>2、添加配置文件，如上面在application.yml中的连接池配置</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  datasource:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;springboot_db?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;useSSL&#x3D;false</span></pre></td></tr><tr><td class="code"><pre><span class="line">    driverClassName: com.mysql.jdbc.Driver</span></pre></td></tr><tr><td class="code"><pre><span class="line">    username: root</span></pre></td></tr><tr><td class="code"><pre><span class="line">    password: root</span></pre></td></tr><tr><td class="code"><pre><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span></pre></td></tr></table></figure><br><strong>3、建立与数据库对应的POJO类</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Author &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Long id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String realName;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String nickName;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; SET和GET方法略</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><br><strong>方式一：与JdbcTemplate集成</strong><br><strong>Spring boot依赖:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;artifactId&gt;spring-boot-starter-jdbc&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependency&gt;</span></pre></td></tr></table></figure><br><strong>引入Junit测试starter:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">       &lt;scope&gt;test&lt;&#x2F;scope&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependency&gt;</span></pre></td></tr></table></figure><br><strong>DAO接口:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface AuthorDao &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    int add(Author author);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    int update(Author author);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    int delete(Long id);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    Author findAuthor(Long id);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    List&lt;Author&gt; findAuthorList();</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><br><strong>DAO接口实现:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Repository</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class AuthorDaoJdbcTemplateImpl implements AuthorDao&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private NamedParameterJdbcTemplate jdbcTemplate;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    </span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public int add(Author author) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        String sql &#x3D; &quot;insert into t_author(id,real_name,nick_name) &quot; +</span></pre></td></tr><tr><td class="code"><pre><span class="line">                &quot;values(:id,:realName,:nickName)&quot;;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Map&lt;String, Object&gt; param &#x3D; new HashMap&lt;&gt;();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        param.put(&quot;id&quot;,author.getId());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        param.put(&quot;realName&quot;, author.getRealName());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        param.put(&quot;nickName&quot;, author.getNickName());</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        return (int) jdbcTemplate.update(sql, param);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public int update(Author author) &#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">        return 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public int delete(Long id) &#123;    </span></pre></td></tr><tr><td class="code"><pre><span class="line">        return 0;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Author findAuthor(Long id) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        return null;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Override</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public List&lt;Author&gt; findAuthorList() &#123;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">          return null;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><br><strong>通过JUit测试:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span></pre></td></tr><tr><td class="code"><pre><span class="line">@SpringBootTest(classes &#x3D; BootApplication.class)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class AuthorDaoTest &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private AuthorDao authorDao;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Test</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void testInsert() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Author author &#x3D; new Author();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        author.setId(1L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        author.setRealName(&quot;莫言&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        author.setNickName(&quot;疯子&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        </span></pre></td></tr><tr><td class="code"><pre><span class="line">        authorDao.add(author);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(&quot;插入成功！&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></p>
<h3 id="方式二-与JPA集成"><a href="#方式二-与JPA集成" class="headerlink" title="方式二: 与JPA集成"></a>方式二: 与JPA集成</h3><p><strong>引入starter：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependency&gt;</span></pre></td></tr></table></figure><br><strong>对POJO类增加Entity的注解，并指定表命(默认为author)，然后制定ID及其生成策略</strong><br><strong>注: 可以查看JPA知识</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import javax.persistence.Entity;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import javax.persistence.GeneratedValue;</span></pre></td></tr><tr><td class="code"><pre><span class="line">import javax.persistence.Id;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">@Entity(name &#x3D; &quot;t_author&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class Author &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Id</span></pre></td></tr><tr><td class="code"><pre><span class="line">    @GeneratedValue</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private Long id;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String realName;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private String nickName;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#x2F;&#x2F; SET和GET方法略</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><br><strong>接口应该继承JpaRepository</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface AuthorRepository extends JpaRepository&lt;Author, Long&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Optional&lt;Author&gt; findById(Long userId);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Query(&quot;select au from com.guxf.domain.Author au where nick_name&#x3D;:nickName&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public List&lt;Author&gt; queryByNickName(@Param(&quot;nickName&quot;) String nickName);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><br><strong>测试代码:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span></pre></td></tr><tr><td class="code"><pre><span class="line">@SpringBootTest(classes &#x3D; BootApplication.class)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class AuthorDaoTestJPA &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private AuthorRepository authorRepository;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Test</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void testQuery() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        List&lt;Author&gt; authorList &#x3D; authorRepository.queryByNickName(&quot;疯子&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        assertTrue(authorList.size() &gt; 0);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(&quot;成功！&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure></p>
<h3 id="方法三-与MyBatis集成"><a href="#方法三-与MyBatis集成" class="headerlink" title="方法三: 与MyBatis集成"></a>方法三: 与MyBatis集成</h3><p><strong>引入starter: Spring没有定义该starter的版本，所以需要自己指定version</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;&#x2F;groupId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;&#x2F;artifactId&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;version&gt;1.1.1&lt;&#x2F;version&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;dependency&gt;</span></pre></td></tr></table></figure><br><strong>MyBatis一般可以通过XML或者注解的方式来指定SQL</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  datasource:</span></pre></td></tr><tr><td class="code"><pre><span class="line">    url: jdbc:mysql:&#x2F;&#x2F;127.0.0.1:3306&#x2F;springboot_db?useUnicode&#x3D;true&amp;characterEncoding&#x3D;UTF-8&amp;useSSL&#x3D;false</span></pre></td></tr><tr><td class="code"><pre><span class="line">    driverClassName: com.mysql.jdbc.Driver</span></pre></td></tr><tr><td class="code"><pre><span class="line">    username: root</span></pre></td></tr><tr><td class="code"><pre><span class="line">    password: root</span></pre></td></tr><tr><td class="code"><pre><span class="line">    type: com.alibaba.druid.pool.DruidDataSource</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">mybatis:</span></pre></td></tr><tr><td class="code"><pre><span class="line">  #config-locations: mybatis&#x2F;mybatis-config.xml</span></pre></td></tr><tr><td class="code"><pre><span class="line">  mapper-locations: com&#x2F;guxf&#x2F;mapper&#x2F;*.xml</span></pre></td></tr><tr><td class="code"><pre><span class="line">  type-aliases-package: com.guxf.mapper.AuthorMapper</span></pre></td></tr></table></figure><br><strong>编写mapper对应的接口:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Mapper</span></pre></td></tr><tr><td class="code"><pre><span class="line">public interface AuthorMapper extends BaseMapper&lt;Author&gt; &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Long insertAuthor(Author author);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void updateAuthor(Author author);</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    public Author queryById(Long id);</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><br><strong>配置Mapper的XML文件:</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot; &gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;mapper namespace&#x3D;&quot;com.guxf.mapper.AuthorMapper&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;!-- 此处需要注意的是，由于我们数据库定义的id存储类型为intbig,但是我们的Entity中Id是Long --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;!-- 前面的两种方式插入没问题，此处报了数据库类型异常 --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;!-- 所以数据库的ID类型改为了Varchar --&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;resultMap id&#x3D;&quot;authorMap&quot; type&#x3D;&quot;com.guxf.domain.Author&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;id column&#x3D;&quot;id&quot; property&#x3D;&quot;id&quot; jdbcType&#x3D;&quot;VARCHAR&quot; &#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;result column&#x3D;&quot;real_name&quot; property&#x3D;&quot;realName&quot; jdbcType&#x3D;&quot;VARCHAR&quot; &#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;result column&#x3D;&quot;nick_name&quot; property&#x3D;&quot;nickName&quot; jdbcType&#x3D;&quot;VARCHAR&quot; &#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;resultMap&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;sql id&#x3D;&quot;base_column&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        id,real_name,nick_name</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;sql&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;insert id&#x3D;&quot;insertAuthor&quot; parameterType&#x3D;&quot;com.guxf.domain.Author&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        INSERT INTO</span></pre></td></tr><tr><td class="code"><pre><span class="line">        t_author(</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;include refid&#x3D;&quot;base_column&quot; &#x2F;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        )</span></pre></td></tr><tr><td class="code"><pre><span class="line">        VALUE</span></pre></td></tr><tr><td class="code"><pre><span class="line">        (#&#123;id&#125;,#&#123;realName&#125;,#&#123;nickName&#125;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;insert&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;update id&#x3D;&quot;updateAuthor&quot; parameterType&#x3D;&quot;com.guxf.domain.Author&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        UPDATE t_author</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;set&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;if test&#x3D;&quot;realName !&#x3D; null&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                real_name &#x3D; #&#123;realName&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;&#x2F;if&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;if test&#x3D;&quot;nickName !&#x3D; null&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">                nick_name &#x3D; #&#123;nickName&#125;,</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &lt;&#x2F;if&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;&#x2F;set&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        WHERE id &#x3D; #&#123;id&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;update&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;select id&#x3D;&quot;queryById&quot; parameterType&#x3D;&quot;Long&quot; resultMap&#x3D;&quot;authorMap&quot;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        SELECT id,</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &lt;include refid&#x3D;&quot;base_column&quot;&gt;&lt;&#x2F;include&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        FROM t_author</span></pre></td></tr><tr><td class="code"><pre><span class="line">        WHERE id &#x3D; #&#123;id&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &lt;&#x2F;select&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;mapper&gt;</span></pre></td></tr></table></figure><br><strong>测试类代码</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span></pre></td></tr><tr><td class="code"><pre><span class="line">@SpringBootTest(classes &#x3D; BootApplication.class)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public class AuthorDaoTestMybatis &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Autowired</span></pre></td></tr><tr><td class="code"><pre><span class="line">    private AuthorMapper mapper;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Test</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void testInsert() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Author author &#x3D; new Author();</span></pre></td></tr><tr><td class="code"><pre><span class="line">        author.setId(4L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        author.setRealName(&quot;唐钰&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        author.setNickName(&quot;小宝&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mapper.insertAuthor(author);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(&quot;成功!&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Test</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void testMybatisQuery() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Author author &#x3D; mapper.queryById(1L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        assertNotNull(author);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        System.out.println(author);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">    @Test</span></pre></td></tr><tr><td class="code"><pre><span class="line">    public void testUpdate() &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        Author author &#x3D; mapper.queryById(2L);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        author.setNickName(&quot;月儿&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        author.setRealName(&quot;林月如&quot;);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        mapper.updateAuthor(author);</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure><br><em>mybatis @SELECT注解的动态拼写SQL</em><br>eg:如果要在查询条件中判断条件是否为空，如判断startNo, pageSize不为空<br>在XML中配置如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;when test&#x3D;&#39;startNo!&#x3D;null and pageSize !&#x3D; null &#39;&gt;</span></pre></td></tr><tr><td class="code"><pre><span class="line">  LIMIT #&#123;startNo&#125;,#&#123;pageSize&#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&lt;&#x2F;when&gt;</span></pre></td></tr></table></figure><br><strong>使用@SELECT</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Select(&quot;&lt;script&gt;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	+&quot;select * from mi_taobao where 1&#x3D;1&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	+&quot;&lt;if test&#x3D;&#39;status !&#x3D; null&#39;&gt;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	+&quot;and status &#x3D; #&#123;status&#125;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	+&quot;&lt;&#x2F;if&gt;&quot;</span></pre></td></tr><tr><td class="code"><pre><span class="line">	+&quot;&lt;&#x2F;script&gt;&quot;)</span></pre></td></tr><tr><td class="code"><pre><span class="line">public List&lt;Taobao&gt; getTaobao(@Param(&quot;status&quot;) Integer status);</span></pre></td></tr></table></figure><br>问题: Caused by: org.apache.ibatis.reflection.ReflectionException: There is no getter for property named ‘status’ in ‘class java.lang.Interger’<br>参数属性不一致导致，需要加@Param(“xxx”),一般两个参数必须添加@Param，一个参数可以不加</p>
]]></content>
      <categories>
        <category>Cloud Compute</category>
      </categories>
      <tags>
        <tag>Cloud Compute</tag>
        <tag>Spring-Boot-DB</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring-Boot-Learn</title>
    <url>/2021/04/24/Spring-Boot-Learn/</url>
    <content><![CDATA[<h2 id="Spring-Boot学习"><a href="#Spring-Boot学习" class="headerlink" title="Spring Boot学习"></a>Spring Boot学习</h2><h3 id="一、创建Spring-Boot新项目"><a href="#一、创建Spring-Boot新项目" class="headerlink" title="一、创建Spring Boot新项目"></a>一、创建Spring Boot新项目</h3><p>创建工具IDEA</p>
<ul>
<li>File-&gt;New-&gt;project-&gt;Spring Initialize-&gt;Next</li>
<li>填写Group、Artifact、Language、Java Version、Version、Name、Description</li>
<li>Next-&gt;Web-&gt;Spring Web(随spring boot版本不同而不同)-&gt;Next-&gt;Finish</li>
</ul>
<p><img src="/2021/04/24/Spring-Boot-Learn/1.png" alt="new"></p>
<ul>
<li>配置环境File-&gt;Settings-&gt;Build,Execution,Deployment-&gt;Maven<ul>
<li>Maven home directory #apache-maven-3.6.3的下载目录</li>
<li>User settings file #apache-maven-3.6.3的配置文件，在其目录的conf下</li>
<li>Local repository #一般在apache-maven-3的配置中已经指定，依赖的下载路径</li>
</ul>
</li>
</ul>
<p><img src="/2021/04/24/Spring-Boot-Learn/2.png" alt="new"></p>
<p>运行程序Application.java<br>浏览器访问：http:localhost:8080<br>会发现如下的错误，前后端没有做映射，后端给出的默认界面</p>
<p><img src="/2021/04/24/Spring-Boot-Learn/3.png" alt="new"></p>
<p>前后端分离：前、后端通过RESTful API传递JSON数据进行交流。后端不涉及前端界面的内容，有别于JSP<br><strong>目前RESTful方式的前后端访问方式比较流行，如openstack提供了底层RESTful API接口给后端访问</strong></p>
<p>前后端对接：前端调用前端的服务器Nginx,后端调用后端的服务器Tomcat<br>反向代理: 前端请求通过前端服务器转发给后端，只需知道后端开放的接口，无需知道如何实现<br>*为了保护服务器，不保留真实地址</p>
<p>重点:<br>组件的依赖关系、版本的确认</p>
]]></content>
      <categories>
        <category>Cloud Compute</category>
      </categories>
      <tags>
        <tag>Cloud Compute</tag>
        <tag>Spring-Boot-Learn</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue-Learn</title>
    <url>/2021/04/24/Vue-Learn/</url>
    <content><![CDATA[<h2 id="Vue学习"><a href="#Vue学习" class="headerlink" title="Vue学习"></a>Vue学习</h2><h3 id="一、Vue安装"><a href="#一、Vue安装" class="headerlink" title="一、Vue安装"></a>一、Vue安装</h3><p><strong>安装Vue CLI脚手架需要</strong><br>1、node, 安装前先查看是否已安装<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;node -v</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#96;&#96;&#96;  </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">2、npm</span></pre></td></tr></table></figure></p>
<blockquote>
<p>npm -v</p>
<h1 id="如未安装"><a href="#如未安装" class="headerlink" title="如未安装"></a>如未安装</h1><p>npm -g install npm  </p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">安装vue-cli</span></pre></td></tr></table></figure>
<blockquote>
<p>npm install -g vue-cli #这是2.x版本，3.x版本安装命令会不一样<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">可能遇到的错误</span></pre></td></tr><tr><td class="code"><pre><span class="line">![vue](Vue-Learn&#x2F;1.png)  </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">---</span></pre></td></tr><tr><td class="code"><pre><span class="line">**构建项目**</span></pre></td></tr><tr><td class="code"><pre><span class="line">如果前面安装时执行了npm install则直接执行：</span></pre></td></tr></table></figure><br>cd xxx_project_name<br>npm run dev<br>```  </p>
</blockquote>
<p><img src="/2021/04/24/Vue-Learn/2.png" alt="exec">  </p>
<p><img src="/2021/04/24/Vue-Learn/3.png" alt="exec">  </p>
<p>项目的构建也可以使用IDEA-&gt;IntelliJ IDEA<br>目录说明, <a href="http://localhost:8080" target="_blank" rel="noopener">http://localhost:8080</a> 访问初始界面<br><img src="/2021/04/24/Vue-Learn/5.png" alt="prostr">  </p>
<p><img src="/2021/04/24/Vue-Learn/6.png" alt="prostr">  </p>
<p><a href="https://www.cnblogs.com/irenehanb/p/10967834.html" target="_blank" rel="noopener">参考</a></p>
<p><strong>关键文件</strong><br>index.html, 定义单页面，编写的其他内容都在此处的div中展示<br>App.vue， 根目录，包括script脚本和路由容器<br>main.js，将App，html，和路由整合到一起<br><img src="/2021/04/24/Vue-Learn/4.png" alt="prostr">  </p>
]]></content>
      <categories>
        <category>Cloud Compute</category>
      </categories>
      <tags>
        <tag>Cloud Compute</tag>
        <tag>Vue-Learn</tag>
      </tags>
  </entry>
  <entry>
    <title>Vim-Summary</title>
    <url>/2021/04/14/Vim-Summary/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Cambricon-Learning</title>
    <url>/2021/04/14/Cambricon-Learning/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Tensorflow-Source-Code-Learning</title>
    <url>/2021/04/14/Tensorflow-Source-Code-Learning/</url>
    <content><![CDATA[<h3 id="Tensorflow-framework核心"><a href="#Tensorflow-framework核心" class="headerlink" title="Tensorflow framework核心"></a>Tensorflow framework核心</h3><p>1、前端接口语言的支持（通过swig实现其他语言与C/C++的编写的程序进行连接，如：Java,Python）<br>2、前后端session的管理<br>3、graph的构建、分裂、运行和执行<br>4、Operation的Register和Run<br>5、模块间的通信，本地和分布式两种<br>6、本地和分布式运行模式<br>7、CPU、GPU和TPU等异构设备的支持</p>
<p>整个框架以C API为主，分为前、后端<br>前端负责，graph的构建、并传递给master<br>后端负责提供运行时环境，分为4层<br>1、运行时：图的接受，剪枝，编排等操作<br>2、计算层：提供op算子的内核实现<br>3、通信层：组件间通信<br>4、设备层：异构设备的支持</p>
<h4 id="Tensorflow-图的构造和执行是相互分离的，大体流程为："><a href="#Tensorflow-图的构造和执行是相互分离的，大体流程为：" class="headerlink" title="Tensorflow 图的构造和执行是相互分离的，大体流程为："></a>Tensorflow 图的构造和执行是相互分离的，大体流程为：</h4><p>1、图的构造：用于在Client端使用前端的多语言编程接口（python、java）添加算子，完成计算图的构造<br>2、图的传递：Client开启Session，通过它建立和Master之间的连接，执行Session Run,将构建好的graph序列化为graphDef后，以Protobuf传给Master<br>3、图的剪枝：Master根据Session.run()传递的fetch和feeds列表，反向遍历全图，找到最小依赖子图，实施剪枝<br>4、图的分裂：Master将最小子图分裂为多个Graph Partition并注册到多个Worker上<br>5、图二次分裂：Worker根据当前的硬件资源，如CPU、GPU、TPU和MLU，将Graph Partition按照op算子设备约束规范二次分裂到不同设备<br>6、图的运行：每个设备，Worker按照op在kernel中的实现完成op运算</p>
<h4 id="Tensorflow-源码编译"><a href="#Tensorflow-源码编译" class="headerlink" title="Tensorflow 源码编译"></a>Tensorflow 源码编译</h4><p>使用bazel编译，得到pywrap_tensorflow_internal.py 对接上层python调用加载_pywrap_tensorflow_internal.so动态库<br>得到pywrap_tensorflow_internal.cc 对接底层c API,注册了一个函数符号表，实现python接口和c接口的映射</p>
]]></content>
      <categories>
        <category>Tensorflow</category>
      </categories>
      <tags>
        <tag>Tensorflow</tag>
      </tags>
  </entry>
  <entry>
    <title>C-Plus-Plus-Summary</title>
    <url>/2021/04/14/C-Plus-Plus-Summary/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Cloud-Compute</title>
    <url>/2021/04/14/Cloud-Compute/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Deep-Recognition-Compute</title>
    <url>/2021/04/14/Deep-Recognition-Compute/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Deep-Learning</title>
    <url>/2021/04/14/Deep-Learning/</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>Docker-Netork-Container</title>
    <url>/2021/04/03/Docker-Netork-Container/</url>
    <content><![CDATA[<h3 id="Docker容器间通信"><a href="#Docker容器间通信" class="headerlink" title="Docker容器间通信"></a>Docker容器间通信</h3><p>容器间的网络是相互独立的，要在容器间通信，必须学习网络的相关知识<br>docker-compose 创建的各个容器都会产生自己的一个默认网络，所以要在不同的容器间通信，需要自定义公用网络，eg. mysql容器与nacos容器通信</p>
<p>查看 默认网络<br><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker network ls</span></pre></td></tr></table></figure></p>
<p>几种网络模式。</p>
<ol>
<li>bridge: 为每一个容器分配、设置IP，并将容器链接到docker0的虚拟网络，默认方式</li>
<li><p>host: 不会虚拟出自己的网卡，使用宿主的IP和端口；</p>
</li>
<li><p>none:容器拥有独立的namespace, 但没有对其进行设置；</p>
</li>
<li>container: 容器不会创建自己的网卡，和指定的容器共享IP、端口号<br><strong>bridge</strong>: Docker守护进程创建一个虚拟以太网桥docker0，新建容器自动桥接到该接口，附加在其上的网卡可以自动转发数据<br>默认，守护进程创建一对对等虚拟设备接口veth pair,一个设置为eth0,另一个设置为vethxxx，实现宿主机与容器的通信<br><strong>veth pari技术</strong><br>veth pair技术特性：保证无论哪一个veth接收到网络报文，都会将报文传输给另一个。<br><strong>宿主机查看网卡信息</strong><br>$ ip addr</li>
</ol>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Docker 容器的IP和Gateway查看 NetworkSettings</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker inspect 容器ID|容器名</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">Docker 查看所有bridge模式下的容器</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker network inspect bridge</span></span></pre></td></tr></table></figure>
<p>host: 容器可以直接使用宿主机的IP与外界进行通信，无需额外的NAT转换<br>缺点：容器的网络缺少了隔离性<br>none: 禁用网络功能，只有local接口，可以根据需求做更多的网络定制化<br>container: Docker中较为特别的网络模式-net container:已运行的容器名称|ID<br>两个容器共享一个网络栈，使用localhost高效快速通信</p>
<p><strong>容器间通信，Docker1.1.0开始，docker daemon内嵌了一个DNS server,使用器可以直接通过容器名通信</strong><br>需求：</p>
<p>1、创建容器时使用—name命名、只能在自定义的网络中使用，</p>
<p>2、创建自定义网络，docker network create “common_network” —driver “network type(bridge|host|none)”</p>
<p>连接网络: docker network connect 网络名称 容器名称<br>断开网络: docker network disconnect 网络名称 容器名称<br>移除网络: docker network rm 网络名称</p>
<p><strong>查看容器之间是否可以ping通</strong></p>
<p>1、查看容器的具体IP</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ docker network inspect bridge</span></pre></td></tr></table></figure>
<p>2、测试容器是否可ping通<br>$ docker exec -it contain_1 ping contain_2IP(192.1.19.0)<br>$ docker exec -it contain_1 ping contain_2</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">3、容器使用相同的网络</span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -di --name contain_name_1 --net custom_network image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker run -di --name contain_name_2 --net custom_network image</span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> docker network inspect custom_network <span class="comment">#查看上述两个容器的IP信息</span></span></span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">参考 &lt;https://zhuanlan.zhihu.com/p/212772001&gt;</span></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL-Install-In-Windows10</title>
    <url>/2021/04/03/MySQL-Install-In-Windows10/</url>
    <content><![CDATA[<h3 id="MySQL8-Install-in-Windows10"><a href="#MySQL8-Install-in-Windows10" class="headerlink" title="MySQL8 Install in Windows10"></a>MySQL8 Install in Windows10</h3><p>1 Use mysql-installer-community-8.0.23.0.msi to install<br>download url: <a href="https://www.mysql.com/cn/downloads/" target="_blank" rel="noopener">https://www.mysql.com/cn/downloads/</a>  </p>
<p>Step1: choise MySQL Community<br><img src="/2021/04/03/MySQL-Install-In-Windows10/mysql_0.png" alt="DOWNLOAD"><br>Step2: choise System<br><img src="/2021/04/03/MySQL-Install-In-Windows10/mysql_1.png" alt="DOWNLOAD"><br>Step3: choise Custom<br><img src="/2021/04/03/MySQL-Install-In-Windows10/mysql_2.png" alt="DOWNLOAD"><br>Step3: choise install product<br><img src="/2021/04/03/MySQL-Install-In-Windows10/mysql_3.png" alt="DOWNLOAD"><br>Step3: next.. next..<br><img src="/2021/04/03/MySQL-Install-In-Windows10/mysql_4.png" alt="DOWNLOAD"><br>Step4: input login in password<br><img src="/2021/04/03/MySQL-Install-In-Windows10/mysql_5.png" alt="DOWNLOAD"><br>Step5: drop Start the MySQL Server at System Startup<br><img src="/2021/04/03/MySQL-Install-In-Windows10/mysql_6.png" alt="DOWNLOAD"><br>Step6: Execute<br><img src="/2021/04/03/MySQL-Install-In-Windows10/mysql_7.png" alt="DOWNLOAD"><br>Step7: Finish!<br><img src="/2021/04/03/MySQL-Install-In-Windows10/mysql_8.png" alt="DOWNLOAD">  </p>
<p>Verity:<br>2 Add environment:compute(right click)-&gt;property-&gt;advance property-&gt;env variable<br>2.1 MYSQL_HOME-&gt;C:\Program Files\MySQL\MySQL Server 8.0<br>2.2 Path: Add-&gt;%MYSQL_HOME%\bin  </p>
<p>cmd(Administrator)-&gt;mysql —port=3306 -uroot -pxxxxxx  </p>
<p>3 if step7 is unsuccessful!  Starting the server error!<br>The configuration for MySQL Server 8.0.23 has failed  </p>
<p>3.1 remove mysql install<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqld --remove mysql</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysqld --remove mysql80</span></pre></td></tr></table></figure></p>
<p>3.2 init<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqld --initialize-insecure --user&#x3D;mysql</span></pre></td></tr></table></figure></p>
<p>3.3 create server<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqld --install msyql</span></pre></td></tr></table></figure></p>
<p>3.4 start server<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net start mysql</span></pre></td></tr></table></figure></p>
<p>3.5 login in<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysql -uroot -p (passward is empty, you kan search passward from $MSYQLPATH&#x2F;data&#x2F;***.err)</span></pre></td></tr></table></figure><br>eg. C:\\Program Files\\MySQL\\MySQL Server 8.0\\data\\DESKTOP-PGENXXX.err</p>
<p>4 You can install Mysql with zip package, but you need configuration by yourself<br>download url: <a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener">https://dev.mysql.com/downloads/mysql/</a><br>4.1 unzip<br>4.2 touch my.ini file,<br>[mysqld]<br>port=3306<br>basedir=D:\\xxxx\\xxxx #(zip path, aim to load my.ini file)<br>datadir=D:\\xxxx\\xxxx\data #(storage mysql data)<br>max_connections=200<br>character-set-server=utf8<br>default-storage-engine=INNODB  #(default storage engine)</p>
<p>[mysql]<br>default-character-set=utf8<br>[client]<br>port=3306<br>default-character-set=utf8</p>
<p>4.3 install mysql<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mysqld --initialize-insecure --user&#x3D;mysql --console #(console will show default login in passward)</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysqld -install</span></pre></td></tr><tr><td class="code"><pre><span class="line">net start mysql</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql -uroot -pxxxx</span></pre></td></tr></table></figure></p>
<p>5 reset mysql passward<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">net stop mysql</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysqld --console --skip-grant-tables --shared-memory</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql -uroot -p</span></pre></td></tr><tr><td class="code"><pre><span class="line">use mysql;</span></pre></td></tr><tr><td class="code"><pre><span class="line">update user set authentication_string&#x3D;&#39;&#39; where user&#x3D;&#39;root&#39;;  #(passward set null)</span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">net start mysql</span></pre></td></tr><tr><td class="code"><pre><span class="line">mysql -u root -p</span></pre></td></tr><tr><td class="code"><pre><span class="line">alter user &#39;root&#39;@&#39;localhost&#39; identified with mysql_native_password BY &#39;xxxxxx&#39;</span></pre></td></tr><tr><td class="code"><pre><span class="line">flush privileges;</span></pre></td></tr><tr><td class="code"><pre><span class="line">exit;</span></pre></td></tr></table></figure></p>
<p>如果执行mysqld install的时候，提示已有安装的版本，但是本地的目录已经删除了<br>可以使用如下的方法删除<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1、mysqld -remove mysql</span></pre></td></tr><tr><td class="code"><pre><span class="line">or</span></pre></td></tr><tr><td class="code"><pre><span class="line">2、sc query mysql &amp;&amp; sc delete mysql</span></pre></td></tr></table></figure></p>
]]></content>
      <categories>
        <category>SoftWare</category>
      </categories>
      <tags>
        <tag>SoftWare</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18.04_RabbitMQ_Install</title>
    <url>/2020/11/14/Ubuntu18-04-RabbitMQ-Install/</url>
    <content><![CDATA[<h3 id="RabbitMQ-Install-in-Ubuntu18-04"><a href="#RabbitMQ-Install-in-Ubuntu18-04" class="headerlink" title="RabbitMQ Install in Ubuntu18.04"></a>RabbitMQ Install in Ubuntu18.04</h3><ol>
<li>set configuration</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">echo &quot;deb https:&#x2F;&#x2F;dl.bintray.com&#x2F;rabbitmq&#x2F;debian trusty main&quot; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;bintray.rabbitmq.list</span></pre></td></tr><tr><td class="code"><pre><span class="line">echo &quot;deb http:&#x2F;&#x2F;packages.erlang-solutions.com&#x2F;ubuntu trusty contrib&quot; | sudo tee -a &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;erlang_solutions.list</span></pre></td></tr></table></figure>
<p>2.import key</p>
<p>wget -c -O- <a href="http://packages.erlang-solutions.com/ubuntu/erlang_solutions.asc" target="_blank" rel="noopener">http://packages.erlang-solutions.com/ubuntu/erlang_solutions.asc</a> | sudo apt-key add -</p>
<p>wget -O- <a href="https://dl.bintray.com/rabbitmq/Keys/rabbitmq-release-signing-key.asc" target="_blank" rel="noopener">https://dl.bintray.com/rabbitmq/Keys/rabbitmq-release-signing-key.asc</a> |sudo apt-key add -</p>
<p>3.Install erlang and RabbitMQ  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get update  </span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo apt-get install erlang-nox  </span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo apt-get install rabbitmq-server</span></pre></td></tr></table></figure>
<p>4.After installed��RabbitMQ has been started��these are some command of RabbitMQ��<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo service rabbitmq-server start # start  </span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo service rabbitmq-server stop # stop  </span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo service rabbitmq-server restart # restart  </span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo service rabbitmq-server status # show current status</span></pre></td></tr></table></figure></p>
<p>5.RabbitMQ manager,it is a RabbitMQ;’s WEB tool</p>
<h1 id="if-you-want-to-use-web-to-manage-RabbitMQ-you-must-to-active-follow-command"><a href="#if-you-want-to-use-web-to-manage-RabbitMQ-you-must-to-active-follow-command" class="headerlink" title="if you want to use web to manage RabbitMQ, you must to active follow command"></a>if you want to use web to manage RabbitMQ, you must to active follow command</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo rabbitmq-plugins enable rabbitmq_management  </span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo systemctl restart rabbitmq-server #restart rabbitmq server </span></pre></td></tr><tr><td class="code"><pre><span class="line">#browser input��http:&#x2F;&#x2F;localhost:15672 #vetify RabbitMQ manager</span></pre></td></tr></table></figure>
<p>6.create user and autority<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#RabbitMQ is interviewed by localhost using default user guest&#x2F;guest from 3.3.0</span></pre></td></tr><tr><td class="code"><pre><span class="line">#grammer rabbitmqctl add_user &lt;username&gt; &lt;password&gt;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">sudo rabbitmqctl add_user admin admin  </span></pre></td></tr><tr><td class="code"><pre><span class="line">#give user admin (administrator) roles  </span></pre></td></tr><tr><td class="code"><pre><span class="line">#firewall-cmd --list-ports  rabbitmqctl set_user_tags &lt;username&gt; &lt;tag&gt; [...]  </span></pre></td></tr><tr><td class="code"><pre><span class="line">rabbitmqctl set_user_tags admin administrator  </span></pre></td></tr><tr><td class="code"><pre><span class="line">#set authority for user admin(start remote accession)  </span></pre></td></tr><tr><td class="code"><pre><span class="line">#set authority </span></pre></td></tr><tr><td class="code"><pre><span class="line">rabbitmqctl set_permissions -p &quot;&#x2F;&quot; admin &quot;.*&quot; &quot;.*&quot; &quot;.*&quot;  </span></pre></td></tr><tr><td class="code"><pre><span class="line">#look for  authority </span></pre></td></tr><tr><td class="code"><pre><span class="line">rabbitmqctl list_permissions -p &#x2F;  </span></pre></td></tr><tr><td class="code"><pre><span class="line"></span></pre></td></tr><tr><td class="code"><pre><span class="line">7.start firewall authority</span></pre></td></tr></table></figure></p>
<h1 id="view-open-ports-No-ports-are-open-by-default"><a href="#view-open-ports-No-ports-are-open-by-default" class="headerlink" title="view open ports(No ports are open by default)"></a>view open ports(No ports are open by default)</h1><p>firewall-cmd —list-ports #may be you shoule to install firewalld use sudo install firewalld  </p>
<h1 id="start-15672-port"><a href="#start-15672-port" class="headerlink" title="start 15672 port"></a>start 15672 port</h1><p>firewall-cmd —zone=public —add-port=15672/tcp —permanent  </p>
<h1 id="restart-firewall"><a href="#restart-firewall" class="headerlink" title="restart firewall"></a>restart firewall</h1><p>firewall-cmd —reload  </p>
<h1 id="Then-check-whether-the-port-is-open-the-following-shows-that-the-port-is-open"><a href="#Then-check-whether-the-port-is-open-the-following-shows-that-the-port-is-open" class="headerlink" title="Then check whether the port is open, the following shows that the port is open"></a>Then check whether the port is open, the following shows that the port is open</h1><p>firewall-cmd —list-ports #15672/tcp<br>```</p>
<h4 id="if-use-Google-broswer-at-windows-to-access-ubuntu-server’s-RabbitMQ-web-manager-you-need-to-modified-hosts-file-in-windows"><a href="#if-use-Google-broswer-at-windows-to-access-ubuntu-server’s-RabbitMQ-web-manager-you-need-to-modified-hosts-file-in-windows" class="headerlink" title="*if use Google broswer at windows to access ubuntu server’s RabbitMQ web manager you need to modified hosts file in windows"></a>*if use Google broswer at windows to access ubuntu server’s RabbitMQ web manager you need to modified hosts file in windows</h4>]]></content>
      <categories>
        <category>SoftWare</category>
      </categories>
      <tags>
        <tag>SoftWare</tag>
      </tags>
  </entry>
  <entry>
    <title>Bilinear Interpolation</title>
    <url>/2019/12/28/BilinerInterpolation/</url>
    <content><![CDATA[<h2 id="线性插值"><a href="#线性插值" class="headerlink" title="线性插值"></a>线性插值</h2><h4 id="已知两点-x0-y0-x1-y1-求x0和x1之间某一个位置x对应的y值"><a href="#已知两点-x0-y0-x1-y1-求x0和x1之间某一个位置x对应的y值" class="headerlink" title="已知两点(x0, y0), (x1, y1)求x0和x1之间某一个位置x对应的y值"></a>已知两点(x0, y0), (x1, y1)求x0和x1之间某一个位置x对应的y值</h4><script type="math/tex; mode=display">
\frac{y-y_0}{x-x_0} = \frac{y_1-y_0}{x_1-x_0}\quad =>\quad y = \frac{x_1-x}{x_1-x_0}y_0 + \frac{x-x_0}{x_1-x_0}y_1</script><h4 id="双线性插值"><a href="#双线性插值" class="headerlink" title="双线性插值"></a>双线性插值</h4><p><img src="/2019/12/28/BilinerInterpolation/BilinerInterpolation.png" alt="BI"></p>
<p><strong>核心思想是在两个方向分别进行一次线性插值</strong></p>
<p>求未知函数f 在点 P = (x, y) 的值，假设我们已知函数 f 的Q11 = (x1, y1)、Q12 = (x1, y2), Q21 = (x2, y1) 以及 Q22 = (x2, y2) 四个点的值。f可以是一个像素点的像素值。首先在 x 方向进行线性插值：</p>
<script type="math/tex; mode=display">
f(R_1)\approx \frac{x_2-x}{x_2-x_1}f(Q_{11}) + \frac{x-x_1}{x_2-x_1}f(Q_{21})\quad where R_1 = (x, y_1)</script><script type="math/tex; mode=display">
f(R_2)\approx \frac{x_2-x}{x_2-x_1}f(Q_{12}) + \frac{x-x_1}{x_2-x_1}f(Q_{22})\quad where R_2 = (x, y_2)</script><p><strong>然后在y方向进行线性插值：</strong></p>
<script type="math/tex; mode=display">
f(P)\approx \frac{y_2-y}{y_2-y_1}f(R_{1}) + \frac{y-y_1}{y_2-y_1}f(R_{2})\quad</script><p>将f(R<sub>1</sub>)和f(R<sub>2</sub>)代入上式。</p>
<p>两个技巧：</p>
<p>一、提高插值时对像素的充分利用</p>
<p>二、加快计算速度(以整数代替，使用位移&gt;&gt;实现)</p>
<p>下面的code参考自<a href="https://blog.csdn.net/random_repick/article/details/76165851" target="_blank" rel="noopener">C++双线性插值</a></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bilinear</span><span class="params">(cv::Mat src, cv::Mat dst)</span></span>&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> scale_x = (<span class="keyword">double</span>)(src.cols / dst.cols)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">double</span> scale_y = (<span class="keyword">double</span>)(src.rows / dst.rows)</span></pre></td></tr><tr><td class="code"><pre><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; ++i) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//以ptr的方式访问dst的数捿修改p极为修改dst（指针）</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        uchar *p = dst.ptr&lt;uchar&gt;(i);</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//使两个图像的几何中心重合，采样更合理</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//将dst的坐标点映射会src</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">float</span> y = (i + <span class="number">0.5</span>) * scale_y - <span class="number">0.5</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//int下取整，相当于y值左上角的整数坐栿        int fy = (int)y;</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//y为坐标的小数部分</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        y -= fy;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        fy = <span class="built_in">std</span>::<span class="built_in">min</span>(fy, src.rows - <span class="number">2</span>);  </span></pre></td></tr><tr><td class="code"><pre><span class="line">    	fy = <span class="built_in">std</span>::<span class="built_in">max</span>(<span class="number">0</span>, fy); </span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="comment">//以整数计算速度更快</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">        short y1 = (<span class="number">1.f</span> - y)*<span class="number">2048</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        short y2 = <span class="number">2048</span> - y1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; col; ++j) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//trick</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">float</span> x = (j + <span class="number">0.5</span>) * scale_x - <span class="number">0.5</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> fx = (<span class="keyword">int</span>)x;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            x -= fx;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (fx &lt; <span class="number">0</span>)&#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            	x = <span class="number">0</span>, fx = <span class="number">0</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">if</span> (fx &gt;= src.cols <span class="number">-1</span>) &#123;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            	x = <span class="number">0</span>, fx = src.cols <span class="number">-2</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//trick</span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            short x1 = (<span class="number">1.f</span> - x) * <span class="number">2048</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            short x2 = <span class="number">2048</span> - x1;</span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="comment">//结果右移22位抵涿048的平斿            </span></span></pre></td></tr><tr><td class="code"><pre><span class="line">            <span class="keyword">int</span> pos = i * dst.rows + j</span></pre></td></tr><tr><td class="code"><pre><span class="line">            p[pos] = (src.at&lt;uchar&gt;(fx,fy)*x1*y1 + src.at&lt;uchar&gt;		                                     					  (fx+<span class="number">1</span>,fy)*x2*y1+src.at&lt;uchar&gt;(fx,fy+<span class="number">1</span>)*x1*y2 + </span></pre></td></tr><tr><td class="code"><pre><span class="line">                     src.at&lt;uchar&gt;(fx+<span class="number">1</span>,fy+<span class="number">1</span>)*x2*y2) &gt;&gt; <span class="number">22</span>;</span></pre></td></tr><tr><td class="code"><pre><span class="line">        &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">    &#125;</span></pre></td></tr><tr><td class="code"><pre><span class="line">&#125;</span></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>Image Processing</category>
      </categories>
      <tags>
        <tag>图像插值</tag>
        <tag>Bilinear Interpolation</tag>
      </tags>
  </entry>
  <entry>
    <title>GBDT</title>
    <url>/2019/12/28/GBDT/</url>
    <content><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h4 id="GBDT-Gradient-Boosting-Decision-Tree-的优点"><a href="#GBDT-Gradient-Boosting-Decision-Tree-的优点" class="headerlink" title="GBDT(Gradient Boosting Decision Tree)的优点"></a>GBDT(Gradient Boosting Decision Tree)的优点</h4><ol>
<li>既可以用于分类，也可以用于回归</li>
<li>可以进行特征筛选（采用树结构）</li>
<li>实验效果不错</li>
</ol>
<h4 id="GBDT训练过程"><a href="#GBDT训练过程" class="headerlink" title="GBDT训练过程"></a>GBDT训练过程</h4><p><img src="/2019/12/28/GBDT/GBDT.png" alt="GBDT"></p>
<p>gbdt通过多轮迭代产生多个足够简单的弱分类器(低方差、高偏差)，将每轮训练得到的弱分类器加权求和得到最终的分类器，并且不断的减小每轮训练过程产生的残差以实现对目标的分类或回归。</p>
<p><strong>上图是针对单个分类，如果多分类的话（K），同时训练k个CART树，k个树相互独立，单个树的训练过程一样</strong><br><strong>对于CART树生成的过程，重点关注那个特征最合适，这个特征对应的最优特征值切分点是多少</strong></p>
<p>通过对每个特征的每个特征值，计算损失值，选取其中最小分量的特征作为树的节点，最小分量对应的特征值作为最佳切分点</p>
<p>弱分类器一般选择<em>分类回归树</em>,必须符合CART模型；弱分类器的参数一般经过经验风险极小化来确定；损失函数(目标函数)有平方损失函数、0-1损失函数、对数损失函数等。</p>
<h3 id="特征选择"><a href="#特征选择" class="headerlink" title="特征选择"></a>特征选择</h3><ol>
<li>假设有M个特征，从中选择一个特征j作为二叉树的第一个节点</li>
<li>对特征j选择一个切分点m，例如，小于m为一类，大于m为一类</li>
<li>依次迭代，直到特征划分完为止<br><strong>这里面的关键是如何选取最优特征和该特征对应的最优切分点。这也是之后的改进算法出现的一个切入点</strong></li>
</ol>
<h3 id="如何使GBDT对数据具有非线性的拟合能力"><a href="#如何使GBDT对数据具有非线性的拟合能力" class="headerlink" title="如何使GBDT对数据具有非线性的拟合能力"></a>如何使GBDT对数据具有非线性的拟合能力</h3><ol>
<li>CTR预估中，工业届一般使用逻辑回归，但其本身适合处理线性可分的数据</li>
<li>为了让逻辑回归能够处理非线性数据，可以通过组合不同的特征</li>
<li>传统的人工特征组合的方式，不仅耗费人力和时间，实验效果也不是很好。因此，希望通过算法自动、高效的寻找有效的特征组合，以提升模型的效果<br><strong>2014年，Facebook提出利用gbdt去产生有效的特征组合，使用GBDT生成两棵树，通过输入X得到最终的叶子节点作为新的特征与原始特征结合，然后输入逻辑回归进行训练，得到了显著的效果提升</strong></li>
</ol>
<hr>
<blockquote>
<p>Practical Lessons from Predicting Clicks on Ads at Facebook</p>
</blockquote>
<hr>
<h4 id="细节请参考"><a href="#细节请参考" class="headerlink" title="细节请参考"></a>细节请参考</h4><p><a href="https://www.cnblogs.com/always-fight/p/9400346.html" target="_blank" rel="noopener">Blog-GBDT</a><br><a href="https://www.jianshu.com/p/405f233ed04b" target="_blank" rel="noopener">JianShu</a></p>
]]></content>
      <categories>
        <category>Machine Learning</category>
      </categories>
      <tags>
        <tag>Machine Learning</tag>
        <tag>GBDT</tag>
      </tags>
  </entry>
</search>
